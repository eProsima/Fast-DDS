name: reusable Fast-DDS continuous integration

on:
  workflow_call:
    inputs:
      os:
        description: 'A json array listing github hosts'
        required: true
        type: string
      config:
        description: 'A json array listing build configs'
        required: true
        type: string
      vs_toolset:
        description: 'A json array listing visual studio toolsets'
        required: true
        type: string

defaults:
  run:
    shell: pwsh

jobs:

  build-matrix:
    runs-on: windows-latest
    outputs:
        configs-matrix: ${{ steps.set-matrix.outputs.configs-matrix }}  
    steps:
        - id: set-matrix
          run: |
               # Use a vector of dictionaries instead of a fixed size matrix
               $configs = @()
               foreach($os in (ConvertFrom-Json '${{ inputs.os }}'))
               {
                   $map = @{}
                   $map.os = $os

                   foreach($config in (ConvertFrom-Json '${{ inputs.config }}'))
                   {
                       $map.config = $config

                       if( $os -match "windows")
                       {
                           foreach($ts in (ConvertFrom-Json '${{ inputs.vs_toolset }}'))
                           {
                               $map.toolset = $ts
                               $configs += $map.Clone()
                           }
                       }
                       else
                       {
                           $configs += $map
                       }
                   }
               }
               'configs-matrix=' + (ConvertTo-Json $configs -Compress) |
                    Out-File $Env:GITHUB_OUTPUT -Append

  build-and-test-ci:
    needs: build-matrix
    strategy:
      matrix:
        configs: ${{ fromJSON(needs.build-matrix.outputs.configs-matrix) }}
      fail-fast: false
 
    name: ${{ matrix.configs.os }} ${{ matrix.configs.config }} ${{ matrix.configs.toolset }} CI
    runs-on: ${{ matrix.configs.os }} 
    steps:
      - name: Setup environment
        run: |
             # Handle single target/multi target
             $env_variables = @()

             if($IsWindows)
             {
               [xml]$info = & "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\installer\vswhere" `
                              -latest -format xml
               $pwshmodule = Join-Path $info.instances.instance.installationPath `
                                       "Common7\Tools\Microsoft.VisualStudio.DevShell.dll" | gi

               $env_variables +=
                 'CXXFLAGS=/MP',
                 'CONFIG_TYPE=--config ${{ matrix.configs.config }}',
                 'BIN_ARCH=-A x64',
                 'HOST_ARCH=-T ${{ matrix.configs.toolset }},host=x64',
                 ('VSPWSH=' + $pwshmodule)
             }
             elseif($IsLinux -or $IsMacOS)
             {
               $env_variables +=
                 'BUILD_TYPE=-DCMAKE_BUILD_TYPE=${{ matrix.configs.config }}'
             }
             else
             {
               throw "Unsupported platform??"
             }

             # download the pull request branches on fetch
             git config --global remote.origin.fetch '+refs/pull/*:refs/remotes/origin/pull/*'

             $env_variables | Out-File $Env:GITHUB_ENV -Append -Encoding OEM

      - name: Enable WER on windows
        id: WERSetup
        if: ${{ contains(matrix.configs.os, 'windows') }}
        run: |
             $wer = "HKLM:\SOFTWARE\Microsoft\Windows\Windows Error Reporting"
             $ld = Join-Path $wer LocalDumps
             $key = Get-Item $wer
 
             if("Disabled" -in $key.Property) {
                 Set-ItemProperty -Path $wer -Name "Disabled" -Value 0
             } else {
                 New-ItemProperty -Path $wer -Name "Disabled" -Value 0 -PropertyType DWord
             }
 
             if(Test-Path $ld) { $key = Get-Item $ld } else { $key = New-Item -Path $wer -Name "LocalDumps" }

             #destination folder
             $crashdir = New-Item -Path "CrashDumps" -Type Directory
             if("DumpFolder" -in $key.Property) {
                 Set-ItemProperty -Path $ld -Name "DumpFolder" -Value $crashdir
             } else {
                 New-ItemProperty -Path $ld -Name "DumpFolder" -Value $crashdir -PropertyType ExpandString
             }
             "DumpFolder=$crashdir" | Out-File $Env:GITHUB_OUTPUT -Append

             # up to DumpCount files in the folder
             if("DumpCount" -in $key.Property) {
                 Set-ItemProperty -Path $ld -Name "DumpCount" -Value 100
             } else {
                 New-ItemProperty -Path $ld -Name "DumpCount" -Value 100 -PropertyType DWord
             }

             # 2 -> full dump
             if("DumpType" -in $key.Property) {
                 Set-ItemProperty -Path $ld -Name "DumpType" -Value 2
             } else {
                 New-ItemProperty -Path $ld -Name "DumpType" -Value 2 -PropertyType DWord
             }

             # WER service is manual by default
             Start-Service WerSvc

      - name: Installing colcon ancillary
        run: |
             pip3 install -U colcon-common-extensions vcstool colcon-mixin

             # patch colcon issue with visual studio 2022
             if($IsWindows)
             {
               $patch = gci -Include build.py -Recurse `
                            -Path ((gcm colcon).source | Split-Path | Join-Path -ChildPath "..\Lib\site-packages\colcon_cmake\*")
               if(!(sls -Path $patch -Pattern "'17.0': 'Visual Studio 17 2022'"))
               {
                  echo "Patching colcon build to admit Visual Studio 17 2022"
                  $tmp = New-TemporaryFile
                  Get-Content $patch | % {
                      if($_ -match "Visual Studio 16 2019") {
                           "                '17.0': 'Visual Studio 17 2022'," }
                      $_
                      } | Out-File $tmp -Encoding OEM
                  Install-Module -Name Pscx -Force -AllowClobber
                  ConvertTo-UnixLineEnding -Destination $patch -Path $tmp.FullName
                  del $tmp
               }
             }
             elseif($IsMacOS)
             {
                 # Add the colcon location to the path
                 $Env:PATH += "${Env:PATH}:/Library/Frameworks/Python.framework/Versions/Current/bin"
                 "PATH=" + $Env:PATH | Out-File $Env:GITHUB_ENV -Append -Encoding OEM
             }

             # refresh mixins
             colcon mixin add default 'https://raw.githubusercontent.com/colcon/colcon-mixin-repository/master/index.yaml'
             colcon mixin update default
             colcon mixin show

      - name: Installing asio and tinyxml2 dependencies
        run: |
             if($IsWindows)
             {
                $tmpdir = New-Item -Path "$Env:TMP\choco_aux" -Type Directory
                iwr -Uri https://github.com/ros2/choco-packages/releases/download/2020-02-24/asio.1.12.1.nupkg -OutFile "$tmpdir\asio.1.12.1.nupkg"
                iwr -Uri https://github.com/ros2/choco-packages/releases/download/2020-02-24/tinyxml2.6.0.0.nupkg -OutFile "$tmpdir\tinyxml2.6.0.0.nupkg"
                choco install -y -s $tmpdir asio tinyxml2
                del $tmpdir -Recurse
             }
             elseif($IsLinux)
             {
                sudo apt install libasio-dev libtinyxml2-dev
             }
             elseif($IsMacOS)
             {
                brew install asio tinyxml2
             }
             else
             {
               throw "Unsupported platform??"
             }

      - name: Download & build & install googletest system wide
        run: |
             git clone --branch release-1.11.0 https://github.com/google/googletest.git
             # windows workaround
             if($IsWindows)
             {
               $crt = '-Dgtest_force_shared_crt=ON' 
             }

             # Generate
             cmake -DBUILD_GMOCK=ON $Env:BUILD_TYPE $crt -DCMAKE_VERBOSE_MAKEFILE=ON `
                   -B ./build/googletest $Env:BIN_ARCH $Env:HOST_ARCH ./googletest 

             # Build and install elevated if required
             $build = { cmake --build ./build/googletest --target install $Env:CONFIG_TYPE --verbose }
             $IsLinux ? (sudo pwsh -C $build) : (& $build) | Tee-Object -FilePath gtest.log

             # Hint install dir
             if($IsWindows)
             {
               $pattern = ("$Env:ProgramFiles" -replace "\\","/") + "/.*/GTestConfig.cmake"
               $matches = sls -Path gtest.log -Pattern $pattern
               ("GTest_DIR=" + ($matches.Matches.Value | Split-Path -Parent)) |
                 Out-File $Env:GITHUB_ENV -Append -Encoding OEM
             }

             # clean up
             'build', 'googletest', 'gtest.log' | del -Recurse -Force 

      - name: Make sure OpenSSL is there
        if: ${{ contains(matrix.configs.os, 'windows') }}
        run: |
             # Windows host has only the binaries installed, we need the headers too
             # download the last installer
             $uri = 'https://slproweb.com' +
               ((iwr 'https://slproweb.com/products/Win32OpenSSL.html').links |
               sls 'href=\"(.*download/Win64OpenSSL-1_1_1.*\.exe)\"').matches.Groups.value[-1]
               iwr -Uri $uri -OutFile "$Env:TMP\Win64OpenSSL.exe"
 
             # Do install
             & "$Env:TMP\Win64OpenSSL.exe" /silent /verysilent /sp- /suppressmsgboxes;
 
             # Update the environment
             "OPENSSL64_ROOT=$Env:ProgramFiles\OpenSSL-Win64" | Out-File $Env:GITHUB_ENV -Append -Encoding OEM
 
             # Wait for the installation to be fulfill
             Get-Process Win??OpenSSL -ErrorAction SilentlyContinue | Wait-Process
             del "$Env:TMP\Win64OpenSSL.exe"

      - name: Update the host file for DNS resolver testing
        if: ${{ !contains(github.event.pull_request.labels.*.name, 'no-test') }}
        run: |
             # File location is OSpecific
             if($IsWindows)
             {
                 $hostfile = "$Env:SystemRoot\system32\drivers" -replace "\\", "/"
             }
             $hostfile += "/etc/hosts"

             # DNS entries to add
             $new_entries = @{
               "localhost.test" = "127.0.0.1", "::1"
               "www.eprosima.com.test" = "154.56.134.194"
               "www.acme.com.test" = "216.58.215.164", "2a00:1450:400e:803::2004"
               "www.foo.com.test" = "140.82.121.4", "140.82.121.3"
               "acme.org.test" = "ff1e::ffff:efff:1"
             }

             # Modify the file
             $mod = { Param([string]$FilePath, [Hashtable]$Entries )
                $entries.GetEnumerator() |
                  % { $hostname = $_.key; $_.value |
                  % { "{0,-25} {1}" -f $_, $hostname }} |
                  Out-File $filepath -Append
             }

             if( $IsLinux -or $IsMacOS )
             {
               sudo pwsh -Command $mod -args $hostfile, $new_entries
             }
             elseif($IsWindows)
             {
               & $mod -FilePath $hostfile -Entries $new_entries
             }
             else
             {
               throw "Unsupported platform??"
             }

             # Show the result
             gc $hostfile

      - name: Set up libp11 and SoftHSM
        if: ${{ !contains(matrix.configs.os, 'macos') }}
        run: |
             if($IsWindows)
             {
                if(!(Test-Path -Path Env:OPENSSL64_ROOT))
                {
                  throw "OpenSSL is not set up properly. Check previous steps."
                }

                # Install the HSM emulator (required for testing PKCS #11 support)
                $urlHSM = "https://github.com/disig/SoftHSM2-for-Windows/releases/download/v2.5.0/SoftHSM2-2.5.0.msi" 
                $msiHSM = "$Env:tmp\SoftHSM2-2.5.0.msi"

                iwr $urlHSM -OutFile $msiHSM
                msiexec /i $msiHSM /quiet TARGETDIR="""${Env:ProgramFiles(x86)}"""
                $Env:SOFTHSM2_ROOT = Join-Path "${Env:ProgramFiles(x86)}" SoftHSM2
                'SOFTHSM2_ROOT=' + $Env:SOFTHSM2_ROOT | Out-File $Env:GITHUB_ENV -Append -Encoding OEM

                # Build pkcs11 library
                $deploy_dir = "$Env:ProgramFiles\libp11"
                git clone https://github.com/OpenSC/libp11.git $deploy_dir
                $deploy_dir = gi $deploy_dir

                $pwshmodule = gi $Env:VSPWSH
                Import-Module $pwshmodule
                Enter-VsDevShell -SetDefaultWindowTitle -VsInstallPath $pwshmodule.Directory.Parent.Parent `
                                 -StartInPath (pwd) -DevCmdArguments '/arch=x64 /host_arch=x64'

                cd $deploy_dir

                nmake .\Makefile.mak OPENSSL_DIR=$Env:OPENSSL64_ROOT BUILD_FOR=WIN64
                $config = ls -Path $Env:OPENSSL64_ROOT -Recurse -Include openssl.cnf; 
                $libp11_path = Join-Path $deploy_dir src
                'LibP11_ROOT_64=' + $libp11_path | Out-File $Env:GITHUB_ENV -Append -Encoding OEM

                # Wait until installation is completed 
                Wait-Process -Name msiexec -ErrorAction SilentlyContinue
                del $msiHSM

                # Set up OpenSSL
                $module_path = gci -Path $Env:SOFTHSM2_ROOT -Recurse -Include '*.dll' | ? FullName -match 64
                $contents = gc $config;

                $header = "# HSM test ancillary configuration",
                          "openssl_conf = openssl_init"

                $footer = "[openssl_init]",
                          "engines = engine_section",
                          "",
                          "[engine_section]",
                          "pkcs11 = pkcs11_section",
                          "",
                          "[pkcs11_section]",
                          "engine_id = pkcs11",
                          ("dynamic_path =" + ("$libp11_path/pkcs11.dll" -replace "\\","/")),
                          ("MODULE_PATH =" + ($module_path.FullName -replace "\\","/")),
                          "init = 0"

                $header_line = ($contents | sls '^HOME')[0].LineNumber;
                ($contents[0..$header_line] + $header +  $contents[$header_line..$contents.count] + $footer) |
                % { $_.TrimStart() } | Out-File $config -Encoding OEM;

                # lead openssl to the right config file
                $Env:OPENSSL_CONF=$config
                
             }
             elseif ($IsLinux)
             {
                sudo apt install libp11-dev libengine-pkcs11-openssl softhsm2
                sudo usermod -a -G softhsm $env:USER
             }
             else
             {
               throw "Libp11 support for this OS is not yet available"
             }

             # check if is working
             openssl engine pkcs11 -t

      - name: Prepare the colcon workspace for build
        run: |
             # Get some convenient tools
             Install-Module -Name ConvertBase64Strings -Force -AllowClobber
             Import-Module -name ConvertBase64Strings -Prefix CI
             Install-Module powershell-yaml -Force

             # Get action credentials for github REST API
             $secret = ConvertTo-SecureString -String "${{ secrets.GITHUB_TOKEN }}" -AsPlainText

             # Check available queries according with github policy
             "Rate Limits with github action token:",
             ((Invoke-WebRequest -Authentication OAuth -Token $secret `
                -Uri https://api.github.com/users/octocat).Headers.GetEnumerator() |
                ? Key -like "X-RateLimit*") | Out-Host

             # download the repos file
             $repos = ((Invoke-WebRequest -Authentication OAuth -Token $secret `
                -Uri "${{ github.api_url }}/repos/eProsima/Fast-DDS/contents/fastrtps.repos?ref=${{ github.ref }}" `
                -Headers @{"method"="GET";"Accept"="application/vnd.github.v3+json"}).content |
                ConvertFrom-Json).content | ConvertFrom-CIBase64 | ConvertFrom-Yaml

             # checkout the commit
             $repos.repositories.fastrtps.version = "${{ github.ref }}" -replace "^refs/pull","origin/pull"
             $repos | ConvertTo-Yaml | Tee-Object -FilePath fastrtps.repos

             # create source dir and donwload the sources
             mkdir src
             vcs import src --input fastrtps.repos

      - name: Retrieve colcon.meta file
        run: |
           # Here a dummy that generates dynamically one
           $meta = [PSCustomObject]@{names=@{fastrtps=@{"cmake-args"=$Null}}}

           $meta.names.fastrtps."cmake-args" = "-DEPROSIMA_BUILD=ON",
                                               "-DINTERNAL_DEBUG=ON",
                                               "-DGTEST_INDIVIDUAL=ON",
                                               "-DFASTRTPS_API_TESTS=OFF",
                                               "-DFASTDDS_PIM_API_TESTS=ON",
                                               "-DPERFORMANCE_TESTS=ON",
                                               "-DNO_TLS=ON"
           if($IsWindows)
           {
             # Enable WER
             $meta.names.fastrtps."cmake-args" += "-DENABLE_WER=ON",
                                                  "-DWER_TIMEOUT_TIME=240"
           }

           # single config processing parafernalia
           if(Test-Path Env:BUILD_TYPE)
           {
             $meta.names.fastrtps."cmake-args" += $Env:BUILD_TYPE
           }
           # Generate the meta file
           $meta | ConvertTo-Json -Depth 3 | Tee-Object -FilePath ci.meta -Encoding OEM

      - name: Build
        run: |
           # build type mixin names doesn't match cmake ones
           $translate = @{
                "Debug"="debug"
                "Release"="release"
                "RelWithDebInfo"="rel-with-deb-info"
                "MinSizeRel"="min-size-rel"
                }
           # For convenience use an array to pass the arguments
           $buildargs = "--merge-install",
                        "--symlink-install",
                        "--event-handlers=console_direct+",
                        "--mixin", $translate["${{ matrix.configs.config }}"]

           # On Windows we must load the developer environment and chose a config
           if($IsWindows)
           {
              $pwshmodule = gi $Env:VSPWSH
              Import-Module $pwshmodule
              Enter-VsDevShell -SetDefaultWindowTitle -VsInstallPath $pwshmodule.Directory.Parent.Parent `
                               -StartInPath (pwd) -DevCmdArguments '/arch=x64 /host_arch=x64'

              $cmakeargs = "--cmake-args", $Env:BIN_ARCH, $Env:HOST_ARCH

              # VS2022 may show warnings using C++11
              $ErrorActionPreference='Continue'

              colcon build $buildargs --metas ci.meta --executor sequential $cmakeargs
           }
           else
           {
              colcon build $buildargs --metas ci.meta --executor sequential
           }

      - name: Test
        if: ${{ !contains(github.event.pull_request.labels.*.name, 'no-test') }}
        run: |
           # Create a junit file for test results
           $junit = New-Item -Path ./junit.xml -ItemType File
           'JUNIT_LOG=' + $junit.FullName | Out-File $Env:GITHUB_ENV -Append -Encoding OEM
           # Run the testing
           colcon test --packages-select fastrtps --event-handlers=console_direct+ `
              --merge-install --executor sequential --ctest-args --timeout 300 --output-junit $junit

      - name: Test Summary
        id: summary
        continue-on-error: true
        run: |
           # If the CMake version (3.21 et seq.) supports junit use it
           $failed = 0

           if(Test-Path Env:JUNIT_LOG)
           {
             # ancillary for markdown summary
             $modules = Get-Module -ListAvailable | Select ModuleType, Version, Name
             if(!($modules | ? Name -eq "MarkdownPS"))
             {
               Install-Module -Name MarkdownPS -Force
             }

             $res = [xml](gc $Env:JUNIT_LOG)
             $failed = $res.testsuite.failures

             # Summary
             $res.testsuite | select name, tests, failures, disabled, hostname, time, timestamp |
              New-MDTable | Tee-Object -FilePath $Env:GITHUB_STEP_SUMMARY

             # list the failures if any
             "::group::Failures Summary"
             $failures = $res.testsuite.testcase | ? status -eq fail
             $failures | select name, time | format-list
             "::endgroup::"

             # list faulty tests output
             "::group::Failed tests output"
             $failures
             "::endgroup::"
           }
           else
           {
             # fallback to parse the ordinary output file
             $pattern = '^(?:.\[0;32m)?(\d+)% tests passed(?:.\[0;0m)?, (\d+) tests failed(?:.\[0;0m)? out of (\d+)$'
             $summary = (cat .\log\latest_test\fastrtps\stdout.log).where({ $_ -match $pattern }, 'skipuntil')
             $failed = $matches[2]

             $summary[0] | out-file -filepath $env:github_step_summary

             $summary
           }

           "test_failures=$failed" | Out-File $Env:GITHUB_OUTPUT -Append

           if($IsWindows -and $failed)
           {
             "::group::Crash dump files"
             # list crash dumps files ordered by date to hint how pid maps to test number
             $dumpfolder = gi (gi "HKLM:\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps").GetValue('DumpFolder')
             ls $dumpfolder | Sort-Object LastWriteTime
             "::endgroup::"

             # upload too the pdb files associated
             # 1. To the library
             ls -Path ./build/* -R -Filter fast*.pdb | Move-Item -Destination $dumpfolder
             # 2. To each failed test
             $test_bin = ((ls -Path $dumpfolder -Filter *.dmp).name |
                            sls  "(?<file>[^\(^\)^\.]+).*\.\d+\.dmp").Matches |
                            % { $_.Groups['file'].Value } | Get-Unique
             ls -Path ./build/* -R -Filter *.pdb | ? basename -in $test_bin |
                Move-Item -Destination $dumpfolder
           }

           exit $failed

      - name: Upload crash dumps
        if: ${{ contains(matrix.configs.os, 'windows') && steps.summary.outcome == 'failure' }}
        uses: actions/upload-artifact@v3
        with:
            name: crash-dumps-${{ matrix.configs.os }}-${{ matrix.configs.toolset }}-${{ matrix.configs.config }}
            path: ${{ steps.WERSetup.outputs.DumpFolder }}

      - name: Check test failures
        if: ${{ steps.summary.outcome == 'failure' }}
        run: exit ${{ steps.summary.outputs.test_failures }}
