// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file calculatorServer.cxx
 * Server implementation for interfaces
 *
 * This file was generated by the tool fastddsgen (version: 4.1.0).
 */

#include "calculatorServer.hpp"

#include <atomic>
#include <condition_variable>
#include <map>
#include <memory>
#include <mutex>
#include <queue>
#include <stdexcept>
#include <string>
#include <thread>
#include <vector>

#include <fastdds/dds/builtin/topic/PublicationBuiltinTopicData.hpp>
#include <fastdds/dds/core/condition/Condition.hpp>
#include <fastdds/dds/core/condition/GuardCondition.hpp>
#include <fastdds/dds/core/condition/WaitSet.hpp>
#include <fastdds/dds/core/Time_t.hpp>
#include <fastdds/dds/domain/DomainParticipant.hpp>
#include <fastdds/dds/domain/qos/ReplierQos.hpp>
#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/rpc/exceptions.hpp>
#include <fastdds/dds/rpc/interfaces.hpp>
#include <fastdds/dds/rpc/RequestInfo.hpp>
#include <fastdds/dds/rpc/Replier.hpp>
#include <fastdds/dds/rpc/Service.hpp>
#include <fastdds/dds/rpc/ServiceTypeSupport.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>

#include "calculator.hpp"
#include "calculator_details.hpp"
#include "calculatorPubSubTypes.hpp"

namespace calculator_example {

//{ interface Calculator

namespace detail {

namespace fdds = eprosima::fastdds::dds;
namespace frpc = eprosima::fastdds::dds::rpc;
namespace frtps = eprosima::fastdds::rtps;

class CalculatorServerLogic
    : public frpc::RpcServer
    , public std::enable_shared_from_this<CalculatorServerLogic>
{
    using RequestType = Calculator_Request;
    using ReplyType = Calculator_Reply;

public:

    CalculatorServerLogic(
            fdds::DomainParticipant& part,
            const char* service_name,
            const fdds::ReplierQos& qos,
            size_t thread_pool_size,
            std::shared_ptr<CalculatorServer_IServerImplementation> implementation)
        : CalculatorServerLogic(
                part,
                service_name,
                qos,
                std::make_shared<ThreadPool>(*this, thread_pool_size),
                std::move(implementation))
    {
    }

    CalculatorServerLogic(
            fdds::DomainParticipant& part,
            const char* service_name,
            const fdds::ReplierQos& qos,
            std::shared_ptr<frpc::RpcServerSchedulingStrategy> scheduler,
            std::shared_ptr<CalculatorServer_IServerImplementation> implementation)
        : frpc::RpcServer()
        , participant_(part)
        , request_scheduler_(scheduler)
        , implementation_(std::move(implementation))
    {
        // Register the service type support
        auto service_type = create_Calculator_service_type_support();
        auto ret = service_type.register_service_type(&participant_, "calculator_example::Calculator");
        if (ret != fdds::RETCODE_OK)
        {
            throw std::runtime_error("Error registering service type");
        }

        // Create the service
        service_ = participant_.create_service(service_name, "calculator_example::Calculator");
        if (nullptr == service_)
        {
            throw std::runtime_error("Error creating service");
        }

        // Create the replier
        replier_ = participant_.create_service_replier(service_, qos);
        if (nullptr == replier_)
        {
            throw std::runtime_error("Error creating requester");
        }
    }

    ~CalculatorServerLogic() override
    {
        if (nullptr != replier_)
        {
            participant_.delete_service_replier(service_->get_service_name(), replier_);
        }

        if (nullptr != service_)
        {
            participant_.delete_service(service_);
        }
    }

    void run() override
    {
        finish_condition_.set_trigger_value(false);
        fdds::WaitSet waitset;
        waitset.attach_condition(finish_condition_);
        fdds::StatusCondition& status_condition = replier_->get_replier_reader()->get_statuscondition();
        status_condition.set_enabled_statuses(fdds::StatusMask::data_available());
        waitset.attach_condition(status_condition);

        while (true)
        {
            fdds::ConditionSeq active_conditions;
            waitset.wait(active_conditions, fdds::c_TimeInfinite);

            // Early exit if the finish condition is triggered
            if (finish_condition_.get_trigger_value())
            {
                break;
            }

            // Take and process the requests
            auto ctx = std::make_shared<RequestContext>();
            while (fdds::RETCODE_OK == ctx->take_from(replier_))
            {
                if (ctx->validate_request())
                {
                    process_request(ctx);
                }
                else
                {
                    ctx->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier_);
                }

                // Prepare next request context
                ctx = std::make_shared<RequestContext>();
            }
        }
    }

    void stop() override
    {
        // Notify all threads to finish
        finish_condition_.set_trigger_value(true);

        // Cancel all pending requests
        {
            std::lock_guard<std::mutex> _(mtx_);
            for (auto& it : processing_requests_)
            {
                it.second->cancel();
            }
            processing_requests_.clear();
        }

        // Wait for all threads to finish
        request_scheduler_->server_stopped(shared_from_this());
    }

    void execute_request(
            const std::shared_ptr<frpc::RpcRequest>& request) override
    {
        auto ctx = std::dynamic_pointer_cast<RequestContext>(request);
        if (ctx)
        {
            execute_request(ctx);
        }
        else
        {
            throw std::runtime_error("Invalid request context type");
        }
    }

private:

    //{ Output feed helpers

    struct IOutputFeedCancellator
    {
        virtual ~IOutputFeedCancellator() = default;
        virtual void cancel() = 0;
    };

    //} Output feed helpers

    //{ Input feed helpers

    struct IInputFeedProcessor
    {
        virtual ~IInputFeedProcessor() = default;
        virtual bool process_additional_request(
                const RequestType& request) = 0;
        virtual void cancel_input_feed() = 0;
    };

    //} Input feed helpers

    //{ operation representation_limits

    //} operation representation_limits

    //{ operation addition

    //} operation addition

    //{ operation subtraction

    //} operation subtraction

    struct RequestContext : frpc::RpcRequest
    {
        RequestType request;
        frpc::RequestInfo info;
        frtps::GUID_t client_id;
        fdds::PublicationBuiltinTopicData pub_data;

        struct representation_limits_feeds_t
        {
        }
        representation_limits_feeds;

        struct addition_feeds_t
        {
        }
        addition_feeds;

        struct subtraction_feeds_t
        {
        }
        subtraction_feeds;

        const frtps::GUID_t& get_client_id() const override
        {
            return client_id;
        }

        const frtps::RemoteLocatorList& get_client_locators() const override
        {
            return pub_data.remote_locators;
        }

        fdds::ReturnCode_t take_from(
                frpc::Replier* replier)
        {
            fdds::ReturnCode_t ret = replier->take_request(&request, info);
            if (ret == fdds::RETCODE_OK)
            {
                client_id = info.sample_identity.writer_guid();
                ret = replier->get_replier_reader()->get_matched_publication_data(pub_data, client_id);
            }
            return ret;
        }

        bool validate_request() const
        {
            size_t n_fields = 0;
            n_fields += request.representation_limits.has_value() ? 1 : 0;
            n_fields += request.addition.has_value() ? 1 : 0;
            n_fields += request.subtraction.has_value() ? 1 : 0;

            return n_fields == 1U;
        }

        void process_additional_request(
                const std::shared_ptr<RequestContext>& ctx,
                frpc::Replier* replier,
                bool& should_erase)
        {
            should_erase = false;
            if (ctx->info.related_sample_identity == info.related_sample_identity)
            {
                // Pass request to input feed processors
                should_erase = true;
                for (const auto& input_feed : input_feed_processors_)
                {
                    if (input_feed->process_additional_request(ctx->request))
                    {
                        should_erase = false;
                        break;
                    }
                }

                // If no input feed processor handled the request, send an exception
                if (should_erase)
                {
                    send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_INVALID_ARGUMENT, replier);
                }
            }
            else
            {
                // This is not the expected request
                should_erase = true;
            }
        }

        bool prepare(
                frpc::Replier* replier)
        {
            if (request.representation_limits.has_value())
            {
                return prepare_representation_limits(replier);
            }

            if (request.addition.has_value())
            {
                return prepare_addition(replier);
            }

            if (request.subtraction.has_value())
            {
                return prepare_subtraction(replier);
            }


            send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNKNOWN_OPERATION, replier);
            return false;
        }

        void send_exception(
                frpc::RemoteExceptionCode_t ex,
                frpc::Replier* replier)
        {
            ReplyType reply{};
            reply.remoteEx = ex;
            replier->send_reply(&reply, info);
        }

        void cancel()
        {
            // Cancel output feed
            if (output_feed_cancellator_)
            {
                output_feed_cancellator_->cancel();
            }

            // Cancel input feeds
            for (const auto& input_feed : input_feed_processors_)
            {
                input_feed->cancel_input_feed();
            }
        }

    private:

        std::shared_ptr<IOutputFeedCancellator> output_feed_cancellator_;
        std::vector<std::shared_ptr<IInputFeedProcessor>> input_feed_processors_;

        bool prepare_representation_limits(
                frpc::Replier* replier)
        {
            static_cast<void>(replier);
            return true;
        }

        bool prepare_addition(
                frpc::Replier* replier)
        {
            static_cast<void>(replier);
            return true;
        }

        bool prepare_subtraction(
                frpc::Replier* replier)
        {
            static_cast<void>(replier);
            return true;
        }

    };

    struct ThreadPool
        : public frpc::RpcServerSchedulingStrategy
    {
        ThreadPool(
                CalculatorServerLogic& server,
                size_t num_threads)
            : server_(server)
        {
            // Create worker threads (at least one)
            if (num_threads == 0)
            {
                num_threads = 1;
            }

            auto process_requests = [this]()
                    {
                        while (!finished_)
                        {
                            std::shared_ptr<frpc::RpcRequest> req;
                            {
                                std::unique_lock<std::mutex> lock(mtx_);
                                cv_.wait(lock, [this]()
                                        {
                                            return finished_ || !requests_.empty();
                                        });
                                if (finished_)
                                {
                                    break;
                                }
                                req = requests_.front();
                                requests_.pop();
                            }

                            // Process the request
                            server_.execute_request(req);
                        }
                    };

            for (size_t i = 0; i < num_threads; ++i)
            {
                threads_.emplace_back(process_requests);
            }
        }

        void schedule_request(
                const std::shared_ptr<frpc::RpcRequest>& req,
                const std::shared_ptr<frpc::RpcServer>& server) override
        {
            static_cast<void>(server);

            std::lock_guard<std::mutex> lock(mtx_);
            if (!finished_)
            {
                requests_.push(req);
                cv_.notify_one();
            }
        }

        void server_stopped(
                const std::shared_ptr<frpc::RpcServer>& server) override
        {
            static_cast<void>(server);

            // Notify all threads in the pool to stop
            {
                std::lock_guard<std::mutex> lock(mtx_);
                finished_ = true;
                cv_.notify_all();
            }

            // Wait for all threads to finish
            for (auto& thread : threads_)
            {
                if (thread.joinable())
                {
                    thread.join();
                }
            }
            threads_.clear();
        }

        CalculatorServerLogic& server_;
        std::mutex mtx_;
        std::condition_variable cv_;
        std::queue<std::shared_ptr<frpc::RpcRequest>> requests_;
        bool finished_{ false };
        std::vector<std::thread> threads_;
    };

    void process_request(
            const std::shared_ptr<RequestContext>& ctx)
    {
        auto id = ctx->info.related_sample_identity;

        {
            std::lock_guard<std::mutex> _(mtx_);
            auto it = processing_requests_.find(id);
            if (it != processing_requests_.end())
            {
                bool should_erase = false;
                it->second->process_additional_request(ctx, replier_, should_erase);
                if (should_erase)
                {
                    processing_requests_.erase(it);
                }
                return;
            }

            if (!ctx->prepare(replier_))
            {
                return;
            }

            processing_requests_[id] = ctx;
        }

        request_scheduler_->schedule_request(ctx, shared_from_this());
    }

    void execute_request(
            const std::shared_ptr<RequestContext>& req)
    {
        try
        {
            for (;;)
            {
                if (req->request.representation_limits.has_value())
                {
                    {
                        ReplyType reply{};
                        reply.representation_limits = calculator_example::detail::Calculator_representation_limits_Result{};
                        reply.representation_limits->result = implementation_->representation_limits(
                            *req);
                        replier_->send_reply(&reply, req->info);
                    }
                    break;
                }

                if (req->request.addition.has_value())
                {
                    try
                    {
                        ReplyType reply{};
                        reply.addition = calculator_example::detail::Calculator_addition_Result{};
                        reply.addition->result = calculator_example::detail::Calculator_addition_Out{};
                        reply.addition->result->return_ = implementation_->addition(
                            *req,
                            req->request.addition->value1,
                            req->request.addition->value2);
                        replier_->send_reply(&reply, req->info);
                    }
                    catch (const calculator_example::OverflowException& ex)
                    {
                        ReplyType reply{};
                        reply.addition = calculator_example::detail::Calculator_addition_Result{};
                        reply.addition->calculator_example_OverflowException_ex = ex;
                        replier_->send_reply(&reply, req->info);
                    }
                    break;
                }

                if (req->request.subtraction.has_value())
                {
                    try
                    {
                        ReplyType reply{};
                        reply.subtraction = calculator_example::detail::Calculator_subtraction_Result{};
                        reply.subtraction->result = calculator_example::detail::Calculator_subtraction_Out{};
                        reply.subtraction->result->return_ = implementation_->subtraction(
                            *req,
                            req->request.subtraction->value1,
                            req->request.subtraction->value2);
                        replier_->send_reply(&reply, req->info);
                    }
                    catch (const calculator_example::OverflowException& ex)
                    {
                        ReplyType reply{};
                        reply.subtraction = calculator_example::detail::Calculator_subtraction_Result{};
                        reply.subtraction->calculator_example_OverflowException_ex = ex;
                        replier_->send_reply(&reply, req->info);
                    }
                    break;
                }

                req->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNSUPPORTED, replier_);
                break;
            }
        }
        catch (const frpc::RpcRemoteException& ex)
        {
            req->send_exception(ex.code(), replier_);
        }
        catch (...)
        {
            req->send_exception(frpc::RemoteExceptionCode_t::REMOTE_EX_UNKNOWN_EXCEPTION, replier_);
        }

        {
            std::lock_guard<std::mutex> _(mtx_);
            processing_requests_.erase(req->info.related_sample_identity);
        }
    }

    fdds::DomainParticipant& participant_;
    frpc::Service* service_ = nullptr;
    frpc::Replier* replier_ = nullptr;
    fdds::GuardCondition finish_condition_;
    std::mutex mtx_;
    std::map<frtps::SampleIdentity, std::shared_ptr<RequestContext>> processing_requests_;
    std::shared_ptr<frpc::RpcServerSchedulingStrategy> request_scheduler_;
    std::shared_ptr<CalculatorServer_IServerImplementation> implementation_;

};

struct CalculatorServerProxy
    : public frpc::RpcServer
{
    CalculatorServerProxy(
            std::shared_ptr<frpc::RpcServer> impl)
        : impl_(std::move(impl))
    {
    }

    ~CalculatorServerProxy() override
    {
        if (impl_)
        {
            impl_->stop();
        }
    }

    void run() override
    {
        impl_->run();
    }

    void stop() override
    {
        impl_->stop();
    }

    void execute_request(
            const std::shared_ptr<frpc::RpcRequest>& request) override
    {
        impl_->execute_request(request);
    }

private:

   std::shared_ptr<frpc::RpcServer> impl_;
};

}  // namespace detail

std::shared_ptr<eprosima::fastdds::dds::rpc::RpcServer> create_CalculatorServer(
        eprosima::fastdds::dds::DomainParticipant& part,
        const char* service_name,
        const eprosima::fastdds::dds::ReplierQos& qos,
        size_t thread_pool_size,
        std::shared_ptr<CalculatorServer_IServerImplementation> implementation)
{
    auto ptr = std::make_shared<detail::CalculatorServerLogic>(
        part, service_name, qos, thread_pool_size, implementation);
    return std::make_shared<detail::CalculatorServerProxy>(ptr);
}

std::shared_ptr<eprosima::fastdds::dds::rpc::RpcServer> create_CalculatorServer(
        eprosima::fastdds::dds::DomainParticipant& part,
        const char* service_name,
        const eprosima::fastdds::dds::ReplierQos& qos,
        std::shared_ptr<eprosima::fastdds::dds::rpc::RpcServerSchedulingStrategy> scheduler,
        std::shared_ptr<CalculatorServer_IServerImplementation> implementation)
{
    auto ptr = std::make_shared<detail::CalculatorServerLogic>(
        part, service_name, qos, scheduler, implementation);
    return std::make_shared<detail::CalculatorServerProxy>(ptr);
}

//} interface Calculator


} // namespace calculator_example

