// Copyright 2023 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file include/fastdds/statistics/ms_types.idl
 */

#include "types.idl"

module eprosima {
module fastdds {
module statistics {

	/* Reuse existing statistics detail module*/
	module detail
	{
		typedef eprosima::fastdds::statistics::detail::EntityId_s EntityId_m;
		typedef eprosima::fastdds::statistics::detail::GUID_s GUID_m;
		typedef eprosima::fastdds::statistics::detail::GuidPrefix_s GuidPrefix_m;
		typedef eprosima::fastdds::statistics::detail::Locator_s Locator_m;
	};

	enum ConnectionMode
	{
		DATA_SHARING,
		INTRAPROCESS,
		TRANSPORT
	};

	struct Connection
	{
		ConnectionMode mode;
		detail::GUID_m guid;
		sequence<detail::Locator_m> announced_locators;
		sequence<detail::Locator_m> used_locators;
	};

	struct QosPolicyCount_m
	{
		unsigned long policy_id;
		unsigned long count;
	};

	struct BaseStatus_m
	{
		unsigned long total_count;
	};

	typedef sequence<QosPolicyCount_m> QosPolicyCountSeq_m;

	struct IncompatibleQoSStatus_m
	{
		unsigned long total_count;
		unsigned long last_policy_id;
		QosPolicyCountSeq_m policies;
	};

	struct LivelinessChangedStatus_m
	{
		unsigned long alive_count;
		unsigned long not_alive_count;
		octet last_publication_handle[16];
	};

	struct DeadlineMissedStatus_m
	{
		unsigned long total_count;
		octet last_instance_handle[16];
	};

	typedef BaseStatus_m LivelinessLostStatus_m;
	typedef BaseStatus_m InconsistentTopicStatus_m;
	typedef BaseStatus_m SampleLostStatus_m;

	enum StatusKind
	{
		PROXY,
		CONNECTION_LIST,
		INCOMPATIBLE_QOS,
		INCONSISTENT_TOPIC,
		LIVELINESS_LOST,
		LIVELINESS_CHANGED,
		DEADLINE_MISSED,
		SAMPLE_LOST,
		STATUSES_SIZE
	};

	union MonitorServiceData switch(StatusKind)
	{
		case PROXY:
			sequence<octet> entity_proxy;
		case CONNECTION_LIST:
			sequence<Connection> connection_list;
		case INCOMPATIBLE_QOS:
			IncompatibleQoSStatus_m incompatible_qos_status;
		case INCONSISTENT_TOPIC:
			InconsistentTopicStatus_m inconsistent_topic_status;
		case LIVELINESS_LOST:
			LivelinessLostStatus_m liveliness_lost_status;
		case LIVELINESS_CHANGED:
			LivelinessChangedStatus_m liveliness_changed_status;
		case DEADLINE_MISSED:
			DeadlineMissedStatus_m deadline_missed_status;
		case SAMPLE_LOST:
			SampleLostStatus_m sample_lost_status;
		case STATUSES_SIZE:
			octet statuses_size;
	};

	struct MonitorServiceStatusData
	{
		@Key detail::GUID_m local_entity;
		@Key StatusKind status_kind;
		MonitorServiceData value;
	};

}; // namespace statisitcs
}; // namespace fastdds
}; // namespace eprosima

