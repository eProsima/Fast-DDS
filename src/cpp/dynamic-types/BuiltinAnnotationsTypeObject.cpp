// Copyright 2019 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file BuiltinAnnotationsTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
} // namespace
#endif // ifdef _WIN32

#include <utility>
#include <sstream>

#include <fastdds/rtps/common/CdrSerialization.hpp>
#include <fastdds/rtps/common/SerializedPayload.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastrtps/types/BuiltinAnnotationsTypeObject.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/utils/md5.h>

using namespace eprosima::fastrtps::rtps;

void register_builtin_annotations_types(
        TypeObjectFactory* factory)
{
    factory->add_type_object("id", GetidIdentifier(factory, true), GetidObject(factory, true));
    factory->add_type_object("id", GetidIdentifier(factory, false), GetidObject(factory, false));

    factory->add_type_object("autoid", GetautoidIdentifier(factory, true), GetautoidObject(factory, true));
    factory->add_type_object("autoid", GetautoidIdentifier(factory, false), GetautoidObject(factory, false));
    {
        using namespace autoid;

        factory->add_type_object("AutoidKind", GetAutoidKindIdentifier(factory, true), GetAutoidKindObject(factory,
                true));
        factory->add_type_object("AutoidKind", GetAutoidKindIdentifier(factory, false),
                GetAutoidKindObject(factory, false));


    }
    factory->add_type_object("optional", GetoptionalIdentifier(factory, true), GetoptionalObject(factory, true));
    factory->add_type_object("optional", GetoptionalIdentifier(factory, false), GetoptionalObject(factory, false));

    factory->add_type_object("position", GetpositionIdentifier(factory, true), GetpositionObject(factory, true));
    factory->add_type_object("position", GetpositionIdentifier(factory, false), GetpositionObject(factory, false));

    factory->add_type_object("value", GetvalueIdentifier(factory, true), GetvalueObject(factory, true));
    factory->add_type_object("value", GetvalueIdentifier(factory, false), GetvalueObject(factory, false));

    factory->add_type_object("extensibility", GetextensibilityIdentifier(factory, true),
            GetextensibilityObject(factory, true));
    factory->add_type_object("extensibility", GetextensibilityIdentifier(factory, false),
            GetextensibilityObject(factory, false));
    {
        using namespace extensibility;

        factory->add_type_object("ExtensibilityKind", GetExtensibilityKindIdentifier(factory, true),
                GetExtensibilityKindObject(factory, true));
        factory->add_type_object("ExtensibilityKind", GetExtensibilityKindIdentifier(factory, false),
                GetExtensibilityKindObject(factory, false));


    }
    factory->add_type_object("final", GetfinalIdentifier(factory, true), GetfinalObject(factory, true));
    factory->add_type_object("final", GetfinalIdentifier(factory, false), GetfinalObject(factory, false));

    factory->add_type_object("appendable", GetappendableIdentifier(factory, true), GetappendableObject(factory, true));
    factory->add_type_object("appendable", GetappendableIdentifier(factory, false),
            GetappendableObject(factory, false));

    factory->add_type_object("mutable", GetmutableIdentifier(factory, true), GetmutableObject(factory, true));
    factory->add_type_object("mutable", GetmutableIdentifier(factory, false), GetmutableObject(factory, false));

    factory->add_type_object("key", GetkeyIdentifier(factory, true), GetkeyObject(factory, true));
    factory->add_type_object("key", GetkeyIdentifier(factory, false), GetkeyObject(factory, false));

    factory->add_type_object("Key", GetkeyIdentifier(factory, true), GetkeyObject(factory, true));
    factory->add_type_object("Key", GetkeyIdentifier(factory, false), GetkeyObject(factory, false));

    factory->add_type_object("must_understand", Getmust_understandIdentifier(factory, true),
            Getmust_understandObject(factory, true));
    factory->add_type_object("must_understand", Getmust_understandIdentifier(factory, false),
            Getmust_understandObject(factory, false));

    factory->add_type_object("default_literal", Getdefault_literalIdentifier(factory, true),
            Getdefault_literalObject(factory, true));
    factory->add_type_object("default_literal", Getdefault_literalIdentifier(factory, false),
            Getdefault_literalObject(factory, false));

    factory->add_type_object("default", GetdefaultIdentifier(factory, true), GetdefaultObject(factory, true));
    factory->add_type_object("default", GetdefaultIdentifier(factory, false), GetdefaultObject(factory, false));

    factory->add_type_object("range", GetrangeIdentifier(factory, true), GetrangeObject(factory, true));
    factory->add_type_object("range", GetrangeIdentifier(factory, false), GetrangeObject(factory, false));

    factory->add_type_object("min", GetminIdentifier(factory, true), GetminObject(factory, true));
    factory->add_type_object("min", GetminIdentifier(factory, false), GetminObject(factory, false));

    factory->add_type_object("max", GetmaxIdentifier(factory, true), GetmaxObject(factory, true));
    factory->add_type_object("max", GetmaxIdentifier(factory, false), GetmaxObject(factory, false));

    factory->add_type_object("unit", GetunitIdentifier(factory, true), GetunitObject(factory, true));
    factory->add_type_object("unit", GetunitIdentifier(factory, false), GetunitObject(factory, false));

    factory->add_type_object("bit_bound", Getbit_boundIdentifier(factory, true), Getbit_boundObject(factory, true));
    factory->add_type_object("bit_bound", Getbit_boundIdentifier(factory, false), Getbit_boundObject(factory, false));

    factory->add_type_object("external", GetexternalIdentifier(factory, true), GetexternalObject(factory, true));
    factory->add_type_object("external", GetexternalIdentifier(factory, false), GetexternalObject(factory, false));

    factory->add_type_object("nested", GetnestedIdentifier(factory, true), GetnestedObject(factory, true));
    factory->add_type_object("nested", GetnestedIdentifier(factory, false), GetnestedObject(factory, false));

    factory->add_type_object("verbatim", GetverbatimIdentifier(factory, true), GetverbatimObject(factory, true));
    factory->add_type_object("verbatim", GetverbatimIdentifier(factory, false), GetverbatimObject(factory, false));
    {
        using namespace verbatim;

        factory->add_type_object("PlacementKind", GetPlacementKindIdentifier(factory, true),
                GetPlacementKindObject(factory, true));
        factory->add_type_object("PlacementKind", GetPlacementKindIdentifier(factory, false),
                GetPlacementKindObject(factory, false));


    }
    factory->add_type_object("service", GetserviceIdentifier(factory, true), GetserviceObject(factory, true));
    factory->add_type_object("service", GetserviceIdentifier(factory, false), GetserviceObject(factory, false));

    factory->add_type_object("oneway", GetonewayIdentifier(factory, true), GetonewayObject(factory, true));
    factory->add_type_object("oneway", GetonewayIdentifier(factory, false), GetonewayObject(factory, false));

    factory->add_type_object("ami", GetamiIdentifier(factory, true), GetamiObject(factory, true));
    factory->add_type_object("ami", GetamiIdentifier(factory, false), GetamiObject(factory, false));

    factory->add_type_object("non_serialized", Getnon_serializedIdentifier(factory, true),
            Getnon_serializedObject(factory, true));
    factory->add_type_object("non_serialized", Getnon_serializedIdentifier(factory, false),
            Getnon_serializedObject(factory, false));

}

const TypeIdentifier* GetidIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("id", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetidObject(factory, complete); // Generated inside
    return factory->get_type_identifier("id", complete);
}

const TypeObject* GetidObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("id", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteidObject(factory);
    }
    // else
    return GetMinimalidObject(factory);
}

const TypeObject* GetMinimalidObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("id", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("uint32_t", false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("id", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("id", false);
}

const TypeObject* GetCompleteidObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("id", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("id");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("uint32_t", false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("id", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("id", true);
}

const TypeIdentifier* GetautoidIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("autoid", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetautoidObject(factory, complete); // Generated inside
    return factory->get_type_identifier("autoid", complete);
}

const TypeObject* GetautoidObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("autoid", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteautoidObject(factory);
    }
    // else
    return GetMinimalautoidObject(factory);
}

const TypeObject* GetMinimalautoidObject(
        TypeObjectFactory* factory)
{
    using namespace autoid;
    const TypeObject* c_type_object = factory->get_type_object("autoid", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*GetAutoidKindIdentifier(factory, false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("1");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("autoid", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("autoid", false);
}

const TypeObject* GetCompleteautoidObject(
        TypeObjectFactory* factory)
{
    using namespace autoid;
    const TypeObject* c_type_object = factory->get_type_object("autoid", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("autoid");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*GetAutoidKindIdentifier(factory, true));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("1");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("autoid", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("autoid", true);
}

namespace autoid {
const TypeIdentifier* GetAutoidKindIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("AutoidKind", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAutoidKindObject(factory, complete); // Generated inside
    return factory->get_type_identifier("AutoidKind", complete);
}

const TypeObject* GetAutoidKindObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("AutoidKind", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAutoidKindObject(factory);
    }
    // else
    return GetMinimalAutoidKindObject(factory);
}

const TypeObject* GetMinimalAutoidKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("AutoidKind", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_SEQUENTIAL;
    mel_SEQUENTIAL.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().IS_KEY(false); // Doesn't apply
    mel_SEQUENTIAL.common().flags().IS_DEFAULT(false);
    mel_SEQUENTIAL.common().value(value++);
    MD5 SEQUENTIAL_hash("SEQUENTIAL");
    for (int i = 0; i < 4; ++i)
    {
        mel_SEQUENTIAL.detail().name_hash()[i] = SEQUENTIAL_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_SEQUENTIAL);

    MinimalEnumeratedLiteral mel_HASH;
    mel_HASH.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_HASH.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_HASH.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_HASH.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_HASH.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_HASH.common().flags().IS_KEY(false); // Doesn't apply
    mel_HASH.common().flags().IS_DEFAULT(false);
    mel_HASH.common().value(value++);
    MD5 HASH_hash("HASH");
    for (int i = 0; i < 4; ++i)
    {
        mel_HASH.detail().name_hash()[i] = HASH_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_HASH);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("AutoidKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("AutoidKind", false);
}

const TypeObject* GetCompleteAutoidKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("AutoidKind", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    //type_object->complete().enumerated_type().header().detail().ann_builtin()...
    //type_object->complete().enumerated_type().header().detail().ann_custom()...
    type_object->complete().enumerated_type().header().detail().type_name("AutoidKind");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_SEQUENTIAL;
    cel_SEQUENTIAL.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().IS_KEY(false); // Doesn't apply
    cel_SEQUENTIAL.common().flags().IS_DEFAULT(false);
    cel_SEQUENTIAL.common().value(value++);
    cel_SEQUENTIAL.detail().name("SEQUENTIAL");
    //cel_SEQUENTIAL.detail().ann_builtin()...
    //cel_SEQUENTIAL.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_SEQUENTIAL);

    CompleteEnumeratedLiteral cel_HASH;
    cel_HASH.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_HASH.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_HASH.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_HASH.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_HASH.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_HASH.common().flags().IS_KEY(false); // Doesn't apply
    cel_HASH.common().flags().IS_DEFAULT(false);
    cel_HASH.common().value(value++);
    cel_HASH.detail().name("HASH");
    //cel_HASH.detail().ann_builtin()...
    //cel_HASH.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_HASH);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("AutoidKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("AutoidKind", true);
}

} // autoid namespace
const TypeIdentifier* GetoptionalIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("optional", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetoptionalObject(factory, complete); // Generated inside
    return factory->get_type_identifier("optional", complete);
}

const TypeObject* GetoptionalObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("optional", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteoptionalObject(factory);
    }
    // else
    return GetMinimaloptionalObject(factory);
}

const TypeObject* GetMinimaloptionalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("optional", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("optional", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("optional", false);
}

const TypeObject* GetCompleteoptionalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("optional", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("optional");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("optional", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("optional", true);
}

const TypeIdentifier* GetpositionIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("position", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetpositionObject(factory, complete); // Generated inside
    return factory->get_type_identifier("position", complete);
}

const TypeObject* GetpositionObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("position", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletepositionObject(factory);
    }
    // else
    return GetMinimalpositionObject(factory);
}

const TypeObject* GetMinimalpositionObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("position", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("uint16_t", false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("position", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("position", false);
}

const TypeObject* GetCompletepositionObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("position", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("position");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("uint16_t", false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("position", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("position", true);
}

const TypeIdentifier* GetvalueIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("value", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetvalueObject(factory, complete); // Generated inside
    return factory->get_type_identifier("value", complete);
}

const TypeObject* GetvalueObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("value", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletevalueObject(factory);
    }
    // else
    return GetMinimalvalueObject(factory);
}

const TypeObject* GetMinimalvalueObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("value", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("value", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("value", false);
}

const TypeObject* GetCompletevalueObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("value", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("value");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("value", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("value", true);
}

const TypeIdentifier* GetextensibilityIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("extensibility",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetextensibilityObject(factory, complete); // Generated inside
    return factory->get_type_identifier("extensibility", complete);
}

const TypeObject* GetextensibilityObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("extensibility", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteextensibilityObject(factory);
    }
    // else
    return GetMinimalextensibilityObject(factory);
}

const TypeObject* GetMinimalextensibilityObject(
        TypeObjectFactory* factory)
{
    using namespace extensibility;
    const TypeObject* c_type_object = factory->get_type_object("extensibility", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*GetExtensibilityKindIdentifier(factory, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("extensibility", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("extensibility", false);
}

const TypeObject* GetCompleteextensibilityObject(
        TypeObjectFactory* factory)
{
    using namespace extensibility;
    const TypeObject* c_type_object = factory->get_type_object("extensibility", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("extensibility");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*GetExtensibilityKindIdentifier(factory, true));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("extensibility", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("extensibility", true);
}

namespace extensibility {
const TypeIdentifier* GetExtensibilityKindIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("ExtensibilityKind",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetExtensibilityKindObject(factory, complete); // Generated inside
    return factory->get_type_identifier("ExtensibilityKind", complete);
}

const TypeObject* GetExtensibilityKindObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("ExtensibilityKind", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteExtensibilityKindObject(factory);
    }
    // else
    return GetMinimalExtensibilityKindObject(factory);
}

const TypeObject* GetMinimalExtensibilityKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("ExtensibilityKind", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_FINAL;
    mel_FINAL.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_FINAL.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_FINAL.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_FINAL.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_FINAL.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_FINAL.common().flags().IS_KEY(false); // Doesn't apply
    mel_FINAL.common().flags().IS_DEFAULT(false);
    mel_FINAL.common().value(value++);
    MD5 FINAL_hash("FINAL");
    for (int i = 0; i < 4; ++i)
    {
        mel_FINAL.detail().name_hash()[i] = FINAL_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_FINAL);

    MinimalEnumeratedLiteral mel_APPENDABLE;
    mel_APPENDABLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_APPENDABLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_APPENDABLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_APPENDABLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_APPENDABLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_APPENDABLE.common().flags().IS_KEY(false); // Doesn't apply
    mel_APPENDABLE.common().flags().IS_DEFAULT(false);
    mel_APPENDABLE.common().value(value++);
    MD5 APPENDABLE_hash("APPENDABLE");
    for (int i = 0; i < 4; ++i)
    {
        mel_APPENDABLE.detail().name_hash()[i] = APPENDABLE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_APPENDABLE);

    MinimalEnumeratedLiteral mel_MUTABLE;
    mel_MUTABLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_MUTABLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_MUTABLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_MUTABLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_MUTABLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_MUTABLE.common().flags().IS_KEY(false); // Doesn't apply
    mel_MUTABLE.common().flags().IS_DEFAULT(false);
    mel_MUTABLE.common().value(value++);
    MD5 MUTABLE_hash("MUTABLE");
    for (int i = 0; i < 4; ++i)
    {
        mel_MUTABLE.detail().name_hash()[i] = MUTABLE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_MUTABLE);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("ExtensibilityKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("ExtensibilityKind", false);
}

const TypeObject* GetCompleteExtensibilityKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("ExtensibilityKind", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    //type_object->complete().enumerated_type().header().detail().ann_builtin()...
    //type_object->complete().enumerated_type().header().detail().ann_custom()...
    type_object->complete().enumerated_type().header().detail().type_name("ExtensibilityKind");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_FINAL;
    cel_FINAL.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_FINAL.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_FINAL.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_FINAL.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_FINAL.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_FINAL.common().flags().IS_KEY(false); // Doesn't apply
    cel_FINAL.common().flags().IS_DEFAULT(false);
    cel_FINAL.common().value(value++);
    cel_FINAL.detail().name("FINAL");
    //cel_FINAL.detail().ann_builtin()...
    //cel_FINAL.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_FINAL);

    CompleteEnumeratedLiteral cel_APPENDABLE;
    cel_APPENDABLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_APPENDABLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_APPENDABLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_APPENDABLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_APPENDABLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_APPENDABLE.common().flags().IS_KEY(false); // Doesn't apply
    cel_APPENDABLE.common().flags().IS_DEFAULT(false);
    cel_APPENDABLE.common().value(value++);
    cel_APPENDABLE.detail().name("APPENDABLE");
    //cel_APPENDABLE.detail().ann_builtin()...
    //cel_APPENDABLE.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_APPENDABLE);

    CompleteEnumeratedLiteral cel_MUTABLE;
    cel_MUTABLE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_MUTABLE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_MUTABLE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_MUTABLE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_MUTABLE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_MUTABLE.common().flags().IS_KEY(false); // Doesn't apply
    cel_MUTABLE.common().flags().IS_DEFAULT(false);
    cel_MUTABLE.common().value(value++);
    cel_MUTABLE.detail().name("MUTABLE");
    //cel_MUTABLE.detail().ann_builtin()...
    //cel_MUTABLE.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_MUTABLE);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("ExtensibilityKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("ExtensibilityKind", true);
}

} // extensibility namespace
const TypeIdentifier* GetfinalIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("final", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetfinalObject(factory, complete); // Generated inside
    return factory->get_type_identifier("final", complete);
}

const TypeObject* GetfinalObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("final", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletefinalObject(factory);
    }
    // else
    return GetMinimalfinalObject(factory);
}

const TypeObject* GetMinimalfinalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("final", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("final", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("final", false);
}

const TypeObject* GetCompletefinalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("final", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("final");


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("final", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("final", true);
}

const TypeIdentifier* GetappendableIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("appendable", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetappendableObject(factory, complete); // Generated inside
    return factory->get_type_identifier("appendable", complete);
}

const TypeObject* GetappendableObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("appendable", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteappendableObject(factory);
    }
    // else
    return GetMinimalappendableObject(factory);
}

const TypeObject* GetMinimalappendableObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("appendable", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("appendable", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("appendable", false);
}

const TypeObject* GetCompleteappendableObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("appendable", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("appendable");


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("appendable", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("appendable", true);
}

const TypeIdentifier* GetmutableIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("mutable", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetmutableObject(factory, complete); // Generated inside
    return factory->get_type_identifier("mutable", complete);
}

const TypeObject* GetmutableObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("mutable", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemutableObject(factory);
    }
    // else
    return GetMinimalmutableObject(factory);
}

const TypeObject* GetMinimalmutableObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("mutable", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("mutable", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("mutable", false);
}

const TypeObject* GetCompletemutableObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("mutable", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("mutable");


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("mutable", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("mutable", true);
}

const TypeIdentifier* GetkeyIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("key", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetkeyObject(factory, complete); // Generated inside
    return factory->get_type_identifier("key", complete);
}

const TypeObject* GetkeyObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("key", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletekeyObject(factory);
    }
    // else
    return GetMinimalkeyObject(factory);
}

const TypeObject* GetMinimalkeyObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("key", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("key", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("key", false);
}

const TypeObject* GetCompletekeyObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("key", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("key");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("key", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("key", true);
}

const TypeIdentifier* Getmust_understandIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("must_understand",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getmust_understandObject(factory, complete); // Generated inside
    return factory->get_type_identifier("must_understand", complete);
}

const TypeObject* Getmust_understandObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("must_understand", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemust_understandObject(factory);
    }
    // else
    return GetMinimalmust_understandObject(factory);
}

const TypeObject* GetMinimalmust_understandObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("must_understand", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("must_understand", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("must_understand", false);
}

const TypeObject* GetCompletemust_understandObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("must_understand", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("must_understand");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("must_understand", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("must_understand", true);
}

const TypeIdentifier* Getdefault_literalIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("default_literal",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getdefault_literalObject(factory, complete); // Generated inside
    return factory->get_type_identifier("default_literal", complete);
}

const TypeObject* Getdefault_literalObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("default_literal", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedefault_literalObject(factory);
    }
    // else
    return GetMinimaldefault_literalObject(factory);
}

const TypeObject* GetMinimaldefault_literalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("default_literal", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("default_literal", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("default_literal", false);
}

const TypeObject* GetCompletedefault_literalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("default_literal", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("default_literal");


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("default_literal", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("default_literal", true);
}

const TypeIdentifier* GetdefaultIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("default", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetdefaultObject(factory, complete); // Generated inside
    return factory->get_type_identifier("default", complete);
}

const TypeObject* GetdefaultObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("default", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletedefaultObject(factory);
    }
    // else
    return GetMinimaldefaultObject(factory);
}

const TypeObject* GetMinimaldefaultObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("default", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("default", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("default", false);
}

const TypeObject* GetCompletedefaultObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("default", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("default");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("default", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("default", true);
}

const TypeIdentifier* GetrangeIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("range", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetrangeObject(factory, complete); // Generated inside
    return factory->get_type_identifier("range", complete);
}

const TypeObject* GetrangeObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("range", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleterangeObject(factory);
    }
    // else
    return GetMinimalrangeObject(factory);
}

const TypeObject* GetMinimalrangeObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("range", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_min;
    mam_min.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_min.name("min");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_min);

    MinimalAnnotationParameter mam_max;
    mam_max.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_max.name("max");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_max);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("range", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("range", false);
}

const TypeObject* GetCompleterangeObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("range", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("range");

    CompleteAnnotationParameter cam_min;
    cam_min.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_min.name("min");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_min);

    CompleteAnnotationParameter cam_max;
    cam_max.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_max.name("max");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_max);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("range", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("range", true);
}

const TypeIdentifier* GetminIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("min", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetminObject(factory, complete); // Generated inside
    return factory->get_type_identifier("min", complete);
}

const TypeObject* GetminObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("min", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteminObject(factory);
    }
    // else
    return GetMinimalminObject(factory);
}

const TypeObject* GetMinimalminObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("min", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("min", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("min", false);
}

const TypeObject* GetCompleteminObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("min", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("min");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("min", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("min", true);
}

const TypeIdentifier* GetmaxIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("max", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetmaxObject(factory, complete); // Generated inside
    return factory->get_type_identifier("max", complete);
}

const TypeObject* GetmaxObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("max", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletemaxObject(factory);
    }
    // else
    return GetMinimalmaxObject(factory);
}

const TypeObject* GetMinimalmaxObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("max", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("max", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("max", false);
}

const TypeObject* GetCompletemaxObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("max", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("max");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("max", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("max", true);
}

const TypeIdentifier* GetunitIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("unit", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetunitObject(factory, complete); // Generated inside
    return factory->get_type_identifier("unit", complete);
}

const TypeObject* GetunitObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("unit", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteunitObject(factory);
    }
    // else
    return GetMinimalunitObject(factory);
}

const TypeObject* GetMinimalunitObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("unit", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("unit", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("unit", false);
}

const TypeObject* GetCompleteunitObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("unit", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("unit");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("unit", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("unit", true);
}

const TypeIdentifier* Getbit_boundIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("bit_bound", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getbit_boundObject(factory, complete); // Generated inside
    return factory->get_type_identifier("bit_bound", complete);
}

const TypeObject* Getbit_boundObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("bit_bound", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletebit_boundObject(factory);
    }
    // else
    return GetMinimalbit_boundObject(factory);
}

const TypeObject* GetMinimalbit_boundObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("bit_bound", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("uint16_t", false));
    mam_value.name("value");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("bit_bound", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("bit_bound", false);
}

const TypeObject* GetCompletebit_boundObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("bit_bound", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("bit_bound");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("uint16_t", false));
    cam_value.name("value");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("bit_bound", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("bit_bound", true);
}

const TypeIdentifier* GetexternalIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("external", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetexternalObject(factory, complete); // Generated inside
    return factory->get_type_identifier("external", complete);
}

const TypeObject* GetexternalObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("external", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteexternalObject(factory);
    }
    // else
    return GetMinimalexternalObject(factory);
}

const TypeObject* GetMinimalexternalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("external", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("external", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("external", false);
}

const TypeObject* GetCompleteexternalObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("external", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("external");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("external", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("external", true);
}

const TypeIdentifier* GetnestedIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("nested", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetnestedObject(factory, complete); // Generated inside
    return factory->get_type_identifier("nested", complete);
}

const TypeObject* GetnestedObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("nested", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletenestedObject(factory);
    }
    // else
    return GetMinimalnestedObject(factory);
}

const TypeObject* GetMinimalnestedObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("nested", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("nested", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("nested", false);
}

const TypeObject* GetCompletenestedObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("nested", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("nested");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("nested", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("nested", true);
}

const TypeIdentifier* GetverbatimIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("verbatim", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetverbatimObject(factory, complete); // Generated inside
    return factory->get_type_identifier("verbatim", complete);
}

const TypeObject* GetverbatimObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("verbatim", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteverbatimObject(factory);
    }
    // else
    return GetMinimalverbatimObject(factory);
}

const TypeObject* GetMinimalverbatimObject(
        TypeObjectFactory* factory)
{
    using namespace verbatim;
    const TypeObject* c_type_object = factory->get_type_object("verbatim", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_language;
    mam_language.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_language.name("language");

    AnnotationParameterValue def_value_language;
    def_value_language._d(mam_language.common().member_type_id()._d());
    def_value_language.from_string("*");
    mam_language.default_value(def_value_language);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_language);

    MinimalAnnotationParameter mam_placement;
    mam_placement.common().member_type_id(*GetPlacementKindIdentifier(factory, false));
    mam_placement.name("placement");

    AnnotationParameterValue def_value_placement;
    def_value_placement._d(mam_placement.common().member_type_id()._d());
    def_value_placement.from_string("1");
    mam_placement.default_value(def_value_placement);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_placement);

    MinimalAnnotationParameter mam_text;
    mam_text.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_text.name("text");

    type_object->minimal().annotation_type().member_seq().emplace_back(mam_text);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("verbatim", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("verbatim", false);
}

const TypeObject* GetCompleteverbatimObject(
        TypeObjectFactory* factory)
{
    using namespace verbatim;
    const TypeObject* c_type_object = factory->get_type_object("verbatim", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("verbatim");

    CompleteAnnotationParameter cam_language;
    cam_language.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_language.name("language");

    AnnotationParameterValue def_value_language;
    def_value_language._d(cam_language.common().member_type_id()._d());
    def_value_language.from_string("*");
    cam_language.default_value(def_value_language);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_language);

    CompleteAnnotationParameter cam_placement;
    cam_placement.common().member_type_id(*GetPlacementKindIdentifier(factory, true));
    cam_placement.name("placement");

    AnnotationParameterValue def_value_placement;
    def_value_placement._d(cam_placement.common().member_type_id()._d());
    def_value_placement.from_string("1");
    cam_placement.default_value(def_value_placement);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_placement);

    CompleteAnnotationParameter cam_text;
    cam_text.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_text.name("text");

    type_object->complete().annotation_type().member_seq().emplace_back(cam_text);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("verbatim", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("verbatim", true);
}

namespace verbatim {
const TypeIdentifier* GetPlacementKindIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("PlacementKind",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetPlacementKindObject(factory, complete); // Generated inside
    return factory->get_type_identifier("PlacementKind", complete);
}

const TypeObject* GetPlacementKindObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("PlacementKind", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletePlacementKindObject(factory);
    }
    // else
    return GetMinimalPlacementKindObject(factory);
}

const TypeObject* GetMinimalPlacementKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("PlacementKind", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);

    // No flags apply
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_BEGIN_FILE;
    mel_BEGIN_FILE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().IS_KEY(false); // Doesn't apply
    mel_BEGIN_FILE.common().flags().IS_DEFAULT(false);
    mel_BEGIN_FILE.common().value(value++);
    MD5 BEGIN_FILE_hash("BEGIN_FILE");
    for (int i = 0; i < 4; ++i)
    {
        mel_BEGIN_FILE.detail().name_hash()[i] = BEGIN_FILE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_BEGIN_FILE);

    MinimalEnumeratedLiteral mel_BEFORE_DECLARATION;
    mel_BEFORE_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    mel_BEFORE_DECLARATION.common().flags().IS_DEFAULT(false);
    mel_BEFORE_DECLARATION.common().value(value++);
    MD5 BEFORE_DECLARATION_hash("BEFORE_DECLARATION");
    for (int i = 0; i < 4; ++i)
    {
        mel_BEFORE_DECLARATION.detail().name_hash()[i] = BEFORE_DECLARATION_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_BEFORE_DECLARATION);

    MinimalEnumeratedLiteral mel_BEGIN_DECLARATION;
    mel_BEGIN_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    mel_BEGIN_DECLARATION.common().flags().IS_DEFAULT(false);
    mel_BEGIN_DECLARATION.common().value(value++);
    MD5 BEGIN_DECLARATION_hash("BEGIN_DECLARATION");
    for (int i = 0; i < 4; ++i)
    {
        mel_BEGIN_DECLARATION.detail().name_hash()[i] = BEGIN_DECLARATION_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_BEGIN_DECLARATION);

    MinimalEnumeratedLiteral mel_END_DECLARATION;
    mel_END_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    mel_END_DECLARATION.common().flags().IS_DEFAULT(false);
    mel_END_DECLARATION.common().value(value++);
    MD5 END_DECLARATION_hash("END_DECLARATION");
    for (int i = 0; i < 4; ++i)
    {
        mel_END_DECLARATION.detail().name_hash()[i] = END_DECLARATION_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_END_DECLARATION);

    MinimalEnumeratedLiteral mel_AFTER_DECLARATION;
    mel_AFTER_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    mel_AFTER_DECLARATION.common().flags().IS_DEFAULT(false);
    mel_AFTER_DECLARATION.common().value(value++);
    MD5 AFTER_DECLARATION_hash("AFTER_DECLARATION");
    for (int i = 0; i < 4; ++i)
    {
        mel_AFTER_DECLARATION.detail().name_hash()[i] = AFTER_DECLARATION_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_AFTER_DECLARATION);

    MinimalEnumeratedLiteral mel_END_FILE;
    mel_END_FILE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    mel_END_FILE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    mel_END_FILE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    mel_END_FILE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    mel_END_FILE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    mel_END_FILE.common().flags().IS_KEY(false); // Doesn't apply
    mel_END_FILE.common().flags().IS_DEFAULT(false);
    mel_END_FILE.common().value(value++);
    MD5 END_FILE_hash("END_FILE");
    for (int i = 0; i < 4; ++i)
    {
        mel_END_FILE.detail().name_hash()[i] = END_FILE_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_END_FILE);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("PlacementKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("PlacementKind", false);
}

const TypeObject* GetCompletePlacementKindObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("PlacementKind", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    // No flags apply
    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(factory, false);
    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(factory, false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    //type_object->complete().enumerated_type().header().detail().ann_builtin()...
    //type_object->complete().enumerated_type().header().detail().ann_custom()...
    type_object->complete().enumerated_type().header().detail().type_name("PlacementKind");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_BEGIN_FILE;
    cel_BEGIN_FILE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().IS_KEY(false); // Doesn't apply
    cel_BEGIN_FILE.common().flags().IS_DEFAULT(false);
    cel_BEGIN_FILE.common().value(value++);
    cel_BEGIN_FILE.detail().name("BEGIN_FILE");
    //cel_BEGIN_FILE.detail().ann_builtin()...
    //cel_BEGIN_FILE.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_BEGIN_FILE);

    CompleteEnumeratedLiteral cel_BEFORE_DECLARATION;
    cel_BEFORE_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    cel_BEFORE_DECLARATION.common().flags().IS_DEFAULT(false);
    cel_BEFORE_DECLARATION.common().value(value++);
    cel_BEFORE_DECLARATION.detail().name("BEFORE_DECLARATION");
    //cel_BEFORE_DECLARATION.detail().ann_builtin()...
    //cel_BEFORE_DECLARATION.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_BEFORE_DECLARATION);

    CompleteEnumeratedLiteral cel_BEGIN_DECLARATION;
    cel_BEGIN_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    cel_BEGIN_DECLARATION.common().flags().IS_DEFAULT(false);
    cel_BEGIN_DECLARATION.common().value(value++);
    cel_BEGIN_DECLARATION.detail().name("BEGIN_DECLARATION");
    //cel_BEGIN_DECLARATION.detail().ann_builtin()...
    //cel_BEGIN_DECLARATION.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_BEGIN_DECLARATION);

    CompleteEnumeratedLiteral cel_END_DECLARATION;
    cel_END_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    cel_END_DECLARATION.common().flags().IS_DEFAULT(false);
    cel_END_DECLARATION.common().value(value++);
    cel_END_DECLARATION.detail().name("END_DECLARATION");
    //cel_END_DECLARATION.detail().ann_builtin()...
    //cel_END_DECLARATION.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_END_DECLARATION);

    CompleteEnumeratedLiteral cel_AFTER_DECLARATION;
    cel_AFTER_DECLARATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().IS_KEY(false); // Doesn't apply
    cel_AFTER_DECLARATION.common().flags().IS_DEFAULT(false);
    cel_AFTER_DECLARATION.common().value(value++);
    cel_AFTER_DECLARATION.detail().name("AFTER_DECLARATION");
    //cel_AFTER_DECLARATION.detail().ann_builtin()...
    //cel_AFTER_DECLARATION.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_AFTER_DECLARATION);

    CompleteEnumeratedLiteral cel_END_FILE;
    cel_END_FILE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
    cel_END_FILE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
    cel_END_FILE.common().flags().IS_EXTERNAL(false); // Doesn't apply
    cel_END_FILE.common().flags().IS_OPTIONAL(false); // Doesn't apply
    cel_END_FILE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
    cel_END_FILE.common().flags().IS_KEY(false); // Doesn't apply
    cel_END_FILE.common().flags().IS_DEFAULT(false);
    cel_END_FILE.common().value(value++);
    cel_END_FILE.detail().name("END_FILE");
    //cel_END_FILE.detail().ann_builtin()...
    //cel_END_FILE.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_END_FILE);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().enumerated_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("PlacementKind", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("PlacementKind", true);
}

} // verbatim namespace
const TypeIdentifier* GetserviceIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("service", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetserviceObject(factory, complete); // Generated inside
    return factory->get_type_identifier("service", complete);
}

const TypeObject* GetserviceObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("service", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteserviceObject(factory);
    }
    // else
    return GetMinimalserviceObject(factory);
}

const TypeObject* GetMinimalserviceObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("service", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_platform;
    mam_platform.common().member_type_id(*factory->get_string_identifier(255, false));
    mam_platform.name("platform");

    AnnotationParameterValue def_value_platform;
    def_value_platform._d(mam_platform.common().member_type_id()._d());
    def_value_platform.from_string("*");
    mam_platform.default_value(def_value_platform);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_platform);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("service", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("service", false);
}

const TypeObject* GetCompleteserviceObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("service", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("service");

    CompleteAnnotationParameter cam_platform;
    cam_platform.common().member_type_id(*factory->get_string_identifier(255, false));
    cam_platform.name("platform");

    AnnotationParameterValue def_value_platform;
    def_value_platform._d(cam_platform.common().member_type_id()._d());
    def_value_platform.from_string("*");
    cam_platform.default_value(def_value_platform);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_platform);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("service", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("service", true);
}

const TypeIdentifier* GetonewayIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("oneway", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetonewayObject(factory, complete); // Generated inside
    return factory->get_type_identifier("oneway", complete);
}

const TypeObject* GetonewayObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("oneway", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteonewayObject(factory);
    }
    // else
    return GetMinimalonewayObject(factory);
}

const TypeObject* GetMinimalonewayObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("oneway", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("oneway", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("oneway", false);
}

const TypeObject* GetCompleteonewayObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("oneway", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("oneway");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("oneway", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("oneway", true);
}

const TypeIdentifier* GetamiIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("ami", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetamiObject(factory, complete); // Generated inside
    return factory->get_type_identifier("ami", complete);
}

const TypeObject* GetamiObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("ami", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteamiObject(factory);
    }
    // else
    return GetMinimalamiObject(factory);
}

const TypeObject* GetMinimalamiObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("ami", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("ami", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("ami", false);
}

const TypeObject* GetCompleteamiObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("ami", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("ami");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("ami", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("ami", true);
}

const TypeIdentifier* Getnon_serializedIdentifier(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeIdentifier* c_identifier = factory->get_type_identifier("non_serialized",
                    complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    Getnon_serializedObject(factory, complete); // Generated inside
    return factory->get_type_identifier("non_serialized", complete);
}

const TypeObject* Getnon_serializedObject(
        TypeObjectFactory* factory,
        bool complete)
{
    const TypeObject* c_type_object = factory->get_type_object("non_serialized", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletenon_serializedObject(factory);
    }
    // else
    return GetMinimalnon_serializedObject(factory);
}

const TypeObject* GetMinimalnon_serializedObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("non_serialized", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ANNOTATION);

    MinimalAnnotationParameter mam_value;
    mam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    mam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(mam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    mam_value.default_value(def_value_value);
    type_object->minimal().annotation_type().member_seq().emplace_back(mam_value);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->minimal().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("non_serialized", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("non_serialized", false);
}

const TypeObject* GetCompletenon_serializedObject(
        TypeObjectFactory* factory)
{
    const TypeObject* c_type_object = factory->get_type_object("non_serialized", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject* type_object = new TypeObject ();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ANNOTATION);

    // No flags apply
    //type_object->complete().annotation_type().annotation_flags().IS_FINAL(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_APPENDABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_MUTABLE(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_NESTED(factory, false);
    //type_object->complete().annotation_type().annotation_flags().IS_AUTOID_HASH(factory, false);

    //type_object->complete().annotation_type().header().detail().ann_builtin()...
    //type_object->complete().annotation_type().header().detail().ann_custom()...
    type_object->complete().annotation_type().header().annotation_name("non_serialized");

    CompleteAnnotationParameter cam_value;
    cam_value.common().member_type_id(*factory->get_type_identifier("bool", false));
    cam_value.name("value");

    AnnotationParameterValue def_value_value;
    def_value_value._d(cam_value.common().member_type_id()._d());
    def_value_value.from_string("true");
    cam_value.default_value(def_value_value);
    type_object->complete().annotation_type().member_seq().emplace_back(cam_value);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
                calculator.calculate_serialized_size(type_object->complete().annotation_type(),
                current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::CdrVersion::XCDRv1);     // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
#if FASTCDR_VERSION_MAJOR == 1
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
#else
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
#endif // FASTCDR_VERSION_MAJOR == 1
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for (int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    factory->add_type_object("non_serialized", &identifier, type_object);
    delete type_object;
    return factory->get_type_object("non_serialized", true);
}
