/* TypeLookupTypes.idl */

#include "../../../../../include/fastdds/dds/xtypes/type_representation/TypeObject.idl"

const long DDS_RETCODE_OK = 0;

module eprosima {

module fastdds {
module dds {

typedef octet GuidPrefix_t[12];

struct EntityId_t {
    octet entityKey[3]; octet entityKind;
};

struct GUID_t {
    GuidPrefix_t guidPrefix;
    EntityId_t entityId;
};

struct SequenceNumber_t {
    long high;
    unsigned long low;
};

struct SampleIdentity {
    GUID_t writer_guid;
    SequenceNumber_t sequence_number;
};


module rpc {

    typedef octet UnknownOperation;
    typedef octet UnknownException;
    typedef octet UnusedMember;

    enum RemoteExceptionCode_t
    {
        REMOTE_EX_OK,
        REMOTE_EX_UNSUPPORTED,
        REMOTE_EX_INVALID_ARGUMENT,
        REMOTE_EX_OUT_OF_RESOURCES,
        REMOTE_EX_UNKNOWN_OPERATION,
        REMOTE_EX_UNKNOWN_EXCEPTION
    };

    typedef string<255> InstanceName;

    @nested
    struct RequestHeader 
    {
        SampleIdentity requestId;
        InstanceName instanceName;
    };

    @nested
    struct ReplyHeader 
    {
        SampleIdentity relatedRequestId;
        dds::rpc::RemoteExceptionCode_t remoteEx;
    };

}; // module rpc




module builtin {

    // computed from @hashid("getTypes")
    const unsigned long TypeLookup_getTypes_HashId = 0x018252d3;

    // computed from @hashid("getDependencies");
    const unsigned long TypeLookup_getDependencies_HashId = 0x05aafb31;

    // Query the TypeObjects associated with one or more TypeIdentifiers
    @extensibility(MUTABLE)
    struct TypeLookup_getTypes_In {
        @hashid sequence<xtypes1_3::TypeIdentifier> type_ids;
    };

    @extensibility(MUTABLE)
    struct TypeLookup_getTypes_Out {
        @hashid sequence<xtypes1_3::TypeIdentifierTypeObjectPair> types;
        @hashid sequence<xtypes1_3::TypeIdentifierPair> complete_to_minimal;
    };

    union TypeLookup_getTypes_Result switch(long) {
        case DDS_RETCODE_OK:
            TypeLookup_getTypes_Out result;
    };

    // Query TypeIdentifiers that the specified types depend on
    @extensibility(MUTABLE)
    struct TypeLookup_getTypeDependencies_In {
        @hashid sequence<xtypes1_3::TypeIdentifier> type_ids;
        @hashid sequence<octet, 32> continuation_point;
    };

    @extensibility(MUTABLE)
    struct TypeLookup_getTypeDependencies_Out {
        @hashid sequence<xtypes1_3::TypeIdentfierWithSize> dependent_typeids;
        @hashid sequence<octet, 32> continuation_point;
    };

    union TypeLookup_getTypeDependencies_Result switch(long){
        case DDS_RETCODE_OK:
            TypeLookup_getTypeDependencies_Out result;
    };

    // Service Request
    union TypeLookup_Call switch(long) {
        case TypeLookup_getTypes_HashId:
            TypeLookup_getTypes_In getTypes;
        case TypeLookup_getDependencies_HashId:
            TypeLookup_getTypeDependencies_In getTypeDependencies;
    };

    @RPCRequestType
    struct TypeLookup_Request {
        rpc::RequestHeader header;
        TypeLookup_Call data;
    };

    // Service Reply
    union TypeLookup_Return switch(long) {
        case TypeLookup_getTypes_HashId:
            TypeLookup_getTypes_Result getType;
        case TypeLookup_getDependencies_HashId:
            TypeLookup_getTypeDependencies_Result getTypeDependencies;
    };

    @RPCReplyType
    struct TypeLookup_Reply {
        rpc::ReplyHeader header;
        TypeLookup_Return return_value; //This name was changed from "return" to "return_value" to avoid problems in c++
    };

}; // builtin
}; // dds

}; // fastdds
}; // eprosima