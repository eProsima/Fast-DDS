// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file dds_xtypes_typeobjectCdrAux.ipp
 * This source file contains some declarations of CDR related functions.
 *
 * This file was generated by the tool fastddsgen (version: 4.1.0).
 */

#ifndef FAST_DDS_GENERATED__DDS_XTYPES_TYPEOBJECTCDRAUX_IPP
#define FAST_DDS_GENERATED__DDS_XTYPES_TYPEOBJECTCDRAUX_IPP

#include <fastdds/dds/xtypes/type_representation/detail/dds_xtypes_typeobjectCdrAux.hpp>

#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

#include <fastdds/dds/core/policy/QosPolicies.hpp>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeObjectHashId& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case EK_COMPLETE:
                case EK_MINIMAL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.hash(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeObjectHashId& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case EK_COMPLETE:
                case EK_MINIMAL:
                    scdr << eprosima::fastcdr::MemberId(1) << data.hash();
                    break;

        default:
            break;
    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeObjectHashId* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeObjectHashId& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case EK_COMPLETE:
                                                case EK_MINIMAL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::EquivalenceHash hash_value{0};
                                                        data.hash(std::move(hash_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                        default:
                            data._default();
                            break;
                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case EK_COMPLETE:
                                                case EK_MINIMAL:
                                                    dcdr >> data.hash();
                                                    break;

                        default:
                            break;
                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeObjectHashId* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2


eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_StringSTypeDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 1ULL ==
               (detail::StringSTypeDefn_offset_of<eprosima::fastdds::dds::xtypes::StringSTypeDefn, detail::StringSTypeDefn_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::SBound));
    }
    else
    {
        return 1ULL ==
            (detail::StringSTypeDefn_offset_of<eprosima::fastdds::dds::xtypes::StringSTypeDefn, detail::StringSTypeDefn_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::SBound));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::StringSTypeDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bound(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bound()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringSTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StringSTypeDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn) == eprosima_fastdds_dds_xtypes_StringSTypeDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::StringSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bound();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::StringSTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StringSTypeDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn) == eprosima_fastdds_dds_xtypes_StringSTypeDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringSTypeDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bound();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_StringLTypeDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 4ULL ==
               (detail::StringLTypeDefn_offset_of<eprosima::fastdds::dds::xtypes::StringLTypeDefn, detail::StringLTypeDefn_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::LBound));
    }
    else
    {
        return 4ULL ==
            (detail::StringLTypeDefn_offset_of<eprosima::fastdds::dds::xtypes::StringLTypeDefn, detail::StringLTypeDefn_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::LBound));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::StringLTypeDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bound(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bound()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringLTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StringLTypeDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn) == eprosima_fastdds_dds_xtypes_StringLTypeDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::StringLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bound();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::StringLTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StringLTypeDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn) == eprosima_fastdds_dds_xtypes_StringLTypeDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StringLTypeDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StringLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bound();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainCollectionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.equiv_kind(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.element_flags(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.equiv_kind()
        << eprosima::fastcdr::MemberId(1) << data.element_flags()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainCollectionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader) == eprosima_fastdds_dds_xtypes_PlainCollectionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.equiv_kind();
                                            break;

                                        case 1:
                                                dcdr >> data.element_flags();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainCollectionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader) == eprosima_fastdds_dds_xtypes_PlainCollectionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainCollectionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.equiv_kind();

                        scdr << data.element_flags();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainSequenceSElemDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.bound(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.bound()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainSequenceSElemDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn) == eprosima_fastdds_dds_xtypes_PlainSequenceSElemDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.bound();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainSequenceSElemDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn) == eprosima_fastdds_dds_xtypes_PlainSequenceSElemDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.bound();

                        scdr << data.element_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainSequenceLElemDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.bound(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.bound()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainSequenceLElemDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn) == eprosima_fastdds_dds_xtypes_PlainSequenceLElemDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.bound();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainSequenceLElemDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn) == eprosima_fastdds_dds_xtypes_PlainSequenceLElemDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.bound();

                        scdr << data.element_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainArraySElemDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainArraySElemDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.array_bound_seq(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArraySElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.array_bound_seq()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArraySElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainArraySElemDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn) == eprosima_fastdds_dds_xtypes_PlainArraySElemDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainArraySElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.array_bound_seq();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainArraySElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainArraySElemDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn) == eprosima_fastdds_dds_xtypes_PlainArraySElemDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArraySElemDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArraySElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.array_bound_seq();

                        scdr << data.element_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainArrayLElemDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.array_bound_seq(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.array_bound_seq()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainArrayLElemDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn) == eprosima_fastdds_dds_xtypes_PlainArrayLElemDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.array_bound_seq();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainArrayLElemDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn) == eprosima_fastdds_dds_xtypes_PlainArrayLElemDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.array_bound_seq();

                        scdr << data.element_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainMapSTypeDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.bound(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.key_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.key_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.bound()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
        << eprosima::fastcdr::MemberId(3) << data.key_flags()
        << eprosima::fastcdr::MemberId(4) << data.key_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainMapSTypeDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn) == eprosima_fastdds_dds_xtypes_PlainMapSTypeDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.bound();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                                        case 3:
                                                dcdr >> data.key_flags();
                                            break;

                                        case 4:
                                                dcdr >> data.key_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainMapSTypeDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn) == eprosima_fastdds_dds_xtypes_PlainMapSTypeDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);






    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.bound();

                        scdr << data.element_identifier();

                        scdr << data.key_flags();

                        scdr << data.key_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_PlainMapLTypeDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.bound(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element_identifier(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.key_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.key_identifier(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.header()
        << eprosima::fastcdr::MemberId(1) << data.bound()
        << eprosima::fastcdr::MemberId(2) << data.element_identifier()
        << eprosima::fastcdr::MemberId(3) << data.key_flags()
        << eprosima::fastcdr::MemberId(4) << data.key_identifier()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainMapLTypeDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn) == eprosima_fastdds_dds_xtypes_PlainMapLTypeDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.header();
                                            break;

                                        case 1:
                                                dcdr >> data.bound();
                                            break;

                                        case 2:
                                                dcdr >> data.element_identifier();
                                            break;

                                        case 3:
                                                dcdr >> data.key_flags();
                                            break;

                                        case 4:
                                                dcdr >> data.key_identifier();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_PlainMapLTypeDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn) == eprosima_fastdds_dds_xtypes_PlainMapLTypeDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::PlainCollectionHeader& data);






    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.header());

                        scdr << data.bound();

                        scdr << data.element_identifier();

                        scdr << data.key_flags();

                        scdr << data.key_identifier();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_StronglyConnectedComponentId_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.sc_component_id(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.scc_length(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.scc_index(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.sc_component_id()
        << eprosima::fastcdr::MemberId(1) << data.scc_length()
        << eprosima::fastcdr::MemberId(2) << data.scc_index()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StronglyConnectedComponentId_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId) == eprosima_fastdds_dds_xtypes_StronglyConnectedComponentId_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.sc_component_id();
                                            break;

                                        case 1:
                                                dcdr >> data.scc_length();
                                            break;

                                        case 2:
                                                dcdr >> data.scc_index();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_StronglyConnectedComponentId_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId) == eprosima_fastdds_dds_xtypes_StronglyConnectedComponentId_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.sc_component_id();

                        scdr << data.scc_length();

                        scdr << data.scc_index();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_ExtendedTypeDefn_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::ExtendedTypeDefn& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_ExtendedTypeDefn_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn) == eprosima_fastdds_dds_xtypes_ExtendedTypeDefn_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::ExtendedTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::ExtendedTypeDefn* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_ExtendedTypeDefn_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn) == eprosima_fastdds_dds_xtypes_ExtendedTypeDefn_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedTypeDefn));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedTypeDefn& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_Dummy_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return true;
    }
    else
    {
        return true;
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::Dummy& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::Dummy& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::Dummy* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_Dummy_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::Dummy) == eprosima_fastdds_dds_xtypes_Dummy_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::Dummy));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::Dummy));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::Dummy& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::Dummy* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_Dummy_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::Dummy) == eprosima_fastdds_dds_xtypes_Dummy_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::Dummy));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::Dummy));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::Dummy& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeIdentifier& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case TK_NONE:
                case TK_BOOLEAN:
                case TK_BYTE:
                case TK_INT8:
                case TK_INT16:
                case TK_INT32:
                case TK_INT64:
                case TK_UINT8:
                case TK_UINT16:
                case TK_UINT32:
                case TK_UINT64:
                case TK_FLOAT32:
                case TK_FLOAT64:
                case TK_FLOAT128:
                case TK_CHAR8:
                case TK_CHAR16:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.no_value(), current_alignment);
                    break;

                case TI_STRING8_SMALL:
                case TI_STRING16_SMALL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.string_sdefn(), current_alignment);
                    break;

                case TI_STRING8_LARGE:
                case TI_STRING16_LARGE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.string_ldefn(), current_alignment);
                    break;

                case TI_PLAIN_SEQUENCE_SMALL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.seq_sdefn(), current_alignment);
                    break;

                case TI_PLAIN_SEQUENCE_LARGE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.seq_ldefn(), current_alignment);
                    break;

                case TI_PLAIN_ARRAY_SMALL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.array_sdefn(), current_alignment);
                    break;

                case TI_PLAIN_ARRAY_LARGE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.array_ldefn(), current_alignment);
                    break;

                case TI_PLAIN_MAP_SMALL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.map_sdefn(), current_alignment);
                    break;

                case TI_PLAIN_MAP_LARGE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.map_ldefn(), current_alignment);
                    break;

                case TI_STRONGLY_CONNECTED_COMPONENT:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.sc_component_id(), current_alignment);
                    break;

                case EK_COMPLETE:
                case EK_MINIMAL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.equivalence_hash(), current_alignment);
                    break;

                default:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                                data.extended_defn(), current_alignment);
                    break;

    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifier& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case TK_NONE:
                case TK_BOOLEAN:
                case TK_BYTE:
                case TK_INT8:
                case TK_INT16:
                case TK_INT32:
                case TK_INT64:
                case TK_UINT8:
                case TK_UINT16:
                case TK_UINT32:
                case TK_UINT64:
                case TK_FLOAT32:
                case TK_FLOAT64:
                case TK_FLOAT128:
                case TK_CHAR8:
                case TK_CHAR16:
                    scdr << eprosima::fastcdr::MemberId(1) << data.no_value();
                    break;

                case TI_STRING8_SMALL:
                case TI_STRING16_SMALL:
                    scdr << eprosima::fastcdr::MemberId(2) << data.string_sdefn();
                    break;

                case TI_STRING8_LARGE:
                case TI_STRING16_LARGE:
                    scdr << eprosima::fastcdr::MemberId(3) << data.string_ldefn();
                    break;

                case TI_PLAIN_SEQUENCE_SMALL:
                    scdr << eprosima::fastcdr::MemberId(4) << data.seq_sdefn();
                    break;

                case TI_PLAIN_SEQUENCE_LARGE:
                    scdr << eprosima::fastcdr::MemberId(5) << data.seq_ldefn();
                    break;

                case TI_PLAIN_ARRAY_SMALL:
                    scdr << eprosima::fastcdr::MemberId(6) << data.array_sdefn();
                    break;

                case TI_PLAIN_ARRAY_LARGE:
                    scdr << eprosima::fastcdr::MemberId(7) << data.array_ldefn();
                    break;

                case TI_PLAIN_MAP_SMALL:
                    scdr << eprosima::fastcdr::MemberId(8) << data.map_sdefn();
                    break;

                case TI_PLAIN_MAP_LARGE:
                    scdr << eprosima::fastcdr::MemberId(9) << data.map_ldefn();
                    break;

                case TI_STRONGLY_CONNECTED_COMPONENT:
                    scdr << eprosima::fastcdr::MemberId(10) << data.sc_component_id();
                    break;

                case EK_COMPLETE:
                case EK_MINIMAL:
                    scdr << eprosima::fastcdr::MemberId(11) << data.equivalence_hash();
                    break;

                default:
                    scdr << eprosima::fastcdr::MemberId(12) << data.extended_defn();
                    break;

    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifier* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifier& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case TK_NONE:
                                                case TK_BOOLEAN:
                                                case TK_BYTE:
                                                case TK_INT8:
                                                case TK_INT16:
                                                case TK_INT32:
                                                case TK_INT64:
                                                case TK_UINT8:
                                                case TK_UINT16:
                                                case TK_UINT32:
                                                case TK_UINT64:
                                                case TK_FLOAT32:
                                                case TK_FLOAT64:
                                                case TK_FLOAT128:
                                                case TK_CHAR8:
                                                case TK_CHAR16:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::Dummy no_value_value;
                                                        data.no_value(std::move(no_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_STRING8_SMALL:
                                                case TI_STRING16_SMALL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::StringSTypeDefn string_sdefn_value;
                                                        data.string_sdefn(std::move(string_sdefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_STRING8_LARGE:
                                                case TI_STRING16_LARGE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::StringLTypeDefn string_ldefn_value;
                                                        data.string_ldefn(std::move(string_ldefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_SEQUENCE_SMALL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainSequenceSElemDefn seq_sdefn_value;
                                                        data.seq_sdefn(std::move(seq_sdefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_SEQUENCE_LARGE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainSequenceLElemDefn seq_ldefn_value;
                                                        data.seq_ldefn(std::move(seq_ldefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_ARRAY_SMALL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainArraySElemDefn array_sdefn_value;
                                                        data.array_sdefn(std::move(array_sdefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_ARRAY_LARGE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainArrayLElemDefn array_ldefn_value;
                                                        data.array_ldefn(std::move(array_ldefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_MAP_SMALL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainMapSTypeDefn map_sdefn_value;
                                                        data.map_sdefn(std::move(map_sdefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_PLAIN_MAP_LARGE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::PlainMapLTypeDefn map_ldefn_value;
                                                        data.map_ldefn(std::move(map_ldefn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TI_STRONGLY_CONNECTED_COMPONENT:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::StronglyConnectedComponentId sc_component_id_value;
                                                        data.sc_component_id(std::move(sc_component_id_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case EK_COMPLETE:
                                                case EK_MINIMAL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::EquivalenceHash equivalence_hash_value{0};
                                                        data.equivalence_hash(std::move(equivalence_hash_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                default:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::ExtendedTypeDefn extended_defn_value;
                                                        data.extended_defn(std::move(extended_defn_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case TK_NONE:
                                                case TK_BOOLEAN:
                                                case TK_BYTE:
                                                case TK_INT8:
                                                case TK_INT16:
                                                case TK_INT32:
                                                case TK_INT64:
                                                case TK_UINT8:
                                                case TK_UINT16:
                                                case TK_UINT32:
                                                case TK_UINT64:
                                                case TK_FLOAT32:
                                                case TK_FLOAT64:
                                                case TK_FLOAT128:
                                                case TK_CHAR8:
                                                case TK_CHAR16:
                                                    dcdr >> data.no_value();
                                                    break;

                                                case TI_STRING8_SMALL:
                                                case TI_STRING16_SMALL:
                                                    dcdr >> data.string_sdefn();
                                                    break;

                                                case TI_STRING8_LARGE:
                                                case TI_STRING16_LARGE:
                                                    dcdr >> data.string_ldefn();
                                                    break;

                                                case TI_PLAIN_SEQUENCE_SMALL:
                                                    dcdr >> data.seq_sdefn();
                                                    break;

                                                case TI_PLAIN_SEQUENCE_LARGE:
                                                    dcdr >> data.seq_ldefn();
                                                    break;

                                                case TI_PLAIN_ARRAY_SMALL:
                                                    dcdr >> data.array_sdefn();
                                                    break;

                                                case TI_PLAIN_ARRAY_LARGE:
                                                    dcdr >> data.array_ldefn();
                                                    break;

                                                case TI_PLAIN_MAP_SMALL:
                                                    dcdr >> data.map_sdefn();
                                                    break;

                                                case TI_PLAIN_MAP_LARGE:
                                                    dcdr >> data.map_ldefn();
                                                    break;

                                                case TI_STRONGLY_CONNECTED_COMPONENT:
                                                    dcdr >> data.sc_component_id();
                                                    break;

                                                case EK_COMPLETE:
                                                case EK_MINIMAL:
                                                    dcdr >> data.equivalence_hash();
                                                    break;

                                                default:
                                                    dcdr >> data.extended_defn();
                                                    break;

                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifier* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2


eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_ExtendedAnnotationParameterValue_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_ExtendedAnnotationParameterValue_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue) == eprosima_fastdds_dds_xtypes_ExtendedAnnotationParameterValue_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_ExtendedAnnotationParameterValue_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue) == eprosima_fastdds_dds_xtypes_ExtendedAnnotationParameterValue_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AnnotationParameterValue& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case TK_BOOLEAN:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.boolean_value(), current_alignment);
                    break;

                case TK_BYTE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.byte_value(), current_alignment);
                    break;

                case TK_INT8:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.int8_value(), current_alignment);
                    break;

                case TK_UINT8:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.uint8_value(), current_alignment);
                    break;

                case TK_INT16:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.int16_value(), current_alignment);
                    break;

                case TK_UINT16:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.uint_16_value(), current_alignment);
                    break;

                case TK_INT32:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.int32_value(), current_alignment);
                    break;

                case TK_UINT32:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.uint32_value(), current_alignment);
                    break;

                case TK_INT64:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.int64_value(), current_alignment);
                    break;

                case TK_UINT64:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.uint64_value(), current_alignment);
                    break;

                case TK_FLOAT32:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.float32_value(), current_alignment);
                    break;

                case TK_FLOAT64:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                                data.float64_value(), current_alignment);
                    break;

                case TK_FLOAT128:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                                data.float128_value(), current_alignment);
                    break;

                case TK_CHAR8:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(14),
                                data.char_value(), current_alignment);
                    break;

                case TK_CHAR16:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(15),
                                data.wchar_value(), current_alignment);
                    break;

                case TK_ENUM:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(16),
                                data.enumerated_value(), current_alignment);
                    break;

                case TK_STRING8:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(17),
                                data.string8_value(), current_alignment);
                    break;

                case TK_STRING16:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(18),
                                data.string16_value(), current_alignment);
                    break;

                default:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(19),
                                data.extended_value(), current_alignment);
                    break;

    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AnnotationParameterValue& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case TK_BOOLEAN:
                    scdr << eprosima::fastcdr::MemberId(1) << data.boolean_value();
                    break;

                case TK_BYTE:
                    scdr << eprosima::fastcdr::MemberId(2) << data.byte_value();
                    break;

                case TK_INT8:
                    scdr << eprosima::fastcdr::MemberId(3) << data.int8_value();
                    break;

                case TK_UINT8:
                    scdr << eprosima::fastcdr::MemberId(4) << data.uint8_value();
                    break;

                case TK_INT16:
                    scdr << eprosima::fastcdr::MemberId(5) << data.int16_value();
                    break;

                case TK_UINT16:
                    scdr << eprosima::fastcdr::MemberId(6) << data.uint_16_value();
                    break;

                case TK_INT32:
                    scdr << eprosima::fastcdr::MemberId(7) << data.int32_value();
                    break;

                case TK_UINT32:
                    scdr << eprosima::fastcdr::MemberId(8) << data.uint32_value();
                    break;

                case TK_INT64:
                    scdr << eprosima::fastcdr::MemberId(9) << data.int64_value();
                    break;

                case TK_UINT64:
                    scdr << eprosima::fastcdr::MemberId(10) << data.uint64_value();
                    break;

                case TK_FLOAT32:
                    scdr << eprosima::fastcdr::MemberId(11) << data.float32_value();
                    break;

                case TK_FLOAT64:
                    scdr << eprosima::fastcdr::MemberId(12) << data.float64_value();
                    break;

                case TK_FLOAT128:
                    scdr << eprosima::fastcdr::MemberId(13) << data.float128_value();
                    break;

                case TK_CHAR8:
                    scdr << eprosima::fastcdr::MemberId(14) << data.char_value();
                    break;

                case TK_CHAR16:
                    scdr << eprosima::fastcdr::MemberId(15) << data.wchar_value();
                    break;

                case TK_ENUM:
                    scdr << eprosima::fastcdr::MemberId(16) << data.enumerated_value();
                    break;

                case TK_STRING8:
                    scdr << eprosima::fastcdr::MemberId(17) << data.string8_value();
                    break;

                case TK_STRING16:
                    scdr << eprosima::fastcdr::MemberId(18) << data.string16_value();
                    break;

                default:
                    scdr << eprosima::fastcdr::MemberId(19) << data.extended_value();
                    break;

    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AnnotationParameterValue* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AnnotationParameterValue& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case TK_BOOLEAN:
                                                    {
                                                        bool boolean_value_value{false};
                                                        data.boolean_value(std::move(boolean_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_BYTE:
                                                    {
                                                        uint8_t byte_value_value{0};
                                                        data.byte_value(std::move(byte_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_INT8:
                                                    {
                                                        int8_t int8_value_value{0};
                                                        data.int8_value(std::move(int8_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UINT8:
                                                    {
                                                        uint8_t uint8_value_value{0};
                                                        data.uint8_value(std::move(uint8_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_INT16:
                                                    {
                                                        int16_t int16_value_value{0};
                                                        data.int16_value(std::move(int16_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UINT16:
                                                    {
                                                        uint16_t uint_16_value_value{0};
                                                        data.uint_16_value(std::move(uint_16_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_INT32:
                                                    {
                                                        int32_t int32_value_value{0};
                                                        data.int32_value(std::move(int32_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UINT32:
                                                    {
                                                        uint32_t uint32_value_value{0};
                                                        data.uint32_value(std::move(uint32_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_INT64:
                                                    {
                                                        int64_t int64_value_value{0};
                                                        data.int64_value(std::move(int64_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UINT64:
                                                    {
                                                        uint64_t uint64_value_value{0};
                                                        data.uint64_value(std::move(uint64_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_FLOAT32:
                                                    {
                                                        float float32_value_value{0.0};
                                                        data.float32_value(std::move(float32_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_FLOAT64:
                                                    {
                                                        double float64_value_value{0.0};
                                                        data.float64_value(std::move(float64_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_FLOAT128:
                                                    {
                                                        long double float128_value_value{0.0};
                                                        data.float128_value(std::move(float128_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_CHAR8:
                                                    {
                                                        char char_value_value{0};
                                                        data.char_value(std::move(char_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_CHAR16:
                                                    {
                                                        wchar_t wchar_value_value{0};
                                                        data.wchar_value(std::move(wchar_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ENUM:
                                                    {
                                                        int32_t enumerated_value_value{0};
                                                        data.enumerated_value(std::move(enumerated_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_STRING8:
                                                    {
                                                        eprosima::fastcdr::fixed_string<ANNOTATION_STR_VALUE_MAX_LEN> string8_value_value;
                                                        data.string8_value(std::move(string8_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_STRING16:
                                                    {
                                                        std::wstring string16_value_value;
                                                        data.string16_value(std::move(string16_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                default:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::ExtendedAnnotationParameterValue extended_value_value;
                                                        data.extended_value(std::move(extended_value_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case TK_BOOLEAN:
                                                    dcdr >> data.boolean_value();
                                                    break;

                                                case TK_BYTE:
                                                    dcdr >> data.byte_value();
                                                    break;

                                                case TK_INT8:
                                                    dcdr >> data.int8_value();
                                                    break;

                                                case TK_UINT8:
                                                    dcdr >> data.uint8_value();
                                                    break;

                                                case TK_INT16:
                                                    dcdr >> data.int16_value();
                                                    break;

                                                case TK_UINT16:
                                                    dcdr >> data.uint_16_value();
                                                    break;

                                                case TK_INT32:
                                                    dcdr >> data.int32_value();
                                                    break;

                                                case TK_UINT32:
                                                    dcdr >> data.uint32_value();
                                                    break;

                                                case TK_INT64:
                                                    dcdr >> data.int64_value();
                                                    break;

                                                case TK_UINT64:
                                                    dcdr >> data.uint64_value();
                                                    break;

                                                case TK_FLOAT32:
                                                    dcdr >> data.float32_value();
                                                    break;

                                                case TK_FLOAT64:
                                                    dcdr >> data.float64_value();
                                                    break;

                                                case TK_FLOAT128:
                                                    dcdr >> data.float128_value();
                                                    break;

                                                case TK_CHAR8:
                                                    dcdr >> data.char_value();
                                                    break;

                                                case TK_CHAR16:
                                                    dcdr >> data.wchar_value();
                                                    break;

                                                case TK_ENUM:
                                                    dcdr >> data.enumerated_value();
                                                    break;

                                                case TK_STRING8:
                                                    dcdr >> data.string8_value();
                                                    break;

                                                case TK_STRING16:
                                                    dcdr >> data.string16_value();
                                                    break;

                                                default:
                                                    dcdr >> data.extended_value();
                                                    break;

                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AnnotationParameterValue* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2


eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_AppliedAnnotationParameter_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.paramname_hash(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.value(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.paramname_hash()
        << eprosima::fastcdr::MemberId(1) << data.value()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedAnnotationParameter_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter) == eprosima_fastdds_dds_xtypes_AppliedAnnotationParameter_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.paramname_hash();
                                            break;

                                        case 1:
                                                dcdr >> data.value();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedAnnotationParameter_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter) == eprosima_fastdds_dds_xtypes_AppliedAnnotationParameter_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.paramname_hash();

                        scdr << data.value();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_AppliedAnnotation_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotation& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.annotation_typeid(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.param_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.annotation_typeid()
        << eprosima::fastcdr::MemberId(1) << data.param_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedAnnotation_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation) == eprosima_fastdds_dds_xtypes_AppliedAnnotation_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AppliedAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.annotation_typeid();
                                            break;

                                        case 1:
                                                dcdr >> data.param_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AppliedAnnotation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedAnnotation_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation) == eprosima_fastdds_dds_xtypes_AppliedAnnotation_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedAnnotation));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.annotation_typeid();

                        if (data.param_seq().has_value())
                        {
                            scdr << data.param_seq().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_AppliedVerbatimAnnotation_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.placement(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.language(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.text(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.placement()
        << eprosima::fastcdr::MemberId(1) << data.language()
        << eprosima::fastcdr::MemberId(2) << data.text()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedVerbatimAnnotation_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation) == eprosima_fastdds_dds_xtypes_AppliedVerbatimAnnotation_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.placement();
                                            break;

                                        case 1:
                                                dcdr >> data.language();
                                            break;

                                        case 2:
                                                dcdr >> data.text();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedVerbatimAnnotation_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation) == eprosima_fastdds_dds_xtypes_AppliedVerbatimAnnotation_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.placement();

                        scdr << data.language();

                        scdr << data.text();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_AppliedBuiltinMemberAnnotations_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.unit(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.min(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.max(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.hash_id(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.unit()
        << eprosima::fastcdr::MemberId(1) << data.min()
        << eprosima::fastcdr::MemberId(2) << data.max()
        << eprosima::fastcdr::MemberId(3) << data.hash_id()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedBuiltinMemberAnnotations_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations) == eprosima_fastdds_dds_xtypes_AppliedBuiltinMemberAnnotations_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.unit();
                                            break;

                                        case 1:
                                                dcdr >> data.min();
                                            break;

                                        case 2:
                                                dcdr >> data.max();
                                            break;

                                        case 3:
                                                dcdr >> data.hash_id();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedBuiltinMemberAnnotations_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations) == eprosima_fastdds_dds_xtypes_AppliedBuiltinMemberAnnotations_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        if (data.unit().has_value())
                        {
                            scdr << data.unit().value();
                        }

                        if (data.min().has_value())
                        {
                            scdr << data.min().value();
                        }

                        if (data.max().has_value())
                        {
                            scdr << data.max().value();
                        }

                        if (data.hash_id().has_value())
                        {
                            scdr << data.hash_id().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonStructMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonStructMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.member_id(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.member_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.member_type_id(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.member_id()
        << eprosima::fastcdr::MemberId(1) << data.member_flags()
        << eprosima::fastcdr::MemberId(2) << data.member_type_id()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonStructMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember) == eprosima_fastdds_dds_xtypes_CommonStructMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.member_id();
                                            break;

                                        case 1:
                                                dcdr >> data.member_flags();
                                            break;

                                        case 2:
                                                dcdr >> data.member_type_id();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonStructMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember) == eprosima_fastdds_dds_xtypes_CommonStructMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonStructMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.member_id();

                        scdr << data.member_flags();

                        scdr << data.member_type_id();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteMemberDetail_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.name(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ann_builtin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ann_custom(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.name()
        << eprosima::fastcdr::MemberId(1) << data.ann_builtin()
        << eprosima::fastcdr::MemberId(2) << data.ann_custom()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMemberDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteMemberDetail_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail) == eprosima_fastdds_dds_xtypes_CompleteMemberDetail_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.name();
                                            break;

                                        case 1:
                                                dcdr >> data.ann_builtin();
                                            break;

                                        case 2:
                                                dcdr >> data.ann_custom();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteMemberDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteMemberDetail_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail) == eprosima_fastdds_dds_xtypes_CompleteMemberDetail_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMemberDetail));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.name();

                        if (data.ann_builtin().has_value())
                        {
                            serialize_key(scdr, data.ann_builtin().value());
                        }

                        if (data.ann_custom().has_value())
                        {
                            scdr << data.ann_custom().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalMemberDetail_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 4ULL ==
               (detail::MinimalMemberDetail_offset_of<eprosima::fastdds::dds::xtypes::MinimalMemberDetail, detail::MinimalMemberDetail_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::NameHash));
    }
    else
    {
        return 4ULL ==
            (detail::MinimalMemberDetail_offset_of<eprosima::fastdds::dds::xtypes::MinimalMemberDetail, detail::MinimalMemberDetail_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::NameHash));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.name_hash(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.name_hash()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMemberDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalMemberDetail_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail) == eprosima_fastdds_dds_xtypes_MinimalMemberDetail_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.name_hash();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalMemberDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalMemberDetail_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail) == eprosima_fastdds_dds_xtypes_MinimalMemberDetail_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMemberDetail));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.name_hash();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteStructMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteStructMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember) == eprosima_fastdds_dds_xtypes_CompleteStructMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember) == eprosima_fastdds_dds_xtypes_CompleteStructMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonStructMember& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalStructMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalStructMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember) == eprosima_fastdds_dds_xtypes_MinimalStructMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalStructMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember) == eprosima_fastdds_dds_xtypes_MinimalStructMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonStructMember& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_AppliedBuiltinTypeAnnotations_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.verbatim(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.verbatim()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedBuiltinTypeAnnotations_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations) == eprosima_fastdds_dds_xtypes_AppliedBuiltinTypeAnnotations_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.verbatim();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_AppliedBuiltinTypeAnnotations_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations) == eprosima_fastdds_dds_xtypes_AppliedBuiltinTypeAnnotations_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedVerbatimAnnotation& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        if (data.verbatim().has_value())
                        {
                            serialize_key(scdr, data.verbatim().value());
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalTypeDetail_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return true;
    }
    else
    {
        return true;
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalTypeDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalTypeDetail_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail) == eprosima_fastdds_dds_xtypes_MinimalTypeDetail_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalTypeDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalTypeDetail_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail) == eprosima_fastdds_dds_xtypes_MinimalTypeDetail_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalTypeDetail));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteTypeDetail_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.ann_builtin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ann_custom(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.type_name(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.ann_builtin()
        << eprosima::fastcdr::MemberId(1) << data.ann_custom()
        << eprosima::fastcdr::MemberId(2) << data.type_name()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteTypeDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteTypeDetail_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail) == eprosima_fastdds_dds_xtypes_CompleteTypeDetail_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.ann_builtin();
                                            break;

                                        case 1:
                                                dcdr >> data.ann_custom();
                                            break;

                                        case 2:
                                                dcdr >> data.type_name();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteTypeDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteTypeDetail_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail) == eprosima_fastdds_dds_xtypes_CompleteTypeDetail_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteTypeDetail));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        if (data.ann_builtin().has_value())
                        {
                            serialize_key(scdr, data.ann_builtin().value());
                        }

                        if (data.ann_custom().has_value())
                        {
                            scdr << data.ann_custom().value();
                        }

                        scdr << data.type_name();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteStructHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteStructHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.base_type(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.base_type()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader) == eprosima_fastdds_dds_xtypes_CompleteStructHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.base_type();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteStructHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader) == eprosima_fastdds_dds_xtypes_CompleteStructHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.base_type();

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalStructHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalStructHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.base_type(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.base_type()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader) == eprosima_fastdds_dds_xtypes_MinimalStructHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.base_type();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalStructHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader) == eprosima_fastdds_dds_xtypes_MinimalStructHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.base_type();

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteStructType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteStructType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.struct_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.struct_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType) == eprosima_fastdds_dds_xtypes_CompleteStructType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.struct_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteStructType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteStructType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType) == eprosima_fastdds_dds_xtypes_CompleteStructType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteStructType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteStructHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.struct_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalStructType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalStructType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.struct_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.struct_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType) == eprosima_fastdds_dds_xtypes_MinimalStructType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.struct_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalStructType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalStructType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType) == eprosima_fastdds_dds_xtypes_MinimalStructType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalStructType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalStructType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalStructHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.struct_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonUnionMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonUnionMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.member_id(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.member_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.type_id(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.label_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.member_id()
        << eprosima::fastcdr::MemberId(1) << data.member_flags()
        << eprosima::fastcdr::MemberId(2) << data.type_id()
        << eprosima::fastcdr::MemberId(3) << data.label_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonUnionMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember) == eprosima_fastdds_dds_xtypes_CommonUnionMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.member_id();
                                            break;

                                        case 1:
                                                dcdr >> data.member_flags();
                                            break;

                                        case 2:
                                                dcdr >> data.type_id();
                                            break;

                                        case 3:
                                                dcdr >> data.label_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonUnionMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember) == eprosima_fastdds_dds_xtypes_CommonUnionMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonUnionMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.member_id();

                        scdr << data.member_flags();

                        scdr << data.type_id();

                        scdr << data.label_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteUnionMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteUnionMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember) == eprosima_fastdds_dds_xtypes_CompleteUnionMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember) == eprosima_fastdds_dds_xtypes_CompleteUnionMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonUnionMember& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalUnionMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalUnionMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember) == eprosima_fastdds_dds_xtypes_MinimalUnionMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember) == eprosima_fastdds_dds_xtypes_MinimalUnionMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonUnionMember& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonDiscriminatorMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.member_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.type_id(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.member_flags()
        << eprosima::fastcdr::MemberId(1) << data.type_id()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonDiscriminatorMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember) == eprosima_fastdds_dds_xtypes_CommonDiscriminatorMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.member_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.type_id();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonDiscriminatorMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember) == eprosima_fastdds_dds_xtypes_CommonDiscriminatorMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.member_flags();

                        scdr << data.type_id();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteDiscriminatorMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ann_builtin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ann_custom(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.ann_builtin()
        << eprosima::fastcdr::MemberId(2) << data.ann_custom()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteDiscriminatorMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember) == eprosima_fastdds_dds_xtypes_CompleteDiscriminatorMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.ann_builtin();
                                            break;

                                        case 2:
                                                dcdr >> data.ann_custom();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteDiscriminatorMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember) == eprosima_fastdds_dds_xtypes_CompleteDiscriminatorMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedBuiltinTypeAnnotations& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        if (data.ann_builtin().has_value())
                        {
                            serialize_key(scdr, data.ann_builtin().value());
                        }

                        if (data.ann_custom().has_value())
                        {
                            scdr << data.ann_custom().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalDiscriminatorMember_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalDiscriminatorMember_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember) == eprosima_fastdds_dds_xtypes_MinimalDiscriminatorMember_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalDiscriminatorMember_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember) == eprosima_fastdds_dds_xtypes_MinimalDiscriminatorMember_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonDiscriminatorMember& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteUnionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteUnionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader) == eprosima_fastdds_dds_xtypes_CompleteUnionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader) == eprosima_fastdds_dds_xtypes_CompleteUnionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalUnionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalUnionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader) == eprosima_fastdds_dds_xtypes_MinimalUnionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader) == eprosima_fastdds_dds_xtypes_MinimalUnionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteUnionType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteUnionType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.union_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.discriminator(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.union_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.discriminator()
        << eprosima::fastcdr::MemberId(3) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType) == eprosima_fastdds_dds_xtypes_CompleteUnionType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.union_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.discriminator();
                                            break;

                                        case 3:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteUnionType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteUnionType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType) == eprosima_fastdds_dds_xtypes_CompleteUnionType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteUnionType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteUnionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteDiscriminatorMember& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.union_flags();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.discriminator());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalUnionType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalUnionType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.union_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.discriminator(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.union_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.discriminator()
        << eprosima::fastcdr::MemberId(3) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType) == eprosima_fastdds_dds_xtypes_MinimalUnionType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.union_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.discriminator();
                                            break;

                                        case 3:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalUnionType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalUnionType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType) == eprosima_fastdds_dds_xtypes_MinimalUnionType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalUnionType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalUnionType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalUnionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalDiscriminatorMember& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.union_flags();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.discriminator());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonAnnotationParameter_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.member_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.member_type_id(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.member_flags()
        << eprosima::fastcdr::MemberId(1) << data.member_type_id()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonAnnotationParameter_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter) == eprosima_fastdds_dds_xtypes_CommonAnnotationParameter_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.member_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.member_type_id();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonAnnotationParameter_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter) == eprosima_fastdds_dds_xtypes_CommonAnnotationParameter_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAnnotationParameter));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.member_flags();

                        scdr << data.member_type_id();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAnnotationParameter_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.name(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.default_value(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.name()
        << eprosima::fastcdr::MemberId(2) << data.default_value()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationParameter_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter) == eprosima_fastdds_dds_xtypes_CompleteAnnotationParameter_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.name();
                                            break;

                                        case 2:
                                                dcdr >> data.default_value();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationParameter_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter) == eprosima_fastdds_dds_xtypes_CompleteAnnotationParameter_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        scdr << data.name();

                        scdr << data.default_value();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAnnotationParameter_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.name_hash(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.default_value(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.name_hash()
        << eprosima::fastcdr::MemberId(2) << data.default_value()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationParameter_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter) == eprosima_fastdds_dds_xtypes_MinimalAnnotationParameter_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.name_hash();
                                            break;

                                        case 2:
                                                dcdr >> data.default_value();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationParameter_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter) == eprosima_fastdds_dds_xtypes_MinimalAnnotationParameter_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationParameter& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonAnnotationParameter& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        scdr << data.name_hash();

                        scdr << data.default_value();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAnnotationHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.annotation_name(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.annotation_name()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader) == eprosima_fastdds_dds_xtypes_CompleteAnnotationHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.annotation_name();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader) == eprosima_fastdds_dds_xtypes_CompleteAnnotationHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.annotation_name();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAnnotationHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader) == eprosima_fastdds_dds_xtypes_MinimalAnnotationHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader) == eprosima_fastdds_dds_xtypes_MinimalAnnotationHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAnnotationType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.annotation_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.annotation_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType) == eprosima_fastdds_dds_xtypes_CompleteAnnotationType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.annotation_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAnnotationType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAnnotationType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType) == eprosima_fastdds_dds_xtypes_CompleteAnnotationType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAnnotationType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteAnnotationHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.annotation_flag();

                        serialize_key(scdr, data.header());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAnnotationType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.annotation_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.member_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.annotation_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.member_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType) == eprosima_fastdds_dds_xtypes_MinimalAnnotationType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.annotation_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.member_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAnnotationType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAnnotationType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType) == eprosima_fastdds_dds_xtypes_MinimalAnnotationType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAnnotationType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAnnotationType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalAnnotationHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.annotation_flag();

                        serialize_key(scdr, data.header());

                        scdr << data.member_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonAliasBody_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonAliasBody& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.related_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.related_type(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.related_flags()
        << eprosima::fastcdr::MemberId(1) << data.related_type()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonAliasBody_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody) == eprosima_fastdds_dds_xtypes_CommonAliasBody_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.related_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.related_type();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonAliasBody_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody) == eprosima_fastdds_dds_xtypes_CommonAliasBody_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonAliasBody));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.related_flags();

                        scdr << data.related_type();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAliasBody_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAliasBody& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ann_builtin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ann_custom(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.ann_builtin()
        << eprosima::fastcdr::MemberId(2) << data.ann_custom()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasBody_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody) == eprosima_fastdds_dds_xtypes_CompleteAliasBody_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.ann_builtin();
                                            break;

                                        case 2:
                                                dcdr >> data.ann_custom();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasBody_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody) == eprosima_fastdds_dds_xtypes_CompleteAliasBody_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasBody));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonAliasBody& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        if (data.ann_builtin().has_value())
                        {
                            serialize_key(scdr, data.ann_builtin().value());
                        }

                        if (data.ann_custom().has_value())
                        {
                            scdr << data.ann_custom().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAliasBody_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAliasBody& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasBody_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody) == eprosima_fastdds_dds_xtypes_MinimalAliasBody_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasBody* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasBody_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody) == eprosima_fastdds_dds_xtypes_MinimalAliasBody_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasBody));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasBody& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonAliasBody& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAliasHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAliasHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader) == eprosima_fastdds_dds_xtypes_CompleteAliasHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader) == eprosima_fastdds_dds_xtypes_CompleteAliasHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAliasHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAliasHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader) == eprosima_fastdds_dds_xtypes_MinimalAliasHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader) == eprosima_fastdds_dds_xtypes_MinimalAliasHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteAliasType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteAliasType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.alias_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.body(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.alias_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.body()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType) == eprosima_fastdds_dds_xtypes_CompleteAliasType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.alias_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.body();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteAliasType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteAliasType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType) == eprosima_fastdds_dds_xtypes_CompleteAliasType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteAliasType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteAliasHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteAliasBody& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.alias_flags();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.body());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalAliasType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalAliasType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.alias_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.body(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.alias_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.body()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType) == eprosima_fastdds_dds_xtypes_MinimalAliasType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.alias_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.body();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalAliasType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalAliasType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType) == eprosima_fastdds_dds_xtypes_MinimalAliasType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalAliasType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalAliasType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalAliasHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalAliasBody& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.alias_flags();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.body());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteElementDetail_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteElementDetail& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.ann_builtin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ann_custom(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteElementDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.ann_builtin()
        << eprosima::fastcdr::MemberId(1) << data.ann_custom()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteElementDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteElementDetail_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail) == eprosima_fastdds_dds_xtypes_CompleteElementDetail_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteElementDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.ann_builtin();
                                            break;

                                        case 1:
                                                dcdr >> data.ann_custom();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteElementDetail* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteElementDetail_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail) == eprosima_fastdds_dds_xtypes_CompleteElementDetail_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteElementDetail));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteElementDetail& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::AppliedBuiltinMemberAnnotations& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        if (data.ann_builtin().has_value())
                        {
                            serialize_key(scdr, data.ann_builtin().value());
                        }

                        if (data.ann_custom().has_value())
                        {
                            scdr << data.ann_custom().value();
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonCollectionElement_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonCollectionElement& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.element_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.type(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.element_flags()
        << eprosima::fastcdr::MemberId(1) << data.type()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonCollectionElement_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement) == eprosima_fastdds_dds_xtypes_CommonCollectionElement_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.element_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.type();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonCollectionElement_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement) == eprosima_fastdds_dds_xtypes_CommonCollectionElement_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionElement));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.element_flags();

                        scdr << data.type();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteCollectionElement_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteCollectionElement_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement) == eprosima_fastdds_dds_xtypes_CompleteCollectionElement_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteCollectionElement_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement) == eprosima_fastdds_dds_xtypes_CompleteCollectionElement_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionElement));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonCollectionElement& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteElementDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalCollectionElement_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalCollectionElement_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement) == eprosima_fastdds_dds_xtypes_MinimalCollectionElement_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalCollectionElement* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalCollectionElement_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement) == eprosima_fastdds_dds_xtypes_MinimalCollectionElement_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionElement));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonCollectionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 4ULL ==
               (detail::CommonCollectionHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonCollectionHeader, detail::CommonCollectionHeader_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::LBound));
    }
    else
    {
        return 4ULL ==
            (detail::CommonCollectionHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonCollectionHeader, detail::CommonCollectionHeader_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::LBound));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bound(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bound()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonCollectionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader) == eprosima_fastdds_dds_xtypes_CommonCollectionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bound();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonCollectionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader) == eprosima_fastdds_dds_xtypes_CommonCollectionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonCollectionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bound();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteCollectionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteCollectionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader) == eprosima_fastdds_dds_xtypes_CompleteCollectionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteCollectionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader) == eprosima_fastdds_dds_xtypes_CompleteCollectionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteCollectionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        if (data.detail().has_value())
                        {
                            serialize_key(scdr, data.detail().value());
                        }

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalCollectionHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalCollectionHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader) == eprosima_fastdds_dds_xtypes_MinimalCollectionHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalCollectionHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalCollectionHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader) == eprosima_fastdds_dds_xtypes_MinimalCollectionHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalCollectionHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonCollectionHeader& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteSequenceType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteSequenceType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteSequenceType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteSequenceType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType) == eprosima_fastdds_dds_xtypes_CompleteSequenceType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteSequenceType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteSequenceType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType) == eprosima_fastdds_dds_xtypes_CompleteSequenceType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteSequenceType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalSequenceType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalSequenceType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalSequenceType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalSequenceType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType) == eprosima_fastdds_dds_xtypes_MinimalSequenceType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalSequenceType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalSequenceType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType) == eprosima_fastdds_dds_xtypes_MinimalSequenceType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalSequenceType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalSequenceType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonArrayHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonArrayHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bound_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bound_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonArrayHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader) == eprosima_fastdds_dds_xtypes_CommonArrayHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bound_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonArrayHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader) == eprosima_fastdds_dds_xtypes_CommonArrayHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonArrayHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bound_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteArrayHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteArrayHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteArrayHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader) == eprosima_fastdds_dds_xtypes_CompleteArrayHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteArrayHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader) == eprosima_fastdds_dds_xtypes_CompleteArrayHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonArrayHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalArrayHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalArrayHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalArrayHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader) == eprosima_fastdds_dds_xtypes_MinimalArrayHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalArrayHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalArrayHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader) == eprosima_fastdds_dds_xtypes_MinimalArrayHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonArrayHeader& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteArrayType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteArrayType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteArrayType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType) == eprosima_fastdds_dds_xtypes_CompleteArrayType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteArrayType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteArrayType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType) == eprosima_fastdds_dds_xtypes_CompleteArrayType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteArrayType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteArrayHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalArrayType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalArrayType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalArrayType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType) == eprosima_fastdds_dds_xtypes_MinimalArrayType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalArrayType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalArrayType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType) == eprosima_fastdds_dds_xtypes_MinimalArrayType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalArrayType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalArrayType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalArrayHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteMapType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteMapType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.key(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.key()
        << eprosima::fastcdr::MemberId(3) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMapType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteMapType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType) == eprosima_fastdds_dds_xtypes_CompleteMapType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.key();
                                            break;

                                        case 3:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteMapType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteMapType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType) == eprosima_fastdds_dds_xtypes_CompleteMapType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteMapType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.key());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalMapType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalMapType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.collection_flag(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.key(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.element(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.collection_flag()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.key()
        << eprosima::fastcdr::MemberId(3) << data.element()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMapType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalMapType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType) == eprosima_fastdds_dds_xtypes_MinimalMapType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.collection_flag();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.key();
                                            break;

                                        case 3:
                                                dcdr >> data.element();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalMapType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalMapType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType) == eprosima_fastdds_dds_xtypes_MinimalMapType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalMapType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalMapType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalCollectionElement& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.collection_flag();

                        serialize_key(scdr, data.header());

                        serialize_key(scdr, data.key());

                        serialize_key(scdr, data.element());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonEnumeratedLiteral_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.value(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.flags(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.value()
        << eprosima::fastcdr::MemberId(1) << data.flags()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonEnumeratedLiteral_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_CommonEnumeratedLiteral_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.value();
                                            break;

                                        case 1:
                                                dcdr >> data.flags();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonEnumeratedLiteral_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_CommonEnumeratedLiteral_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.value();

                        scdr << data.flags();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedLiteral_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedLiteral_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedLiteral_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedLiteral_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedLiteral_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedLiteral_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedLiteral_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedLiteral_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedLiteral_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedLiteral_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedLiteral& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonEnumeratedLiteral& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonEnumeratedHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 2ULL ==
               (detail::CommonEnumeratedHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader, detail::CommonEnumeratedHeader_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::BitBound));
    }
    else
    {
        return 2ULL ==
            (detail::CommonEnumeratedHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader, detail::CommonEnumeratedHeader_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::BitBound));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bit_bound(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bit_bound()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonEnumeratedHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader) == eprosima_fastdds_dds_xtypes_CommonEnumeratedHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bit_bound();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonEnumeratedHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader) == eprosima_fastdds_dds_xtypes_CommonEnumeratedHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bit_bound();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonEnumeratedHeader& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.enum_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.literal_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.enum_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.literal_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.enum_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.literal_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteEnumeratedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteEnumeratedType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType) == eprosima_fastdds_dds_xtypes_CompleteEnumeratedType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteEnumeratedType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteEnumeratedHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.enum_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.literal_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.enum_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.literal_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.enum_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.literal_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.enum_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.literal_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalEnumeratedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalEnumeratedType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType) == eprosima_fastdds_dds_xtypes_MinimalEnumeratedType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalEnumeratedType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalEnumeratedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalEnumeratedHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.enum_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.literal_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonBitflag_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonBitflag& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.position(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.flags(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.position()
        << eprosima::fastcdr::MemberId(1) << data.flags()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitflag_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag) == eprosima_fastdds_dds_xtypes_CommonBitflag_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.position();
                                            break;

                                        case 1:
                                                dcdr >> data.flags();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitflag_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag) == eprosima_fastdds_dds_xtypes_CommonBitflag_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitflag));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.position();

                        scdr << data.flags();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteBitflag_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteBitflag& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitflag_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag) == eprosima_fastdds_dds_xtypes_CompleteBitflag_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitflag_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag) == eprosima_fastdds_dds_xtypes_CompleteBitflag_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitflag));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonBitflag& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalBitflag_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalBitflag& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitflag_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag) == eprosima_fastdds_dds_xtypes_MinimalBitflag_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalBitflag* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitflag_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag) == eprosima_fastdds_dds_xtypes_MinimalBitflag_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitflag));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitflag& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonBitflag& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonBitmaskHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    if (data_representation == eprosima::fastdds::dds::DataRepresentationId_t::XCDR2_DATA_REPRESENTATION)
    {
        return 2ULL ==
               (detail::CommonBitmaskHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonBitmaskHeader, detail::CommonBitmaskHeader_f>() +
               sizeof(eprosima::fastdds::dds::xtypes::BitBound));
    }
    else
    {
        return 2ULL ==
            (detail::CommonBitmaskHeader_offset_of<eprosima::fastdds::dds::xtypes::CommonBitmaskHeader, detail::CommonBitmaskHeader_f>() +
                sizeof(eprosima::fastdds::dds::xtypes::BitBound));
    }
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonBitmaskHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bit_bound(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitmaskHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bit_bound()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitmaskHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitmaskHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader) == eprosima_fastdds_dds_xtypes_CommonBitmaskHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonBitmaskHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bit_bound();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonBitmaskHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitmaskHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader) == eprosima_fastdds_dds_xtypes_CommonBitmaskHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitmaskHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitmaskHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bit_bound();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteBitmaskType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteBitmaskType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bitmask_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.flag_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bitmask_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.flag_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitmaskType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitmaskType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType) == eprosima_fastdds_dds_xtypes_CompleteBitmaskType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bitmask_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.flag_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteBitmaskType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitmaskType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType) == eprosima_fastdds_dds_xtypes_CompleteBitmaskType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitmaskType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bitmask_flags();

                        scdr << data.header();

                        scdr << data.flag_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalBitmaskType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalBitmaskType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bitmask_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.flag_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bitmask_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.flag_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitmaskType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitmaskType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType) == eprosima_fastdds_dds_xtypes_MinimalBitmaskType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bitmask_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.flag_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalBitmaskType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitmaskType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType) == eprosima_fastdds_dds_xtypes_MinimalBitmaskType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitmaskType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitmaskType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bitmask_flags();

                        scdr << data.header();

                        scdr << data.flag_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CommonBitfield_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CommonBitfield& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.position(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.bitcount(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.holder_type(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.position()
        << eprosima::fastcdr::MemberId(1) << data.flags()
        << eprosima::fastcdr::MemberId(2) << data.bitcount()
        << eprosima::fastcdr::MemberId(3) << data.holder_type()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitfield_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield) == eprosima_fastdds_dds_xtypes_CommonBitfield_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CommonBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.position();
                                            break;

                                        case 1:
                                                dcdr >> data.flags();
                                            break;

                                        case 2:
                                                dcdr >> data.bitcount();
                                            break;

                                        case 3:
                                                dcdr >> data.holder_type();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CommonBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CommonBitfield_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield) == eprosima_fastdds_dds_xtypes_CommonBitfield_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CommonBitfield));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CommonBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.position();

                        scdr << data.flags();

                        scdr << data.bitcount();

                        scdr << data.holder_type();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteBitfield_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteBitfield& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitfield_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield) == eprosima_fastdds_dds_xtypes_CompleteBitfield_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitfield_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield) == eprosima_fastdds_dds_xtypes_CompleteBitfield_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitfield));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonBitfield& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteMemberDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalBitfield_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalBitfield& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.common(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.name_hash(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.common()
        << eprosima::fastcdr::MemberId(1) << data.name_hash()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitfield_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield) == eprosima_fastdds_dds_xtypes_MinimalBitfield_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.common();
                                            break;

                                        case 1:
                                                dcdr >> data.name_hash();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalBitfield* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitfield_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield) == eprosima_fastdds_dds_xtypes_MinimalBitfield_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitfield));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitfield& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CommonBitfield& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.common());

                        scdr << data.name_hash();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteBitsetHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.detail(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.detail()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitsetHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader) == eprosima_fastdds_dds_xtypes_CompleteBitsetHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.detail();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteBitsetHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitsetHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader) == eprosima_fastdds_dds_xtypes_CompleteBitsetHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteTypeDetail& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.detail());

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalBitsetHeader_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetHeader& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitsetHeader_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader) == eprosima_fastdds_dds_xtypes_MinimalBitsetHeader_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalBitsetHeader* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitsetHeader_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader) == eprosima_fastdds_dds_xtypes_MinimalBitsetHeader_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetHeader));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetHeader& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteBitsetType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bitset_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.field_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bitset_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.field_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitsetType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType) == eprosima_fastdds_dds_xtypes_CompleteBitsetType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bitset_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.field_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteBitsetType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteBitsetType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType) == eprosima_fastdds_dds_xtypes_CompleteBitsetType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteBitsetType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::CompleteBitsetHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bitset_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.field_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalBitsetType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.bitset_flags(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.header(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.field_seq(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.bitset_flags()
        << eprosima::fastcdr::MemberId(1) << data.header()
        << eprosima::fastcdr::MemberId(2) << data.field_seq()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitsetType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType) == eprosima_fastdds_dds_xtypes_MinimalBitsetType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.bitset_flags();
                                            break;

                                        case 1:
                                                dcdr >> data.header();
                                            break;

                                        case 2:
                                                dcdr >> data.field_seq();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalBitsetType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalBitsetType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType) == eprosima_fastdds_dds_xtypes_MinimalBitsetType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalBitsetType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalBitsetType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::MinimalBitsetHeader& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.bitset_flags();

                        serialize_key(scdr, data.header());

                        scdr << data.field_seq();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_CompleteExtendedType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteExtendedType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteExtendedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteExtendedType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType) == eprosima_fastdds_dds_xtypes_CompleteExtendedType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteExtendedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_CompleteExtendedType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType) == eprosima_fastdds_dds_xtypes_CompleteExtendedType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::CompleteExtendedType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::CompleteTypeObject& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case TK_ALIAS:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.alias_type(), current_alignment);
                    break;

                case TK_ANNOTATION:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.annotation_type(), current_alignment);
                    break;

                case TK_STRUCTURE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.struct_type(), current_alignment);
                    break;

                case TK_UNION:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.union_type(), current_alignment);
                    break;

                case TK_BITSET:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.bitset_type(), current_alignment);
                    break;

                case TK_SEQUENCE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.sequence_type(), current_alignment);
                    break;

                case TK_ARRAY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.array_type(), current_alignment);
                    break;

                case TK_MAP:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.map_type(), current_alignment);
                    break;

                case TK_ENUM:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.enumerated_type(), current_alignment);
                    break;

                case TK_BITMASK:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.bitmask_type(), current_alignment);
                    break;

                default:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.extended_type(), current_alignment);
                    break;

    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteTypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case TK_ALIAS:
                    scdr << eprosima::fastcdr::MemberId(1) << data.alias_type();
                    break;

                case TK_ANNOTATION:
                    scdr << eprosima::fastcdr::MemberId(2) << data.annotation_type();
                    break;

                case TK_STRUCTURE:
                    scdr << eprosima::fastcdr::MemberId(3) << data.struct_type();
                    break;

                case TK_UNION:
                    scdr << eprosima::fastcdr::MemberId(4) << data.union_type();
                    break;

                case TK_BITSET:
                    scdr << eprosima::fastcdr::MemberId(5) << data.bitset_type();
                    break;

                case TK_SEQUENCE:
                    scdr << eprosima::fastcdr::MemberId(6) << data.sequence_type();
                    break;

                case TK_ARRAY:
                    scdr << eprosima::fastcdr::MemberId(7) << data.array_type();
                    break;

                case TK_MAP:
                    scdr << eprosima::fastcdr::MemberId(8) << data.map_type();
                    break;

                case TK_ENUM:
                    scdr << eprosima::fastcdr::MemberId(9) << data.enumerated_type();
                    break;

                case TK_BITMASK:
                    scdr << eprosima::fastcdr::MemberId(10) << data.bitmask_type();
                    break;

                default:
                    scdr << eprosima::fastcdr::MemberId(11) << data.extended_type();
                    break;

    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::CompleteTypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::CompleteTypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case TK_ALIAS:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteAliasType alias_type_value;
                                                        data.alias_type(std::move(alias_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ANNOTATION:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteAnnotationType annotation_type_value;
                                                        data.annotation_type(std::move(annotation_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_STRUCTURE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteStructType struct_type_value;
                                                        data.struct_type(std::move(struct_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UNION:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteUnionType union_type_value;
                                                        data.union_type(std::move(union_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_BITSET:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteBitsetType bitset_type_value;
                                                        data.bitset_type(std::move(bitset_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_SEQUENCE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteSequenceType sequence_type_value;
                                                        data.sequence_type(std::move(sequence_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ARRAY:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteArrayType array_type_value;
                                                        data.array_type(std::move(array_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_MAP:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteMapType map_type_value;
                                                        data.map_type(std::move(map_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ENUM:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteEnumeratedType enumerated_type_value;
                                                        data.enumerated_type(std::move(enumerated_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_BITMASK:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteBitmaskType bitmask_type_value;
                                                        data.bitmask_type(std::move(bitmask_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                default:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteExtendedType extended_type_value;
                                                        data.extended_type(std::move(extended_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case TK_ALIAS:
                                                    dcdr >> data.alias_type();
                                                    break;

                                                case TK_ANNOTATION:
                                                    dcdr >> data.annotation_type();
                                                    break;

                                                case TK_STRUCTURE:
                                                    dcdr >> data.struct_type();
                                                    break;

                                                case TK_UNION:
                                                    dcdr >> data.union_type();
                                                    break;

                                                case TK_BITSET:
                                                    dcdr >> data.bitset_type();
                                                    break;

                                                case TK_SEQUENCE:
                                                    dcdr >> data.sequence_type();
                                                    break;

                                                case TK_ARRAY:
                                                    dcdr >> data.array_type();
                                                    break;

                                                case TK_MAP:
                                                    dcdr >> data.map_type();
                                                    break;

                                                case TK_ENUM:
                                                    dcdr >> data.enumerated_type();
                                                    break;

                                                case TK_BITMASK:
                                                    dcdr >> data.bitmask_type();
                                                    break;

                                                default:
                                                    dcdr >> data.extended_type();
                                                    break;

                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::CompleteTypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2


eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_MinimalExtendedType_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalExtendedType& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalExtendedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalExtendedType_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType) == eprosima_fastdds_dds_xtypes_MinimalExtendedType_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalExtendedType* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_MinimalExtendedType_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType) == eprosima_fastdds_dds_xtypes_MinimalExtendedType_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::MinimalExtendedType));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalExtendedType& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::MinimalTypeObject& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case TK_ALIAS:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.alias_type(), current_alignment);
                    break;

                case TK_ANNOTATION:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.annotation_type(), current_alignment);
                    break;

                case TK_STRUCTURE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.struct_type(), current_alignment);
                    break;

                case TK_UNION:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.union_type(), current_alignment);
                    break;

                case TK_BITSET:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.bitset_type(), current_alignment);
                    break;

                case TK_SEQUENCE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.sequence_type(), current_alignment);
                    break;

                case TK_ARRAY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.array_type(), current_alignment);
                    break;

                case TK_MAP:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.map_type(), current_alignment);
                    break;

                case TK_ENUM:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.enumerated_type(), current_alignment);
                    break;

                case TK_BITMASK:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.bitmask_type(), current_alignment);
                    break;

                default:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.extended_type(), current_alignment);
                    break;

    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalTypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case TK_ALIAS:
                    scdr << eprosima::fastcdr::MemberId(1) << data.alias_type();
                    break;

                case TK_ANNOTATION:
                    scdr << eprosima::fastcdr::MemberId(2) << data.annotation_type();
                    break;

                case TK_STRUCTURE:
                    scdr << eprosima::fastcdr::MemberId(3) << data.struct_type();
                    break;

                case TK_UNION:
                    scdr << eprosima::fastcdr::MemberId(4) << data.union_type();
                    break;

                case TK_BITSET:
                    scdr << eprosima::fastcdr::MemberId(5) << data.bitset_type();
                    break;

                case TK_SEQUENCE:
                    scdr << eprosima::fastcdr::MemberId(6) << data.sequence_type();
                    break;

                case TK_ARRAY:
                    scdr << eprosima::fastcdr::MemberId(7) << data.array_type();
                    break;

                case TK_MAP:
                    scdr << eprosima::fastcdr::MemberId(8) << data.map_type();
                    break;

                case TK_ENUM:
                    scdr << eprosima::fastcdr::MemberId(9) << data.enumerated_type();
                    break;

                case TK_BITMASK:
                    scdr << eprosima::fastcdr::MemberId(10) << data.bitmask_type();
                    break;

                default:
                    scdr << eprosima::fastcdr::MemberId(11) << data.extended_type();
                    break;

    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::MinimalTypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::MinimalTypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case TK_ALIAS:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalAliasType alias_type_value;
                                                        data.alias_type(std::move(alias_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ANNOTATION:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalAnnotationType annotation_type_value;
                                                        data.annotation_type(std::move(annotation_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_STRUCTURE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalStructType struct_type_value;
                                                        data.struct_type(std::move(struct_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_UNION:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalUnionType union_type_value;
                                                        data.union_type(std::move(union_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_BITSET:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalBitsetType bitset_type_value;
                                                        data.bitset_type(std::move(bitset_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_SEQUENCE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalSequenceType sequence_type_value;
                                                        data.sequence_type(std::move(sequence_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ARRAY:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalArrayType array_type_value;
                                                        data.array_type(std::move(array_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_MAP:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalMapType map_type_value;
                                                        data.map_type(std::move(map_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_ENUM:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalEnumeratedType enumerated_type_value;
                                                        data.enumerated_type(std::move(enumerated_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case TK_BITMASK:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalBitmaskType bitmask_type_value;
                                                        data.bitmask_type(std::move(bitmask_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                default:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalExtendedType extended_type_value;
                                                        data.extended_type(std::move(extended_type_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case TK_ALIAS:
                                                    dcdr >> data.alias_type();
                                                    break;

                                                case TK_ANNOTATION:
                                                    dcdr >> data.annotation_type();
                                                    break;

                                                case TK_STRUCTURE:
                                                    dcdr >> data.struct_type();
                                                    break;

                                                case TK_UNION:
                                                    dcdr >> data.union_type();
                                                    break;

                                                case TK_BITSET:
                                                    dcdr >> data.bitset_type();
                                                    break;

                                                case TK_SEQUENCE:
                                                    dcdr >> data.sequence_type();
                                                    break;

                                                case TK_ARRAY:
                                                    dcdr >> data.array_type();
                                                    break;

                                                case TK_MAP:
                                                    dcdr >> data.map_type();
                                                    break;

                                                case TK_ENUM:
                                                    dcdr >> data.enumerated_type();
                                                    break;

                                                case TK_BITMASK:
                                                    dcdr >> data.bitmask_type();
                                                    break;

                                                default:
                                                    dcdr >> data.extended_type();
                                                    break;

                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::MinimalTypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeObject& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
                case EK_COMPLETE:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.complete(), current_alignment);
                    break;

                case EK_MINIMAL:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.minimal(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case EK_COMPLETE:
                    scdr << eprosima::fastcdr::MemberId(1) << data.complete();
                    break;

                case EK_MINIMAL:
                    scdr << eprosima::fastcdr::MemberId(2) << data.minimal();
                    break;

        default:
            break;
    }

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for serialization
    // of arrays of unions not yet supported
    scdr.serialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeObject& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                if (0 == mid.id)
                {
                    uint8_t discriminator;
                    dcdr >> discriminator;

                    switch (discriminator)
                    {
                                                case EK_COMPLETE:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::CompleteTypeObject complete_value;
                                                        data.complete(std::move(complete_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                                                case EK_MINIMAL:
                                                    {
                                                        eprosima::fastdds::dds::xtypes::MinimalTypeObject minimal_value;
                                                        data.minimal(std::move(minimal_value));
                                                        data._d(discriminator);
                                                        break;
                                                    }

                        default:
                            data._default();
                            break;
                    }
                }
                else
                {
                    switch (data._d())
                    {
                                                case EK_COMPLETE:
                                                    dcdr >> data.complete();
                                                    break;

                                                case EK_MINIMAL:
                                                    dcdr >> data.minimal();
                                                    break;

                        default:
                            break;
                    }
                    ret_value = false;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeObject* array_ptr,
        const std::size_t array_size)
{
    // Optimization for deserialization
    // of arrays of unions not yet supported
    scdr.deserialize_array(array_ptr, array_size);
}
#endif // FASTCDR_VERSION_MAJOR > 2


eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_TypeIdentifierTypeObjectPair_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.type_identifier(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.type_object(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.type_identifier()
        << eprosima::fastcdr::MemberId(1) << data.type_object()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierTypeObjectPair_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair) == eprosima_fastdds_dds_xtypes_TypeIdentifierTypeObjectPair_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.type_identifier();
                                            break;

                                        case 1:
                                                dcdr >> data.type_object();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierTypeObjectPair_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair) == eprosima_fastdds_dds_xtypes_TypeIdentifierTypeObjectPair_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierTypeObjectPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.type_identifier();

                        scdr << data.type_object();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_TypeIdentifierPair_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierPair& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.type_identifier1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.type_identifier2(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.type_identifier1()
        << eprosima::fastcdr::MemberId(1) << data.type_identifier2()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierPair* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierPair_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair) == eprosima_fastdds_dds_xtypes_TypeIdentifierPair_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.type_identifier1();
                                            break;

                                        case 1:
                                                dcdr >> data.type_identifier2();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierPair* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierPair_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair) == eprosima_fastdds_dds_xtypes_TypeIdentifierPair_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierPair));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierPair& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.type_identifier1();

                        scdr << data.type_identifier2();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_TypeIdentfierWithSize_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.type_id(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.typeobject_serialized_size(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.type_id()
        << eprosima::fastcdr::MemberId(1) << data.typeobject_serialized_size()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentfierWithSize_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize) == eprosima_fastdds_dds_xtypes_TypeIdentfierWithSize_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.type_id();
                                            break;

                                        case 1:
                                                dcdr >> data.typeobject_serialized_size();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentfierWithSize_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize) == eprosima_fastdds_dds_xtypes_TypeIdentfierWithSize_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.type_id();

                        scdr << data.typeobject_serialized_size();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_TypeIdentifierWithDependencies_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.typeid_with_size(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.dependent_typeid_count(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.dependent_typeids(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.typeid_with_size()
        << eprosima::fastcdr::MemberId(1) << data.dependent_typeid_count()
        << eprosima::fastcdr::MemberId(2) << data.dependent_typeids()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierWithDependencies_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies) == eprosima_fastdds_dds_xtypes_TypeIdentifierWithDependencies_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.typeid_with_size();
                                            break;

                                        case 1:
                                                dcdr >> data.dependent_typeid_count();
                                            break;

                                        case 2:
                                                dcdr >> data.dependent_typeids();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeIdentifierWithDependencies_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies) == eprosima_fastdds_dds_xtypes_TypeIdentifierWithDependencies_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::TypeIdentfierWithSize& data);




    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.typeid_with_size());

                        scdr << data.dependent_typeid_count();

                        scdr << data.dependent_typeids();

}



eProsima_user_DllExport bool is_eprosima_fastdds_dds_xtypes_TypeInformation_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const eprosima::fastdds::dds::xtypes::TypeInformation& data,
        size_t& current_alignment)
{
    using namespace eprosima::fastdds::dds::xtypes;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0x00001001),
                data.minimal(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0x00001002),
                data.complete(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeInformation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0x00001001) << data.minimal()
        << eprosima::fastcdr::MemberId(0x00001002) << data.complete()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeInformation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeInformation_cdr_plain(data_representation) &&
                sizeof(eprosima::fastdds::dds::xtypes::TypeInformation) == eprosima_fastdds_dds_xtypes_TypeInformation_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeInformation));

            scdr.jump((array_size -1) * sizeof(eprosima::fastdds::dds::xtypes::TypeInformation));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        eprosima::fastdds::dds::xtypes::TypeInformation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0x00001001:
                                                dcdr >> data.minimal();
                                            break;

                                        case 0x00001002:
                                                dcdr >> data.complete();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        eprosima::fastdds::dds::xtypes::TypeInformation* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_eprosima_fastdds_dds_xtypes_TypeInformation_cdr_plain(data_representation) &&
            sizeof(eprosima::fastdds::dds::xtypes::TypeInformation) == eprosima_fastdds_dds_xtypes_TypeInformation_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeInformation));

            scdr.jump((array_size - 1) * sizeof(eprosima::fastdds::dds::xtypes::TypeInformation));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const eprosima::fastdds::dds::xtypes::TypeInformation& data)
{
    using namespace eprosima::fastdds::dds::xtypes;
            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const eprosima::fastdds::dds::xtypes::TypeIdentifierWithDependencies& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.minimal());

                        serialize_key(scdr, data.complete());

}



} // namespace fastcdr
} // namespace eprosima

#endif // FAST_DDS_GENERATED__DDS_XTYPES_TYPEOBJECTCDRAUX_IPP

