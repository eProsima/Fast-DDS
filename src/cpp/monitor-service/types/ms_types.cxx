// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ms_types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "ms_types.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define eprosima_fastdds_statistics_DiscoveryTime_max_cdr_typesize 820ULL;


#define eprosima_fastdds_statistics_detail_SampleIdentity_s_max_cdr_typesize 24ULL;

#define eprosima_fastrtps_monitor_service_Connection_max_cdr_typesize 4828ULL;
#define eprosima_fastrtps_monitor_service_LivelinessChangedStatus_m_max_cdr_typesize 24ULL;
#define eprosima_fastrtps_monitor_service_BaseStatus_m_max_cdr_typesize 4ULL;
#define eprosima_fastdds_statistics_detail_EntityId_s_max_cdr_typesize 4ULL;



#define eprosima_fastdds_statistics_detail_SequenceNumber_s_max_cdr_typesize 8ULL;

#define eprosima_fastrtps_monitor_service_IncompatibleQoSStatus_m_max_cdr_typesize 812ULL;

#define eprosima_fastdds_statistics_PhysicalData_max_cdr_typesize 796ULL;
#define eprosima_fastrtps_monitor_service_MonitorServiceStatusData_max_cdr_typesize 482828ULL;
#define eprosima_fastdds_statistics_detail_Locator_s_max_cdr_typesize 24ULL;
#define eprosima_fastrtps_monitor_service_QosPolicyCount_m_max_cdr_typesize 8ULL;
#define eprosima_fastdds_statistics_detail_GuidPrefix_s_max_cdr_typesize 12ULL;
#define eprosima_fastdds_statistics_EntityData_max_cdr_typesize 20ULL;
#define eprosima_fastdds_statistics_Entity2LocatorTraffic_max_cdr_typesize 58ULL;

#define eprosima_fastdds_statistics_EntityCount_max_cdr_typesize 24ULL;
#define eprosima_fastrtps_monitor_service_DeadlineMissedStatus_m_max_cdr_typesize 20ULL;


#define eprosima_fastdds_statistics_WriterReaderData_max_cdr_typesize 36ULL;
#define eprosima_fastdds_statistics_SampleIdentityCount_max_cdr_typesize 32ULL;
#define eprosima_fastdds_statistics_Locator2LocatorData_max_cdr_typesize 52ULL;
#define eprosima_fastdds_statistics_detail_GUID_s_max_cdr_typesize 16ULL;


#define eprosima_fastdds_statistics_DiscoveryTime_max_key_cdr_typesize 32ULL;


#define eprosima_fastdds_statistics_detail_SampleIdentity_s_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_monitor_service_Connection_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_monitor_service_LivelinessChangedStatus_m_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_monitor_service_BaseStatus_m_max_key_cdr_typesize 0ULL;
#define eprosima_fastdds_statistics_detail_EntityId_s_max_key_cdr_typesize 0ULL;



#define eprosima_fastdds_statistics_detail_SequenceNumber_s_max_key_cdr_typesize 0ULL;

#define eprosima_fastrtps_monitor_service_IncompatibleQoSStatus_m_max_key_cdr_typesize 0ULL;

#define eprosima_fastdds_statistics_PhysicalData_max_key_cdr_typesize 16ULL;
#define eprosima_fastrtps_monitor_service_MonitorServiceStatusData_max_key_cdr_typesize 20ULL;
#define eprosima_fastdds_statistics_detail_Locator_s_max_key_cdr_typesize 0ULL;
#define eprosima_fastrtps_monitor_service_QosPolicyCount_m_max_key_cdr_typesize 0ULL;
#define eprosima_fastdds_statistics_detail_GuidPrefix_s_max_key_cdr_typesize 0ULL;
#define eprosima_fastdds_statistics_EntityData_max_key_cdr_typesize 16ULL;
#define eprosima_fastdds_statistics_Entity2LocatorTraffic_max_key_cdr_typesize 40ULL;

#define eprosima_fastdds_statistics_EntityCount_max_key_cdr_typesize 16ULL;
#define eprosima_fastrtps_monitor_service_DeadlineMissedStatus_m_max_key_cdr_typesize 0ULL;


#define eprosima_fastdds_statistics_WriterReaderData_max_key_cdr_typesize 32ULL;
#define eprosima_fastdds_statistics_SampleIdentityCount_max_key_cdr_typesize 24ULL;
#define eprosima_fastdds_statistics_Locator2LocatorData_max_key_cdr_typesize 48ULL;
#define eprosima_fastdds_statistics_detail_GUID_s_max_key_cdr_typesize 0ULL;









eprosima::fastrtps::monitor_service::Connection::Connection()
{
    // eprosima::fastrtps::monitor_service::ConnectionMode m_mode
    m_mode = eprosima::fastrtps::monitor_service::DATA_SHARING;
    // eprosima::fastdds::statistics::detail::GUID_s m_guid

    // sequence<eprosima::fastrtps::monitor_service::detail::Locator_m> m_announced_locators

    // sequence<eprosima::fastrtps::monitor_service::detail::Locator_m> m_used_locators


}

eprosima::fastrtps::monitor_service::Connection::~Connection()
{




}

eprosima::fastrtps::monitor_service::Connection::Connection(
        const Connection& x)
{
    m_mode = x.m_mode;
    m_guid = x.m_guid;
    m_announced_locators = x.m_announced_locators;
    m_used_locators = x.m_used_locators;
}

eprosima::fastrtps::monitor_service::Connection::Connection(
        Connection&& x) noexcept 
{
    m_mode = x.m_mode;
    m_guid = std::move(x.m_guid);
    m_announced_locators = std::move(x.m_announced_locators);
    m_used_locators = std::move(x.m_used_locators);
}

eprosima::fastrtps::monitor_service::Connection& eprosima::fastrtps::monitor_service::Connection::operator =(
        const Connection& x)
{

    m_mode = x.m_mode;
    m_guid = x.m_guid;
    m_announced_locators = x.m_announced_locators;
    m_used_locators = x.m_used_locators;

    return *this;
}

eprosima::fastrtps::monitor_service::Connection& eprosima::fastrtps::monitor_service::Connection::operator =(
        Connection&& x) noexcept
{

    m_mode = x.m_mode;
    m_guid = std::move(x.m_guid);
    m_announced_locators = std::move(x.m_announced_locators);
    m_used_locators = std::move(x.m_used_locators);

    return *this;
}

bool eprosima::fastrtps::monitor_service::Connection::operator ==(
        const Connection& x) const
{

    return (m_mode == x.m_mode && m_guid == x.m_guid && m_announced_locators == x.m_announced_locators && m_used_locators == x.m_used_locators);
}

bool eprosima::fastrtps::monitor_service::Connection::operator !=(
        const Connection& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::Connection::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_Connection_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::Connection::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::Connection& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += eprosima::fastdds::statistics::detail::GUID_s::getCdrSerializedSize(data.guid(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.announced_locators().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::monitor_service::detail::Locator_m::getCdrSerializedSize(data.announced_locators().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.used_locators().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::monitor_service::detail::Locator_m::getCdrSerializedSize(data.used_locators().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::Connection::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_mode;
    scdr << m_guid;
    scdr << m_announced_locators;
    scdr << m_used_locators;

}

void eprosima::fastrtps::monitor_service::Connection::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_mode = (eprosima::fastrtps::monitor_service::ConnectionMode)enum_value;
    }

    dcdr >> m_guid;
    dcdr >> m_announced_locators;
    dcdr >> m_used_locators;
}

/*!
 * @brief This function sets a value in member mode
 * @param _mode New value for member mode
 */
void eprosima::fastrtps::monitor_service::Connection::mode(
        eprosima::fastrtps::monitor_service::ConnectionMode _mode)
{
    m_mode = _mode;
}

/*!
 * @brief This function returns the value of member mode
 * @return Value of member mode
 */
eprosima::fastrtps::monitor_service::ConnectionMode eprosima::fastrtps::monitor_service::Connection::mode() const
{
    return m_mode;
}

/*!
 * @brief This function returns a reference to member mode
 * @return Reference to member mode
 */
eprosima::fastrtps::monitor_service::ConnectionMode& eprosima::fastrtps::monitor_service::Connection::mode()
{
    return m_mode;
}

/*!
 * @brief This function copies the value in member guid
 * @param _guid New value to be copied in member guid
 */
void eprosima::fastrtps::monitor_service::Connection::guid(
        const eprosima::fastdds::statistics::detail::GUID_s& _guid)
{
    m_guid = _guid;
}

/*!
 * @brief This function moves the value in member guid
 * @param _guid New value to be moved in member guid
 */
void eprosima::fastrtps::monitor_service::Connection::guid(
        eprosima::fastdds::statistics::detail::GUID_s&& _guid)
{
    m_guid = std::move(_guid);
}

/*!
 * @brief This function returns a constant reference to member guid
 * @return Constant reference to member guid
 */
const eprosima::fastdds::statistics::detail::GUID_s& eprosima::fastrtps::monitor_service::Connection::guid() const
{
    return m_guid;
}

/*!
 * @brief This function returns a reference to member guid
 * @return Reference to member guid
 */
eprosima::fastdds::statistics::detail::GUID_s& eprosima::fastrtps::monitor_service::Connection::guid()
{
    return m_guid;
}
/*!
 * @brief This function copies the value in member announced_locators
 * @param _announced_locators New value to be copied in member announced_locators
 */
void eprosima::fastrtps::monitor_service::Connection::announced_locators(
        const std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& _announced_locators)
{
    m_announced_locators = _announced_locators;
}

/*!
 * @brief This function moves the value in member announced_locators
 * @param _announced_locators New value to be moved in member announced_locators
 */
void eprosima::fastrtps::monitor_service::Connection::announced_locators(
        std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>&& _announced_locators)
{
    m_announced_locators = std::move(_announced_locators);
}

/*!
 * @brief This function returns a constant reference to member announced_locators
 * @return Constant reference to member announced_locators
 */
const std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& eprosima::fastrtps::monitor_service::Connection::announced_locators() const
{
    return m_announced_locators;
}

/*!
 * @brief This function returns a reference to member announced_locators
 * @return Reference to member announced_locators
 */
std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& eprosima::fastrtps::monitor_service::Connection::announced_locators()
{
    return m_announced_locators;
}
/*!
 * @brief This function copies the value in member used_locators
 * @param _used_locators New value to be copied in member used_locators
 */
void eprosima::fastrtps::monitor_service::Connection::used_locators(
        const std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& _used_locators)
{
    m_used_locators = _used_locators;
}

/*!
 * @brief This function moves the value in member used_locators
 * @param _used_locators New value to be moved in member used_locators
 */
void eprosima::fastrtps::monitor_service::Connection::used_locators(
        std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>&& _used_locators)
{
    m_used_locators = std::move(_used_locators);
}

/*!
 * @brief This function returns a constant reference to member used_locators
 * @return Constant reference to member used_locators
 */
const std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& eprosima::fastrtps::monitor_service::Connection::used_locators() const
{
    return m_used_locators;
}

/*!
 * @brief This function returns a reference to member used_locators
 * @return Reference to member used_locators
 */
std::vector<eprosima::fastrtps::monitor_service::detail::Locator_m>& eprosima::fastrtps::monitor_service::Connection::used_locators()
{
    return m_used_locators;
}


size_t eprosima::fastrtps::monitor_service::Connection::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_Connection_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::Connection::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::Connection::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::monitor_service::QosPolicyCount_m::QosPolicyCount_m()
{
    // unsigned long m_policy_id
    m_policy_id = 0;
    // unsigned long m_count
    m_count = 0;

}

eprosima::fastrtps::monitor_service::QosPolicyCount_m::~QosPolicyCount_m()
{


}

eprosima::fastrtps::monitor_service::QosPolicyCount_m::QosPolicyCount_m(
        const QosPolicyCount_m& x)
{
    m_policy_id = x.m_policy_id;
    m_count = x.m_count;
}

eprosima::fastrtps::monitor_service::QosPolicyCount_m::QosPolicyCount_m(
        QosPolicyCount_m&& x) noexcept 
{
    m_policy_id = x.m_policy_id;
    m_count = x.m_count;
}

eprosima::fastrtps::monitor_service::QosPolicyCount_m& eprosima::fastrtps::monitor_service::QosPolicyCount_m::operator =(
        const QosPolicyCount_m& x)
{

    m_policy_id = x.m_policy_id;
    m_count = x.m_count;

    return *this;
}

eprosima::fastrtps::monitor_service::QosPolicyCount_m& eprosima::fastrtps::monitor_service::QosPolicyCount_m::operator =(
        QosPolicyCount_m&& x) noexcept
{

    m_policy_id = x.m_policy_id;
    m_count = x.m_count;

    return *this;
}

bool eprosima::fastrtps::monitor_service::QosPolicyCount_m::operator ==(
        const QosPolicyCount_m& x) const
{

    return (m_policy_id == x.m_policy_id && m_count == x.m_count);
}

bool eprosima::fastrtps::monitor_service::QosPolicyCount_m::operator !=(
        const QosPolicyCount_m& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::QosPolicyCount_m::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_QosPolicyCount_m_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::QosPolicyCount_m::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::QosPolicyCount_m& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::QosPolicyCount_m::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_policy_id;
    scdr << m_count;

}

void eprosima::fastrtps::monitor_service::QosPolicyCount_m::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_policy_id;
    dcdr >> m_count;
}

/*!
 * @brief This function sets a value in member policy_id
 * @param _policy_id New value for member policy_id
 */
void eprosima::fastrtps::monitor_service::QosPolicyCount_m::policy_id(
        uint32_t _policy_id)
{
    m_policy_id = _policy_id;
}

/*!
 * @brief This function returns the value of member policy_id
 * @return Value of member policy_id
 */
uint32_t eprosima::fastrtps::monitor_service::QosPolicyCount_m::policy_id() const
{
    return m_policy_id;
}

/*!
 * @brief This function returns a reference to member policy_id
 * @return Reference to member policy_id
 */
uint32_t& eprosima::fastrtps::monitor_service::QosPolicyCount_m::policy_id()
{
    return m_policy_id;
}

/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void eprosima::fastrtps::monitor_service::QosPolicyCount_m::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t eprosima::fastrtps::monitor_service::QosPolicyCount_m::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& eprosima::fastrtps::monitor_service::QosPolicyCount_m::count()
{
    return m_count;
}



size_t eprosima::fastrtps::monitor_service::QosPolicyCount_m::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_QosPolicyCount_m_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::QosPolicyCount_m::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::QosPolicyCount_m::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::monitor_service::BaseStatus_m::BaseStatus_m()
{
    // unsigned long m_total_count
    m_total_count = 0;

}

eprosima::fastrtps::monitor_service::BaseStatus_m::~BaseStatus_m()
{
}

eprosima::fastrtps::monitor_service::BaseStatus_m::BaseStatus_m(
        const BaseStatus_m& x)
{
    m_total_count = x.m_total_count;
}

eprosima::fastrtps::monitor_service::BaseStatus_m::BaseStatus_m(
        BaseStatus_m&& x) noexcept 
{
    m_total_count = x.m_total_count;
}

eprosima::fastrtps::monitor_service::BaseStatus_m& eprosima::fastrtps::monitor_service::BaseStatus_m::operator =(
        const BaseStatus_m& x)
{

    m_total_count = x.m_total_count;

    return *this;
}

eprosima::fastrtps::monitor_service::BaseStatus_m& eprosima::fastrtps::monitor_service::BaseStatus_m::operator =(
        BaseStatus_m&& x) noexcept
{

    m_total_count = x.m_total_count;

    return *this;
}

bool eprosima::fastrtps::monitor_service::BaseStatus_m::operator ==(
        const BaseStatus_m& x) const
{

    return (m_total_count == x.m_total_count);
}

bool eprosima::fastrtps::monitor_service::BaseStatus_m::operator !=(
        const BaseStatus_m& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::BaseStatus_m::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_BaseStatus_m_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::BaseStatus_m::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::BaseStatus_m& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::BaseStatus_m::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_total_count;

}

void eprosima::fastrtps::monitor_service::BaseStatus_m::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_total_count;
}

/*!
 * @brief This function sets a value in member total_count
 * @param _total_count New value for member total_count
 */
void eprosima::fastrtps::monitor_service::BaseStatus_m::total_count(
        uint32_t _total_count)
{
    m_total_count = _total_count;
}

/*!
 * @brief This function returns the value of member total_count
 * @return Value of member total_count
 */
uint32_t eprosima::fastrtps::monitor_service::BaseStatus_m::total_count() const
{
    return m_total_count;
}

/*!
 * @brief This function returns a reference to member total_count
 * @return Reference to member total_count
 */
uint32_t& eprosima::fastrtps::monitor_service::BaseStatus_m::total_count()
{
    return m_total_count;
}



size_t eprosima::fastrtps::monitor_service::BaseStatus_m::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_BaseStatus_m_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::BaseStatus_m::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::BaseStatus_m::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}



eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::IncompatibleQoSStatus_m()
{
    // unsigned long m_total_count
    m_total_count = 0;
    // unsigned long m_last_policy_id
    m_last_policy_id = 0;
    // eprosima::fastrtps::monitor_service::QosPolicyCountSeq_m m_policies


}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::~IncompatibleQoSStatus_m()
{



}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::IncompatibleQoSStatus_m(
        const IncompatibleQoSStatus_m& x)
{
    m_total_count = x.m_total_count;
    m_last_policy_id = x.m_last_policy_id;
    m_policies = x.m_policies;
}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::IncompatibleQoSStatus_m(
        IncompatibleQoSStatus_m&& x) noexcept 
{
    m_total_count = x.m_total_count;
    m_last_policy_id = x.m_last_policy_id;
    m_policies = std::move(x.m_policies);
}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::operator =(
        const IncompatibleQoSStatus_m& x)
{

    m_total_count = x.m_total_count;
    m_last_policy_id = x.m_last_policy_id;
    m_policies = x.m_policies;

    return *this;
}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::operator =(
        IncompatibleQoSStatus_m&& x) noexcept
{

    m_total_count = x.m_total_count;
    m_last_policy_id = x.m_last_policy_id;
    m_policies = std::move(x.m_policies);

    return *this;
}

bool eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::operator ==(
        const IncompatibleQoSStatus_m& x) const
{

    return (m_total_count == x.m_total_count && m_last_policy_id == x.m_last_policy_id && m_policies == x.m_policies);
}

bool eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::operator !=(
        const IncompatibleQoSStatus_m& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_IncompatibleQoSStatus_m_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.policies().size(); ++a)
    {
        current_alignment += eprosima::fastrtps::monitor_service::QosPolicyCount_m::getCdrSerializedSize(data.policies().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_total_count;
    scdr << m_last_policy_id;
    scdr << m_policies;

}

void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_total_count;
    dcdr >> m_last_policy_id;
    dcdr >> m_policies;
}

/*!
 * @brief This function sets a value in member total_count
 * @param _total_count New value for member total_count
 */
void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::total_count(
        uint32_t _total_count)
{
    m_total_count = _total_count;
}

/*!
 * @brief This function returns the value of member total_count
 * @return Value of member total_count
 */
uint32_t eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::total_count() const
{
    return m_total_count;
}

/*!
 * @brief This function returns a reference to member total_count
 * @return Reference to member total_count
 */
uint32_t& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::total_count()
{
    return m_total_count;
}

/*!
 * @brief This function sets a value in member last_policy_id
 * @param _last_policy_id New value for member last_policy_id
 */
void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::last_policy_id(
        uint32_t _last_policy_id)
{
    m_last_policy_id = _last_policy_id;
}

/*!
 * @brief This function returns the value of member last_policy_id
 * @return Value of member last_policy_id
 */
uint32_t eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::last_policy_id() const
{
    return m_last_policy_id;
}

/*!
 * @brief This function returns a reference to member last_policy_id
 * @return Reference to member last_policy_id
 */
uint32_t& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::last_policy_id()
{
    return m_last_policy_id;
}

/*!
 * @brief This function copies the value in member policies
 * @param _policies New value to be copied in member policies
 */
void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::policies(
        const eprosima::fastrtps::monitor_service::QosPolicyCountSeq_m& _policies)
{
    m_policies = _policies;
}

/*!
 * @brief This function moves the value in member policies
 * @param _policies New value to be moved in member policies
 */
void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::policies(
        eprosima::fastrtps::monitor_service::QosPolicyCountSeq_m&& _policies)
{
    m_policies = std::move(_policies);
}

/*!
 * @brief This function returns a constant reference to member policies
 * @return Constant reference to member policies
 */
const eprosima::fastrtps::monitor_service::QosPolicyCountSeq_m& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::policies() const
{
    return m_policies;
}

/*!
 * @brief This function returns a reference to member policies
 * @return Reference to member policies
 */
eprosima::fastrtps::monitor_service::QosPolicyCountSeq_m& eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::policies()
{
    return m_policies;
}


size_t eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_IncompatibleQoSStatus_m_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::LivelinessChangedStatus_m()
{
    // unsigned long m_alive_count
    m_alive_count = 0;
    // unsigned long m_not_alive_count
    m_not_alive_count = 0;
    // octet m_last_publication_handle
    memset(&m_last_publication_handle, 0, (16) * 1);

}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::~LivelinessChangedStatus_m()
{



}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::LivelinessChangedStatus_m(
        const LivelinessChangedStatus_m& x)
{
    m_alive_count = x.m_alive_count;
    m_not_alive_count = x.m_not_alive_count;
    m_last_publication_handle = x.m_last_publication_handle;
}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::LivelinessChangedStatus_m(
        LivelinessChangedStatus_m&& x) noexcept 
{
    m_alive_count = x.m_alive_count;
    m_not_alive_count = x.m_not_alive_count;
    m_last_publication_handle = std::move(x.m_last_publication_handle);
}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::operator =(
        const LivelinessChangedStatus_m& x)
{

    m_alive_count = x.m_alive_count;
    m_not_alive_count = x.m_not_alive_count;
    m_last_publication_handle = x.m_last_publication_handle;

    return *this;
}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::operator =(
        LivelinessChangedStatus_m&& x) noexcept
{

    m_alive_count = x.m_alive_count;
    m_not_alive_count = x.m_not_alive_count;
    m_last_publication_handle = std::move(x.m_last_publication_handle);

    return *this;
}

bool eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::operator ==(
        const LivelinessChangedStatus_m& x) const
{

    return (m_alive_count == x.m_alive_count && m_not_alive_count == x.m_not_alive_count && m_last_publication_handle == x.m_last_publication_handle);
}

bool eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::operator !=(
        const LivelinessChangedStatus_m& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_LivelinessChangedStatus_m_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((16) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_alive_count;
    scdr << m_not_alive_count;
    scdr << m_last_publication_handle;


}

void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_alive_count;
    dcdr >> m_not_alive_count;
    dcdr >> m_last_publication_handle;

}

/*!
 * @brief This function sets a value in member alive_count
 * @param _alive_count New value for member alive_count
 */
void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::alive_count(
        uint32_t _alive_count)
{
    m_alive_count = _alive_count;
}

/*!
 * @brief This function returns the value of member alive_count
 * @return Value of member alive_count
 */
uint32_t eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::alive_count() const
{
    return m_alive_count;
}

/*!
 * @brief This function returns a reference to member alive_count
 * @return Reference to member alive_count
 */
uint32_t& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::alive_count()
{
    return m_alive_count;
}

/*!
 * @brief This function sets a value in member not_alive_count
 * @param _not_alive_count New value for member not_alive_count
 */
void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::not_alive_count(
        uint32_t _not_alive_count)
{
    m_not_alive_count = _not_alive_count;
}

/*!
 * @brief This function returns the value of member not_alive_count
 * @return Value of member not_alive_count
 */
uint32_t eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::not_alive_count() const
{
    return m_not_alive_count;
}

/*!
 * @brief This function returns a reference to member not_alive_count
 * @return Reference to member not_alive_count
 */
uint32_t& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::not_alive_count()
{
    return m_not_alive_count;
}

/*!
 * @brief This function copies the value in member last_publication_handle
 * @param _last_publication_handle New value to be copied in member last_publication_handle
 */
void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::last_publication_handle(
        const std::array<uint8_t, 16>& _last_publication_handle)
{
    m_last_publication_handle = _last_publication_handle;
}

/*!
 * @brief This function moves the value in member last_publication_handle
 * @param _last_publication_handle New value to be moved in member last_publication_handle
 */
void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::last_publication_handle(
        std::array<uint8_t, 16>&& _last_publication_handle)
{
    m_last_publication_handle = std::move(_last_publication_handle);
}

/*!
 * @brief This function returns a constant reference to member last_publication_handle
 * @return Constant reference to member last_publication_handle
 */
const std::array<uint8_t, 16>& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::last_publication_handle() const
{
    return m_last_publication_handle;
}

/*!
 * @brief This function returns a reference to member last_publication_handle
 * @return Reference to member last_publication_handle
 */
std::array<uint8_t, 16>& eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::last_publication_handle()
{
    return m_last_publication_handle;
}


size_t eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_LivelinessChangedStatus_m_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::DeadlineMissedStatus_m()
{
    // unsigned long m_total_count
    m_total_count = 0;
    // octet m_last_instance_handle
    memset(&m_last_instance_handle, 0, (16) * 1);

}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::~DeadlineMissedStatus_m()
{


}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::DeadlineMissedStatus_m(
        const DeadlineMissedStatus_m& x)
{
    m_total_count = x.m_total_count;
    m_last_instance_handle = x.m_last_instance_handle;
}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::DeadlineMissedStatus_m(
        DeadlineMissedStatus_m&& x) noexcept 
{
    m_total_count = x.m_total_count;
    m_last_instance_handle = std::move(x.m_last_instance_handle);
}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::operator =(
        const DeadlineMissedStatus_m& x)
{

    m_total_count = x.m_total_count;
    m_last_instance_handle = x.m_last_instance_handle;

    return *this;
}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::operator =(
        DeadlineMissedStatus_m&& x) noexcept
{

    m_total_count = x.m_total_count;
    m_last_instance_handle = std::move(x.m_last_instance_handle);

    return *this;
}

bool eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::operator ==(
        const DeadlineMissedStatus_m& x) const
{

    return (m_total_count == x.m_total_count && m_last_instance_handle == x.m_last_instance_handle);
}

bool eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::operator !=(
        const DeadlineMissedStatus_m& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_DeadlineMissedStatus_m_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((16) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_total_count;
    scdr << m_last_instance_handle;


}

void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_total_count;
    dcdr >> m_last_instance_handle;

}

/*!
 * @brief This function sets a value in member total_count
 * @param _total_count New value for member total_count
 */
void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::total_count(
        uint32_t _total_count)
{
    m_total_count = _total_count;
}

/*!
 * @brief This function returns the value of member total_count
 * @return Value of member total_count
 */
uint32_t eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::total_count() const
{
    return m_total_count;
}

/*!
 * @brief This function returns a reference to member total_count
 * @return Reference to member total_count
 */
uint32_t& eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::total_count()
{
    return m_total_count;
}

/*!
 * @brief This function copies the value in member last_instance_handle
 * @param _last_instance_handle New value to be copied in member last_instance_handle
 */
void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::last_instance_handle(
        const std::array<uint8_t, 16>& _last_instance_handle)
{
    m_last_instance_handle = _last_instance_handle;
}

/*!
 * @brief This function moves the value in member last_instance_handle
 * @param _last_instance_handle New value to be moved in member last_instance_handle
 */
void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::last_instance_handle(
        std::array<uint8_t, 16>&& _last_instance_handle)
{
    m_last_instance_handle = std::move(_last_instance_handle);
}

/*!
 * @brief This function returns a constant reference to member last_instance_handle
 * @return Constant reference to member last_instance_handle
 */
const std::array<uint8_t, 16>& eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::last_instance_handle() const
{
    return m_last_instance_handle;
}

/*!
 * @brief This function returns a reference to member last_instance_handle
 * @return Reference to member last_instance_handle
 */
std::array<uint8_t, 16>& eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::last_instance_handle()
{
    return m_last_instance_handle;
}


size_t eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_DeadlineMissedStatus_m_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::isKeyDefined()
{
    return false;
}

void eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}






eprosima::fastrtps::monitor_service::Data::Data()
{
    m__d = eprosima::fastrtps::monitor_service::PROXY;
    // sequence<octet> m_entity_proxy

    // sequence<eprosima::fastrtps::monitor_service::Connection> m_connection_list

    // eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m m_incompatible_qos_status

    // eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m m_inconsistent_topic_status

    // eprosima::fastrtps::monitor_service::LivelinessLostStatus_m m_liveliness_lost_status

    // eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m m_liveliness_changed_status

    // eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m m_deadline_missed_status

    // eprosima::fastrtps::monitor_service::SampleLostStatus_m m_sample_lost_status

}

eprosima::fastrtps::monitor_service::Data::~Data()
{
}

eprosima::fastrtps::monitor_service::Data::Data(
        const Data& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        m_entity_proxy = x.m_entity_proxy;
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        m_connection_list = x.m_connection_list;
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        m_incompatible_qos_status = x.m_incompatible_qos_status;
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        m_inconsistent_topic_status = x.m_inconsistent_topic_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        m_liveliness_lost_status = x.m_liveliness_lost_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        m_liveliness_changed_status = x.m_liveliness_changed_status;
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        m_deadline_missed_status = x.m_deadline_missed_status;
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        m_sample_lost_status = x.m_sample_lost_status;
        break;
        default:
        break;
    }
}

eprosima::fastrtps::monitor_service::Data::Data(
        Data&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        m_entity_proxy = std::move(x.m_entity_proxy);
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        m_connection_list = std::move(x.m_connection_list);
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        m_incompatible_qos_status = std::move(x.m_incompatible_qos_status);
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        m_inconsistent_topic_status = std::move(x.m_inconsistent_topic_status);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        m_liveliness_lost_status = std::move(x.m_liveliness_lost_status);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        m_liveliness_changed_status = std::move(x.m_liveliness_changed_status);
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        m_deadline_missed_status = std::move(x.m_deadline_missed_status);
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        m_sample_lost_status = std::move(x.m_sample_lost_status);
        break;
        default:
        break;
    }
}

eprosima::fastrtps::monitor_service::Data& eprosima::fastrtps::monitor_service::Data::operator =(
        const Data& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        m_entity_proxy = x.m_entity_proxy;
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        m_connection_list = x.m_connection_list;
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        m_incompatible_qos_status = x.m_incompatible_qos_status;
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        m_inconsistent_topic_status = x.m_inconsistent_topic_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        m_liveliness_lost_status = x.m_liveliness_lost_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        m_liveliness_changed_status = x.m_liveliness_changed_status;
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        m_deadline_missed_status = x.m_deadline_missed_status;
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        m_sample_lost_status = x.m_sample_lost_status;
        break;
        default:
        break;
    }

    return *this;
}

eprosima::fastrtps::monitor_service::Data& eprosima::fastrtps::monitor_service::Data::operator =(
        Data&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        m_entity_proxy = std::move(x.m_entity_proxy);
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        m_connection_list = std::move(x.m_connection_list);
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        m_incompatible_qos_status = std::move(x.m_incompatible_qos_status);
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        m_inconsistent_topic_status = std::move(x.m_inconsistent_topic_status);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        m_liveliness_lost_status = std::move(x.m_liveliness_lost_status);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        m_liveliness_changed_status = std::move(x.m_liveliness_changed_status);
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        m_deadline_missed_status = std::move(x.m_deadline_missed_status);
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        m_sample_lost_status = std::move(x.m_sample_lost_status);
        break;
        default:
        break;
    }

    return *this;
}

bool eprosima::fastrtps::monitor_service::Data::operator ==(
        const Data& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
            return (m_entity_proxy == x.m_entity_proxy);
            break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
            return (m_connection_list == x.m_connection_list);
            break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
            return (m_incompatible_qos_status == x.m_incompatible_qos_status);
            break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
            return (m_inconsistent_topic_status == x.m_inconsistent_topic_status);
            break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
            return (m_liveliness_lost_status == x.m_liveliness_lost_status);
            break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
            return (m_liveliness_changed_status == x.m_liveliness_changed_status);
            break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
            return (m_deadline_missed_status == x.m_deadline_missed_status);
            break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
            return (m_sample_lost_status == x.m_sample_lost_status);
            break;
        default:
        break;
    }
    return false;
}

bool eprosima::fastrtps::monitor_service::Data::operator !=(
        const Data& x) const
{
    return !(*this == x);
}

void eprosima::fastrtps::monitor_service::Data::_d(
        eprosima::fastrtps::monitor_service::StatusKind __d)
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::PROXY:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
            b = true;
            break;
            default:
            break;
        }
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        switch(__d)
        {
            case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

eprosima::fastrtps::monitor_service::StatusKind eprosima::fastrtps::monitor_service::Data::_d() const
{
    return m__d;
}

eprosima::fastrtps::monitor_service::StatusKind& eprosima::fastrtps::monitor_service::Data::_d()
{
    return m__d;
}

void eprosima::fastrtps::monitor_service::Data::entity_proxy(
        const std::vector<uint8_t>& _entity_proxy)
{
    m_entity_proxy = _entity_proxy;
    m__d = eprosima::fastrtps::monitor_service::PROXY;
}

void eprosima::fastrtps::monitor_service::Data::entity_proxy(
        std::vector<uint8_t>&& _entity_proxy)
{
    m_entity_proxy = std::move(_entity_proxy);
    m__d = eprosima::fastrtps::monitor_service::PROXY;
}

const std::vector<uint8_t>& eprosima::fastrtps::monitor_service::Data::entity_proxy() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_entity_proxy;
}

std::vector<uint8_t>& eprosima::fastrtps::monitor_service::Data::entity_proxy()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_entity_proxy;
}
void eprosima::fastrtps::monitor_service::Data::connection_list(
        const std::vector<eprosima::fastrtps::monitor_service::Connection>& _connection_list)
{
    m_connection_list = _connection_list;
    m__d = eprosima::fastrtps::monitor_service::CONNECTION_LIST;
}

void eprosima::fastrtps::monitor_service::Data::connection_list(
        std::vector<eprosima::fastrtps::monitor_service::Connection>&& _connection_list)
{
    m_connection_list = std::move(_connection_list);
    m__d = eprosima::fastrtps::monitor_service::CONNECTION_LIST;
}

const std::vector<eprosima::fastrtps::monitor_service::Connection>& eprosima::fastrtps::monitor_service::Data::connection_list() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_connection_list;
}

std::vector<eprosima::fastrtps::monitor_service::Connection>& eprosima::fastrtps::monitor_service::Data::connection_list()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_connection_list;
}
void eprosima::fastrtps::monitor_service::Data::incompatible_qos_status(
        const eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& _incompatible_qos_status)
{
    m_incompatible_qos_status = _incompatible_qos_status;
    m__d = eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS;
}

void eprosima::fastrtps::monitor_service::Data::incompatible_qos_status(
        eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m&& _incompatible_qos_status)
{
    m_incompatible_qos_status = std::move(_incompatible_qos_status);
    m__d = eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS;
}

const eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& eprosima::fastrtps::monitor_service::Data::incompatible_qos_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_incompatible_qos_status;
}

eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m& eprosima::fastrtps::monitor_service::Data::incompatible_qos_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_incompatible_qos_status;
}
void eprosima::fastrtps::monitor_service::Data::inconsistent_topic_status(
        const eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m& _inconsistent_topic_status)
{
    m_inconsistent_topic_status = _inconsistent_topic_status;
    m__d = eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC;
}

void eprosima::fastrtps::monitor_service::Data::inconsistent_topic_status(
        eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m&& _inconsistent_topic_status)
{
    m_inconsistent_topic_status = std::move(_inconsistent_topic_status);
    m__d = eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC;
}

const eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m& eprosima::fastrtps::monitor_service::Data::inconsistent_topic_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_inconsistent_topic_status;
}

eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m& eprosima::fastrtps::monitor_service::Data::inconsistent_topic_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_inconsistent_topic_status;
}
void eprosima::fastrtps::monitor_service::Data::liveliness_lost_status(
        const eprosima::fastrtps::monitor_service::LivelinessLostStatus_m& _liveliness_lost_status)
{
    m_liveliness_lost_status = _liveliness_lost_status;
    m__d = eprosima::fastrtps::monitor_service::LIVELINESS_LOST;
}

void eprosima::fastrtps::monitor_service::Data::liveliness_lost_status(
        eprosima::fastrtps::monitor_service::LivelinessLostStatus_m&& _liveliness_lost_status)
{
    m_liveliness_lost_status = std::move(_liveliness_lost_status);
    m__d = eprosima::fastrtps::monitor_service::LIVELINESS_LOST;
}

const eprosima::fastrtps::monitor_service::LivelinessLostStatus_m& eprosima::fastrtps::monitor_service::Data::liveliness_lost_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_liveliness_lost_status;
}

eprosima::fastrtps::monitor_service::LivelinessLostStatus_m& eprosima::fastrtps::monitor_service::Data::liveliness_lost_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_liveliness_lost_status;
}
void eprosima::fastrtps::monitor_service::Data::liveliness_changed_status(
        const eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& _liveliness_changed_status)
{
    m_liveliness_changed_status = _liveliness_changed_status;
    m__d = eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED;
}

void eprosima::fastrtps::monitor_service::Data::liveliness_changed_status(
        eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m&& _liveliness_changed_status)
{
    m_liveliness_changed_status = std::move(_liveliness_changed_status);
    m__d = eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED;
}

const eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& eprosima::fastrtps::monitor_service::Data::liveliness_changed_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_liveliness_changed_status;
}

eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m& eprosima::fastrtps::monitor_service::Data::liveliness_changed_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_liveliness_changed_status;
}
void eprosima::fastrtps::monitor_service::Data::deadline_missed_status(
        const eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& _deadline_missed_status)
{
    m_deadline_missed_status = _deadline_missed_status;
    m__d = eprosima::fastrtps::monitor_service::DEADLINE_MISSED;
}

void eprosima::fastrtps::monitor_service::Data::deadline_missed_status(
        eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m&& _deadline_missed_status)
{
    m_deadline_missed_status = std::move(_deadline_missed_status);
    m__d = eprosima::fastrtps::monitor_service::DEADLINE_MISSED;
}

const eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& eprosima::fastrtps::monitor_service::Data::deadline_missed_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_deadline_missed_status;
}

eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m& eprosima::fastrtps::monitor_service::Data::deadline_missed_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_deadline_missed_status;
}
void eprosima::fastrtps::monitor_service::Data::sample_lost_status(
        const eprosima::fastrtps::monitor_service::SampleLostStatus_m& _sample_lost_status)
{
    m_sample_lost_status = _sample_lost_status;
    m__d = eprosima::fastrtps::monitor_service::SAMPLE_LOST;
}

void eprosima::fastrtps::monitor_service::Data::sample_lost_status(
        eprosima::fastrtps::monitor_service::SampleLostStatus_m&& _sample_lost_status)
{
    m_sample_lost_status = std::move(_sample_lost_status);
    m__d = eprosima::fastrtps::monitor_service::SAMPLE_LOST;
}

const eprosima::fastrtps::monitor_service::SampleLostStatus_m& eprosima::fastrtps::monitor_service::Data::sample_lost_status() const
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_sample_lost_status;
}

eprosima::fastrtps::monitor_service::SampleLostStatus_m& eprosima::fastrtps::monitor_service::Data::sample_lost_status()
{
    bool b = false;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_sample_lost_status;
}

// TODO(Ricardo) Review
size_t eprosima::fastrtps::monitor_service::Data::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::Data& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        if (data.entity_proxy().size() > 0)
        {
            current_alignment += (data.entity_proxy().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
        }


        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for(size_t a = 0; a < data.connection_list().size(); ++a)
        {
            current_alignment += eprosima::fastrtps::monitor_service::Connection::getCdrSerializedSize(data.connection_list().at(a), current_alignment);}
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        current_alignment += eprosima::fastrtps::monitor_service::IncompatibleQoSStatus_m::getCdrSerializedSize(data.incompatible_qos_status(), current_alignment);
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        current_alignment += eprosima::fastrtps::monitor_service::InconsistentTopicStatus_m::getCdrSerializedSize(data.inconsistent_topic_status(), current_alignment);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        current_alignment += eprosima::fastrtps::monitor_service::LivelinessLostStatus_m::getCdrSerializedSize(data.liveliness_lost_status(), current_alignment);
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        current_alignment += eprosima::fastrtps::monitor_service::LivelinessChangedStatus_m::getCdrSerializedSize(data.liveliness_changed_status(), current_alignment);
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        current_alignment += eprosima::fastrtps::monitor_service::DeadlineMissedStatus_m::getCdrSerializedSize(data.deadline_missed_status(), current_alignment);
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        current_alignment += eprosima::fastrtps::monitor_service::SampleLostStatus_m::getCdrSerializedSize(data.sample_lost_status(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::Data::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << (uint32_t)m__d;

    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        scdr << m_entity_proxy;
        break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        scdr << m_connection_list;
        break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        scdr << m_incompatible_qos_status;

        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        scdr << m_inconsistent_topic_status;

        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        scdr << m_liveliness_lost_status;

        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        scdr << m_liveliness_changed_status;

        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        scdr << m_deadline_missed_status;

        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        scdr << m_sample_lost_status;

        break;
        default:
        break;
    }
}

void eprosima::fastrtps::monitor_service::Data::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m__d = (eprosima::fastrtps::monitor_service::StatusKind)enum_value;
    }


    switch(m__d)
    {
        case eprosima::fastrtps::monitor_service::PROXY:
        dcdr >> m_entity_proxy;break;
        case eprosima::fastrtps::monitor_service::CONNECTION_LIST:
        dcdr >> m_connection_list;break;
        case eprosima::fastrtps::monitor_service::INCOMPATIBLE_QOS:
        dcdr >> m_incompatible_qos_status;
        break;
        case eprosima::fastrtps::monitor_service::INCONSISTENT_TOPIC:
        dcdr >> m_inconsistent_topic_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_LOST:
        dcdr >> m_liveliness_lost_status;
        break;
        case eprosima::fastrtps::monitor_service::LIVELINESS_CHANGED:
        dcdr >> m_liveliness_changed_status;
        break;
        case eprosima::fastrtps::monitor_service::DEADLINE_MISSED:
        dcdr >> m_deadline_missed_status;
        break;
        case eprosima::fastrtps::monitor_service::SAMPLE_LOST:
        dcdr >> m_sample_lost_status;
        break;
        default:
        break;
    }
}


eprosima::fastrtps::monitor_service::MonitorServiceStatusData::MonitorServiceStatusData()
{
    // eprosima::fastrtps::monitor_service::detail::GUID_m m_local_entity

    // eprosima::fastrtps::monitor_service::StatusKind m_status_kind
    m_status_kind = eprosima::fastrtps::monitor_service::PROXY;
    // eprosima::fastrtps::monitor_service::Data m_value


}

eprosima::fastrtps::monitor_service::MonitorServiceStatusData::~MonitorServiceStatusData()
{



}

eprosima::fastrtps::monitor_service::MonitorServiceStatusData::MonitorServiceStatusData(
        const MonitorServiceStatusData& x)
{
    m_local_entity = x.m_local_entity;
    m_status_kind = x.m_status_kind;
    m_value = x.m_value;
}

eprosima::fastrtps::monitor_service::MonitorServiceStatusData::MonitorServiceStatusData(
        MonitorServiceStatusData&& x) noexcept 
{
    m_local_entity = std::move(x.m_local_entity);
    m_status_kind = x.m_status_kind;
    m_value = std::move(x.m_value);
}

eprosima::fastrtps::monitor_service::MonitorServiceStatusData& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::operator =(
        const MonitorServiceStatusData& x)
{

    m_local_entity = x.m_local_entity;
    m_status_kind = x.m_status_kind;
    m_value = x.m_value;

    return *this;
}

eprosima::fastrtps::monitor_service::MonitorServiceStatusData& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::operator =(
        MonitorServiceStatusData&& x) noexcept
{

    m_local_entity = std::move(x.m_local_entity);
    m_status_kind = x.m_status_kind;
    m_value = std::move(x.m_value);

    return *this;
}

bool eprosima::fastrtps::monitor_service::MonitorServiceStatusData::operator ==(
        const MonitorServiceStatusData& x) const
{

    return (m_local_entity == x.m_local_entity && m_status_kind == x.m_status_kind && m_value == x.m_value);
}

bool eprosima::fastrtps::monitor_service::MonitorServiceStatusData::operator !=(
        const MonitorServiceStatusData& x) const
{
    return !(*this == x);
}

size_t eprosima::fastrtps::monitor_service::MonitorServiceStatusData::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_MonitorServiceStatusData_max_cdr_typesize;
}

size_t eprosima::fastrtps::monitor_service::MonitorServiceStatusData::getCdrSerializedSize(
        const eprosima::fastrtps::monitor_service::MonitorServiceStatusData& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += eprosima::fastrtps::monitor_service::detail::GUID_m::getCdrSerializedSize(data.local_entity(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += eprosima::fastrtps::monitor_service::Data::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_local_entity;
    scdr << (uint32_t)m_status_kind;
    scdr << m_value;

}

void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_local_entity;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status_kind = (eprosima::fastrtps::monitor_service::StatusKind)enum_value;
    }

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member local_entity
 * @param _local_entity New value to be copied in member local_entity
 */
void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::local_entity(
        const eprosima::fastrtps::monitor_service::detail::GUID_m& _local_entity)
{
    m_local_entity = _local_entity;
}

/*!
 * @brief This function moves the value in member local_entity
 * @param _local_entity New value to be moved in member local_entity
 */
void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::local_entity(
        eprosima::fastrtps::monitor_service::detail::GUID_m&& _local_entity)
{
    m_local_entity = std::move(_local_entity);
}

/*!
 * @brief This function returns a constant reference to member local_entity
 * @return Constant reference to member local_entity
 */
const eprosima::fastrtps::monitor_service::detail::GUID_m& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::local_entity() const
{
    return m_local_entity;
}

/*!
 * @brief This function returns a reference to member local_entity
 * @return Reference to member local_entity
 */
eprosima::fastrtps::monitor_service::detail::GUID_m& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::local_entity()
{
    return m_local_entity;
}
/*!
 * @brief This function sets a value in member status_kind
 * @param _status_kind New value for member status_kind
 */
void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::status_kind(
        eprosima::fastrtps::monitor_service::StatusKind _status_kind)
{
    m_status_kind = _status_kind;
}

/*!
 * @brief This function returns the value of member status_kind
 * @return Value of member status_kind
 */
eprosima::fastrtps::monitor_service::StatusKind eprosima::fastrtps::monitor_service::MonitorServiceStatusData::status_kind() const
{
    return m_status_kind;
}

/*!
 * @brief This function returns a reference to member status_kind
 * @return Reference to member status_kind
 */
eprosima::fastrtps::monitor_service::StatusKind& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::status_kind()
{
    return m_status_kind;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::value(
        const eprosima::fastrtps::monitor_service::Data& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::value(
        eprosima::fastrtps::monitor_service::Data&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const eprosima::fastrtps::monitor_service::Data& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
eprosima::fastrtps::monitor_service::Data& eprosima::fastrtps::monitor_service::MonitorServiceStatusData::value()
{
    return m_value;
}


size_t eprosima::fastrtps::monitor_service::MonitorServiceStatusData::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return eprosima_fastrtps_monitor_service_MonitorServiceStatusData_max_key_cdr_typesize;
}

bool eprosima::fastrtps::monitor_service::MonitorServiceStatusData::isKeyDefined()
{
    return true;
}

void eprosima::fastrtps::monitor_service::MonitorServiceStatusData::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
   scdr << m_local_entity;
   
  scdr << (uint32_t)m_status_kind;
   
  
}




