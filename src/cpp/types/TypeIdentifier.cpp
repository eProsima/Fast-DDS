// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypeIdentifier.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#include <fastrtps/types/TypeIdentifier.h>

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace eprosima{
namespace fastrtps{

using namespace rtps;

namespace types{

TypeIdentifier::TypeIdentifier()
{
    m__d = 0x00; // Default
    m_string_sdefn = 0;
    m_string_ldefn = 0;
    m_seq_sdefn = 0;
    m_seq_ldefn = 0;
    m_array_sdefn = 0;
    m_array_ldefn = 0;
    m_map_sdefn = 0;
    m_map_ldefn = 0;
    m_sc_component_id = 0;
    m_equivalence_hash = 0;
    m_extended_defn = 0;
}

TypeIdentifier::~TypeIdentifier()
{
}

TypeIdentifier::TypeIdentifier(const TypeIdentifier &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        m_string_sdefn = x.m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        m_string_ldefn = x.m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        m_seq_sdefn = x.m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        m_seq_ldefn = x.m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        m_array_sdefn = x.m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        m_array_ldefn = x.m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        m_map_sdefn = x.m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        m_map_ldefn = x.m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        m_sc_component_id = x.m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        m_equivalence_hash = x.m_equivalence_hash;
        break;
        default:
        m_extended_defn = x.m_extended_defn;
        break;
    }
}

TypeIdentifier::TypeIdentifier(TypeIdentifier &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        m_string_sdefn = x.m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        m_string_ldefn = x.m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        m_seq_sdefn = x.m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        m_seq_ldefn = x.m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        m_array_sdefn = x.m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        m_array_ldefn = x.m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        m_map_sdefn = x.m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        m_map_ldefn = x.m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        m_sc_component_id = x.m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        m_equivalence_hash = x.m_equivalence_hash;
        break;
        default:
        m_extended_defn = x.m_extended_defn;
        break;
    }
}

TypeIdentifier& TypeIdentifier::operator=(const TypeIdentifier &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        m_string_sdefn = x.m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        m_string_ldefn = x.m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        m_seq_sdefn = x.m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        m_seq_ldefn = x.m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        m_array_sdefn = x.m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        m_array_ldefn = x.m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        m_map_sdefn = x.m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        m_map_ldefn = x.m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        m_sc_component_id = x.m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        m_equivalence_hash = x.m_equivalence_hash;
        break;
        default:
        m_extended_defn = x.m_extended_defn;
        break;
    }

    return *this;
}

TypeIdentifier& TypeIdentifier::operator=(TypeIdentifier &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        m_string_sdefn = x.m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        m_string_ldefn = x.m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        m_seq_sdefn = x.m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        m_seq_ldefn = x.m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        m_array_sdefn = x.m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        m_array_ldefn = x.m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        m_map_sdefn = x.m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        m_map_ldefn = x.m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        m_sc_component_id = x.m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        m_equivalence_hash = x.m_equivalence_hash;
        break;
        default:
        m_extended_defn = x.m_extended_defn;
        break;
    }

    return *this;
}

void TypeIdentifier::_d(char __d)
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        switch(__d)
        {
            case TI_STRING8_SMALL:
            case TI_STRING16_SMALL:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        switch(__d)
        {
            case TI_STRING8_LARGE:
            case TI_STRING16_LARGE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        switch(__d)
        {
            case TI_PLAIN_SEQUENCE_SMALL:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        switch(__d)
        {
            case TI_PLAIN_SEQUENCE_LARGE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_ARRAY_SMALL:
        switch(__d)
        {
            case TI_PLAIN_ARRAY_SMALL:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_ARRAY_LARGE:
        switch(__d)
        {
            case TI_PLAIN_ARRAY_LARGE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_MAP_SMALL:
        switch(__d)
        {
            case TI_PLAIN_MAP_SMALL:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_PLAIN_MAP_LARGE:
        switch(__d)
        {
            case TI_PLAIN_MAP_LARGE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        switch(__d)
        {
            case TI_STRONGLY_CONNECTED_COMPONENT:
            b = true;
            break;
            default:
            break;
        }
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        switch(__d)
        {
            case EK_COMPLETE:
            case EK_MINIMAL:
            b = true;
            break;
            default:
            break;
        }
        break;
        default:
        switch(__d)
        {
            case TI_PLAIN_ARRAY_SMALL:
            case TI_PLAIN_SEQUENCE_LARGE:
            case TI_PLAIN_SEQUENCE_SMALL:
            case TI_STRING8_LARGE:
            case TI_STRING16_LARGE:
            case TI_STRING8_SMALL:
            case TI_STRING16_SMALL:
            case TI_PLAIN_ARRAY_LARGE:
            case TI_PLAIN_MAP_SMALL:
            case TI_PLAIN_MAP_LARGE:
            case TI_STRONGLY_CONNECTED_COMPONENT:
            case EK_COMPLETE:
            case EK_MINIMAL:
            break;
            default:
            b = true;
            break;
        }
        break;
    }

    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

char TypeIdentifier::_d() const
{
    return m__d;
}

char& TypeIdentifier::_d()
{
    return m__d;
}

void TypeIdentifier::string_sdefn(StringSTypeDefn _string_sdefn)
{
    m_string_sdefn = _string_sdefn;
    m__d = TI_STRING8_SMALL;
}

StringSTypeDefn TypeIdentifier::string_sdefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_string_sdefn;
}

StringSTypeDefn& TypeIdentifier::string_sdefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_string_sdefn;
}
void TypeIdentifier::string_ldefn(StringLTypeDefn _string_ldefn)
{
    m_string_ldefn = _string_ldefn;
    m__d = TI_STRING8_LARGE;
}

StringLTypeDefn TypeIdentifier::string_ldefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_string_ldefn;
}

StringLTypeDefn& TypeIdentifier::string_ldefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_string_ldefn;
}
void TypeIdentifier::seq_sdefn(PlainSequenceSElemDefn _seq_sdefn)
{
    m_seq_sdefn = _seq_sdefn;
    m__d = TI_PLAIN_SEQUENCE_SMALL;
}

PlainSequenceSElemDefn TypeIdentifier::seq_sdefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_SEQUENCE_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_seq_sdefn;
}

PlainSequenceSElemDefn& TypeIdentifier::seq_sdefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_SEQUENCE_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_seq_sdefn;
}
void TypeIdentifier::seq_ldefn(PlainSequenceLElemDefn _seq_ldefn)
{
    m_seq_ldefn = _seq_ldefn;
    m__d = TI_PLAIN_SEQUENCE_LARGE;
}

PlainSequenceLElemDefn TypeIdentifier::seq_ldefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_SEQUENCE_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_seq_ldefn;
}

PlainSequenceLElemDefn& TypeIdentifier::seq_ldefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_SEQUENCE_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_seq_ldefn;
}
void TypeIdentifier::array_sdefn(PlainArraySElemDefn _array_sdefn)
{
    m_array_sdefn = _array_sdefn;
    m__d = TI_PLAIN_ARRAY_SMALL;
}

PlainArraySElemDefn TypeIdentifier::array_sdefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_array_sdefn;
}

PlainArraySElemDefn& TypeIdentifier::array_sdefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_array_sdefn;
}
void TypeIdentifier::array_ldefn(PlainArrayLElemDefn _array_ldefn)
{
    m_array_ldefn = _array_ldefn;
    m__d = TI_PLAIN_ARRAY_LARGE;
}

PlainArrayLElemDefn TypeIdentifier::array_ldefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_array_ldefn;
}

PlainArrayLElemDefn& TypeIdentifier::array_ldefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_array_ldefn;
}
void TypeIdentifier::map_sdefn(PlainMapSTypeDefn _map_sdefn)
{
    m_map_sdefn = _map_sdefn;
    m__d = TI_PLAIN_MAP_SMALL;
}

PlainMapSTypeDefn TypeIdentifier::map_sdefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_MAP_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_map_sdefn;
}

PlainMapSTypeDefn& TypeIdentifier::map_sdefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_MAP_SMALL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_map_sdefn;
}
void TypeIdentifier::map_ldefn(PlainMapLTypeDefn _map_ldefn)
{
    m_map_ldefn = _map_ldefn;
    m__d = TI_PLAIN_MAP_LARGE;
}

PlainMapLTypeDefn TypeIdentifier::map_ldefn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_MAP_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_map_ldefn;
}

PlainMapLTypeDefn& TypeIdentifier::map_ldefn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_MAP_LARGE:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_map_ldefn;
}
void TypeIdentifier::sc_component_id(StronglyConnectedComponentId _sc_component_id)
{
    m_sc_component_id = _sc_component_id;
    m__d = TI_STRONGLY_CONNECTED_COMPONENT;
}

StronglyConnectedComponentId TypeIdentifier::sc_component_id() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRONGLY_CONNECTED_COMPONENT:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_sc_component_id;
}

StronglyConnectedComponentId& TypeIdentifier::sc_component_id()
{
    bool b = false;

    switch(m__d)
    {
        case TI_STRONGLY_CONNECTED_COMPONENT:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_sc_component_id;
}
void TypeIdentifier::equivalence_hash(EquivalenceHash _equivalence_hash)
{
    m_equivalence_hash = _equivalence_hash;
    m__d = EK_COMPLETE;
}

EquivalenceHash TypeIdentifier::equivalence_hash() const
{
    bool b = false;

    switch(m__d)
    {
        case EK_COMPLETE:
        case EK_MINIMAL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_equivalence_hash;
}

EquivalenceHash& TypeIdentifier::equivalence_hash()
{
    bool b = false;

    switch(m__d)
    {
        case EK_COMPLETE:
        case EK_MINIMAL:
        b = true;
        break;
        default:
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_equivalence_hash;
}

void TypeIdentifier::extended_defn(ExtendedTypeDefn _extended_defn)
{
    m_extended_defn = _extended_defn;
    m__d = 0x00; // Default
}

ExtendedTypeDefn TypeIdentifier::extended_defn() const
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_SMALL:
        case TI_PLAIN_SEQUENCE_LARGE:
        case TI_PLAIN_SEQUENCE_SMALL:
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        case TI_PLAIN_ARRAY_LARGE:
        case TI_PLAIN_MAP_SMALL:
        case TI_PLAIN_MAP_LARGE:
        case TI_STRONGLY_CONNECTED_COMPONENT:
        case EK_COMPLETE:
        case EK_MINIMAL:
        break;
        default:
        b = true;
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_equivalence_hash;
}

ExtendedTypeDefn& TypeIdentifier::extended_defn()
{
    bool b = false;

    switch(m__d)
    {
        case TI_PLAIN_ARRAY_SMALL:
        case TI_PLAIN_SEQUENCE_LARGE:
        case TI_PLAIN_SEQUENCE_SMALL:
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        case TI_PLAIN_ARRAY_LARGE:
        case TI_PLAIN_MAP_SMALL:
        case TI_PLAIN_MAP_LARGE:
        case TI_STRONGLY_CONNECTED_COMPONENT:
        case EK_COMPLETE:
        case EK_MINIMAL:
        break;
        default:
        b = true;
        break;
    }
    if(!b) throw BadParamException("This member is not been selected");

    return m_equivalence_hash;
}

size_t TypeIdentifier::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;



    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t TypeIdentifier::getCdrSerializedSize(const TypeIdentifier& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_ARRAY_SMALL:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_ARRAY_LARGE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_MAP_SMALL:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_PLAIN_MAP_LARGE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
        break;
    }

    return current_alignment - initial_alignment;
}

void TypeIdentifier::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        scdr << m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        scdr << m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        scdr << m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        scdr << m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        scdr << m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        scdr << m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        scdr << m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        scdr << m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        scdr << m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        scdr << m_equivalence_hash;
        break;
        default:
        scdr << m_extended_defn;
        break;
    }
}

void TypeIdentifier::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case TI_STRING8_SMALL:
        case TI_STRING16_SMALL:
        dcdr >> m_string_sdefn;
        break;
        case TI_STRING8_LARGE:
        case TI_STRING16_LARGE:
        dcdr >> m_string_ldefn;
        break;
        case TI_PLAIN_SEQUENCE_SMALL:
        dcdr >> m_seq_sdefn;
        break;
        case TI_PLAIN_SEQUENCE_LARGE:
        dcdr >> m_seq_ldefn;
        break;
        case TI_PLAIN_ARRAY_SMALL:
        dcdr >> m_array_sdefn;
        break;
        case TI_PLAIN_ARRAY_LARGE:
        dcdr >> m_array_ldefn;
        break;
        case TI_PLAIN_MAP_SMALL:
        dcdr >> m_map_sdefn;
        break;
        case TI_PLAIN_MAP_LARGE:
        dcdr >> m_map_ldefn;
        break;
        case TI_STRONGLY_CONNECTED_COMPONENT:
        dcdr >> m_sc_component_id;
        break;
        case EK_COMPLETE:
        case EK_MINIMAL:
        dcdr >> m_equivalence_hash;
        break;
        default:
        dcdr >> m_extended_defn;
        break;
    }
}


} // namespace types
} // namespace fastrtps
} // namespace eprosima