// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file core_typesPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include "core_typesPubSubTypes.hpp"

#include <fastdds/dds/log/Log.hpp>
#include <fastdds/rtps/common/CdrSerialization.hpp>

#include "core_typesCdrAux.hpp"
#include "core_typesTypeObjectSupport.hpp"

using SerializedPayload_t = eprosima::fastdds::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastdds::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

namespace eprosima {
    namespace fastdds {
        namespace rtps {
            namespace core {
                namespace detail {
                    EntityId_tPubSubType::EntityId_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::EntityId_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(EntityId_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_EntityId_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_EntityId_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_EntityId_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    EntityId_tPubSubType::~EntityId_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool EntityId_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const EntityId_t* p_type = static_cast<const EntityId_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool EntityId_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            EntityId_t* p_type = static_cast<EntityId_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> EntityId_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<EntityId_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const EntityId_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* EntityId_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new EntityId_t());
                    }

                    void EntityId_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<EntityId_t*>(data));
                    }

                    bool EntityId_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const EntityId_t* p_type = static_cast<const EntityId_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_EntityId_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_EntityId_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void EntityId_tPubSubType::register_type_object_representation()
                    {
                        register_EntityId_t_type_identifier(type_identifiers_);
                    }

                    ProtocolVersion_tPubSubType::ProtocolVersion_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::ProtocolVersion_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(ProtocolVersion_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_ProtocolVersion_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_ProtocolVersion_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_ProtocolVersion_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    ProtocolVersion_tPubSubType::~ProtocolVersion_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool ProtocolVersion_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const ProtocolVersion_t* p_type = static_cast<const ProtocolVersion_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool ProtocolVersion_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            ProtocolVersion_t* p_type = static_cast<ProtocolVersion_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> ProtocolVersion_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ProtocolVersion_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const ProtocolVersion_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* ProtocolVersion_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new ProtocolVersion_t());
                    }

                    void ProtocolVersion_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<ProtocolVersion_t*>(data));
                    }

                    bool ProtocolVersion_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const ProtocolVersion_t* p_type = static_cast<const ProtocolVersion_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_ProtocolVersion_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_ProtocolVersion_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void ProtocolVersion_tPubSubType::register_type_object_representation()
                    {
                        register_ProtocolVersion_t_type_identifier(type_identifiers_);
                    }

                    VendorId_tPubSubType::VendorId_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::VendorId_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(VendorId_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_VendorId_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_VendorId_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_VendorId_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    VendorId_tPubSubType::~VendorId_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool VendorId_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const VendorId_t* p_type = static_cast<const VendorId_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool VendorId_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            VendorId_t* p_type = static_cast<VendorId_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> VendorId_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<VendorId_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const VendorId_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* VendorId_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new VendorId_t());
                    }

                    void VendorId_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<VendorId_t*>(data));
                    }

                    bool VendorId_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const VendorId_t* p_type = static_cast<const VendorId_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_VendorId_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_VendorId_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void VendorId_tPubSubType::register_type_object_representation()
                    {
                        register_VendorId_t_type_identifier(type_identifiers_);
                    }

                    GuidPrefix_tPubSubType::GuidPrefix_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::GuidPrefix_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(GuidPrefix_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_GuidPrefix_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_GuidPrefix_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_GuidPrefix_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    GuidPrefix_tPubSubType::~GuidPrefix_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool GuidPrefix_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const GuidPrefix_t* p_type = static_cast<const GuidPrefix_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool GuidPrefix_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            GuidPrefix_t* p_type = static_cast<GuidPrefix_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> GuidPrefix_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GuidPrefix_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const GuidPrefix_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* GuidPrefix_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new GuidPrefix_t());
                    }

                    void GuidPrefix_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<GuidPrefix_t*>(data));
                    }

                    bool GuidPrefix_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const GuidPrefix_t* p_type = static_cast<const GuidPrefix_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_GuidPrefix_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_GuidPrefix_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void GuidPrefix_tPubSubType::register_type_object_representation()
                    {
                        register_GuidPrefix_t_type_identifier(type_identifiers_);
                    }

                    GUID_tPubSubType::GUID_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::GUID_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(GUID_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_GUID_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_GUID_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_GUID_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    GUID_tPubSubType::~GUID_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool GUID_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const GUID_t* p_type = static_cast<const GUID_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool GUID_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            GUID_t* p_type = static_cast<GUID_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> GUID_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GUID_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const GUID_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* GUID_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new GUID_t());
                    }

                    void GUID_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<GUID_t*>(data));
                    }

                    bool GUID_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const GUID_t* p_type = static_cast<const GUID_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_GUID_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_GUID_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void GUID_tPubSubType::register_type_object_representation()
                    {
                        register_GUID_t_type_identifier(type_identifiers_);
                    }

                    SequenceNumber_tPubSubType::SequenceNumber_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::SequenceNumber_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(SequenceNumber_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_SequenceNumber_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_SequenceNumber_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_SequenceNumber_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    SequenceNumber_tPubSubType::~SequenceNumber_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool SequenceNumber_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const SequenceNumber_t* p_type = static_cast<const SequenceNumber_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool SequenceNumber_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            SequenceNumber_t* p_type = static_cast<SequenceNumber_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> SequenceNumber_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<SequenceNumber_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const SequenceNumber_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* SequenceNumber_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new SequenceNumber_t());
                    }

                    void SequenceNumber_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<SequenceNumber_t*>(data));
                    }

                    bool SequenceNumber_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const SequenceNumber_t* p_type = static_cast<const SequenceNumber_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_SequenceNumber_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_SequenceNumber_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void SequenceNumber_tPubSubType::register_type_object_representation()
                    {
                        register_SequenceNumber_t_type_identifier(type_identifiers_);
                    }

                    Count_tPubSubType::Count_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::Count_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(Count_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_Count_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_Count_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_Count_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    Count_tPubSubType::~Count_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool Count_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const Count_t* p_type = static_cast<const Count_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool Count_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            Count_t* p_type = static_cast<Count_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> Count_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Count_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const Count_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* Count_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new Count_t());
                    }

                    void Count_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<Count_t*>(data));
                    }

                    bool Count_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const Count_t* p_type = static_cast<const Count_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_Count_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_Count_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void Count_tPubSubType::register_type_object_representation()
                    {
                        register_Count_t_type_identifier(type_identifiers_);
                    }

                    Time_tPubSubType::Time_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::Time_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(Time_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_Time_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_Time_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_Time_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    Time_tPubSubType::~Time_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool Time_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const Time_t* p_type = static_cast<const Time_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool Time_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            Time_t* p_type = static_cast<Time_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> Time_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Time_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const Time_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* Time_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new Time_t());
                    }

                    void Time_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<Time_t*>(data));
                    }

                    bool Time_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const Time_t* p_type = static_cast<const Time_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_Time_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_Time_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void Time_tPubSubType::register_type_object_representation()
                    {
                        register_Time_t_type_identifier(type_identifiers_);
                    }


                    SequenceNumberSetPubSubType::SequenceNumberSetPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::SequenceNumberSet");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(SequenceNumberSet::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_SequenceNumberSet_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_SequenceNumberSet_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_SequenceNumberSet_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    SequenceNumberSetPubSubType::~SequenceNumberSetPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool SequenceNumberSetPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const SequenceNumberSet* p_type = static_cast<const SequenceNumberSet*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool SequenceNumberSetPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            SequenceNumberSet* p_type = static_cast<SequenceNumberSet*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> SequenceNumberSetPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<SequenceNumberSet*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const SequenceNumberSet*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* SequenceNumberSetPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new SequenceNumberSet());
                    }

                    void SequenceNumberSetPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<SequenceNumberSet*>(data));
                    }

                    bool SequenceNumberSetPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const SequenceNumberSet* p_type = static_cast<const SequenceNumberSet*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_SequenceNumberSet_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_SequenceNumberSet_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void SequenceNumberSetPubSubType::register_type_object_representation()
                    {
                        register_SequenceNumberSet_type_identifier(type_identifiers_);
                    }

                    Locator_tPubSubType::Locator_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::Locator_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(Locator_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_Locator_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_Locator_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_Locator_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    Locator_tPubSubType::~Locator_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool Locator_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const Locator_t* p_type = static_cast<const Locator_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool Locator_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            Locator_t* p_type = static_cast<Locator_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> Locator_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Locator_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const Locator_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* Locator_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new Locator_t());
                    }

                    void Locator_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<Locator_t*>(data));
                    }

                    bool Locator_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const Locator_t* p_type = static_cast<const Locator_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_Locator_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_Locator_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void Locator_tPubSubType::register_type_object_representation()
                    {
                        register_Locator_t_type_identifier(type_identifiers_);
                    }

                    Duration_tPubSubType::Duration_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::Duration_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(Duration_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_Duration_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_Duration_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_Duration_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    Duration_tPubSubType::~Duration_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool Duration_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const Duration_t* p_type = static_cast<const Duration_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool Duration_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            Duration_t* p_type = static_cast<Duration_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> Duration_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Duration_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const Duration_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* Duration_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new Duration_t());
                    }

                    void Duration_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<Duration_t*>(data));
                    }

                    bool Duration_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const Duration_t* p_type = static_cast<const Duration_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_Duration_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_Duration_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void Duration_tPubSubType::register_type_object_representation()
                    {
                        register_Duration_t_type_identifier(type_identifiers_);
                    }



                    StatusInfo_tPubSubType::StatusInfo_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::StatusInfo_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(StatusInfo_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_StatusInfo_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_StatusInfo_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_StatusInfo_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    StatusInfo_tPubSubType::~StatusInfo_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool StatusInfo_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const StatusInfo_t* p_type = static_cast<const StatusInfo_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool StatusInfo_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            StatusInfo_t* p_type = static_cast<StatusInfo_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> StatusInfo_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<StatusInfo_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const StatusInfo_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* StatusInfo_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new StatusInfo_t());
                    }

                    void StatusInfo_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<StatusInfo_t*>(data));
                    }

                    bool StatusInfo_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const StatusInfo_t* p_type = static_cast<const StatusInfo_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_StatusInfo_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_StatusInfo_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void StatusInfo_tPubSubType::register_type_object_representation()
                    {
                        register_StatusInfo_t_type_identifier(type_identifiers_);
                    }

                    KeyHash_tPubSubType::KeyHash_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::KeyHash_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(KeyHash_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_KeyHash_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_KeyHash_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_KeyHash_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    KeyHash_tPubSubType::~KeyHash_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool KeyHash_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const KeyHash_t* p_type = static_cast<const KeyHash_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool KeyHash_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            KeyHash_t* p_type = static_cast<KeyHash_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> KeyHash_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<KeyHash_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const KeyHash_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* KeyHash_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new KeyHash_t());
                    }

                    void KeyHash_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<KeyHash_t*>(data));
                    }

                    bool KeyHash_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const KeyHash_t* p_type = static_cast<const KeyHash_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_KeyHash_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_KeyHash_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void KeyHash_tPubSubType::register_type_object_representation()
                    {
                        register_KeyHash_t_type_identifier(type_identifiers_);
                    }

                    EntityName_tPubSubType::EntityName_tPubSubType()
                    {
                        setName("eprosima::fastdds::rtps::core::detail::EntityName_t");
                        uint32_t type_size =
                    #if FASTCDR_VERSION_MAJOR == 1
                            static_cast<uint32_t>(EntityName_t::getMaxCdrSerializedSize());
                    #else
                            eprosima_fastdds_rtps_core_detail_EntityName_t_max_cdr_typesize;
                    #endif
                        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                        m_typeSize = type_size + 4; /*encapsulation*/
                        m_isGetKeyDefined = false;
                        uint32_t keyLength = eprosima_fastdds_rtps_core_detail_EntityName_t_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_detail_EntityName_t_max_key_cdr_typesize : 16;
                        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                        memset(m_keyBuffer, 0, keyLength);
                    }

                    EntityName_tPubSubType::~EntityName_tPubSubType()
                    {
                        if (m_keyBuffer != nullptr)
                        {
                            free(m_keyBuffer);
                        }
                    }

                    bool EntityName_tPubSubType::serialize(
                            const void* const data,
                            SerializedPayload_t* payload,
                            DataRepresentationId_t data_representation)
                    {
                        const EntityName_t* p_type = static_cast<const EntityName_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    #if FASTCDR_VERSION_MAJOR > 1
                        ser.set_encoding_flag(
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                    #endif // FASTCDR_VERSION_MAJOR > 1

                        try
                        {
                            // Serialize encapsulation
                            ser.serialize_encapsulation();
                            // Serialize the object.
                            ser << *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        // Get the serialized length
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                    #else
                        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        return true;
                    }

                    bool EntityName_tPubSubType::deserialize(
                            SerializedPayload_t* payload,
                            void* data)
                    {
                        try
                        {
                            // Convert DATA to pointer of your type
                            EntityName_t* p_type = static_cast<EntityName_t*>(data);

                            // Object that manages the raw buffer.
                            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                            // Object that deserializes the data.
                            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                    #if FASTCDR_VERSION_MAJOR == 1
                                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                    #endif // FASTCDR_VERSION_MAJOR == 1
                                    );

                            // Deserialize encapsulation.
                            deser.read_encapsulation();
                            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                            // Deserialize the object.
                            deser >> *p_type;
                        }
                        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                        {
                            return false;
                        }

                        return true;
                    }

                    std::function<uint32_t()> EntityName_tPubSubType::getSerializedSizeProvider(
                            const void* const data,
                            DataRepresentationId_t data_representation)
                    {
                        return [data, data_representation]() -> uint32_t
                               {
                    #if FASTCDR_VERSION_MAJOR == 1
                                   static_cast<void>(data_representation);
                                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<EntityName_t*>(data))) +
                                          4u /*encapsulation*/;
                    #else
                                   try
                                   {
                                       eprosima::fastcdr::CdrSizeCalculator calculator(
                                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                       size_t current_alignment {0};
                                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                                   *static_cast<const EntityName_t*>(data), current_alignment)) +
                                               4u /*encapsulation*/;
                                   }
                                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                                   {
                                       return 0;
                                   }
                    #endif // FASTCDR_VERSION_MAJOR == 1
                               };
                    }

                    void* EntityName_tPubSubType::createData()
                    {
                        return reinterpret_cast<void*>(new EntityName_t());
                    }

                    void EntityName_tPubSubType::deleteData(
                            void* data)
                    {
                        delete(reinterpret_cast<EntityName_t*>(data));
                    }

                    bool EntityName_tPubSubType::getKey(
                            const void* const data,
                            InstanceHandle_t* handle,
                            bool force_md5)
                    {
                        if (!m_isGetKeyDefined)
                        {
                            return false;
                        }

                        const EntityName_t* p_type = static_cast<const EntityName_t*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                                eprosima_fastdds_rtps_core_detail_EntityName_t_max_key_cdr_typesize);

                        // Object that serializes the data.
                        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                    #if FASTCDR_VERSION_MAJOR == 1
                        p_type->serializeKey(ser);
                    #else
                        eprosima::fastcdr::serialize_key(ser, *p_type);
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        if (force_md5 || eprosima_fastdds_rtps_core_detail_EntityName_t_max_key_cdr_typesize > 16)
                        {
                            m_md5.init();
                    #if FASTCDR_VERSION_MAJOR == 1
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    #else
                            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                    #endif // FASTCDR_VERSION_MAJOR == 1
                            m_md5.finalize();
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_md5.digest[i];
                            }
                        }
                        else
                        {
                            for (uint8_t i = 0; i < 16; ++i)
                            {
                                handle->value[i] = m_keyBuffer[i];
                            }
                        }
                        return true;
                    }

                    void EntityName_tPubSubType::register_type_object_representation()
                    {
                        register_EntityName_t_type_identifier(type_identifiers_);
                    }

                } // namespace detail

                HeaderPubSubType::HeaderPubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::Header");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(Header::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_Header_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_Header_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_Header_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                HeaderPubSubType::~HeaderPubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool HeaderPubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const Header* p_type = static_cast<const Header*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool HeaderPubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        Header* p_type = static_cast<Header*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HeaderPubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Header*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const Header*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* HeaderPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new Header());
                }

                void HeaderPubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<Header*>(data));
                }

                bool HeaderPubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const Header* p_type = static_cast<const Header*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_Header_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_Header_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void HeaderPubSubType::register_type_object_representation()
                {
                    register_Header_type_identifier(type_identifiers_);
                }

                SubmessageHeaderPubSubType::SubmessageHeaderPubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::SubmessageHeader");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(SubmessageHeader::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_SubmessageHeader_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_SubmessageHeader_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_SubmessageHeader_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                SubmessageHeaderPubSubType::~SubmessageHeaderPubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool SubmessageHeaderPubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const SubmessageHeader* p_type = static_cast<const SubmessageHeader*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool SubmessageHeaderPubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        SubmessageHeader* p_type = static_cast<SubmessageHeader*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> SubmessageHeaderPubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<SubmessageHeader*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const SubmessageHeader*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* SubmessageHeaderPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new SubmessageHeader());
                }

                void SubmessageHeaderPubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<SubmessageHeader*>(data));
                }

                bool SubmessageHeaderPubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const SubmessageHeader* p_type = static_cast<const SubmessageHeader*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_SubmessageHeader_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_SubmessageHeader_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void SubmessageHeaderPubSubType::register_type_object_representation()
                {
                    register_SubmessageHeader_type_identifier(type_identifiers_);
                }

                namespace SubmessageKind {
                } // namespace SubmessageKind

                AckNackSubmessagePubSubType::AckNackSubmessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::AckNackSubmessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(AckNackSubmessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_AckNackSubmessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_AckNackSubmessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_AckNackSubmessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                AckNackSubmessagePubSubType::~AckNackSubmessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool AckNackSubmessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const AckNackSubmessage* p_type = static_cast<const AckNackSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool AckNackSubmessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        AckNackSubmessage* p_type = static_cast<AckNackSubmessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> AckNackSubmessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<AckNackSubmessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const AckNackSubmessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* AckNackSubmessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new AckNackSubmessage());
                }

                void AckNackSubmessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<AckNackSubmessage*>(data));
                }

                bool AckNackSubmessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const AckNackSubmessage* p_type = static_cast<const AckNackSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_AckNackSubmessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_AckNackSubmessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void AckNackSubmessagePubSubType::register_type_object_representation()
                {
                    register_AckNackSubmessage_type_identifier(type_identifiers_);
                }

                HeartBeatSubmessagePubSubType::HeartBeatSubmessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::HeartBeatSubmessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(HeartBeatSubmessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_HeartBeatSubmessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_HeartBeatSubmessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_HeartBeatSubmessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                HeartBeatSubmessagePubSubType::~HeartBeatSubmessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool HeartBeatSubmessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const HeartBeatSubmessage* p_type = static_cast<const HeartBeatSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool HeartBeatSubmessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        HeartBeatSubmessage* p_type = static_cast<HeartBeatSubmessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HeartBeatSubmessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<HeartBeatSubmessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const HeartBeatSubmessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* HeartBeatSubmessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new HeartBeatSubmessage());
                }

                void HeartBeatSubmessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<HeartBeatSubmessage*>(data));
                }

                bool HeartBeatSubmessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const HeartBeatSubmessage* p_type = static_cast<const HeartBeatSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_HeartBeatSubmessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_HeartBeatSubmessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void HeartBeatSubmessagePubSubType::register_type_object_representation()
                {
                    register_HeartBeatSubmessage_type_identifier(type_identifiers_);
                }

                InfoDestinationSubmessagePubSubType::InfoDestinationSubmessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::InfoDestinationSubmessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(InfoDestinationSubmessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_InfoDestinationSubmessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_InfoDestinationSubmessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_InfoDestinationSubmessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                InfoDestinationSubmessagePubSubType::~InfoDestinationSubmessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool InfoDestinationSubmessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const InfoDestinationSubmessage* p_type = static_cast<const InfoDestinationSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool InfoDestinationSubmessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        InfoDestinationSubmessage* p_type = static_cast<InfoDestinationSubmessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> InfoDestinationSubmessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<InfoDestinationSubmessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const InfoDestinationSubmessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* InfoDestinationSubmessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new InfoDestinationSubmessage());
                }

                void InfoDestinationSubmessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<InfoDestinationSubmessage*>(data));
                }

                bool InfoDestinationSubmessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const InfoDestinationSubmessage* p_type = static_cast<const InfoDestinationSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_InfoDestinationSubmessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_InfoDestinationSubmessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void InfoDestinationSubmessagePubSubType::register_type_object_representation()
                {
                    register_InfoDestinationSubmessage_type_identifier(type_identifiers_);
                }

                InfoSourceSubmessagePubSubType::InfoSourceSubmessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::InfoSourceSubmessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(InfoSourceSubmessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_InfoSourceSubmessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_InfoSourceSubmessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_InfoSourceSubmessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                InfoSourceSubmessagePubSubType::~InfoSourceSubmessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool InfoSourceSubmessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const InfoSourceSubmessage* p_type = static_cast<const InfoSourceSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool InfoSourceSubmessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        InfoSourceSubmessage* p_type = static_cast<InfoSourceSubmessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> InfoSourceSubmessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<InfoSourceSubmessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const InfoSourceSubmessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* InfoSourceSubmessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new InfoSourceSubmessage());
                }

                void InfoSourceSubmessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<InfoSourceSubmessage*>(data));
                }

                bool InfoSourceSubmessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const InfoSourceSubmessage* p_type = static_cast<const InfoSourceSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_InfoSourceSubmessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_InfoSourceSubmessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void InfoSourceSubmessagePubSubType::register_type_object_representation()
                {
                    register_InfoSourceSubmessage_type_identifier(type_identifiers_);
                }

                InfoTimestampSubmessagePubSubType::InfoTimestampSubmessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::InfoTimestampSubmessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(InfoTimestampSubmessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_InfoTimestampSubmessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_InfoTimestampSubmessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_InfoTimestampSubmessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                InfoTimestampSubmessagePubSubType::~InfoTimestampSubmessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool InfoTimestampSubmessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const InfoTimestampSubmessage* p_type = static_cast<const InfoTimestampSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool InfoTimestampSubmessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        InfoTimestampSubmessage* p_type = static_cast<InfoTimestampSubmessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> InfoTimestampSubmessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<InfoTimestampSubmessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const InfoTimestampSubmessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* InfoTimestampSubmessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new InfoTimestampSubmessage());
                }

                void InfoTimestampSubmessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<InfoTimestampSubmessage*>(data));
                }

                bool InfoTimestampSubmessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const InfoTimestampSubmessage* p_type = static_cast<const InfoTimestampSubmessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_InfoTimestampSubmessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_InfoTimestampSubmessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void InfoTimestampSubmessagePubSubType::register_type_object_representation()
                {
                    register_InfoTimestampSubmessage_type_identifier(type_identifiers_);
                }


                RTPSMessagePubSubType::RTPSMessagePubSubType()
                {
                    setName("eprosima::fastdds::rtps::core::RTPSMessage");
                    uint32_t type_size =
                #if FASTCDR_VERSION_MAJOR == 1
                        static_cast<uint32_t>(RTPSMessage::getMaxCdrSerializedSize());
                #else
                        eprosima_fastdds_rtps_core_RTPSMessage_max_cdr_typesize;
                #endif
                    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
                    m_typeSize = type_size + 4; /*encapsulation*/
                    m_isGetKeyDefined = false;
                    uint32_t keyLength = eprosima_fastdds_rtps_core_RTPSMessage_max_key_cdr_typesize > 16 ? eprosima_fastdds_rtps_core_RTPSMessage_max_key_cdr_typesize : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                RTPSMessagePubSubType::~RTPSMessagePubSubType()
                {
                    if (m_keyBuffer != nullptr)
                    {
                        free(m_keyBuffer);
                    }
                }

                bool RTPSMessagePubSubType::serialize(
                        const void* const data,
                        SerializedPayload_t* payload,
                        DataRepresentationId_t data_representation)
                {
                    const RTPSMessage* p_type = static_cast<const RTPSMessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                #if FASTCDR_VERSION_MAJOR > 1
                    ser.set_encoding_flag(
                        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
                        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
                #endif // FASTCDR_VERSION_MAJOR > 1

                    try
                    {
                        // Serialize encapsulation
                        ser.serialize_encapsulation();
                        // Serialize the object.
                        ser << *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    // Get the serialized length
                #if FASTCDR_VERSION_MAJOR == 1
                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
                #else
                    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
                #endif // FASTCDR_VERSION_MAJOR == 1
                    return true;
                }

                bool RTPSMessagePubSubType::deserialize(
                        SerializedPayload_t* payload,
                        void* data)
                {
                    try
                    {
                        // Convert DATA to pointer of your type
                        RTPSMessage* p_type = static_cast<RTPSMessage*>(data);

                        // Object that manages the raw buffer.
                        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

                        // Object that deserializes the data.
                        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
                #if FASTCDR_VERSION_MAJOR == 1
                                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
                #endif // FASTCDR_VERSION_MAJOR == 1
                                );

                        // Deserialize encapsulation.
                        deser.read_encapsulation();
                        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        // Deserialize the object.
                        deser >> *p_type;
                    }
                    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> RTPSMessagePubSubType::getSerializedSizeProvider(
                        const void* const data,
                        DataRepresentationId_t data_representation)
                {
                    return [data, data_representation]() -> uint32_t
                           {
                #if FASTCDR_VERSION_MAJOR == 1
                               static_cast<void>(data_representation);
                               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<RTPSMessage*>(data))) +
                                      4u /*encapsulation*/;
                #else
                               try
                               {
                                   eprosima::fastcdr::CdrSizeCalculator calculator(
                                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                                   size_t current_alignment {0};
                                   return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                               *static_cast<const RTPSMessage*>(data), current_alignment)) +
                                           4u /*encapsulation*/;
                               }
                               catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                               {
                                   return 0;
                               }
                #endif // FASTCDR_VERSION_MAJOR == 1
                           };
                }

                void* RTPSMessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new RTPSMessage());
                }

                void RTPSMessagePubSubType::deleteData(
                        void* data)
                {
                    delete(reinterpret_cast<RTPSMessage*>(data));
                }

                bool RTPSMessagePubSubType::getKey(
                        const void* const data,
                        InstanceHandle_t* handle,
                        bool force_md5)
                {
                    if (!m_isGetKeyDefined)
                    {
                        return false;
                    }

                    const RTPSMessage* p_type = static_cast<const RTPSMessage*>(data);

                    // Object that manages the raw buffer.
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                            eprosima_fastdds_rtps_core_RTPSMessage_max_key_cdr_typesize);

                    // Object that serializes the data.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
                #if FASTCDR_VERSION_MAJOR == 1
                    p_type->serializeKey(ser);
                #else
                    eprosima::fastcdr::serialize_key(ser, *p_type);
                #endif // FASTCDR_VERSION_MAJOR == 1
                    if (force_md5 || eprosima_fastdds_rtps_core_RTPSMessage_max_key_cdr_typesize > 16)
                    {
                        m_md5.init();
                #if FASTCDR_VERSION_MAJOR == 1
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                #else
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
                #endif // FASTCDR_VERSION_MAJOR == 1
                        m_md5.finalize();
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else
                    {
                        for (uint8_t i = 0; i < 16; ++i)
                        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                void RTPSMessagePubSubType::register_type_object_representation()
                {
                    register_RTPSMessage_type_identifier(type_identifiers_);
                }

            } // namespace core

        } // namespace rtps

    } // namespace fastdds

} // namespace eprosima


// Include auxiliary functions like for serializing/deserializing.
#include "core_typesCdrAux.ipp"
