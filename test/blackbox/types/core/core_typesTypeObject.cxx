// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file core_typesTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "core_types.h"
#include "core_typesTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastdds/rtps/common/CdrSerialization.hpp>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>

using namespace eprosima::fastdds::rtps;

void registercore_typesTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::EntityId_t", eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetEntityId_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::EntityId_t", eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetEntityId_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::ProtocolVersion_t", eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::ProtocolVersion_t", eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::VendorId_t", eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetVendorId_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::VendorId_t", eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetVendorId_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::GuidPrefix_t", eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::GuidPrefix_t", eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::GUID_t", eprosima::fastdds::rtps::core::detail::GetGUID_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetGUID_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::GUID_t", eprosima::fastdds::rtps::core::detail::GetGUID_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetGUID_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::SequenceNumber_t", eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::SequenceNumber_t", eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Count_t", eprosima::fastdds::rtps::core::detail::GetCount_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetCount_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Count_t", eprosima::fastdds::rtps::core::detail::GetCount_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetCount_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Time_t", eprosima::fastdds::rtps::core::detail::GetTime_tIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetTime_tObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Time_t", eprosima::fastdds::rtps::core::detail::GetTime_tIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetTime_tObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Timestamp", eprosima::fastdds::rtps::core::detail::GetTimestampIdentifier(true),
                        eprosima::fastdds::rtps::core::detail::GetTimestampObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::detail::Timestamp", eprosima::fastdds::rtps::core::detail::GetTimestampIdentifier(false),
                        eprosima::fastdds::rtps::core::detail::GetTimestampObject(false));



                factory->add_type_object("eprosima::fastdds::rtps::core::Header", eprosima::fastdds::rtps::core::GetHeaderIdentifier(true),
                        eprosima::fastdds::rtps::core::GetHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::Header", eprosima::fastdds::rtps::core::GetHeaderIdentifier(false),
                        eprosima::fastdds::rtps::core::GetHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::SubmessageHeader", eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true),
                        eprosima::fastdds::rtps::core::GetSubmessageHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::SubmessageHeader", eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false),
                        eprosima::fastdds::rtps::core::GetSubmessageHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::SubmessageKind", eprosima::fastdds::rtps::core::GetSubmessageKindIdentifier(true),
                        eprosima::fastdds::rtps::core::GetSubmessageKindObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::SubmessageKind", eprosima::fastdds::rtps::core::GetSubmessageKindIdentifier(false),
                        eprosima::fastdds::rtps::core::GetSubmessageKindObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::HeartBeatSubmessage", eprosima::fastdds::rtps::core::GetHeartBeatSubmessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetHeartBeatSubmessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::HeartBeatSubmessage", eprosima::fastdds::rtps::core::GetHeartBeatSubmessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetHeartBeatSubmessageObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::InfoDestinationSubmessage", eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::InfoDestinationSubmessage", eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::InfoSourceSubmessage", eprosima::fastdds::rtps::core::GetInfoSourceSubmessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetInfoSourceSubmessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::InfoSourceSubmessage", eprosima::fastdds::rtps::core::GetInfoSourceSubmessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetInfoSourceSubmessageObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::InfoTimestampSubmessage", eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::InfoTimestampSubmessage", eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::Submessage", eprosima::fastdds::rtps::core::GetSubmessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetSubmessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::Submessage", eprosima::fastdds::rtps::core::GetSubmessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetSubmessageObject(false));


                factory->add_type_object("eprosima::fastdds::rtps::core::RTPSMessage", eprosima::fastdds::rtps::core::GetRTPSMessageIdentifier(true),
                        eprosima::fastdds::rtps::core::GetRTPSMessageObject(true));
                factory->add_type_object("eprosima::fastdds::rtps::core::RTPSMessage", eprosima::fastdds::rtps::core::GetRTPSMessageIdentifier(false),
                        eprosima::fastdds::rtps::core::GetRTPSMessageObject(false));





            });
}

namespace eprosima {
    namespace fastdds {
        namespace rtps {
            namespace core {
                namespace detail {


                    const TypeIdentifier* GetEntityId_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("EntityId_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetEntityId_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("EntityId_t", complete);
                    }

                    const TypeObject* GetEntityId_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EntityId_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteEntityId_tObject();
                        }
                        //else
                        return GetMinimalEntityId_tObject();
                    }

                    const TypeObject* GetMinimalEntityId_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EntityId_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_value;
                        mst_value.common().member_id(memberId++);
                        mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_value.common().member_flags().IS_OPTIONAL(false);
                        mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_value.common().member_flags().IS_KEY(false);
                        mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {4}, false));

                        MD5 value_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_value.detail().name_hash()[i] = value_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("EntityId_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("EntityId_t", false);
                    }

                    const TypeObject* GetCompleteEntityId_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("EntityId_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_value;
                        cst_value.common().member_id(memberId++);
                        cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_value.common().member_flags().IS_OPTIONAL(false);
                        cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_value.common().member_flags().IS_KEY(false);
                        cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {4}, true));

                        cst_value.detail().name("value");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_value);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("EntityId_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("EntityId_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("EntityId_t", true);
                    }



                    const TypeIdentifier* GetProtocolVersion_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ProtocolVersion_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetProtocolVersion_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("ProtocolVersion_t", complete);
                    }

                    const TypeObject* GetProtocolVersion_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ProtocolVersion_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteProtocolVersion_tObject();
                        }
                        //else
                        return GetMinimalProtocolVersion_tObject();
                    }

                    const TypeObject* GetMinimalProtocolVersion_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ProtocolVersion_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_major;
                        mst_major.common().member_id(memberId++);
                        mst_major.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_major.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_major.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_major.common().member_flags().IS_OPTIONAL(false);
                        mst_major.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_major.common().member_flags().IS_KEY(false);
                        mst_major.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_major.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                        MD5 major_hash("major");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_major.detail().name_hash()[i] = major_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_major);

                        MinimalStructMember mst_minor;
                        mst_minor.common().member_id(memberId++);
                        mst_minor.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_minor.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_minor.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_minor.common().member_flags().IS_OPTIONAL(false);
                        mst_minor.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_minor.common().member_flags().IS_KEY(false);
                        mst_minor.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_minor.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                        MD5 minor_hash("minor");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_minor.detail().name_hash()[i] = minor_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_minor);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("ProtocolVersion_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("ProtocolVersion_t", false);
                    }

                    const TypeObject* GetCompleteProtocolVersion_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ProtocolVersion_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_major;
                        cst_major.common().member_id(memberId++);
                        cst_major.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_major.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_major.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_major.common().member_flags().IS_OPTIONAL(false);
                        cst_major.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_major.common().member_flags().IS_KEY(false);
                        cst_major.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_major.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                        cst_major.detail().name("major");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_major);

                        CompleteStructMember cst_minor;
                        cst_minor.common().member_id(memberId++);
                        cst_minor.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_minor.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_minor.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_minor.common().member_flags().IS_OPTIONAL(false);
                        cst_minor.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_minor.common().member_flags().IS_KEY(false);
                        cst_minor.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_minor.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                        cst_minor.detail().name("minor");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_minor);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("ProtocolVersion_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("ProtocolVersion_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("ProtocolVersion_t", true);
                    }



                    const TypeIdentifier* GetVendorId_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("VendorId_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetVendorId_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("VendorId_t", complete);
                    }

                    const TypeObject* GetVendorId_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("VendorId_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteVendorId_tObject();
                        }
                        //else
                        return GetMinimalVendorId_tObject();
                    }

                    const TypeObject* GetMinimalVendorId_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("VendorId_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_vendorId;
                        mst_vendorId.common().member_id(memberId++);
                        mst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_vendorId.common().member_flags().IS_OPTIONAL(false);
                        mst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_vendorId.common().member_flags().IS_KEY(false);
                        mst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_vendorId.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {2}, false));

                        MD5 vendorId_hash("vendorId");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_vendorId.detail().name_hash()[i] = vendorId_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_vendorId);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("VendorId_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("VendorId_t", false);
                    }

                    const TypeObject* GetCompleteVendorId_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("VendorId_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_vendorId;
                        cst_vendorId.common().member_id(memberId++);
                        cst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_vendorId.common().member_flags().IS_OPTIONAL(false);
                        cst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_vendorId.common().member_flags().IS_KEY(false);
                        cst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_vendorId.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {2}, true));

                        cst_vendorId.detail().name("vendorId");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_vendorId);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("VendorId_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("VendorId_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("VendorId_t", true);
                    }



                    const TypeIdentifier* GetGuidPrefix_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("GuidPrefix_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetGuidPrefix_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("GuidPrefix_t", complete);
                    }

                    const TypeObject* GetGuidPrefix_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GuidPrefix_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteGuidPrefix_tObject();
                        }
                        //else
                        return GetMinimalGuidPrefix_tObject();
                    }

                    const TypeObject* GetMinimalGuidPrefix_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GuidPrefix_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_value;
                        mst_value.common().member_id(memberId++);
                        mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_value.common().member_flags().IS_OPTIONAL(false);
                        mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_value.common().member_flags().IS_KEY(false);
                        mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {12}, false));

                        MD5 value_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_value.detail().name_hash()[i] = value_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("GuidPrefix_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("GuidPrefix_t", false);
                    }

                    const TypeObject* GetCompleteGuidPrefix_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GuidPrefix_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_value;
                        cst_value.common().member_id(memberId++);
                        cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_value.common().member_flags().IS_OPTIONAL(false);
                        cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_value.common().member_flags().IS_KEY(false);
                        cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {12}, true));

                        cst_value.detail().name("value");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_value);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("GuidPrefix_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("GuidPrefix_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("GuidPrefix_t", true);
                    }



                    const TypeIdentifier* GetGUID_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("GUID_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetGUID_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("GUID_t", complete);
                    }

                    const TypeObject* GetGUID_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GUID_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteGUID_tObject();
                        }
                        //else
                        return GetMinimalGUID_tObject();
                    }

                    const TypeObject* GetMinimalGUID_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GUID_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_guidPrefix;
                        mst_guidPrefix.common().member_id(memberId++);
                        mst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                        mst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_guidPrefix.common().member_flags().IS_KEY(false);
                        mst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(false));

                        MD5 guidPrefix_hash("guidPrefix");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_guidPrefix.detail().name_hash()[i] = guidPrefix_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_guidPrefix);

                        MinimalStructMember mst_entityId;
                        mst_entityId.common().member_id(memberId++);
                        mst_entityId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_entityId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_entityId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_entityId.common().member_flags().IS_OPTIONAL(false);
                        mst_entityId.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_entityId.common().member_flags().IS_KEY(false);
                        mst_entityId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_entityId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(false));

                        MD5 entityId_hash("entityId");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_entityId.detail().name_hash()[i] = entityId_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_entityId);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("GUID_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("GUID_t", false);
                    }

                    const TypeObject* GetCompleteGUID_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("GUID_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_guidPrefix;
                        cst_guidPrefix.common().member_id(memberId++);
                        cst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                        cst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_guidPrefix.common().member_flags().IS_KEY(false);
                        cst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(true));

                        cst_guidPrefix.detail().name("guidPrefix");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_guidPrefix);

                        CompleteStructMember cst_entityId;
                        cst_entityId.common().member_id(memberId++);
                        cst_entityId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_entityId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_entityId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_entityId.common().member_flags().IS_OPTIONAL(false);
                        cst_entityId.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_entityId.common().member_flags().IS_KEY(false);
                        cst_entityId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_entityId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(true));

                        cst_entityId.detail().name("entityId");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_entityId);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("GUID_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("GUID_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("GUID_t", true);
                    }



                    const TypeIdentifier* GetSequenceNumber_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SequenceNumber_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetSequenceNumber_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("SequenceNumber_t", complete);
                    }

                    const TypeObject* GetSequenceNumber_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceNumber_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteSequenceNumber_tObject();
                        }
                        //else
                        return GetMinimalSequenceNumber_tObject();
                    }

                    const TypeObject* GetMinimalSequenceNumber_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceNumber_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_high;
                        mst_high.common().member_id(memberId++);
                        mst_high.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_high.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_high.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_high.common().member_flags().IS_OPTIONAL(false);
                        mst_high.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_high.common().member_flags().IS_KEY(false);
                        mst_high.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_high.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                        MD5 high_hash("high");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_high.detail().name_hash()[i] = high_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_high);

                        MinimalStructMember mst_low;
                        mst_low.common().member_id(memberId++);
                        mst_low.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_low.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_low.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_low.common().member_flags().IS_OPTIONAL(false);
                        mst_low.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_low.common().member_flags().IS_KEY(false);
                        mst_low.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_low.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        MD5 low_hash("low");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_low.detail().name_hash()[i] = low_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_low);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("SequenceNumber_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("SequenceNumber_t", false);
                    }

                    const TypeObject* GetCompleteSequenceNumber_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SequenceNumber_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_high;
                        cst_high.common().member_id(memberId++);
                        cst_high.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_high.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_high.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_high.common().member_flags().IS_OPTIONAL(false);
                        cst_high.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_high.common().member_flags().IS_KEY(false);
                        cst_high.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_high.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                        cst_high.detail().name("high");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_high);

                        CompleteStructMember cst_low;
                        cst_low.common().member_id(memberId++);
                        cst_low.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_low.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_low.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_low.common().member_flags().IS_OPTIONAL(false);
                        cst_low.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_low.common().member_flags().IS_KEY(false);
                        cst_low.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_low.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        cst_low.detail().name("low");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_low);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("SequenceNumber_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("SequenceNumber_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("SequenceNumber_t", true);
                    }



                    const TypeIdentifier* GetCount_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Count_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetCount_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("Count_t", complete);
                    }

                    const TypeObject* GetCount_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Count_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteCount_tObject();
                        }
                        //else
                        return GetMinimalCount_tObject();
                    }

                    const TypeObject* GetMinimalCount_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Count_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_value;
                        mst_value.common().member_id(memberId++);
                        mst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_value.common().member_flags().IS_OPTIONAL(false);
                        mst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_value.common().member_flags().IS_KEY(false);
                        mst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                        MD5 value_hash("value");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_value.detail().name_hash()[i] = value_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_value);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("Count_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Count_t", false);
                    }

                    const TypeObject* GetCompleteCount_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Count_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_value;
                        cst_value.common().member_id(memberId++);
                        cst_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_value.common().member_flags().IS_OPTIONAL(false);
                        cst_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_value.common().member_flags().IS_KEY(false);
                        cst_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_value.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                        cst_value.detail().name("value");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_value);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("Count_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("Count_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Count_t", true);
                    }



                    const TypeIdentifier* GetTime_tIdentifier(bool complete)
                    {
                        const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Time_t", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetTime_tObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("Time_t", complete);
                    }

                    const TypeObject* GetTime_tObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time_t", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteTime_tObject();
                        }
                        //else
                        return GetMinimalTime_tObject();
                    }

                    const TypeObject* GetMinimalTime_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time_t", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_STRUCTURE);

                        type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                        type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                        type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        MinimalStructMember mst_seconds;
                        mst_seconds.common().member_id(memberId++);
                        mst_seconds.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_seconds.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_seconds.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_seconds.common().member_flags().IS_OPTIONAL(false);
                        mst_seconds.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_seconds.common().member_flags().IS_KEY(false);
                        mst_seconds.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_seconds.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        MD5 seconds_hash("seconds");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_seconds.detail().name_hash()[i] = seconds_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_seconds);

                        MinimalStructMember mst_fraction;
                        mst_fraction.common().member_id(memberId++);
                        mst_fraction.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        mst_fraction.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        mst_fraction.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        mst_fraction.common().member_flags().IS_OPTIONAL(false);
                        mst_fraction.common().member_flags().IS_MUST_UNDERSTAND(false);
                        mst_fraction.common().member_flags().IS_KEY(false);
                        mst_fraction.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        mst_fraction.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        MD5 fraction_hash("fraction");
                        for(int i = 0; i < 4; ++i)
                        {
                            mst_fraction.detail().name_hash()[i] = fraction_hash.digest[i];
                        }
                        type_object->minimal().struct_type().member_seq().emplace_back(mst_fraction);


                        // Header
                        // TODO Inheritance
                        //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                        //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("Time_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Time_t", false);
                    }

                    const TypeObject* GetCompleteTime_tObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time_t", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_STRUCTURE);

                        type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                        type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                        type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                        type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                        MemberId memberId = 0;
                        CompleteStructMember cst_seconds;
                        cst_seconds.common().member_id(memberId++);
                        cst_seconds.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_seconds.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_seconds.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_seconds.common().member_flags().IS_OPTIONAL(false);
                        cst_seconds.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_seconds.common().member_flags().IS_KEY(false);
                        cst_seconds.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_seconds.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        cst_seconds.detail().name("seconds");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_seconds);

                        CompleteStructMember cst_fraction;
                        cst_fraction.common().member_id(memberId++);
                        cst_fraction.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                        cst_fraction.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                        cst_fraction.common().member_flags().IS_EXTERNAL(false); // Unsupported
                        cst_fraction.common().member_flags().IS_OPTIONAL(false);
                        cst_fraction.common().member_flags().IS_MUST_UNDERSTAND(false);
                        cst_fraction.common().member_flags().IS_KEY(false);
                        cst_fraction.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                        cst_fraction.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));


                        cst_fraction.detail().name("fraction");

                        type_object->complete().struct_type().member_seq().emplace_back(cst_fraction);


                        // Header
                        type_object->complete().struct_type().header().detail().type_name("Time_t");
                        // TODO inheritance
                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        TypeObjectFactory::get_instance()->add_type_object("Time_t", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Time_t", true);
                    }

                    const TypeIdentifier* GetTimestampIdentifier(bool complete)
                    {
                        const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Timestamp", complete);
                        if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                        {
                            return c_identifier;
                        }

                        GetTimestampObject(complete); // Generated inside
                        return TypeObjectFactory::get_instance()->get_type_identifier("Timestamp", complete);
                    }

                    const TypeObject* GetTimestampObject(bool complete)
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Timestamp", complete);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }
                        else if (complete)
                        {
                            return GetCompleteTimestampObject();
                        }
                        else
                        {
                            return GetMinimalTimestampObject();
                        }
                    }

                    const TypeObject* GetMinimalTimestampObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Timestamp", false);
                        if (c_type_object != nullptr)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_MINIMAL);
                        type_object->minimal()._d(TK_ALIAS);

                        // No flags apply
                        //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
                        //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
                        //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
                        //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
                        //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

                        // type_object->minimal().alias_type().header()... Is empty

                        // No flags apply
                        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                        //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                        //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                        //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                        //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                        //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
                        //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

                        // Must be defined already, if don't, may be an recursive alias
                        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("eprosima::fastdds::rtps::core::detail::Time_t", false);


                        if (relatedType != nullptr)
                        {
                            type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
                        }
                        else
                        {
                            // Cannot determine base type
                            delete type_object;
                            return nullptr;
                        }

                        TypeIdentifier identifier;
                        identifier._d(EK_MINIMAL);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        // Don't add our TypeIdentifier but our alias
                        TypeObjectFactory::get_instance()->add_alias("Timestamp", "eprosima::fastdds::rtps::core::detail::Time_t");

                        TypeObjectFactory::get_instance()->add_type_object("Timestamp", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Timestamp", false);
                    }

                    const TypeObject* GetCompleteTimestampObject()
                    {
                        const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Timestamp", true);
                        if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                        {
                            return c_type_object;
                        }

                        TypeObject *type_object = new TypeObject();
                        type_object->_d(EK_COMPLETE);
                        type_object->complete()._d(TK_ALIAS);

                        // No flags apply
                        //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
                        //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
                        //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
                        //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
                        //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

                        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
                        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
                        //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
                        //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
                        type_object->complete().alias_type().header().detail().type_name("Timestamp");

                        // No flags apply
                        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                        //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                        //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                        //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                        //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                        //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
                        //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

                        //type_object->complete().alias_type().body().common().ann_builtin()
                        //type_object->complete().alias_type().body().common().ann_custom()

                        // Must be defined already, if don't, may be an recursive alias
                        const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("eprosima::fastdds::rtps::core::detail::Time_t");


                        if (relatedType != nullptr)
                        {
                            type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
                        }
                        else
                        {
                            // Cannot determine base type
                            delete type_object;
                            return nullptr;
                        }

                        TypeIdentifier identifier;
                        identifier._d(EK_COMPLETE);

                        eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                        size_t current_alignment {0};
                        SerializedPayload_t payload(static_cast<uint32_t>(
                            calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
                        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                        // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                        eprosima::fastcdr::Cdr ser(
                            fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                            eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                        payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                        ser << *type_object;
                    #if FASTCDR_VERSION_MAJOR == 1
                        payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    #else
                        payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    #endif // FASTCDR_VERSION_MAJOR == 1
                        MD5 objectHash;
                        objectHash.update((char*)payload.data, payload.length);
                        objectHash.finalize();
                        for(int i = 0; i < 14; ++i)
                        {
                            identifier.equivalence_hash()[i] = objectHash.digest[i];
                        }

                        // Don't add our TypeIdentifier but our alias
                        TypeObjectFactory::get_instance()->add_alias("Timestamp", "eprosima::fastdds::rtps::core::detail::Time_t");

                        TypeObjectFactory::get_instance()->add_type_object("Timestamp", &identifier, type_object);
                        delete type_object;
                        return TypeObjectFactory::get_instance()->get_type_object("Timestamp", true);
                    }

                } // namespace detail


                const TypeIdentifier* GetHeaderIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Header", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetHeaderObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("Header", complete);
                }

                const TypeObject* GetHeaderObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Header", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteHeaderObject();
                    }
                    //else
                    return GetMinimalHeaderObject();
                }

                const TypeObject* GetMinimalHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Header", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_prefix;
                    mst_prefix.common().member_id(memberId++);
                    mst_prefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_prefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_prefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_prefix.common().member_flags().IS_OPTIONAL(false);
                    mst_prefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_prefix.common().member_flags().IS_KEY(false);
                    mst_prefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_prefix.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {4}, false));

                    MD5 prefix_hash("prefix");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_prefix.detail().name_hash()[i] = prefix_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_prefix);

                    MinimalStructMember mst_version;
                    mst_version.common().member_id(memberId++);
                    mst_version.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_version.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_version.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_version.common().member_flags().IS_OPTIONAL(false);
                    mst_version.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_version.common().member_flags().IS_KEY(false);
                    mst_version.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_version.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(false));

                    MD5 version_hash("version");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_version.detail().name_hash()[i] = version_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_version);

                    MinimalStructMember mst_vendorId;
                    mst_vendorId.common().member_id(memberId++);
                    mst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_vendorId.common().member_flags().IS_OPTIONAL(false);
                    mst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_vendorId.common().member_flags().IS_KEY(false);
                    mst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_vendorId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(false));

                    MD5 vendorId_hash("vendorId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_vendorId.detail().name_hash()[i] = vendorId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_vendorId);

                    MinimalStructMember mst_guidPrefix;
                    mst_guidPrefix.common().member_id(memberId++);
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    mst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_guidPrefix.common().member_flags().IS_KEY(false);
                    mst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(false));

                    MD5 guidPrefix_hash("guidPrefix");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_guidPrefix.detail().name_hash()[i] = guidPrefix_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_guidPrefix);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("Header", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("Header", false);
                }

                const TypeObject* GetCompleteHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Header", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_prefix;
                    cst_prefix.common().member_id(memberId++);
                    cst_prefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_prefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_prefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_prefix.common().member_flags().IS_OPTIONAL(false);
                    cst_prefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_prefix.common().member_flags().IS_KEY(false);
                    cst_prefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_prefix.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {4}, true));

                    cst_prefix.detail().name("prefix");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_prefix);

                    CompleteStructMember cst_version;
                    cst_version.common().member_id(memberId++);
                    cst_version.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_version.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_version.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_version.common().member_flags().IS_OPTIONAL(false);
                    cst_version.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_version.common().member_flags().IS_KEY(false);
                    cst_version.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_version.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(true));

                    cst_version.detail().name("version");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_version);

                    CompleteStructMember cst_vendorId;
                    cst_vendorId.common().member_id(memberId++);
                    cst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_vendorId.common().member_flags().IS_OPTIONAL(false);
                    cst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_vendorId.common().member_flags().IS_KEY(false);
                    cst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_vendorId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(true));

                    cst_vendorId.detail().name("vendorId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_vendorId);

                    CompleteStructMember cst_guidPrefix;
                    cst_guidPrefix.common().member_id(memberId++);
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    cst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_guidPrefix.common().member_flags().IS_KEY(false);
                    cst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(true));

                    cst_guidPrefix.detail().name("guidPrefix");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_guidPrefix);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("Header");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("Header", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("Header", true);
                }



                const TypeIdentifier* GetSubmessageHeaderIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SubmessageHeader", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetSubmessageHeaderObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("SubmessageHeader", complete);
                }

                const TypeObject* GetSubmessageHeaderObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageHeader", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteSubmessageHeaderObject();
                    }
                    //else
                    return GetMinimalSubmessageHeaderObject();
                }

                const TypeObject* GetMinimalSubmessageHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageHeader", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_submessageId;
                    mst_submessageId.common().member_id(memberId++);
                    mst_submessageId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submessageId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submessageId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submessageId.common().member_flags().IS_OPTIONAL(false);
                    mst_submessageId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submessageId.common().member_flags().IS_KEY(false);
                    mst_submessageId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submessageId.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                    MD5 submessageId_hash("submessageId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submessageId.detail().name_hash()[i] = submessageId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submessageId);

                    MinimalStructMember mst_flags;
                    mst_flags.common().member_id(memberId++);
                    mst_flags.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_flags.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_flags.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_flags.common().member_flags().IS_OPTIONAL(false);
                    mst_flags.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_flags.common().member_flags().IS_KEY(false);
                    mst_flags.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_flags.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                    MD5 flags_hash("flags");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_flags.detail().name_hash()[i] = flags_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_flags);

                    MinimalStructMember mst_submessageLength;
                    mst_submessageLength.common().member_id(memberId++);
                    mst_submessageLength.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submessageLength.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submessageLength.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submessageLength.common().member_flags().IS_OPTIONAL(false);
                    mst_submessageLength.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submessageLength.common().member_flags().IS_KEY(false);
                    mst_submessageLength.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submessageLength.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));


                    MD5 submessageLength_hash("submessageLength");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submessageLength.detail().name_hash()[i] = submessageLength_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submessageLength);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("SubmessageHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("SubmessageHeader", false);
                }

                const TypeObject* GetCompleteSubmessageHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageHeader", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_submessageId;
                    cst_submessageId.common().member_id(memberId++);
                    cst_submessageId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submessageId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submessageId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submessageId.common().member_flags().IS_OPTIONAL(false);
                    cst_submessageId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submessageId.common().member_flags().IS_KEY(false);
                    cst_submessageId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submessageId.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                    cst_submessageId.detail().name("submessageId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submessageId);

                    CompleteStructMember cst_flags;
                    cst_flags.common().member_id(memberId++);
                    cst_flags.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_flags.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_flags.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_flags.common().member_flags().IS_OPTIONAL(false);
                    cst_flags.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_flags.common().member_flags().IS_KEY(false);
                    cst_flags.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_flags.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));


                    cst_flags.detail().name("flags");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_flags);

                    CompleteStructMember cst_submessageLength;
                    cst_submessageLength.common().member_id(memberId++);
                    cst_submessageLength.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submessageLength.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submessageLength.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submessageLength.common().member_flags().IS_OPTIONAL(false);
                    cst_submessageLength.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submessageLength.common().member_flags().IS_KEY(false);
                    cst_submessageLength.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submessageLength.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));


                    cst_submessageLength.detail().name("submessageLength");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submessageLength);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("SubmessageHeader");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("SubmessageHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("SubmessageHeader", true);
                }

                const TypeIdentifier* GetSubmessageKindIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("SubmessageKind", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetSubmessageKindObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("SubmessageKind", complete);
                }

                const TypeObject* GetSubmessageKindObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageKind", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteSubmessageKindObject();
                    }
                    // else
                    return GetMinimalSubmessageKindObject();
                }

                const TypeObject* GetMinimalSubmessageKindObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageKind", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ENUM);

                    // No flags apply
                    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

                    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

                    uint32_t value = 0;
                    MinimalEnumeratedLiteral mel_RTPS_HE;
                    mel_RTPS_HE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().IS_KEY(false); // Doesn't apply
                    mel_RTPS_HE.common().flags().IS_DEFAULT(false);
                    mel_RTPS_HE.common().value(value++);
                    MD5 RTPS_HE_hash("RTPS_HE");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_RTPS_HE.detail().name_hash()[i] = RTPS_HE_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_RTPS_HE);

                    MinimalEnumeratedLiteral mel_PAD;
                    mel_PAD.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_PAD.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_PAD.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_PAD.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_PAD.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_PAD.common().flags().IS_KEY(false); // Doesn't apply
                    mel_PAD.common().flags().IS_DEFAULT(false);
                    mel_PAD.common().value(value++);
                    MD5 PAD_hash("PAD");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_PAD.detail().name_hash()[i] = PAD_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_PAD);

                    MinimalEnumeratedLiteral mel_ACKNACK;
                    mel_ACKNACK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_ACKNACK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_ACKNACK.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_ACKNACK.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_ACKNACK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_ACKNACK.common().flags().IS_KEY(false); // Doesn't apply
                    mel_ACKNACK.common().flags().IS_DEFAULT(false);
                    mel_ACKNACK.common().value(value++);
                    MD5 ACKNACK_hash("ACKNACK");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_ACKNACK.detail().name_hash()[i] = ACKNACK_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_ACKNACK);

                    MinimalEnumeratedLiteral mel_HEARTBEAT;
                    mel_HEARTBEAT.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().IS_KEY(false); // Doesn't apply
                    mel_HEARTBEAT.common().flags().IS_DEFAULT(false);
                    mel_HEARTBEAT.common().value(value++);
                    MD5 HEARTBEAT_hash("HEARTBEAT");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_HEARTBEAT.detail().name_hash()[i] = HEARTBEAT_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_HEARTBEAT);

                    MinimalEnumeratedLiteral mel_GAP;
                    mel_GAP.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_GAP.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_GAP.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_GAP.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_GAP.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_GAP.common().flags().IS_KEY(false); // Doesn't apply
                    mel_GAP.common().flags().IS_DEFAULT(false);
                    mel_GAP.common().value(value++);
                    MD5 GAP_hash("GAP");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_GAP.detail().name_hash()[i] = GAP_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_GAP);

                    MinimalEnumeratedLiteral mel_INFO_TS;
                    mel_INFO_TS.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_INFO_TS.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_INFO_TS.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_INFO_TS.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_INFO_TS.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_INFO_TS.common().flags().IS_KEY(false); // Doesn't apply
                    mel_INFO_TS.common().flags().IS_DEFAULT(false);
                    mel_INFO_TS.common().value(value++);
                    MD5 INFO_TS_hash("INFO_TS");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_INFO_TS.detail().name_hash()[i] = INFO_TS_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INFO_TS);

                    MinimalEnumeratedLiteral mel_INFO_SRC;
                    mel_INFO_SRC.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().IS_KEY(false); // Doesn't apply
                    mel_INFO_SRC.common().flags().IS_DEFAULT(false);
                    mel_INFO_SRC.common().value(value++);
                    MD5 INFO_SRC_hash("INFO_SRC");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_INFO_SRC.detail().name_hash()[i] = INFO_SRC_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INFO_SRC);

                    MinimalEnumeratedLiteral mel_INFO_REPLY_IP4;
                    mel_INFO_REPLY_IP4.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().IS_KEY(false); // Doesn't apply
                    mel_INFO_REPLY_IP4.common().flags().IS_DEFAULT(false);
                    mel_INFO_REPLY_IP4.common().value(value++);
                    MD5 INFO_REPLY_IP4_hash("INFO_REPLY_IP4");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_INFO_REPLY_IP4.detail().name_hash()[i] = INFO_REPLY_IP4_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INFO_REPLY_IP4);

                    MinimalEnumeratedLiteral mel_INFO_DST;
                    mel_INFO_DST.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_INFO_DST.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_INFO_DST.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_INFO_DST.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_INFO_DST.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_INFO_DST.common().flags().IS_KEY(false); // Doesn't apply
                    mel_INFO_DST.common().flags().IS_DEFAULT(false);
                    mel_INFO_DST.common().value(value++);
                    MD5 INFO_DST_hash("INFO_DST");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_INFO_DST.detail().name_hash()[i] = INFO_DST_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INFO_DST);

                    MinimalEnumeratedLiteral mel_INFO_REPLY;
                    mel_INFO_REPLY.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().IS_KEY(false); // Doesn't apply
                    mel_INFO_REPLY.common().flags().IS_DEFAULT(false);
                    mel_INFO_REPLY.common().value(value++);
                    MD5 INFO_REPLY_hash("INFO_REPLY");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_INFO_REPLY.detail().name_hash()[i] = INFO_REPLY_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_INFO_REPLY);

                    MinimalEnumeratedLiteral mel_NACK_FRAG;
                    mel_NACK_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    mel_NACK_FRAG.common().flags().IS_DEFAULT(false);
                    mel_NACK_FRAG.common().value(value++);
                    MD5 NACK_FRAG_hash("NACK_FRAG");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_NACK_FRAG.detail().name_hash()[i] = NACK_FRAG_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_NACK_FRAG);

                    MinimalEnumeratedLiteral mel_HEARTBEAT_FRAG;
                    mel_HEARTBEAT_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    mel_HEARTBEAT_FRAG.common().flags().IS_DEFAULT(false);
                    mel_HEARTBEAT_FRAG.common().value(value++);
                    MD5 HEARTBEAT_FRAG_hash("HEARTBEAT_FRAG");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_HEARTBEAT_FRAG.detail().name_hash()[i] = HEARTBEAT_FRAG_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_HEARTBEAT_FRAG);

                    MinimalEnumeratedLiteral mel_DATA;
                    mel_DATA.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_DATA.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_DATA.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_DATA.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_DATA.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_DATA.common().flags().IS_KEY(false); // Doesn't apply
                    mel_DATA.common().flags().IS_DEFAULT(false);
                    mel_DATA.common().value(value++);
                    MD5 DATA_hash("DATA");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_DATA.detail().name_hash()[i] = DATA_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_DATA);

                    MinimalEnumeratedLiteral mel_DATA_FRAG;
                    mel_DATA_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    mel_DATA_FRAG.common().flags().IS_DEFAULT(false);
                    mel_DATA_FRAG.common().value(value++);
                    MD5 DATA_FRAG_hash("DATA_FRAG");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_DATA_FRAG.detail().name_hash()[i] = DATA_FRAG_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_DATA_FRAG);


                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("SubmessageKind", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("SubmessageKind", false);
                }

                const TypeObject* GetCompleteSubmessageKindObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("SubmessageKind", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ENUM);

                    // No flags apply
                    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

                    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
                    type_object->complete().enumerated_type().header().detail().type_name("SubmessageKind");

                    uint32_t value = 0;
                    CompleteEnumeratedLiteral cel_RTPS_HE;
                    cel_RTPS_HE.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().IS_KEY(false); // Doesn't apply
                    cel_RTPS_HE.common().flags().IS_DEFAULT(false);
                    cel_RTPS_HE.common().value(value++);
                    cel_RTPS_HE.detail().name("RTPS_HE");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x00");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_RTPS_HE.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_RTPS_HE);

                    CompleteEnumeratedLiteral cel_PAD;
                    cel_PAD.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_PAD.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_PAD.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_PAD.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_PAD.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_PAD.common().flags().IS_KEY(false); // Doesn't apply
                    cel_PAD.common().flags().IS_DEFAULT(false);
                    cel_PAD.common().value(value++);
                    cel_PAD.detail().name("PAD");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x01");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_PAD.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_PAD);

                    CompleteEnumeratedLiteral cel_ACKNACK;
                    cel_ACKNACK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_ACKNACK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_ACKNACK.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_ACKNACK.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_ACKNACK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_ACKNACK.common().flags().IS_KEY(false); // Doesn't apply
                    cel_ACKNACK.common().flags().IS_DEFAULT(false);
                    cel_ACKNACK.common().value(value++);
                    cel_ACKNACK.detail().name("ACKNACK");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x06");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_ACKNACK.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_ACKNACK);

                    CompleteEnumeratedLiteral cel_HEARTBEAT;
                    cel_HEARTBEAT.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().IS_KEY(false); // Doesn't apply
                    cel_HEARTBEAT.common().flags().IS_DEFAULT(false);
                    cel_HEARTBEAT.common().value(value++);
                    cel_HEARTBEAT.detail().name("HEARTBEAT");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x07");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_HEARTBEAT.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_HEARTBEAT);

                    CompleteEnumeratedLiteral cel_GAP;
                    cel_GAP.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_GAP.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_GAP.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_GAP.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_GAP.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_GAP.common().flags().IS_KEY(false); // Doesn't apply
                    cel_GAP.common().flags().IS_DEFAULT(false);
                    cel_GAP.common().value(value++);
                    cel_GAP.detail().name("GAP");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x08");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_GAP.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_GAP);

                    CompleteEnumeratedLiteral cel_INFO_TS;
                    cel_INFO_TS.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_INFO_TS.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_INFO_TS.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_INFO_TS.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_INFO_TS.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_INFO_TS.common().flags().IS_KEY(false); // Doesn't apply
                    cel_INFO_TS.common().flags().IS_DEFAULT(false);
                    cel_INFO_TS.common().value(value++);
                    cel_INFO_TS.detail().name("INFO_TS");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x09");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_INFO_TS.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INFO_TS);

                    CompleteEnumeratedLiteral cel_INFO_SRC;
                    cel_INFO_SRC.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().IS_KEY(false); // Doesn't apply
                    cel_INFO_SRC.common().flags().IS_DEFAULT(false);
                    cel_INFO_SRC.common().value(value++);
                    cel_INFO_SRC.detail().name("INFO_SRC");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x0c");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_INFO_SRC.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INFO_SRC);

                    CompleteEnumeratedLiteral cel_INFO_REPLY_IP4;
                    cel_INFO_REPLY_IP4.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().IS_KEY(false); // Doesn't apply
                    cel_INFO_REPLY_IP4.common().flags().IS_DEFAULT(false);
                    cel_INFO_REPLY_IP4.common().value(value++);
                    cel_INFO_REPLY_IP4.detail().name("INFO_REPLY_IP4");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x0d");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_INFO_REPLY_IP4.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INFO_REPLY_IP4);

                    CompleteEnumeratedLiteral cel_INFO_DST;
                    cel_INFO_DST.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_INFO_DST.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_INFO_DST.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_INFO_DST.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_INFO_DST.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_INFO_DST.common().flags().IS_KEY(false); // Doesn't apply
                    cel_INFO_DST.common().flags().IS_DEFAULT(false);
                    cel_INFO_DST.common().value(value++);
                    cel_INFO_DST.detail().name("INFO_DST");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x0e");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_INFO_DST.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INFO_DST);

                    CompleteEnumeratedLiteral cel_INFO_REPLY;
                    cel_INFO_REPLY.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().IS_KEY(false); // Doesn't apply
                    cel_INFO_REPLY.common().flags().IS_DEFAULT(false);
                    cel_INFO_REPLY.common().value(value++);
                    cel_INFO_REPLY.detail().name("INFO_REPLY");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x0f");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_INFO_REPLY.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_INFO_REPLY);

                    CompleteEnumeratedLiteral cel_NACK_FRAG;
                    cel_NACK_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    cel_NACK_FRAG.common().flags().IS_DEFAULT(false);
                    cel_NACK_FRAG.common().value(value++);
                    cel_NACK_FRAG.detail().name("NACK_FRAG");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x12");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_NACK_FRAG.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_NACK_FRAG);

                    CompleteEnumeratedLiteral cel_HEARTBEAT_FRAG;
                    cel_HEARTBEAT_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    cel_HEARTBEAT_FRAG.common().flags().IS_DEFAULT(false);
                    cel_HEARTBEAT_FRAG.common().value(value++);
                    cel_HEARTBEAT_FRAG.detail().name("HEARTBEAT_FRAG");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x13");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_HEARTBEAT_FRAG.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_HEARTBEAT_FRAG);

                    CompleteEnumeratedLiteral cel_DATA;
                    cel_DATA.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_DATA.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_DATA.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_DATA.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_DATA.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_DATA.common().flags().IS_KEY(false); // Doesn't apply
                    cel_DATA.common().flags().IS_DEFAULT(false);
                    cel_DATA.common().value(value++);
                    cel_DATA.detail().name("DATA");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x15");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_DATA.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_DATA);

                    CompleteEnumeratedLiteral cel_DATA_FRAG;
                    cel_DATA_FRAG.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().IS_KEY(false); // Doesn't apply
                    cel_DATA_FRAG.common().flags().IS_DEFAULT(false);
                    cel_DATA_FRAG.common().value(value++);
                    cel_DATA_FRAG.detail().name("DATA_FRAG");

                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetvalueIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("value"));
                            {
                                AppliedAnnotationParameter annParam;
                                MD5 message_hash("value");
                                for(int i = 0; i < 4; ++i)
                                {
                                    annParam.paramname_hash()[i] = message_hash.digest[i];
                                }
                                AnnotationParameterValue paramValue;
                                paramValue._d();
                                paramValue.from_string("0x16");
                                annParam.value(paramValue);
                                ann.param_seq().push_back(annParam);
                            }

                        cel_DATA_FRAG.detail().ann_custom().push_back(ann);
                    }


                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_DATA_FRAG);


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().enumerated_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("SubmessageKind", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("SubmessageKind", true);
                }



                const TypeIdentifier* GetHeartBeatSubmessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("HeartBeatSubmessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetHeartBeatSubmessageObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("HeartBeatSubmessage", complete);
                }

                const TypeObject* GetHeartBeatSubmessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HeartBeatSubmessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteHeartBeatSubmessageObject();
                    }
                    //else
                    return GetMinimalHeartBeatSubmessageObject();
                }

                const TypeObject* GetMinimalHeartBeatSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HeartBeatSubmessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_submsgHeader;
                    mst_submsgHeader.common().member_id(memberId++);
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    mst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submsgHeader.common().member_flags().IS_KEY(false);
                    mst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false));

                    MD5 submsgHeader_hash("submsgHeader");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submsgHeader.detail().name_hash()[i] = submsgHeader_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submsgHeader);

                    MinimalStructMember mst_readerId;
                    mst_readerId.common().member_id(memberId++);
                    mst_readerId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_readerId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_readerId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_readerId.common().member_flags().IS_OPTIONAL(false);
                    mst_readerId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_readerId.common().member_flags().IS_KEY(false);
                    mst_readerId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_readerId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(false));

                    MD5 readerId_hash("readerId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_readerId.detail().name_hash()[i] = readerId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_readerId);

                    MinimalStructMember mst_writerId;
                    mst_writerId.common().member_id(memberId++);
                    mst_writerId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_writerId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_writerId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_writerId.common().member_flags().IS_OPTIONAL(false);
                    mst_writerId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_writerId.common().member_flags().IS_KEY(false);
                    mst_writerId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_writerId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(false));

                    MD5 writerId_hash("writerId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_writerId.detail().name_hash()[i] = writerId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_writerId);

                    MinimalStructMember mst_firstSN;
                    mst_firstSN.common().member_id(memberId++);
                    mst_firstSN.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_firstSN.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_firstSN.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_firstSN.common().member_flags().IS_OPTIONAL(false);
                    mst_firstSN.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_firstSN.common().member_flags().IS_KEY(false);
                    mst_firstSN.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_firstSN.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(false));

                    MD5 firstSN_hash("firstSN");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_firstSN.detail().name_hash()[i] = firstSN_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_firstSN);

                    MinimalStructMember mst_lastSN;
                    mst_lastSN.common().member_id(memberId++);
                    mst_lastSN.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_lastSN.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_lastSN.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_lastSN.common().member_flags().IS_OPTIONAL(false);
                    mst_lastSN.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_lastSN.common().member_flags().IS_KEY(false);
                    mst_lastSN.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_lastSN.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(false));

                    MD5 lastSN_hash("lastSN");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_lastSN.detail().name_hash()[i] = lastSN_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_lastSN);

                    MinimalStructMember mst_count;
                    mst_count.common().member_id(memberId++);
                    mst_count.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_count.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_count.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_count.common().member_flags().IS_OPTIONAL(false);
                    mst_count.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_count.common().member_flags().IS_KEY(false);
                    mst_count.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_count.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetCount_tIdentifier(false));

                    MD5 count_hash("count");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_count.detail().name_hash()[i] = count_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_count);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("HeartBeatSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("HeartBeatSubmessage", false);
                }

                const TypeObject* GetCompleteHeartBeatSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("HeartBeatSubmessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_submsgHeader;
                    cst_submsgHeader.common().member_id(memberId++);
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    cst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submsgHeader.common().member_flags().IS_KEY(false);
                    cst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true));

                    cst_submsgHeader.detail().name("submsgHeader");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submsgHeader);

                    CompleteStructMember cst_readerId;
                    cst_readerId.common().member_id(memberId++);
                    cst_readerId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_readerId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_readerId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_readerId.common().member_flags().IS_OPTIONAL(false);
                    cst_readerId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_readerId.common().member_flags().IS_KEY(false);
                    cst_readerId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_readerId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(true));

                    cst_readerId.detail().name("readerId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_readerId);

                    CompleteStructMember cst_writerId;
                    cst_writerId.common().member_id(memberId++);
                    cst_writerId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_writerId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_writerId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_writerId.common().member_flags().IS_OPTIONAL(false);
                    cst_writerId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_writerId.common().member_flags().IS_KEY(false);
                    cst_writerId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_writerId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetEntityId_tIdentifier(true));

                    cst_writerId.detail().name("writerId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_writerId);

                    CompleteStructMember cst_firstSN;
                    cst_firstSN.common().member_id(memberId++);
                    cst_firstSN.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_firstSN.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_firstSN.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_firstSN.common().member_flags().IS_OPTIONAL(false);
                    cst_firstSN.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_firstSN.common().member_flags().IS_KEY(false);
                    cst_firstSN.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_firstSN.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(true));

                    cst_firstSN.detail().name("firstSN");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_firstSN);

                    CompleteStructMember cst_lastSN;
                    cst_lastSN.common().member_id(memberId++);
                    cst_lastSN.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_lastSN.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_lastSN.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_lastSN.common().member_flags().IS_OPTIONAL(false);
                    cst_lastSN.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_lastSN.common().member_flags().IS_KEY(false);
                    cst_lastSN.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_lastSN.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetSequenceNumber_tIdentifier(true));

                    cst_lastSN.detail().name("lastSN");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_lastSN);

                    CompleteStructMember cst_count;
                    cst_count.common().member_id(memberId++);
                    cst_count.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_count.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_count.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_count.common().member_flags().IS_OPTIONAL(false);
                    cst_count.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_count.common().member_flags().IS_KEY(false);
                    cst_count.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_count.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetCount_tIdentifier(true));

                    cst_count.detail().name("count");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_count);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("HeartBeatSubmessage");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("HeartBeatSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("HeartBeatSubmessage", true);
                }



                const TypeIdentifier* GetInfoDestinationSubmessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InfoDestinationSubmessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetInfoDestinationSubmessageObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("InfoDestinationSubmessage", complete);
                }

                const TypeObject* GetInfoDestinationSubmessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoDestinationSubmessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteInfoDestinationSubmessageObject();
                    }
                    //else
                    return GetMinimalInfoDestinationSubmessageObject();
                }

                const TypeObject* GetMinimalInfoDestinationSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoDestinationSubmessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_submsgHeader;
                    mst_submsgHeader.common().member_id(memberId++);
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    mst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submsgHeader.common().member_flags().IS_KEY(false);
                    mst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false));

                    MD5 submsgHeader_hash("submsgHeader");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submsgHeader.detail().name_hash()[i] = submsgHeader_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submsgHeader);

                    MinimalStructMember mst_guidPrefix;
                    mst_guidPrefix.common().member_id(memberId++);
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    mst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_guidPrefix.common().member_flags().IS_KEY(false);
                    mst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(false));

                    MD5 guidPrefix_hash("guidPrefix");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_guidPrefix.detail().name_hash()[i] = guidPrefix_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_guidPrefix);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoDestinationSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoDestinationSubmessage", false);
                }

                const TypeObject* GetCompleteInfoDestinationSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoDestinationSubmessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_submsgHeader;
                    cst_submsgHeader.common().member_id(memberId++);
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    cst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submsgHeader.common().member_flags().IS_KEY(false);
                    cst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true));

                    cst_submsgHeader.detail().name("submsgHeader");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submsgHeader);

                    CompleteStructMember cst_guidPrefix;
                    cst_guidPrefix.common().member_id(memberId++);
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    cst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_guidPrefix.common().member_flags().IS_KEY(false);
                    cst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(true));

                    cst_guidPrefix.detail().name("guidPrefix");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_guidPrefix);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("InfoDestinationSubmessage");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoDestinationSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoDestinationSubmessage", true);
                }



                const TypeIdentifier* GetInfoSourceSubmessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InfoSourceSubmessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetInfoSourceSubmessageObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("InfoSourceSubmessage", complete);
                }

                const TypeObject* GetInfoSourceSubmessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoSourceSubmessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteInfoSourceSubmessageObject();
                    }
                    //else
                    return GetMinimalInfoSourceSubmessageObject();
                }

                const TypeObject* GetMinimalInfoSourceSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoSourceSubmessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_submsgHeader;
                    mst_submsgHeader.common().member_id(memberId++);
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    mst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submsgHeader.common().member_flags().IS_KEY(false);
                    mst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false));

                    MD5 submsgHeader_hash("submsgHeader");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submsgHeader.detail().name_hash()[i] = submsgHeader_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submsgHeader);

                    MinimalStructMember mst_unused;
                    mst_unused.common().member_id(memberId++);
                    mst_unused.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_unused.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_unused.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_unused.common().member_flags().IS_OPTIONAL(false);
                    mst_unused.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_unused.common().member_flags().IS_KEY(false);
                    mst_unused.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_unused.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                    MD5 unused_hash("unused");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_unused.detail().name_hash()[i] = unused_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_unused);

                    MinimalStructMember mst_version;
                    mst_version.common().member_id(memberId++);
                    mst_version.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_version.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_version.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_version.common().member_flags().IS_OPTIONAL(false);
                    mst_version.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_version.common().member_flags().IS_KEY(false);
                    mst_version.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_version.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(false));

                    MD5 version_hash("version");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_version.detail().name_hash()[i] = version_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_version);

                    MinimalStructMember mst_vendorId;
                    mst_vendorId.common().member_id(memberId++);
                    mst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_vendorId.common().member_flags().IS_OPTIONAL(false);
                    mst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_vendorId.common().member_flags().IS_KEY(false);
                    mst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_vendorId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(false));

                    MD5 vendorId_hash("vendorId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_vendorId.detail().name_hash()[i] = vendorId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_vendorId);

                    MinimalStructMember mst_guidPrefix;
                    mst_guidPrefix.common().member_id(memberId++);
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    mst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_guidPrefix.common().member_flags().IS_KEY(false);
                    mst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(false));

                    MD5 guidPrefix_hash("guidPrefix");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_guidPrefix.detail().name_hash()[i] = guidPrefix_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_guidPrefix);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoSourceSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoSourceSubmessage", false);
                }

                const TypeObject* GetCompleteInfoSourceSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoSourceSubmessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_submsgHeader;
                    cst_submsgHeader.common().member_id(memberId++);
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    cst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submsgHeader.common().member_flags().IS_KEY(false);
                    cst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true));

                    cst_submsgHeader.detail().name("submsgHeader");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submsgHeader);

                    CompleteStructMember cst_unused;
                    cst_unused.common().member_id(memberId++);
                    cst_unused.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_unused.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_unused.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_unused.common().member_flags().IS_OPTIONAL(false);
                    cst_unused.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_unused.common().member_flags().IS_KEY(false);
                    cst_unused.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_unused.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


                    cst_unused.detail().name("unused");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_unused);

                    CompleteStructMember cst_version;
                    cst_version.common().member_id(memberId++);
                    cst_version.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_version.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_version.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_version.common().member_flags().IS_OPTIONAL(false);
                    cst_version.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_version.common().member_flags().IS_KEY(false);
                    cst_version.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_version.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetProtocolVersion_tIdentifier(true));

                    cst_version.detail().name("version");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_version);

                    CompleteStructMember cst_vendorId;
                    cst_vendorId.common().member_id(memberId++);
                    cst_vendorId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_vendorId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_vendorId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_vendorId.common().member_flags().IS_OPTIONAL(false);
                    cst_vendorId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_vendorId.common().member_flags().IS_KEY(false);
                    cst_vendorId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_vendorId.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetVendorId_tIdentifier(true));

                    cst_vendorId.detail().name("vendorId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_vendorId);

                    CompleteStructMember cst_guidPrefix;
                    cst_guidPrefix.common().member_id(memberId++);
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_guidPrefix.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_guidPrefix.common().member_flags().IS_OPTIONAL(false);
                    cst_guidPrefix.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_guidPrefix.common().member_flags().IS_KEY(false);
                    cst_guidPrefix.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_guidPrefix.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetGuidPrefix_tIdentifier(true));

                    cst_guidPrefix.detail().name("guidPrefix");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_guidPrefix);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("InfoSourceSubmessage");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoSourceSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoSourceSubmessage", true);
                }



                const TypeIdentifier* GetInfoTimestampSubmessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InfoTimestampSubmessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetInfoTimestampSubmessageObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("InfoTimestampSubmessage", complete);
                }

                const TypeObject* GetInfoTimestampSubmessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoTimestampSubmessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteInfoTimestampSubmessageObject();
                    }
                    //else
                    return GetMinimalInfoTimestampSubmessageObject();
                }

                const TypeObject* GetMinimalInfoTimestampSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoTimestampSubmessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_submsgHeader;
                    mst_submsgHeader.common().member_id(memberId++);
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    mst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submsgHeader.common().member_flags().IS_KEY(false);
                    mst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false));

                    MD5 submsgHeader_hash("submsgHeader");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submsgHeader.detail().name_hash()[i] = submsgHeader_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submsgHeader);

                    MinimalStructMember mst_timestamp;
                    mst_timestamp.common().member_id(memberId++);
                    mst_timestamp.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_timestamp.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_timestamp.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_timestamp.common().member_flags().IS_OPTIONAL(false);
                    mst_timestamp.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_timestamp.common().member_flags().IS_KEY(false);
                    mst_timestamp.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_timestamp.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetTimestampIdentifier(false));

                    MD5 timestamp_hash("timestamp");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_timestamp.detail().name_hash()[i] = timestamp_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_timestamp);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoTimestampSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoTimestampSubmessage", false);
                }

                const TypeObject* GetCompleteInfoTimestampSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InfoTimestampSubmessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_submsgHeader;
                    cst_submsgHeader.common().member_id(memberId++);
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submsgHeader.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submsgHeader.common().member_flags().IS_OPTIONAL(false);
                    cst_submsgHeader.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submsgHeader.common().member_flags().IS_KEY(false);
                    cst_submsgHeader.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submsgHeader.common().member_type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true));

                    cst_submsgHeader.detail().name("submsgHeader");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submsgHeader);

                    CompleteStructMember cst_timestamp;
                    cst_timestamp.common().member_id(memberId++);
                    cst_timestamp.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_timestamp.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_timestamp.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_timestamp.common().member_flags().IS_OPTIONAL(false);
                    cst_timestamp.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_timestamp.common().member_flags().IS_KEY(false);
                    cst_timestamp.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_timestamp.common().member_type_id(*eprosima::fastdds::rtps::core::detail::GetTimestampIdentifier(true));

                    cst_timestamp.detail().name("timestamp");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_timestamp);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("InfoTimestampSubmessage");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("InfoTimestampSubmessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InfoTimestampSubmessage", true);
                }



                const TypeIdentifier* GetSubmessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Submessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetSubmessageObject(complete);
                    return TypeObjectFactory::get_instance()->get_type_identifier("Submessage", complete);
                }

                const TypeObject* GetSubmessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Submessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteSubmessageObject();
                    }
                    // else
                    return GetMinimalSubmessageObject();
                }

                const TypeObject* GetMinimalSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Submessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_UNION);

                    type_object->minimal().union_type().union_flags().IS_FINAL(false);
                    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
                    type_object->minimal().union_type().union_flags().IS_NESTED(false);
                    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->minimal().union_type().discriminator().common().type_id(*GetSubmessageKindIdentifier(false));

                    MemberId memberId = 0;
                    MinimalUnionMember mst_heartbeat_submsg;
                    mst_heartbeat_submsg.common().member_id(memberId++);
                    mst_heartbeat_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_heartbeat_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_heartbeat_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_heartbeat_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_heartbeat_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_heartbeat_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_heartbeat_submsg.common().member_flags().IS_DEFAULT(false);
                    mst_heartbeat_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetHeartBeatSubmessageIdentifier(false));

                    mst_heartbeat_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::HEARTBEAT);

                    MD5 heartbeat_submsg_hash("heartbeat_submsg");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_heartbeat_submsg.detail().name_hash()[i] = heartbeat_submsg_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_heartbeat_submsg);

                    MinimalUnionMember mst_info_ts_submsg;
                    mst_info_ts_submsg.common().member_id(memberId++);
                    mst_info_ts_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_info_ts_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_info_ts_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_info_ts_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_info_ts_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_info_ts_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_info_ts_submsg.common().member_flags().IS_DEFAULT(false);
                    mst_info_ts_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageIdentifier(false));

                    mst_info_ts_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_TS);

                    MD5 info_ts_submsg_hash("info_ts_submsg");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_info_ts_submsg.detail().name_hash()[i] = info_ts_submsg_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_info_ts_submsg);

                    MinimalUnionMember mst_info_src_submsg;
                    mst_info_src_submsg.common().member_id(memberId++);
                    mst_info_src_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_info_src_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_info_src_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_info_src_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_info_src_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_info_src_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_info_src_submsg.common().member_flags().IS_DEFAULT(false);
                    mst_info_src_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoSourceSubmessageIdentifier(false));

                    mst_info_src_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_SRC);

                    MD5 info_src_submsg_hash("info_src_submsg");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_info_src_submsg.detail().name_hash()[i] = info_src_submsg_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_info_src_submsg);

                    MinimalUnionMember mst_info_dst_submsg;
                    mst_info_dst_submsg.common().member_id(memberId++);
                    mst_info_dst_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_info_dst_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_info_dst_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_info_dst_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_info_dst_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_info_dst_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_info_dst_submsg.common().member_flags().IS_DEFAULT(false);
                    mst_info_dst_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageIdentifier(false));

                    mst_info_dst_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_DST);

                    MD5 info_dst_submsg_hash("info_dst_submsg");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_info_dst_submsg.detail().name_hash()[i] = info_dst_submsg_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_info_dst_submsg);

                    MinimalUnionMember mst_unknown_submsg;
                    mst_unknown_submsg.common().member_id(memberId++);
                    mst_unknown_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_unknown_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_unknown_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_unknown_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_unknown_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_unknown_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_unknown_submsg.common().member_flags().IS_DEFAULT(false);
                    mst_unknown_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(false));

                    MD5 unknown_submsg_hash("unknown_submsg");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_unknown_submsg.detail().name_hash()[i] = unknown_submsg_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_unknown_submsg);


                    // Header
                    //type_object->minimal().union_type().header().detail()... // Empty

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("Submessage", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("Submessage", false);
                }

                const TypeObject* GetCompleteSubmessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Submessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_UNION);

                    type_object->complete().union_type().union_flags().IS_FINAL(false);
                    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
                    type_object->complete().union_type().union_flags().IS_NESTED(false);
                    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->complete().union_type().discriminator().common().type_id(*GetSubmessageKindIdentifier(true));

                    MemberId memberId = 0;
                    CompleteUnionMember cst_heartbeat_submsg;
                    cst_heartbeat_submsg.common().member_id(memberId++);
                    cst_heartbeat_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_heartbeat_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_heartbeat_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_heartbeat_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_heartbeat_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_heartbeat_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_heartbeat_submsg.common().member_flags().IS_DEFAULT(false);
                    cst_heartbeat_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetHeartBeatSubmessageIdentifier(true));
                    cst_heartbeat_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::HEARTBEAT);


                    cst_heartbeat_submsg.detail().name("heartbeat_submsg");

                    type_object->complete().union_type().member_seq().emplace_back(cst_heartbeat_submsg);

                    CompleteUnionMember cst_info_ts_submsg;
                    cst_info_ts_submsg.common().member_id(memberId++);
                    cst_info_ts_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_info_ts_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_info_ts_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_info_ts_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_info_ts_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_info_ts_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_info_ts_submsg.common().member_flags().IS_DEFAULT(false);
                    cst_info_ts_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoTimestampSubmessageIdentifier(true));
                    cst_info_ts_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_TS);


                    cst_info_ts_submsg.detail().name("info_ts_submsg");

                    type_object->complete().union_type().member_seq().emplace_back(cst_info_ts_submsg);

                    CompleteUnionMember cst_info_src_submsg;
                    cst_info_src_submsg.common().member_id(memberId++);
                    cst_info_src_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_info_src_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_info_src_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_info_src_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_info_src_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_info_src_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_info_src_submsg.common().member_flags().IS_DEFAULT(false);
                    cst_info_src_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoSourceSubmessageIdentifier(true));
                    cst_info_src_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_SRC);


                    cst_info_src_submsg.detail().name("info_src_submsg");

                    type_object->complete().union_type().member_seq().emplace_back(cst_info_src_submsg);

                    CompleteUnionMember cst_info_dst_submsg;
                    cst_info_dst_submsg.common().member_id(memberId++);
                    cst_info_dst_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_info_dst_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_info_dst_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_info_dst_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_info_dst_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_info_dst_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_info_dst_submsg.common().member_flags().IS_DEFAULT(false);
                    cst_info_dst_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetInfoDestinationSubmessageIdentifier(true));
                    cst_info_dst_submsg.common().label_seq().emplace_back(eprosima::fastdds::rtps::core::INFO_DST);


                    cst_info_dst_submsg.detail().name("info_dst_submsg");

                    type_object->complete().union_type().member_seq().emplace_back(cst_info_dst_submsg);

                    CompleteUnionMember cst_unknown_submsg;
                    cst_unknown_submsg.common().member_id(memberId++);
                    cst_unknown_submsg.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_unknown_submsg.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_unknown_submsg.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_unknown_submsg.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_unknown_submsg.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_unknown_submsg.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_unknown_submsg.common().member_flags().IS_DEFAULT(false);
                    cst_unknown_submsg.common().type_id(*eprosima::fastdds::rtps::core::GetSubmessageHeaderIdentifier(true));

                    cst_unknown_submsg.detail().name("unknown_submsg");

                    type_object->complete().union_type().member_seq().emplace_back(cst_unknown_submsg);


                    // Header
                    type_object->complete().union_type().header().detail().type_name("Submessage");

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("Submessage", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("Submessage", true);
                }





                const TypeIdentifier* GetRTPSMessageIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RTPSMessage", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetRTPSMessageObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("RTPSMessage", complete);
                }

                const TypeObject* GetRTPSMessageObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RTPSMessage", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteRTPSMessageObject();
                    }
                    //else
                    return GetMinimalRTPSMessageObject();
                }

                const TypeObject* GetMinimalRTPSMessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RTPSMessage", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_msg_header;
                    mst_msg_header.common().member_id(memberId++);
                    mst_msg_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_msg_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_msg_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_msg_header.common().member_flags().IS_OPTIONAL(false);
                    mst_msg_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_msg_header.common().member_flags().IS_KEY(false);
                    mst_msg_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_msg_header.common().member_type_id(*eprosima::fastdds::rtps::core::GetHeaderIdentifier(false));

                    MD5 msg_header_hash("msg_header");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_msg_header.detail().name_hash()[i] = msg_header_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_msg_header);

                    MinimalStructMember mst_submessages;
                    mst_submessages.common().member_id(memberId++);
                    mst_submessages.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_submessages.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_submessages.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_submessages.common().member_flags().IS_OPTIONAL(false);
                    mst_submessages.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_submessages.common().member_flags().IS_KEY(false);
                    mst_submessages.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_submessages.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::rtps::core::Submessage", 100, false));

                    MD5 submessages_hash("submessages");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_submessages.detail().name_hash()[i] = submessages_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_submessages);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RTPSMessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RTPSMessage", false);
                }

                const TypeObject* GetCompleteRTPSMessageObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RTPSMessage", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_msg_header;
                    cst_msg_header.common().member_id(memberId++);
                    cst_msg_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_msg_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_msg_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_msg_header.common().member_flags().IS_OPTIONAL(false);
                    cst_msg_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_msg_header.common().member_flags().IS_KEY(false);
                    cst_msg_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_msg_header.common().member_type_id(*eprosima::fastdds::rtps::core::GetHeaderIdentifier(true));

                    cst_msg_header.detail().name("msg_header");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_msg_header);

                    CompleteStructMember cst_submessages;
                    cst_submessages.common().member_id(memberId++);
                    cst_submessages.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_submessages.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_submessages.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_submessages.common().member_flags().IS_OPTIONAL(false);
                    cst_submessages.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_submessages.common().member_flags().IS_KEY(false);
                    cst_submessages.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_submessages.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::rtps::core::Submessage", 100, true));

                    cst_submessages.detail().name("submessages");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_submessages);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("RTPSMessage");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                #if FASTCDR_VERSION_MAJOR == 1
                    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                #else
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                #endif // FASTCDR_VERSION_MAJOR == 1
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RTPSMessage", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RTPSMessage", true);
                }

            } // namespace core
        } // namespace rtps
    } // namespace fastdds
} // namespace eprosima