// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file arraysPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen (version: 4.2.0).
 */

#include "arraysPubSubTypes.hpp"

#include <algorithm>
#include <mutex>

#include <fastdds/dds/log/Log.hpp>
#include <fastdds/rtps/common/CdrSerialization.hpp>

#include "arraysCdrAux.hpp"
#include "arraysTypeObjectSupport.hpp"

using SerializedPayload_t = eprosima::fastdds::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastdds::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

ArrayShortPubSubType::ArrayShortPubSubType()
{
    set_name("ArrayShort");
    uint32_t type_size = ArrayShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayShortPubSubType::~ArrayShortPubSubType()
{
}

bool ArrayShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayShort* p_type =
            static_cast<const ::ArrayShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayShort* p_type =
                static_cast<::ArrayShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayShort* p_type =
                static_cast<const ::ArrayShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayShort());
}

void ArrayShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayShort*>(data));
}

bool ArrayShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayShortPubSubType::register_type_object_representation()
{
    register_ArrayShort_type_identifier(type_identifiers_);
}

ArrayUShortPubSubType::ArrayUShortPubSubType()
{
    set_name("ArrayUShort");
    uint32_t type_size = ArrayUShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayUShortPubSubType::~ArrayUShortPubSubType()
{
}

bool ArrayUShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayUShort* p_type =
            static_cast<const ::ArrayUShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayUShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayUShort* p_type =
                static_cast<::ArrayUShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayUShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayUShort* p_type =
                static_cast<const ::ArrayUShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayUShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayUShort());
}

void ArrayUShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayUShort*>(data));
}

bool ArrayUShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayUShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayUShortPubSubType::register_type_object_representation()
{
    register_ArrayUShort_type_identifier(type_identifiers_);
}

ArrayLongPubSubType::ArrayLongPubSubType()
{
    set_name("ArrayLong");
    uint32_t type_size = ArrayLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayLongPubSubType::~ArrayLongPubSubType()
{
}

bool ArrayLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayLong* p_type =
            static_cast<const ::ArrayLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayLong* p_type =
                static_cast<::ArrayLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayLong* p_type =
                static_cast<const ::ArrayLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayLong());
}

void ArrayLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayLong*>(data));
}

bool ArrayLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayLongPubSubType::register_type_object_representation()
{
    register_ArrayLong_type_identifier(type_identifiers_);
}

ArrayULongPubSubType::ArrayULongPubSubType()
{
    set_name("ArrayULong");
    uint32_t type_size = ArrayULong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayULongPubSubType::~ArrayULongPubSubType()
{
}

bool ArrayULongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayULong* p_type =
            static_cast<const ::ArrayULong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayULongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayULong* p_type =
                static_cast<::ArrayULong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayULongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayULong* p_type =
                static_cast<const ::ArrayULong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayULongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayULong());
}

void ArrayULongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayULong*>(data));
}

bool ArrayULongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayULongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayULongPubSubType::register_type_object_representation()
{
    register_ArrayULong_type_identifier(type_identifiers_);
}

ArrayLongLongPubSubType::ArrayLongLongPubSubType()
{
    set_name("ArrayLongLong");
    uint32_t type_size = ArrayLongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayLongLongPubSubType::~ArrayLongLongPubSubType()
{
}

bool ArrayLongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayLongLong* p_type =
            static_cast<const ::ArrayLongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayLongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayLongLong* p_type =
                static_cast<::ArrayLongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayLongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayLongLong* p_type =
                static_cast<const ::ArrayLongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayLongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayLongLong());
}

void ArrayLongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayLongLong*>(data));
}

bool ArrayLongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayLongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayLongLongPubSubType::register_type_object_representation()
{
    register_ArrayLongLong_type_identifier(type_identifiers_);
}

ArrayULongLongPubSubType::ArrayULongLongPubSubType()
{
    set_name("ArrayULongLong");
    uint32_t type_size = ArrayULongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayULongLongPubSubType::~ArrayULongLongPubSubType()
{
}

bool ArrayULongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayULongLong* p_type =
            static_cast<const ::ArrayULongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayULongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayULongLong* p_type =
                static_cast<::ArrayULongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayULongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayULongLong* p_type =
                static_cast<const ::ArrayULongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayULongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayULongLong());
}

void ArrayULongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayULongLong*>(data));
}

bool ArrayULongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayULongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayULongLongPubSubType::register_type_object_representation()
{
    register_ArrayULongLong_type_identifier(type_identifiers_);
}

ArrayFloatPubSubType::ArrayFloatPubSubType()
{
    set_name("ArrayFloat");
    uint32_t type_size = ArrayFloat_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayFloatPubSubType::~ArrayFloatPubSubType()
{
}

bool ArrayFloatPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayFloat* p_type =
            static_cast<const ::ArrayFloat*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayFloatPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayFloat* p_type =
                static_cast<::ArrayFloat*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayFloatPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayFloat* p_type =
                static_cast<const ::ArrayFloat*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayFloatPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayFloat());
}

void ArrayFloatPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayFloat*>(data));
}

bool ArrayFloatPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayFloatPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayFloatPubSubType::register_type_object_representation()
{
    register_ArrayFloat_type_identifier(type_identifiers_);
}

ArrayDoublePubSubType::ArrayDoublePubSubType()
{
    set_name("ArrayDouble");
    uint32_t type_size = ArrayDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayDoublePubSubType::~ArrayDoublePubSubType()
{
}

bool ArrayDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayDouble* p_type =
            static_cast<const ::ArrayDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayDouble* p_type =
                static_cast<::ArrayDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayDouble* p_type =
                static_cast<const ::ArrayDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayDouble());
}

void ArrayDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayDouble*>(data));
}

bool ArrayDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayDoublePubSubType::register_type_object_representation()
{
    register_ArrayDouble_type_identifier(type_identifiers_);
}

ArrayLongDoublePubSubType::ArrayLongDoublePubSubType()
{
    set_name("ArrayLongDouble");
    uint32_t type_size = ArrayLongDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayLongDoublePubSubType::~ArrayLongDoublePubSubType()
{
}

bool ArrayLongDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayLongDouble* p_type =
            static_cast<const ::ArrayLongDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayLongDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayLongDouble* p_type =
                static_cast<::ArrayLongDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayLongDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayLongDouble* p_type =
                static_cast<const ::ArrayLongDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayLongDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayLongDouble());
}

void ArrayLongDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayLongDouble*>(data));
}

bool ArrayLongDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayLongDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayLongDoublePubSubType::register_type_object_representation()
{
    register_ArrayLongDouble_type_identifier(type_identifiers_);
}

ArrayBooleanPubSubType::ArrayBooleanPubSubType()
{
    set_name("ArrayBoolean");
    uint32_t type_size = ArrayBoolean_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayBooleanPubSubType::~ArrayBooleanPubSubType()
{
}

bool ArrayBooleanPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayBoolean* p_type =
            static_cast<const ::ArrayBoolean*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayBooleanPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayBoolean* p_type =
                static_cast<::ArrayBoolean*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayBooleanPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayBoolean* p_type =
                static_cast<const ::ArrayBoolean*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayBooleanPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayBoolean());
}

void ArrayBooleanPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayBoolean*>(data));
}

bool ArrayBooleanPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayBooleanPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayBooleanPubSubType::register_type_object_representation()
{
    register_ArrayBoolean_type_identifier(type_identifiers_);
}

ArrayOctetPubSubType::ArrayOctetPubSubType()
{
    set_name("ArrayOctet");
    uint32_t type_size = ArrayOctet_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayOctetPubSubType::~ArrayOctetPubSubType()
{
}

bool ArrayOctetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayOctet* p_type =
            static_cast<const ::ArrayOctet*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayOctetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayOctet* p_type =
                static_cast<::ArrayOctet*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayOctetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayOctet* p_type =
                static_cast<const ::ArrayOctet*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayOctetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayOctet());
}

void ArrayOctetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayOctet*>(data));
}

bool ArrayOctetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayOctetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayOctetPubSubType::register_type_object_representation()
{
    register_ArrayOctet_type_identifier(type_identifiers_);
}

ArrayUInt8PubSubType::ArrayUInt8PubSubType()
{
    set_name("ArrayUInt8");
    uint32_t type_size = ArrayUInt8_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayUInt8PubSubType::~ArrayUInt8PubSubType()
{
}

bool ArrayUInt8PubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayUInt8* p_type =
            static_cast<const ::ArrayUInt8*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayUInt8PubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayUInt8* p_type =
                static_cast<::ArrayUInt8*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayUInt8PubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayUInt8* p_type =
                static_cast<const ::ArrayUInt8*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayUInt8PubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayUInt8());
}

void ArrayUInt8PubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayUInt8*>(data));
}

bool ArrayUInt8PubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayUInt8PubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayUInt8PubSubType::register_type_object_representation()
{
    register_ArrayUInt8_type_identifier(type_identifiers_);
}

ArrayCharPubSubType::ArrayCharPubSubType()
{
    set_name("ArrayChar");
    uint32_t type_size = ArrayChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayCharPubSubType::~ArrayCharPubSubType()
{
}

bool ArrayCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayChar* p_type =
            static_cast<const ::ArrayChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayChar* p_type =
                static_cast<::ArrayChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayChar* p_type =
                static_cast<const ::ArrayChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayChar());
}

void ArrayCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayChar*>(data));
}

bool ArrayCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayCharPubSubType::register_type_object_representation()
{
    register_ArrayChar_type_identifier(type_identifiers_);
}

ArrayWCharPubSubType::ArrayWCharPubSubType()
{
    set_name("ArrayWChar");
    uint32_t type_size = ArrayWChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayWCharPubSubType::~ArrayWCharPubSubType()
{
}

bool ArrayWCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayWChar* p_type =
            static_cast<const ::ArrayWChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayWCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayWChar* p_type =
                static_cast<::ArrayWChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayWCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayWChar* p_type =
                static_cast<const ::ArrayWChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayWCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayWChar());
}

void ArrayWCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayWChar*>(data));
}

bool ArrayWCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayWCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayWCharPubSubType::register_type_object_representation()
{
    register_ArrayWChar_type_identifier(type_identifiers_);
}

ArrayStringPubSubType::ArrayStringPubSubType()
{
    set_name("ArrayString");
    uint32_t type_size = ArrayString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayStringPubSubType::~ArrayStringPubSubType()
{
}

bool ArrayStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayString* p_type =
            static_cast<const ::ArrayString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayString* p_type =
                static_cast<::ArrayString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayString* p_type =
                static_cast<const ::ArrayString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayString());
}

void ArrayStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayString*>(data));
}

bool ArrayStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayStringPubSubType::register_type_object_representation()
{
    register_ArrayString_type_identifier(type_identifiers_);
}

ArrayWStringPubSubType::ArrayWStringPubSubType()
{
    set_name("ArrayWString");
    uint32_t type_size = ArrayWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayWStringPubSubType::~ArrayWStringPubSubType()
{
}

bool ArrayWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayWString* p_type =
            static_cast<const ::ArrayWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayWString* p_type =
                static_cast<::ArrayWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayWString* p_type =
                static_cast<const ::ArrayWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayWString());
}

void ArrayWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayWString*>(data));
}

bool ArrayWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayWStringPubSubType::register_type_object_representation()
{
    register_ArrayWString_type_identifier(type_identifiers_);
}

ArrayBoundedStringPubSubType::ArrayBoundedStringPubSubType()
{
    set_name("ArrayBoundedString");
    uint32_t type_size = ArrayBoundedString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayBoundedStringPubSubType::~ArrayBoundedStringPubSubType()
{
}

bool ArrayBoundedStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayBoundedString* p_type =
            static_cast<const ::ArrayBoundedString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayBoundedStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayBoundedString* p_type =
                static_cast<::ArrayBoundedString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayBoundedStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayBoundedString* p_type =
                static_cast<const ::ArrayBoundedString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayBoundedStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayBoundedString());
}

void ArrayBoundedStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayBoundedString*>(data));
}

bool ArrayBoundedStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayBoundedStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayBoundedStringPubSubType::register_type_object_representation()
{
    register_ArrayBoundedString_type_identifier(type_identifiers_);
}

ArrayBoundedWStringPubSubType::ArrayBoundedWStringPubSubType()
{
    set_name("ArrayBoundedWString");
    uint32_t type_size = ArrayBoundedWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayBoundedWStringPubSubType::~ArrayBoundedWStringPubSubType()
{
}

bool ArrayBoundedWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayBoundedWString* p_type =
            static_cast<const ::ArrayBoundedWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayBoundedWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayBoundedWString* p_type =
                static_cast<::ArrayBoundedWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayBoundedWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayBoundedWString* p_type =
                static_cast<const ::ArrayBoundedWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayBoundedWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayBoundedWString());
}

void ArrayBoundedWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayBoundedWString*>(data));
}

bool ArrayBoundedWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayBoundedWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayBoundedWStringPubSubType::register_type_object_representation()
{
    register_ArrayBoundedWString_type_identifier(type_identifiers_);
}

ArrayEnumPubSubType::ArrayEnumPubSubType()
{
    set_name("ArrayEnum");
    uint32_t type_size = ArrayEnum_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayEnumPubSubType::~ArrayEnumPubSubType()
{
}

bool ArrayEnumPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayEnum* p_type =
            static_cast<const ::ArrayEnum*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayEnumPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayEnum* p_type =
                static_cast<::ArrayEnum*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayEnumPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayEnum* p_type =
                static_cast<const ::ArrayEnum*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayEnumPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayEnum());
}

void ArrayEnumPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayEnum*>(data));
}

bool ArrayEnumPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayEnumPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayEnumPubSubType::register_type_object_representation()
{
    register_ArrayEnum_type_identifier(type_identifiers_);
}

ArrayBitMaskPubSubType::ArrayBitMaskPubSubType()
{
    set_name("ArrayBitMask");
    uint32_t type_size = ArrayBitMask_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayBitMaskPubSubType::~ArrayBitMaskPubSubType()
{
}

bool ArrayBitMaskPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayBitMask* p_type =
            static_cast<const ::ArrayBitMask*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayBitMaskPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayBitMask* p_type =
                static_cast<::ArrayBitMask*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayBitMaskPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayBitMask* p_type =
                static_cast<const ::ArrayBitMask*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayBitMaskPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayBitMask());
}

void ArrayBitMaskPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayBitMask*>(data));
}

bool ArrayBitMaskPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayBitMaskPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayBitMaskPubSubType::register_type_object_representation()
{
    register_ArrayBitMask_type_identifier(type_identifiers_);
}

ArrayAliasPubSubType::ArrayAliasPubSubType()
{
    set_name("ArrayAlias");
    uint32_t type_size = ArrayAlias_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayAliasPubSubType::~ArrayAliasPubSubType()
{
}

bool ArrayAliasPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayAlias* p_type =
            static_cast<const ::ArrayAlias*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayAliasPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayAlias* p_type =
                static_cast<::ArrayAlias*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayAliasPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayAlias* p_type =
                static_cast<const ::ArrayAlias*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayAliasPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayAlias());
}

void ArrayAliasPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayAlias*>(data));
}

bool ArrayAliasPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayAliasPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayAliasPubSubType::register_type_object_representation()
{
    register_ArrayAlias_type_identifier(type_identifiers_);
}

ArrayShortArrayPubSubType::ArrayShortArrayPubSubType()
{
    set_name("ArrayShortArray");
    uint32_t type_size = ArrayShortArray_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayShortArrayPubSubType::~ArrayShortArrayPubSubType()
{
}

bool ArrayShortArrayPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayShortArray* p_type =
            static_cast<const ::ArrayShortArray*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayShortArrayPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayShortArray* p_type =
                static_cast<::ArrayShortArray*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayShortArrayPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayShortArray* p_type =
                static_cast<const ::ArrayShortArray*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayShortArrayPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayShortArray());
}

void ArrayShortArrayPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayShortArray*>(data));
}

bool ArrayShortArrayPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayShortArrayPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayShortArrayPubSubType::register_type_object_representation()
{
    register_ArrayShortArray_type_identifier(type_identifiers_);
}

ArraySequencePubSubType::ArraySequencePubSubType()
{
    set_name("ArraySequence");
    uint32_t type_size = ArraySequence_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySequencePubSubType::~ArraySequencePubSubType()
{
}

bool ArraySequencePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySequence* p_type =
            static_cast<const ::ArraySequence*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySequencePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySequence* p_type =
                static_cast<::ArraySequence*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySequencePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySequence* p_type =
                static_cast<const ::ArraySequence*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySequencePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySequence());
}

void ArraySequencePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySequence*>(data));
}

bool ArraySequencePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySequencePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySequencePubSubType::register_type_object_representation()
{
    register_ArraySequence_type_identifier(type_identifiers_);
}

ArrayMapPubSubType::ArrayMapPubSubType()
{
    set_name("ArrayMap");
    uint32_t type_size = ArrayMap_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMapPubSubType::~ArrayMapPubSubType()
{
}

bool ArrayMapPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMap* p_type =
            static_cast<const ::ArrayMap*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMapPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMap* p_type =
                static_cast<::ArrayMap*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMapPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMap* p_type =
                static_cast<const ::ArrayMap*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMapPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMap());
}

void ArrayMapPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMap*>(data));
}

bool ArrayMapPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMapPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMapPubSubType::register_type_object_representation()
{
    register_ArrayMap_type_identifier(type_identifiers_);
}

ArrayUnionPubSubType::ArrayUnionPubSubType()
{
    set_name("ArrayUnion");
    uint32_t type_size = ArrayUnion_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayUnionPubSubType::~ArrayUnionPubSubType()
{
}

bool ArrayUnionPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayUnion* p_type =
            static_cast<const ::ArrayUnion*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayUnionPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayUnion* p_type =
                static_cast<::ArrayUnion*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayUnionPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayUnion* p_type =
                static_cast<const ::ArrayUnion*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayUnionPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayUnion());
}

void ArrayUnionPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayUnion*>(data));
}

bool ArrayUnionPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayUnionPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayUnionPubSubType::register_type_object_representation()
{
    register_ArrayUnion_type_identifier(type_identifiers_);
}

ArrayStructurePubSubType::ArrayStructurePubSubType()
{
    set_name("ArrayStructure");
    uint32_t type_size = ArrayStructure_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayStructurePubSubType::~ArrayStructurePubSubType()
{
}

bool ArrayStructurePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayStructure* p_type =
            static_cast<const ::ArrayStructure*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayStructurePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayStructure* p_type =
                static_cast<::ArrayStructure*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayStructurePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayStructure* p_type =
                static_cast<const ::ArrayStructure*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayStructurePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayStructure());
}

void ArrayStructurePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayStructure*>(data));
}

bool ArrayStructurePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayStructurePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayStructurePubSubType::register_type_object_representation()
{
    register_ArrayStructure_type_identifier(type_identifiers_);
}

ArrayBitsetPubSubType::ArrayBitsetPubSubType()
{
    set_name("ArrayBitset");
    uint32_t type_size = ArrayBitset_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayBitsetPubSubType::~ArrayBitsetPubSubType()
{
}

bool ArrayBitsetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayBitset* p_type =
            static_cast<const ::ArrayBitset*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayBitsetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayBitset* p_type =
                static_cast<::ArrayBitset*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayBitsetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayBitset* p_type =
                static_cast<const ::ArrayBitset*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayBitsetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayBitset());
}

void ArrayBitsetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayBitset*>(data));
}

bool ArrayBitsetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayBitsetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayBitsetPubSubType::register_type_object_representation()
{
    register_ArrayBitset_type_identifier(type_identifiers_);
}

ArrayMultiDimensionShortPubSubType::ArrayMultiDimensionShortPubSubType()
{
    set_name("ArrayMultiDimensionShort");
    uint32_t type_size = ArrayMultiDimensionShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionShortPubSubType::~ArrayMultiDimensionShortPubSubType()
{
}

bool ArrayMultiDimensionShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionShort* p_type =
            static_cast<const ::ArrayMultiDimensionShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionShort* p_type =
                static_cast<::ArrayMultiDimensionShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionShort* p_type =
                static_cast<const ::ArrayMultiDimensionShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionShort());
}

void ArrayMultiDimensionShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionShort*>(data));
}

bool ArrayMultiDimensionShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionShortPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionShort_type_identifier(type_identifiers_);
}

ArrayMultiDimensionUShortPubSubType::ArrayMultiDimensionUShortPubSubType()
{
    set_name("ArrayMultiDimensionUShort");
    uint32_t type_size = ArrayMultiDimensionUShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionUShortPubSubType::~ArrayMultiDimensionUShortPubSubType()
{
}

bool ArrayMultiDimensionUShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionUShort* p_type =
            static_cast<const ::ArrayMultiDimensionUShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionUShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionUShort* p_type =
                static_cast<::ArrayMultiDimensionUShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionUShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionUShort* p_type =
                static_cast<const ::ArrayMultiDimensionUShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionUShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionUShort());
}

void ArrayMultiDimensionUShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionUShort*>(data));
}

bool ArrayMultiDimensionUShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionUShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionUShortPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionUShort_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLongPubSubType::ArrayMultiDimensionLongPubSubType()
{
    set_name("ArrayMultiDimensionLong");
    uint32_t type_size = ArrayMultiDimensionLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLongPubSubType::~ArrayMultiDimensionLongPubSubType()
{
}

bool ArrayMultiDimensionLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLong* p_type =
            static_cast<const ::ArrayMultiDimensionLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLong* p_type =
                static_cast<::ArrayMultiDimensionLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLong* p_type =
                static_cast<const ::ArrayMultiDimensionLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLong());
}

void ArrayMultiDimensionLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLong*>(data));
}

bool ArrayMultiDimensionLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionULongPubSubType::ArrayMultiDimensionULongPubSubType()
{
    set_name("ArrayMultiDimensionULong");
    uint32_t type_size = ArrayMultiDimensionULong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionULongPubSubType::~ArrayMultiDimensionULongPubSubType()
{
}

bool ArrayMultiDimensionULongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionULong* p_type =
            static_cast<const ::ArrayMultiDimensionULong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionULongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionULong* p_type =
                static_cast<::ArrayMultiDimensionULong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionULongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionULong* p_type =
                static_cast<const ::ArrayMultiDimensionULong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionULongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionULong());
}

void ArrayMultiDimensionULongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionULong*>(data));
}

bool ArrayMultiDimensionULongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionULongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionULongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionULong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLongLongPubSubType::ArrayMultiDimensionLongLongPubSubType()
{
    set_name("ArrayMultiDimensionLongLong");
    uint32_t type_size = ArrayMultiDimensionLongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLongLongPubSubType::~ArrayMultiDimensionLongLongPubSubType()
{
}

bool ArrayMultiDimensionLongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLongLong* p_type =
            static_cast<const ::ArrayMultiDimensionLongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLongLong* p_type =
                static_cast<::ArrayMultiDimensionLongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLongLong* p_type =
                static_cast<const ::ArrayMultiDimensionLongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLongLong());
}

void ArrayMultiDimensionLongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLongLong*>(data));
}

bool ArrayMultiDimensionLongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLongLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLongLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionULongLongPubSubType::ArrayMultiDimensionULongLongPubSubType()
{
    set_name("ArrayMultiDimensionULongLong");
    uint32_t type_size = ArrayMultiDimensionULongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionULongLongPubSubType::~ArrayMultiDimensionULongLongPubSubType()
{
}

bool ArrayMultiDimensionULongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionULongLong* p_type =
            static_cast<const ::ArrayMultiDimensionULongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionULongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionULongLong* p_type =
                static_cast<::ArrayMultiDimensionULongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionULongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionULongLong* p_type =
                static_cast<const ::ArrayMultiDimensionULongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionULongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionULongLong());
}

void ArrayMultiDimensionULongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionULongLong*>(data));
}

bool ArrayMultiDimensionULongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionULongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionULongLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionULongLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionFloatPubSubType::ArrayMultiDimensionFloatPubSubType()
{
    set_name("ArrayMultiDimensionFloat");
    uint32_t type_size = ArrayMultiDimensionFloat_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionFloatPubSubType::~ArrayMultiDimensionFloatPubSubType()
{
}

bool ArrayMultiDimensionFloatPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionFloat* p_type =
            static_cast<const ::ArrayMultiDimensionFloat*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionFloatPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionFloat* p_type =
                static_cast<::ArrayMultiDimensionFloat*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionFloatPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionFloat* p_type =
                static_cast<const ::ArrayMultiDimensionFloat*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionFloatPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionFloat());
}

void ArrayMultiDimensionFloatPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionFloat*>(data));
}

bool ArrayMultiDimensionFloatPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionFloatPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionFloatPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionFloat_type_identifier(type_identifiers_);
}

ArrayMultiDimensionDoublePubSubType::ArrayMultiDimensionDoublePubSubType()
{
    set_name("ArrayMultiDimensionDouble");
    uint32_t type_size = ArrayMultiDimensionDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionDoublePubSubType::~ArrayMultiDimensionDoublePubSubType()
{
}

bool ArrayMultiDimensionDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionDouble* p_type =
            static_cast<const ::ArrayMultiDimensionDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionDouble* p_type =
                static_cast<::ArrayMultiDimensionDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionDouble* p_type =
                static_cast<const ::ArrayMultiDimensionDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionDouble());
}

void ArrayMultiDimensionDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionDouble*>(data));
}

bool ArrayMultiDimensionDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionDoublePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionDouble_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLongDoublePubSubType::ArrayMultiDimensionLongDoublePubSubType()
{
    set_name("ArrayMultiDimensionLongDouble");
    uint32_t type_size = ArrayMultiDimensionLongDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLongDoublePubSubType::~ArrayMultiDimensionLongDoublePubSubType()
{
}

bool ArrayMultiDimensionLongDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLongDouble* p_type =
            static_cast<const ::ArrayMultiDimensionLongDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLongDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLongDouble* p_type =
                static_cast<::ArrayMultiDimensionLongDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLongDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLongDouble* p_type =
                static_cast<const ::ArrayMultiDimensionLongDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLongDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLongDouble());
}

void ArrayMultiDimensionLongDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLongDouble*>(data));
}

bool ArrayMultiDimensionLongDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLongDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLongDoublePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLongDouble_type_identifier(type_identifiers_);
}

ArrayMultiDimensionBooleanPubSubType::ArrayMultiDimensionBooleanPubSubType()
{
    set_name("ArrayMultiDimensionBoolean");
    uint32_t type_size = ArrayMultiDimensionBoolean_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionBooleanPubSubType::~ArrayMultiDimensionBooleanPubSubType()
{
}

bool ArrayMultiDimensionBooleanPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionBoolean* p_type =
            static_cast<const ::ArrayMultiDimensionBoolean*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionBooleanPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionBoolean* p_type =
                static_cast<::ArrayMultiDimensionBoolean*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionBooleanPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionBoolean* p_type =
                static_cast<const ::ArrayMultiDimensionBoolean*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionBooleanPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionBoolean());
}

void ArrayMultiDimensionBooleanPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionBoolean*>(data));
}

bool ArrayMultiDimensionBooleanPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionBooleanPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionBooleanPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionBoolean_type_identifier(type_identifiers_);
}

ArrayMultiDimensionOctetPubSubType::ArrayMultiDimensionOctetPubSubType()
{
    set_name("ArrayMultiDimensionOctet");
    uint32_t type_size = ArrayMultiDimensionOctet_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionOctetPubSubType::~ArrayMultiDimensionOctetPubSubType()
{
}

bool ArrayMultiDimensionOctetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionOctet* p_type =
            static_cast<const ::ArrayMultiDimensionOctet*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionOctetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionOctet* p_type =
                static_cast<::ArrayMultiDimensionOctet*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionOctetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionOctet* p_type =
                static_cast<const ::ArrayMultiDimensionOctet*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionOctetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionOctet());
}

void ArrayMultiDimensionOctetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionOctet*>(data));
}

bool ArrayMultiDimensionOctetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionOctetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionOctetPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionOctet_type_identifier(type_identifiers_);
}

ArrayMultiDimensionCharPubSubType::ArrayMultiDimensionCharPubSubType()
{
    set_name("ArrayMultiDimensionChar");
    uint32_t type_size = ArrayMultiDimensionChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionCharPubSubType::~ArrayMultiDimensionCharPubSubType()
{
}

bool ArrayMultiDimensionCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionChar* p_type =
            static_cast<const ::ArrayMultiDimensionChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionChar* p_type =
                static_cast<::ArrayMultiDimensionChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionChar* p_type =
                static_cast<const ::ArrayMultiDimensionChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionChar());
}

void ArrayMultiDimensionCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionChar*>(data));
}

bool ArrayMultiDimensionCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionCharPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionChar_type_identifier(type_identifiers_);
}

ArrayMultiDimensionWCharPubSubType::ArrayMultiDimensionWCharPubSubType()
{
    set_name("ArrayMultiDimensionWChar");
    uint32_t type_size = ArrayMultiDimensionWChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionWCharPubSubType::~ArrayMultiDimensionWCharPubSubType()
{
}

bool ArrayMultiDimensionWCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionWChar* p_type =
            static_cast<const ::ArrayMultiDimensionWChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionWCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionWChar* p_type =
                static_cast<::ArrayMultiDimensionWChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionWCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionWChar* p_type =
                static_cast<const ::ArrayMultiDimensionWChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionWCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionWChar());
}

void ArrayMultiDimensionWCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionWChar*>(data));
}

bool ArrayMultiDimensionWCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionWCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionWCharPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionWChar_type_identifier(type_identifiers_);
}

ArrayMultiDimensionStringPubSubType::ArrayMultiDimensionStringPubSubType()
{
    set_name("ArrayMultiDimensionString");
    uint32_t type_size = ArrayMultiDimensionString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionStringPubSubType::~ArrayMultiDimensionStringPubSubType()
{
}

bool ArrayMultiDimensionStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionString* p_type =
            static_cast<const ::ArrayMultiDimensionString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionString* p_type =
                static_cast<::ArrayMultiDimensionString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionString* p_type =
                static_cast<const ::ArrayMultiDimensionString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionString());
}

void ArrayMultiDimensionStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionString*>(data));
}

bool ArrayMultiDimensionStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionWStringPubSubType::ArrayMultiDimensionWStringPubSubType()
{
    set_name("ArrayMultiDimensionWString");
    uint32_t type_size = ArrayMultiDimensionWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionWStringPubSubType::~ArrayMultiDimensionWStringPubSubType()
{
}

bool ArrayMultiDimensionWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionWString* p_type =
            static_cast<const ::ArrayMultiDimensionWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionWString* p_type =
                static_cast<::ArrayMultiDimensionWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionWString* p_type =
                static_cast<const ::ArrayMultiDimensionWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionWString());
}

void ArrayMultiDimensionWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionWString*>(data));
}

bool ArrayMultiDimensionWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionWStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionWString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionBoundedStringPubSubType::ArrayMultiDimensionBoundedStringPubSubType()
{
    set_name("ArrayMultiDimensionBoundedString");
    uint32_t type_size = ArrayMultiDimensionBoundedString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionBoundedStringPubSubType::~ArrayMultiDimensionBoundedStringPubSubType()
{
}

bool ArrayMultiDimensionBoundedStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionBoundedString* p_type =
            static_cast<const ::ArrayMultiDimensionBoundedString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionBoundedStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionBoundedString* p_type =
                static_cast<::ArrayMultiDimensionBoundedString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionBoundedStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionBoundedString* p_type =
                static_cast<const ::ArrayMultiDimensionBoundedString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionBoundedStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionBoundedString());
}

void ArrayMultiDimensionBoundedStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionBoundedString*>(data));
}

bool ArrayMultiDimensionBoundedStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionBoundedStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionBoundedStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionBoundedString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionBoundedWStringPubSubType::ArrayMultiDimensionBoundedWStringPubSubType()
{
    set_name("ArrayMultiDimensionBoundedWString");
    uint32_t type_size = ArrayMultiDimensionBoundedWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionBoundedWStringPubSubType::~ArrayMultiDimensionBoundedWStringPubSubType()
{
}

bool ArrayMultiDimensionBoundedWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionBoundedWString* p_type =
            static_cast<const ::ArrayMultiDimensionBoundedWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionBoundedWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionBoundedWString* p_type =
                static_cast<::ArrayMultiDimensionBoundedWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionBoundedWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionBoundedWString* p_type =
                static_cast<const ::ArrayMultiDimensionBoundedWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionBoundedWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionBoundedWString());
}

void ArrayMultiDimensionBoundedWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionBoundedWString*>(data));
}

bool ArrayMultiDimensionBoundedWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionBoundedWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionBoundedWStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionBoundedWString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionEnumPubSubType::ArrayMultiDimensionEnumPubSubType()
{
    set_name("ArrayMultiDimensionEnum");
    uint32_t type_size = ArrayMultiDimensionEnum_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionEnumPubSubType::~ArrayMultiDimensionEnumPubSubType()
{
}

bool ArrayMultiDimensionEnumPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionEnum* p_type =
            static_cast<const ::ArrayMultiDimensionEnum*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionEnumPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionEnum* p_type =
                static_cast<::ArrayMultiDimensionEnum*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionEnumPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionEnum* p_type =
                static_cast<const ::ArrayMultiDimensionEnum*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionEnumPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionEnum());
}

void ArrayMultiDimensionEnumPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionEnum*>(data));
}

bool ArrayMultiDimensionEnumPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionEnumPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionEnumPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionEnum_type_identifier(type_identifiers_);
}

ArrayMultiDimensionBitMaskPubSubType::ArrayMultiDimensionBitMaskPubSubType()
{
    set_name("ArrayMultiDimensionBitMask");
    uint32_t type_size = ArrayMultiDimensionBitMask_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionBitMaskPubSubType::~ArrayMultiDimensionBitMaskPubSubType()
{
}

bool ArrayMultiDimensionBitMaskPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionBitMask* p_type =
            static_cast<const ::ArrayMultiDimensionBitMask*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionBitMaskPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionBitMask* p_type =
                static_cast<::ArrayMultiDimensionBitMask*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionBitMaskPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionBitMask* p_type =
                static_cast<const ::ArrayMultiDimensionBitMask*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionBitMaskPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionBitMask());
}

void ArrayMultiDimensionBitMaskPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionBitMask*>(data));
}

bool ArrayMultiDimensionBitMaskPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionBitMaskPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionBitMaskPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionBitMask_type_identifier(type_identifiers_);
}

ArrayMultiDimensionAliasPubSubType::ArrayMultiDimensionAliasPubSubType()
{
    set_name("ArrayMultiDimensionAlias");
    uint32_t type_size = ArrayMultiDimensionAlias_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionAliasPubSubType::~ArrayMultiDimensionAliasPubSubType()
{
}

bool ArrayMultiDimensionAliasPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionAlias* p_type =
            static_cast<const ::ArrayMultiDimensionAlias*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionAliasPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionAlias* p_type =
                static_cast<::ArrayMultiDimensionAlias*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionAliasPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionAlias* p_type =
                static_cast<const ::ArrayMultiDimensionAlias*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionAliasPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionAlias());
}

void ArrayMultiDimensionAliasPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionAlias*>(data));
}

bool ArrayMultiDimensionAliasPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionAliasPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionAliasPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionAlias_type_identifier(type_identifiers_);
}

ArrayMultiDimensionSequencePubSubType::ArrayMultiDimensionSequencePubSubType()
{
    set_name("ArrayMultiDimensionSequence");
    uint32_t type_size = ArrayMultiDimensionSequence_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionSequencePubSubType::~ArrayMultiDimensionSequencePubSubType()
{
}

bool ArrayMultiDimensionSequencePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionSequence* p_type =
            static_cast<const ::ArrayMultiDimensionSequence*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionSequencePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionSequence* p_type =
                static_cast<::ArrayMultiDimensionSequence*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionSequencePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionSequence* p_type =
                static_cast<const ::ArrayMultiDimensionSequence*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionSequencePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionSequence());
}

void ArrayMultiDimensionSequencePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionSequence*>(data));
}

bool ArrayMultiDimensionSequencePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionSequencePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionSequencePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionSequence_type_identifier(type_identifiers_);
}

ArrayMultiDimensionMapPubSubType::ArrayMultiDimensionMapPubSubType()
{
    set_name("ArrayMultiDimensionMap");
    uint32_t type_size = ArrayMultiDimensionMap_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionMapPubSubType::~ArrayMultiDimensionMapPubSubType()
{
}

bool ArrayMultiDimensionMapPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionMap* p_type =
            static_cast<const ::ArrayMultiDimensionMap*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionMapPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionMap* p_type =
                static_cast<::ArrayMultiDimensionMap*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionMapPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionMap* p_type =
                static_cast<const ::ArrayMultiDimensionMap*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionMapPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionMap());
}

void ArrayMultiDimensionMapPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionMap*>(data));
}

bool ArrayMultiDimensionMapPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionMapPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionMapPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionMap_type_identifier(type_identifiers_);
}

ArrayMultiDimensionUnionPubSubType::ArrayMultiDimensionUnionPubSubType()
{
    set_name("ArrayMultiDimensionUnion");
    uint32_t type_size = ArrayMultiDimensionUnion_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionUnionPubSubType::~ArrayMultiDimensionUnionPubSubType()
{
}

bool ArrayMultiDimensionUnionPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionUnion* p_type =
            static_cast<const ::ArrayMultiDimensionUnion*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionUnionPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionUnion* p_type =
                static_cast<::ArrayMultiDimensionUnion*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionUnionPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionUnion* p_type =
                static_cast<const ::ArrayMultiDimensionUnion*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionUnionPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionUnion());
}

void ArrayMultiDimensionUnionPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionUnion*>(data));
}

bool ArrayMultiDimensionUnionPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionUnionPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionUnionPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionUnion_type_identifier(type_identifiers_);
}

ArrayMultiDimensionStructurePubSubType::ArrayMultiDimensionStructurePubSubType()
{
    set_name("ArrayMultiDimensionStructure");
    uint32_t type_size = ArrayMultiDimensionStructure_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionStructurePubSubType::~ArrayMultiDimensionStructurePubSubType()
{
}

bool ArrayMultiDimensionStructurePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionStructure* p_type =
            static_cast<const ::ArrayMultiDimensionStructure*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionStructurePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionStructure* p_type =
                static_cast<::ArrayMultiDimensionStructure*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionStructurePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionStructure* p_type =
                static_cast<const ::ArrayMultiDimensionStructure*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionStructurePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionStructure());
}

void ArrayMultiDimensionStructurePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionStructure*>(data));
}

bool ArrayMultiDimensionStructurePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionStructurePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionStructurePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionStructure_type_identifier(type_identifiers_);
}

ArrayMultiDimensionBitsetPubSubType::ArrayMultiDimensionBitsetPubSubType()
{
    set_name("ArrayMultiDimensionBitset");
    uint32_t type_size = ArrayMultiDimensionBitset_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionBitsetPubSubType::~ArrayMultiDimensionBitsetPubSubType()
{
}

bool ArrayMultiDimensionBitsetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionBitset* p_type =
            static_cast<const ::ArrayMultiDimensionBitset*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionBitsetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionBitset* p_type =
                static_cast<::ArrayMultiDimensionBitset*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionBitsetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionBitset* p_type =
                static_cast<const ::ArrayMultiDimensionBitset*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionBitsetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionBitset());
}

void ArrayMultiDimensionBitsetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionBitset*>(data));
}

bool ArrayMultiDimensionBitsetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionBitsetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionBitsetPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionBitset_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsShortPubSubType::ArraySingleDimensionLiteralsShortPubSubType()
{
    set_name("ArraySingleDimensionLiteralsShort");
    uint32_t type_size = ArraySingleDimensionLiteralsShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsShortPubSubType::~ArraySingleDimensionLiteralsShortPubSubType()
{
}

bool ArraySingleDimensionLiteralsShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsShort* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsShort* p_type =
                static_cast<::ArraySingleDimensionLiteralsShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsShort* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsShort());
}

void ArraySingleDimensionLiteralsShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsShort*>(data));
}

bool ArraySingleDimensionLiteralsShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsShortPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsShort_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsUnsignedShortPubSubType::ArraySingleDimensionLiteralsUnsignedShortPubSubType()
{
    set_name("ArraySingleDimensionLiteralsUnsignedShort");
    uint32_t type_size = ArraySingleDimensionLiteralsUnsignedShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsUnsignedShortPubSubType::~ArraySingleDimensionLiteralsUnsignedShortPubSubType()
{
}

bool ArraySingleDimensionLiteralsUnsignedShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsUnsignedShort* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsUnsignedShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsUnsignedShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsUnsignedShort* p_type =
                static_cast<::ArraySingleDimensionLiteralsUnsignedShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsUnsignedShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsUnsignedShort* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsUnsignedShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsUnsignedShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsUnsignedShort());
}

void ArraySingleDimensionLiteralsUnsignedShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsUnsignedShort*>(data));
}

bool ArraySingleDimensionLiteralsUnsignedShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsUnsignedShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsUnsignedShortPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsUnsignedShort_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsLongPubSubType::ArraySingleDimensionLiteralsLongPubSubType()
{
    set_name("ArraySingleDimensionLiteralsLong");
    uint32_t type_size = ArraySingleDimensionLiteralsLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsLongPubSubType::~ArraySingleDimensionLiteralsLongPubSubType()
{
}

bool ArraySingleDimensionLiteralsLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsLong* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsLong* p_type =
                static_cast<::ArraySingleDimensionLiteralsLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsLong* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsLong());
}

void ArraySingleDimensionLiteralsLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsLong*>(data));
}

bool ArraySingleDimensionLiteralsLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsLongPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsLong_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsUnsignedLongPubSubType::ArraySingleDimensionLiteralsUnsignedLongPubSubType()
{
    set_name("ArraySingleDimensionLiteralsUnsignedLong");
    uint32_t type_size = ArraySingleDimensionLiteralsUnsignedLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsUnsignedLongPubSubType::~ArraySingleDimensionLiteralsUnsignedLongPubSubType()
{
}

bool ArraySingleDimensionLiteralsUnsignedLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsUnsignedLong* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsUnsignedLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsUnsignedLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsUnsignedLong* p_type =
                static_cast<::ArraySingleDimensionLiteralsUnsignedLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsUnsignedLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsUnsignedLong* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsUnsignedLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsUnsignedLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsUnsignedLong());
}

void ArraySingleDimensionLiteralsUnsignedLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsUnsignedLong*>(data));
}

bool ArraySingleDimensionLiteralsUnsignedLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsUnsignedLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsUnsignedLongPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsUnsignedLong_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsLongLongPubSubType::ArraySingleDimensionLiteralsLongLongPubSubType()
{
    set_name("ArraySingleDimensionLiteralsLongLong");
    uint32_t type_size = ArraySingleDimensionLiteralsLongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsLongLongPubSubType::~ArraySingleDimensionLiteralsLongLongPubSubType()
{
}

bool ArraySingleDimensionLiteralsLongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsLongLong* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsLongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsLongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsLongLong* p_type =
                static_cast<::ArraySingleDimensionLiteralsLongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsLongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsLongLong* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsLongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsLongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsLongLong());
}

void ArraySingleDimensionLiteralsLongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsLongLong*>(data));
}

bool ArraySingleDimensionLiteralsLongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsLongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsLongLongPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsLongLong_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::ArraySingleDimensionLiteralsUnsignedLongLongPubSubType()
{
    set_name("ArraySingleDimensionLiteralsUnsignedLongLong");
    uint32_t type_size = ArraySingleDimensionLiteralsUnsignedLongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::~ArraySingleDimensionLiteralsUnsignedLongLongPubSubType()
{
}

bool ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsUnsignedLongLong* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsUnsignedLongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsUnsignedLongLong* p_type =
                static_cast<::ArraySingleDimensionLiteralsUnsignedLongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsUnsignedLongLong* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsUnsignedLongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsUnsignedLongLong());
}

void ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsUnsignedLongLong*>(data));
}

bool ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsUnsignedLongLongPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsUnsignedLongLong_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsFloatPubSubType::ArraySingleDimensionLiteralsFloatPubSubType()
{
    set_name("ArraySingleDimensionLiteralsFloat");
    uint32_t type_size = ArraySingleDimensionLiteralsFloat_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsFloatPubSubType::~ArraySingleDimensionLiteralsFloatPubSubType()
{
}

bool ArraySingleDimensionLiteralsFloatPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsFloat* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsFloat*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsFloatPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsFloat* p_type =
                static_cast<::ArraySingleDimensionLiteralsFloat*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsFloatPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsFloat* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsFloat*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsFloatPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsFloat());
}

void ArraySingleDimensionLiteralsFloatPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsFloat*>(data));
}

bool ArraySingleDimensionLiteralsFloatPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsFloatPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsFloatPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsFloat_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsDoublePubSubType::ArraySingleDimensionLiteralsDoublePubSubType()
{
    set_name("ArraySingleDimensionLiteralsDouble");
    uint32_t type_size = ArraySingleDimensionLiteralsDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsDoublePubSubType::~ArraySingleDimensionLiteralsDoublePubSubType()
{
}

bool ArraySingleDimensionLiteralsDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsDouble* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsDouble* p_type =
                static_cast<::ArraySingleDimensionLiteralsDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsDouble* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsDouble());
}

void ArraySingleDimensionLiteralsDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsDouble*>(data));
}

bool ArraySingleDimensionLiteralsDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsDoublePubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsDouble_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsLongDoublePubSubType::ArraySingleDimensionLiteralsLongDoublePubSubType()
{
    set_name("ArraySingleDimensionLiteralsLongDouble");
    uint32_t type_size = ArraySingleDimensionLiteralsLongDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsLongDoublePubSubType::~ArraySingleDimensionLiteralsLongDoublePubSubType()
{
}

bool ArraySingleDimensionLiteralsLongDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsLongDouble* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsLongDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsLongDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsLongDouble* p_type =
                static_cast<::ArraySingleDimensionLiteralsLongDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsLongDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsLongDouble* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsLongDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsLongDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsLongDouble());
}

void ArraySingleDimensionLiteralsLongDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsLongDouble*>(data));
}

bool ArraySingleDimensionLiteralsLongDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsLongDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsLongDoublePubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsLongDouble_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsBooleanPubSubType::ArraySingleDimensionLiteralsBooleanPubSubType()
{
    set_name("ArraySingleDimensionLiteralsBoolean");
    uint32_t type_size = ArraySingleDimensionLiteralsBoolean_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsBooleanPubSubType::~ArraySingleDimensionLiteralsBooleanPubSubType()
{
}

bool ArraySingleDimensionLiteralsBooleanPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsBoolean* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsBoolean*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsBooleanPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsBoolean* p_type =
                static_cast<::ArraySingleDimensionLiteralsBoolean*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsBooleanPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsBoolean* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsBoolean*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsBooleanPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsBoolean());
}

void ArraySingleDimensionLiteralsBooleanPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsBoolean*>(data));
}

bool ArraySingleDimensionLiteralsBooleanPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsBooleanPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsBooleanPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsBoolean_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsOctetPubSubType::ArraySingleDimensionLiteralsOctetPubSubType()
{
    set_name("ArraySingleDimensionLiteralsOctet");
    uint32_t type_size = ArraySingleDimensionLiteralsOctet_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsOctetPubSubType::~ArraySingleDimensionLiteralsOctetPubSubType()
{
}

bool ArraySingleDimensionLiteralsOctetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsOctet* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsOctet*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsOctetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsOctet* p_type =
                static_cast<::ArraySingleDimensionLiteralsOctet*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsOctetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsOctet* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsOctet*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsOctetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsOctet());
}

void ArraySingleDimensionLiteralsOctetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsOctet*>(data));
}

bool ArraySingleDimensionLiteralsOctetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsOctetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsOctetPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsOctet_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsCharPubSubType::ArraySingleDimensionLiteralsCharPubSubType()
{
    set_name("ArraySingleDimensionLiteralsChar");
    uint32_t type_size = ArraySingleDimensionLiteralsChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsCharPubSubType::~ArraySingleDimensionLiteralsCharPubSubType()
{
}

bool ArraySingleDimensionLiteralsCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsChar* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsChar* p_type =
                static_cast<::ArraySingleDimensionLiteralsChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsChar* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsChar());
}

void ArraySingleDimensionLiteralsCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsChar*>(data));
}

bool ArraySingleDimensionLiteralsCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsCharPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsChar_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsWCharPubSubType::ArraySingleDimensionLiteralsWCharPubSubType()
{
    set_name("ArraySingleDimensionLiteralsWChar");
    uint32_t type_size = ArraySingleDimensionLiteralsWChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsWCharPubSubType::~ArraySingleDimensionLiteralsWCharPubSubType()
{
}

bool ArraySingleDimensionLiteralsWCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsWChar* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsWChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsWCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsWChar* p_type =
                static_cast<::ArraySingleDimensionLiteralsWChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsWCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsWChar* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsWChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsWCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsWChar());
}

void ArraySingleDimensionLiteralsWCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsWChar*>(data));
}

bool ArraySingleDimensionLiteralsWCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsWCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsWCharPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsWChar_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsStringPubSubType::ArraySingleDimensionLiteralsStringPubSubType()
{
    set_name("ArraySingleDimensionLiteralsString");
    uint32_t type_size = ArraySingleDimensionLiteralsString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsStringPubSubType::~ArraySingleDimensionLiteralsStringPubSubType()
{
}

bool ArraySingleDimensionLiteralsStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsString* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsString* p_type =
                static_cast<::ArraySingleDimensionLiteralsString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsString* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsString());
}

void ArraySingleDimensionLiteralsStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsString*>(data));
}

bool ArraySingleDimensionLiteralsStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsStringPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsString_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsWStringPubSubType::ArraySingleDimensionLiteralsWStringPubSubType()
{
    set_name("ArraySingleDimensionLiteralsWString");
    uint32_t type_size = ArraySingleDimensionLiteralsWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsWStringPubSubType::~ArraySingleDimensionLiteralsWStringPubSubType()
{
}

bool ArraySingleDimensionLiteralsWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsWString* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsWString* p_type =
                static_cast<::ArraySingleDimensionLiteralsWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsWString* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsWString());
}

void ArraySingleDimensionLiteralsWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsWString*>(data));
}

bool ArraySingleDimensionLiteralsWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsWStringPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsWString_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsBoundedStringPubSubType::ArraySingleDimensionLiteralsBoundedStringPubSubType()
{
    set_name("ArraySingleDimensionLiteralsBoundedString");
    uint32_t type_size = ArraySingleDimensionLiteralsBoundedString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsBoundedStringPubSubType::~ArraySingleDimensionLiteralsBoundedStringPubSubType()
{
}

bool ArraySingleDimensionLiteralsBoundedStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsBoundedString* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsBoundedString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsBoundedStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsBoundedString* p_type =
                static_cast<::ArraySingleDimensionLiteralsBoundedString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsBoundedStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsBoundedString* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsBoundedString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsBoundedStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsBoundedString());
}

void ArraySingleDimensionLiteralsBoundedStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsBoundedString*>(data));
}

bool ArraySingleDimensionLiteralsBoundedStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsBoundedStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsBoundedStringPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsBoundedString_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsBoundedWStringPubSubType::ArraySingleDimensionLiteralsBoundedWStringPubSubType()
{
    set_name("ArraySingleDimensionLiteralsBoundedWString");
    uint32_t type_size = ArraySingleDimensionLiteralsBoundedWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsBoundedWStringPubSubType::~ArraySingleDimensionLiteralsBoundedWStringPubSubType()
{
}

bool ArraySingleDimensionLiteralsBoundedWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsBoundedWString* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsBoundedWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsBoundedWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsBoundedWString* p_type =
                static_cast<::ArraySingleDimensionLiteralsBoundedWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsBoundedWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsBoundedWString* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsBoundedWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsBoundedWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsBoundedWString());
}

void ArraySingleDimensionLiteralsBoundedWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsBoundedWString*>(data));
}

bool ArraySingleDimensionLiteralsBoundedWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsBoundedWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsBoundedWStringPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsBoundedWString_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsEnumPubSubType::ArraySingleDimensionLiteralsEnumPubSubType()
{
    set_name("ArraySingleDimensionLiteralsEnum");
    uint32_t type_size = ArraySingleDimensionLiteralsEnum_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsEnumPubSubType::~ArraySingleDimensionLiteralsEnumPubSubType()
{
}

bool ArraySingleDimensionLiteralsEnumPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsEnum* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsEnum*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsEnumPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsEnum* p_type =
                static_cast<::ArraySingleDimensionLiteralsEnum*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsEnumPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsEnum* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsEnum*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsEnumPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsEnum());
}

void ArraySingleDimensionLiteralsEnumPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsEnum*>(data));
}

bool ArraySingleDimensionLiteralsEnumPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsEnumPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsEnumPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsEnum_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsBitMaskPubSubType::ArraySingleDimensionLiteralsBitMaskPubSubType()
{
    set_name("ArraySingleDimensionLiteralsBitMask");
    uint32_t type_size = ArraySingleDimensionLiteralsBitMask_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsBitMaskPubSubType::~ArraySingleDimensionLiteralsBitMaskPubSubType()
{
}

bool ArraySingleDimensionLiteralsBitMaskPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsBitMask* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsBitMask*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsBitMaskPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsBitMask* p_type =
                static_cast<::ArraySingleDimensionLiteralsBitMask*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsBitMaskPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsBitMask* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsBitMask*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsBitMaskPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsBitMask());
}

void ArraySingleDimensionLiteralsBitMaskPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsBitMask*>(data));
}

bool ArraySingleDimensionLiteralsBitMaskPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsBitMaskPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsBitMaskPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsBitMask_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsAliasPubSubType::ArraySingleDimensionLiteralsAliasPubSubType()
{
    set_name("ArraySingleDimensionLiteralsAlias");
    uint32_t type_size = ArraySingleDimensionLiteralsAlias_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsAliasPubSubType::~ArraySingleDimensionLiteralsAliasPubSubType()
{
}

bool ArraySingleDimensionLiteralsAliasPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsAlias* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsAlias*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsAliasPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsAlias* p_type =
                static_cast<::ArraySingleDimensionLiteralsAlias*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsAliasPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsAlias* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsAlias*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsAliasPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsAlias());
}

void ArraySingleDimensionLiteralsAliasPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsAlias*>(data));
}

bool ArraySingleDimensionLiteralsAliasPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsAliasPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsAliasPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsAlias_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsShortArrayPubSubType::ArraySingleDimensionLiteralsShortArrayPubSubType()
{
    set_name("ArraySingleDimensionLiteralsShortArray");
    uint32_t type_size = ArraySingleDimensionLiteralsShortArray_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsShortArrayPubSubType::~ArraySingleDimensionLiteralsShortArrayPubSubType()
{
}

bool ArraySingleDimensionLiteralsShortArrayPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsShortArray* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsShortArray*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsShortArrayPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsShortArray* p_type =
                static_cast<::ArraySingleDimensionLiteralsShortArray*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsShortArrayPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsShortArray* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsShortArray*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsShortArrayPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsShortArray());
}

void ArraySingleDimensionLiteralsShortArrayPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsShortArray*>(data));
}

bool ArraySingleDimensionLiteralsShortArrayPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsShortArrayPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsShortArrayPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsShortArray_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsSequencePubSubType::ArraySingleDimensionLiteralsSequencePubSubType()
{
    set_name("ArraySingleDimensionLiteralsSequence");
    uint32_t type_size = ArraySingleDimensionLiteralsSequence_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsSequencePubSubType::~ArraySingleDimensionLiteralsSequencePubSubType()
{
}

bool ArraySingleDimensionLiteralsSequencePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsSequence* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsSequence*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsSequencePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsSequence* p_type =
                static_cast<::ArraySingleDimensionLiteralsSequence*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsSequencePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsSequence* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsSequence*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsSequencePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsSequence());
}

void ArraySingleDimensionLiteralsSequencePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsSequence*>(data));
}

bool ArraySingleDimensionLiteralsSequencePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsSequencePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsSequencePubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsSequence_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsMapPubSubType::ArraySingleDimensionLiteralsMapPubSubType()
{
    set_name("ArraySingleDimensionLiteralsMap");
    uint32_t type_size = ArraySingleDimensionLiteralsMap_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsMapPubSubType::~ArraySingleDimensionLiteralsMapPubSubType()
{
}

bool ArraySingleDimensionLiteralsMapPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsMap* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsMap*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsMapPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsMap* p_type =
                static_cast<::ArraySingleDimensionLiteralsMap*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsMapPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsMap* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsMap*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsMapPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsMap());
}

void ArraySingleDimensionLiteralsMapPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsMap*>(data));
}

bool ArraySingleDimensionLiteralsMapPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsMapPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsMapPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsMap_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsUnionPubSubType::ArraySingleDimensionLiteralsUnionPubSubType()
{
    set_name("ArraySingleDimensionLiteralsUnion");
    uint32_t type_size = ArraySingleDimensionLiteralsUnion_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsUnionPubSubType::~ArraySingleDimensionLiteralsUnionPubSubType()
{
}

bool ArraySingleDimensionLiteralsUnionPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsUnion* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsUnion*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsUnionPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsUnion* p_type =
                static_cast<::ArraySingleDimensionLiteralsUnion*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsUnionPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsUnion* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsUnion*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsUnionPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsUnion());
}

void ArraySingleDimensionLiteralsUnionPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsUnion*>(data));
}

bool ArraySingleDimensionLiteralsUnionPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsUnionPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsUnionPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsUnion_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsStructurePubSubType::ArraySingleDimensionLiteralsStructurePubSubType()
{
    set_name("ArraySingleDimensionLiteralsStructure");
    uint32_t type_size = ArraySingleDimensionLiteralsStructure_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsStructurePubSubType::~ArraySingleDimensionLiteralsStructurePubSubType()
{
}

bool ArraySingleDimensionLiteralsStructurePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsStructure* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsStructure*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsStructurePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsStructure* p_type =
                static_cast<::ArraySingleDimensionLiteralsStructure*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsStructurePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsStructure* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsStructure*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsStructurePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsStructure());
}

void ArraySingleDimensionLiteralsStructurePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsStructure*>(data));
}

bool ArraySingleDimensionLiteralsStructurePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsStructurePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsStructurePubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsStructure_type_identifier(type_identifiers_);
}

ArraySingleDimensionLiteralsBitsetPubSubType::ArraySingleDimensionLiteralsBitsetPubSubType()
{
    set_name("ArraySingleDimensionLiteralsBitset");
    uint32_t type_size = ArraySingleDimensionLiteralsBitset_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArraySingleDimensionLiteralsBitsetPubSubType::~ArraySingleDimensionLiteralsBitsetPubSubType()
{
}

bool ArraySingleDimensionLiteralsBitsetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArraySingleDimensionLiteralsBitset* p_type =
            static_cast<const ::ArraySingleDimensionLiteralsBitset*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArraySingleDimensionLiteralsBitsetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArraySingleDimensionLiteralsBitset* p_type =
                static_cast<::ArraySingleDimensionLiteralsBitset*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArraySingleDimensionLiteralsBitsetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArraySingleDimensionLiteralsBitset* p_type =
                static_cast<const ::ArraySingleDimensionLiteralsBitset*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArraySingleDimensionLiteralsBitsetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArraySingleDimensionLiteralsBitset());
}

void ArraySingleDimensionLiteralsBitsetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArraySingleDimensionLiteralsBitset*>(data));
}

bool ArraySingleDimensionLiteralsBitsetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArraySingleDimensionLiteralsBitsetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArraySingleDimensionLiteralsBitsetPubSubType::register_type_object_representation()
{
    register_ArraySingleDimensionLiteralsBitset_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsShortPubSubType::ArrayMultiDimensionLiteralsShortPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsShort");
    uint32_t type_size = ArrayMultiDimensionLiteralsShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsShortPubSubType::~ArrayMultiDimensionLiteralsShortPubSubType()
{
}

bool ArrayMultiDimensionLiteralsShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsShort* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsShort* p_type =
                static_cast<::ArrayMultiDimensionLiteralsShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsShort* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsShort());
}

void ArrayMultiDimensionLiteralsShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsShort*>(data));
}

bool ArrayMultiDimensionLiteralsShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsShortPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsShort_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsUShortPubSubType::ArrayMultiDimensionLiteralsUShortPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsUShort");
    uint32_t type_size = ArrayMultiDimensionLiteralsUShort_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsUShortPubSubType::~ArrayMultiDimensionLiteralsUShortPubSubType()
{
}

bool ArrayMultiDimensionLiteralsUShortPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsUShort* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsUShort*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsUShortPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsUShort* p_type =
                static_cast<::ArrayMultiDimensionLiteralsUShort*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsUShortPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsUShort* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsUShort*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsUShortPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsUShort());
}

void ArrayMultiDimensionLiteralsUShortPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsUShort*>(data));
}

bool ArrayMultiDimensionLiteralsUShortPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsUShortPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsUShortPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsUShort_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsLongPubSubType::ArrayMultiDimensionLiteralsLongPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsLong");
    uint32_t type_size = ArrayMultiDimensionLiteralsLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsLongPubSubType::~ArrayMultiDimensionLiteralsLongPubSubType()
{
}

bool ArrayMultiDimensionLiteralsLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsLong* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsLong* p_type =
                static_cast<::ArrayMultiDimensionLiteralsLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsLong* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsLong());
}

void ArrayMultiDimensionLiteralsLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsLong*>(data));
}

bool ArrayMultiDimensionLiteralsLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsULongPubSubType::ArrayMultiDimensionLiteralsULongPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsULong");
    uint32_t type_size = ArrayMultiDimensionLiteralsULong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsULongPubSubType::~ArrayMultiDimensionLiteralsULongPubSubType()
{
}

bool ArrayMultiDimensionLiteralsULongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsULong* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsULong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsULongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsULong* p_type =
                static_cast<::ArrayMultiDimensionLiteralsULong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsULongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsULong* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsULong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsULongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsULong());
}

void ArrayMultiDimensionLiteralsULongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsULong*>(data));
}

bool ArrayMultiDimensionLiteralsULongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsULongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsULongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsULong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsLongLongPubSubType::ArrayMultiDimensionLiteralsLongLongPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsLongLong");
    uint32_t type_size = ArrayMultiDimensionLiteralsLongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsLongLongPubSubType::~ArrayMultiDimensionLiteralsLongLongPubSubType()
{
}

bool ArrayMultiDimensionLiteralsLongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsLongLong* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsLongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsLongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsLongLong* p_type =
                static_cast<::ArrayMultiDimensionLiteralsLongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsLongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsLongLong* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsLongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsLongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsLongLong());
}

void ArrayMultiDimensionLiteralsLongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsLongLong*>(data));
}

bool ArrayMultiDimensionLiteralsLongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsLongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsLongLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsLongLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsULongLongPubSubType::ArrayMultiDimensionLiteralsULongLongPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsULongLong");
    uint32_t type_size = ArrayMultiDimensionLiteralsULongLong_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsULongLongPubSubType::~ArrayMultiDimensionLiteralsULongLongPubSubType()
{
}

bool ArrayMultiDimensionLiteralsULongLongPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsULongLong* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsULongLong*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsULongLongPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsULongLong* p_type =
                static_cast<::ArrayMultiDimensionLiteralsULongLong*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsULongLongPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsULongLong* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsULongLong*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsULongLongPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsULongLong());
}

void ArrayMultiDimensionLiteralsULongLongPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsULongLong*>(data));
}

bool ArrayMultiDimensionLiteralsULongLongPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsULongLongPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsULongLongPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsULongLong_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsFloatPubSubType::ArrayMultiDimensionLiteralsFloatPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsFloat");
    uint32_t type_size = ArrayMultiDimensionLiteralsFloat_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsFloatPubSubType::~ArrayMultiDimensionLiteralsFloatPubSubType()
{
}

bool ArrayMultiDimensionLiteralsFloatPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsFloat* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsFloat*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsFloatPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsFloat* p_type =
                static_cast<::ArrayMultiDimensionLiteralsFloat*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsFloatPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsFloat* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsFloat*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsFloatPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsFloat());
}

void ArrayMultiDimensionLiteralsFloatPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsFloat*>(data));
}

bool ArrayMultiDimensionLiteralsFloatPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsFloatPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsFloatPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsFloat_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsDoublePubSubType::ArrayMultiDimensionLiteralsDoublePubSubType()
{
    set_name("ArrayMultiDimensionLiteralsDouble");
    uint32_t type_size = ArrayMultiDimensionLiteralsDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsDoublePubSubType::~ArrayMultiDimensionLiteralsDoublePubSubType()
{
}

bool ArrayMultiDimensionLiteralsDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsDouble* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsDouble* p_type =
                static_cast<::ArrayMultiDimensionLiteralsDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsDouble* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsDouble());
}

void ArrayMultiDimensionLiteralsDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsDouble*>(data));
}

bool ArrayMultiDimensionLiteralsDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsDoublePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsDouble_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsLongDoublePubSubType::ArrayMultiDimensionLiteralsLongDoublePubSubType()
{
    set_name("ArrayMultiDimensionLiteralsLongDouble");
    uint32_t type_size = ArrayMultiDimensionLiteralsLongDouble_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsLongDoublePubSubType::~ArrayMultiDimensionLiteralsLongDoublePubSubType()
{
}

bool ArrayMultiDimensionLiteralsLongDoublePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsLongDouble* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsLongDouble*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsLongDoublePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsLongDouble* p_type =
                static_cast<::ArrayMultiDimensionLiteralsLongDouble*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsLongDoublePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsLongDouble* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsLongDouble*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsLongDoublePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsLongDouble());
}

void ArrayMultiDimensionLiteralsLongDoublePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsLongDouble*>(data));
}

bool ArrayMultiDimensionLiteralsLongDoublePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsLongDoublePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsLongDoublePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsLongDouble_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsBooleanPubSubType::ArrayMultiDimensionLiteralsBooleanPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsBoolean");
    uint32_t type_size = ArrayMultiDimensionLiteralsBoolean_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsBooleanPubSubType::~ArrayMultiDimensionLiteralsBooleanPubSubType()
{
}

bool ArrayMultiDimensionLiteralsBooleanPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsBoolean* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsBoolean*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsBooleanPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsBoolean* p_type =
                static_cast<::ArrayMultiDimensionLiteralsBoolean*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsBooleanPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsBoolean* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsBoolean*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsBooleanPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsBoolean());
}

void ArrayMultiDimensionLiteralsBooleanPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsBoolean*>(data));
}

bool ArrayMultiDimensionLiteralsBooleanPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsBooleanPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsBooleanPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsBoolean_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsOctetPubSubType::ArrayMultiDimensionLiteralsOctetPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsOctet");
    uint32_t type_size = ArrayMultiDimensionLiteralsOctet_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsOctetPubSubType::~ArrayMultiDimensionLiteralsOctetPubSubType()
{
}

bool ArrayMultiDimensionLiteralsOctetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsOctet* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsOctet*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsOctetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsOctet* p_type =
                static_cast<::ArrayMultiDimensionLiteralsOctet*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsOctetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsOctet* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsOctet*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsOctetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsOctet());
}

void ArrayMultiDimensionLiteralsOctetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsOctet*>(data));
}

bool ArrayMultiDimensionLiteralsOctetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsOctetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsOctetPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsOctet_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsCharPubSubType::ArrayMultiDimensionLiteralsCharPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsChar");
    uint32_t type_size = ArrayMultiDimensionLiteralsChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsCharPubSubType::~ArrayMultiDimensionLiteralsCharPubSubType()
{
}

bool ArrayMultiDimensionLiteralsCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsChar* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsChar* p_type =
                static_cast<::ArrayMultiDimensionLiteralsChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsChar* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsChar());
}

void ArrayMultiDimensionLiteralsCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsChar*>(data));
}

bool ArrayMultiDimensionLiteralsCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsCharPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsChar_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsWCharPubSubType::ArrayMultiDimensionLiteralsWCharPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsWChar");
    uint32_t type_size = ArrayMultiDimensionLiteralsWChar_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsWCharPubSubType::~ArrayMultiDimensionLiteralsWCharPubSubType()
{
}

bool ArrayMultiDimensionLiteralsWCharPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsWChar* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsWChar*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsWCharPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsWChar* p_type =
                static_cast<::ArrayMultiDimensionLiteralsWChar*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsWCharPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsWChar* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsWChar*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsWCharPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsWChar());
}

void ArrayMultiDimensionLiteralsWCharPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsWChar*>(data));
}

bool ArrayMultiDimensionLiteralsWCharPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsWCharPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsWCharPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsWChar_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsStringPubSubType::ArrayMultiDimensionLiteralsStringPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsString");
    uint32_t type_size = ArrayMultiDimensionLiteralsString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsStringPubSubType::~ArrayMultiDimensionLiteralsStringPubSubType()
{
}

bool ArrayMultiDimensionLiteralsStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsString* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsString* p_type =
                static_cast<::ArrayMultiDimensionLiteralsString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsString* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsString());
}

void ArrayMultiDimensionLiteralsStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsString*>(data));
}

bool ArrayMultiDimensionLiteralsStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsWStringPubSubType::ArrayMultiDimensionLiteralsWStringPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsWString");
    uint32_t type_size = ArrayMultiDimensionLiteralsWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsWStringPubSubType::~ArrayMultiDimensionLiteralsWStringPubSubType()
{
}

bool ArrayMultiDimensionLiteralsWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsWString* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsWString* p_type =
                static_cast<::ArrayMultiDimensionLiteralsWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsWString* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsWString());
}

void ArrayMultiDimensionLiteralsWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsWString*>(data));
}

bool ArrayMultiDimensionLiteralsWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsWStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsWString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsBoundedStringPubSubType::ArrayMultiDimensionLiteralsBoundedStringPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsBoundedString");
    uint32_t type_size = ArrayMultiDimensionLiteralsBoundedString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsBoundedStringPubSubType::~ArrayMultiDimensionLiteralsBoundedStringPubSubType()
{
}

bool ArrayMultiDimensionLiteralsBoundedStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsBoundedString* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsBoundedString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsBoundedStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsBoundedString* p_type =
                static_cast<::ArrayMultiDimensionLiteralsBoundedString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsBoundedStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsBoundedString* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsBoundedString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsBoundedStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsBoundedString());
}

void ArrayMultiDimensionLiteralsBoundedStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsBoundedString*>(data));
}

bool ArrayMultiDimensionLiteralsBoundedStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsBoundedStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsBoundedStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsBoundedString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsBoundedWStringPubSubType::ArrayMultiDimensionLiteralsBoundedWStringPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsBoundedWString");
    uint32_t type_size = ArrayMultiDimensionLiteralsBoundedWString_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsBoundedWStringPubSubType::~ArrayMultiDimensionLiteralsBoundedWStringPubSubType()
{
}

bool ArrayMultiDimensionLiteralsBoundedWStringPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsBoundedWString* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsBoundedWString*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsBoundedWStringPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsBoundedWString* p_type =
                static_cast<::ArrayMultiDimensionLiteralsBoundedWString*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsBoundedWStringPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsBoundedWString* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsBoundedWString*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsBoundedWStringPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsBoundedWString());
}

void ArrayMultiDimensionLiteralsBoundedWStringPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsBoundedWString*>(data));
}

bool ArrayMultiDimensionLiteralsBoundedWStringPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsBoundedWStringPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsBoundedWStringPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsBoundedWString_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsEnumPubSubType::ArrayMultiDimensionLiteralsEnumPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsEnum");
    uint32_t type_size = ArrayMultiDimensionLiteralsEnum_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsEnumPubSubType::~ArrayMultiDimensionLiteralsEnumPubSubType()
{
}

bool ArrayMultiDimensionLiteralsEnumPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsEnum* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsEnum*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsEnumPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsEnum* p_type =
                static_cast<::ArrayMultiDimensionLiteralsEnum*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsEnumPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsEnum* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsEnum*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsEnumPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsEnum());
}

void ArrayMultiDimensionLiteralsEnumPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsEnum*>(data));
}

bool ArrayMultiDimensionLiteralsEnumPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsEnumPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsEnumPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsEnum_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsBitMaskPubSubType::ArrayMultiDimensionLiteralsBitMaskPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsBitMask");
    uint32_t type_size = ArrayMultiDimensionLiteralsBitMask_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsBitMaskPubSubType::~ArrayMultiDimensionLiteralsBitMaskPubSubType()
{
}

bool ArrayMultiDimensionLiteralsBitMaskPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsBitMask* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsBitMask*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsBitMaskPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsBitMask* p_type =
                static_cast<::ArrayMultiDimensionLiteralsBitMask*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsBitMaskPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsBitMask* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsBitMask*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsBitMaskPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsBitMask());
}

void ArrayMultiDimensionLiteralsBitMaskPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsBitMask*>(data));
}

bool ArrayMultiDimensionLiteralsBitMaskPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsBitMaskPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsBitMaskPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsBitMask_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsAliasPubSubType::ArrayMultiDimensionLiteralsAliasPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsAlias");
    uint32_t type_size = ArrayMultiDimensionLiteralsAlias_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsAliasPubSubType::~ArrayMultiDimensionLiteralsAliasPubSubType()
{
}

bool ArrayMultiDimensionLiteralsAliasPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsAlias* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsAlias*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsAliasPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsAlias* p_type =
                static_cast<::ArrayMultiDimensionLiteralsAlias*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsAliasPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsAlias* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsAlias*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsAliasPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsAlias());
}

void ArrayMultiDimensionLiteralsAliasPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsAlias*>(data));
}

bool ArrayMultiDimensionLiteralsAliasPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsAliasPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsAliasPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsAlias_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsSequencePubSubType::ArrayMultiDimensionLiteralsSequencePubSubType()
{
    set_name("ArrayMultiDimensionLiteralsSequence");
    uint32_t type_size = ArrayMultiDimensionLiteralsSequence_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsSequencePubSubType::~ArrayMultiDimensionLiteralsSequencePubSubType()
{
}

bool ArrayMultiDimensionLiteralsSequencePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsSequence* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsSequence*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsSequencePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsSequence* p_type =
                static_cast<::ArrayMultiDimensionLiteralsSequence*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsSequencePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsSequence* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsSequence*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsSequencePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsSequence());
}

void ArrayMultiDimensionLiteralsSequencePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsSequence*>(data));
}

bool ArrayMultiDimensionLiteralsSequencePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsSequencePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsSequencePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsSequence_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsMapPubSubType::ArrayMultiDimensionLiteralsMapPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsMap");
    uint32_t type_size = ArrayMultiDimensionLiteralsMap_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsMapPubSubType::~ArrayMultiDimensionLiteralsMapPubSubType()
{
}

bool ArrayMultiDimensionLiteralsMapPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsMap* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsMap*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsMapPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsMap* p_type =
                static_cast<::ArrayMultiDimensionLiteralsMap*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsMapPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsMap* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsMap*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsMapPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsMap());
}

void ArrayMultiDimensionLiteralsMapPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsMap*>(data));
}

bool ArrayMultiDimensionLiteralsMapPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsMapPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsMapPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsMap_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsUnionPubSubType::ArrayMultiDimensionLiteralsUnionPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsUnion");
    uint32_t type_size = ArrayMultiDimensionLiteralsUnion_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsUnionPubSubType::~ArrayMultiDimensionLiteralsUnionPubSubType()
{
}

bool ArrayMultiDimensionLiteralsUnionPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsUnion* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsUnion*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsUnionPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsUnion* p_type =
                static_cast<::ArrayMultiDimensionLiteralsUnion*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsUnionPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsUnion* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsUnion*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsUnionPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsUnion());
}

void ArrayMultiDimensionLiteralsUnionPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsUnion*>(data));
}

bool ArrayMultiDimensionLiteralsUnionPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsUnionPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsUnionPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsUnion_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsStructurePubSubType::ArrayMultiDimensionLiteralsStructurePubSubType()
{
    set_name("ArrayMultiDimensionLiteralsStructure");
    uint32_t type_size = ArrayMultiDimensionLiteralsStructure_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsStructurePubSubType::~ArrayMultiDimensionLiteralsStructurePubSubType()
{
}

bool ArrayMultiDimensionLiteralsStructurePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsStructure* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsStructure*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsStructurePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsStructure* p_type =
                static_cast<::ArrayMultiDimensionLiteralsStructure*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsStructurePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsStructure* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsStructure*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsStructurePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsStructure());
}

void ArrayMultiDimensionLiteralsStructurePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsStructure*>(data));
}

bool ArrayMultiDimensionLiteralsStructurePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsStructurePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsStructurePubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsStructure_type_identifier(type_identifiers_);
}

ArrayMultiDimensionLiteralsBitSetPubSubType::ArrayMultiDimensionLiteralsBitSetPubSubType()
{
    set_name("ArrayMultiDimensionLiteralsBitSet");
    uint32_t type_size = ArrayMultiDimensionLiteralsBitSet_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

ArrayMultiDimensionLiteralsBitSetPubSubType::~ArrayMultiDimensionLiteralsBitSetPubSubType()
{
}

bool ArrayMultiDimensionLiteralsBitSetPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::ArrayMultiDimensionLiteralsBitSet* p_type =
            static_cast<const ::ArrayMultiDimensionLiteralsBitSet*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool ArrayMultiDimensionLiteralsBitSetPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::ArrayMultiDimensionLiteralsBitSet* p_type =
                static_cast<::ArrayMultiDimensionLiteralsBitSet*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t ArrayMultiDimensionLiteralsBitSetPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::ArrayMultiDimensionLiteralsBitSet* p_type =
                static_cast<const ::ArrayMultiDimensionLiteralsBitSet*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* ArrayMultiDimensionLiteralsBitSetPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::ArrayMultiDimensionLiteralsBitSet());
}

void ArrayMultiDimensionLiteralsBitSetPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::ArrayMultiDimensionLiteralsBitSet*>(data));
}

bool ArrayMultiDimensionLiteralsBitSetPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool ArrayMultiDimensionLiteralsBitSetPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void ArrayMultiDimensionLiteralsBitSetPubSubType::register_type_object_representation()
{
    register_ArrayMultiDimensionLiteralsBitSet_type_identifier(type_identifiers_);
}

BoundedSmallArraysPubSubType::BoundedSmallArraysPubSubType()
{
    set_name("BoundedSmallArrays");
    uint32_t type_size = BoundedSmallArrays_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

BoundedSmallArraysPubSubType::~BoundedSmallArraysPubSubType()
{
}

bool BoundedSmallArraysPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::BoundedSmallArrays* p_type =
            static_cast<const ::BoundedSmallArrays*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool BoundedSmallArraysPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::BoundedSmallArrays* p_type =
                static_cast<::BoundedSmallArrays*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t BoundedSmallArraysPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::BoundedSmallArrays* p_type =
                static_cast<const ::BoundedSmallArrays*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* BoundedSmallArraysPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::BoundedSmallArrays());
}

void BoundedSmallArraysPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::BoundedSmallArrays*>(data));
}

bool BoundedSmallArraysPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool BoundedSmallArraysPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void BoundedSmallArraysPubSubType::register_type_object_representation()
{
    register_BoundedSmallArrays_type_identifier(type_identifiers_);
}

BoundedBigArraysPubSubType::BoundedBigArraysPubSubType()
{
    set_name("BoundedBigArrays");
    uint32_t type_size = BoundedBigArrays_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = false;
}

BoundedBigArraysPubSubType::~BoundedBigArraysPubSubType()
{
}

bool BoundedBigArraysPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::BoundedBigArrays* p_type =
            static_cast<const ::BoundedBigArrays*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool BoundedBigArraysPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::BoundedBigArrays* p_type =
                static_cast<::BoundedBigArrays*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t BoundedBigArraysPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::BoundedBigArrays* p_type =
                static_cast<const ::BoundedBigArrays*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* BoundedBigArraysPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::BoundedBigArrays());
}

void BoundedBigArraysPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::BoundedBigArrays*>(data));
}

bool BoundedBigArraysPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(payload);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

bool BoundedBigArraysPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    static_cast<void>(data);
    static_cast<void>(handle);
    static_cast<void>(force_md5);

    return false;
}

void BoundedBigArraysPubSubType::register_type_object_representation()
{
    register_BoundedBigArrays_type_identifier(type_identifiers_);
}

// Include auxiliary functions like for serializing/deserializing.
#include "arraysCdrAux.ipp"
