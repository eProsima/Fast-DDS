// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file keyPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen (version: 4.2.0).
 */

#include "keyPubSubTypes.hpp"

#include <algorithm>
#include <mutex>

#include <fastdds/dds/log/Log.hpp>
#include <fastdds/rtps/common/CdrSerialization.hpp>

#include "keyCdrAux.hpp"
#include "keyTypeObjectSupport.hpp"

using SerializedPayload_t = eprosima::fastdds::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastdds::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

KeyedShortStructPubSubType::KeyedShortStructPubSubType()
{
    set_name("KeyedShortStruct");
    uint32_t type_size = KeyedShortStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedShortStructPubSubType::~KeyedShortStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedShortStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedShortStruct* p_type =
            static_cast<const ::KeyedShortStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedShortStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedShortStruct* p_type =
                static_cast<::KeyedShortStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedShortStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedShortStruct* p_type =
                static_cast<const ::KeyedShortStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedShortStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedShortStruct());
}

void KeyedShortStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedShortStruct*>(data));
}

bool KeyedShortStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedShortStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedShortStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedShortStruct* p_type =
            static_cast<const ::KeyedShortStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedShortStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedShortStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedShortStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedShortStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedShortStructPubSubType::register_type_object_representation()
{
    register_KeyedShortStruct_type_identifier(type_identifiers_);
}

KeyedUShortStructPubSubType::KeyedUShortStructPubSubType()
{
    set_name("KeyedUShortStruct");
    uint32_t type_size = KeyedUShortStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedUShortStructPubSubType::~KeyedUShortStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedUShortStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedUShortStruct* p_type =
            static_cast<const ::KeyedUShortStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedUShortStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedUShortStruct* p_type =
                static_cast<::KeyedUShortStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedUShortStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedUShortStruct* p_type =
                static_cast<const ::KeyedUShortStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedUShortStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedUShortStruct());
}

void KeyedUShortStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedUShortStruct*>(data));
}

bool KeyedUShortStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedUShortStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedUShortStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedUShortStruct* p_type =
            static_cast<const ::KeyedUShortStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedUShortStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedUShortStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedUShortStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedUShortStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedUShortStructPubSubType::register_type_object_representation()
{
    register_KeyedUShortStruct_type_identifier(type_identifiers_);
}

KeyedLongStructPubSubType::KeyedLongStructPubSubType()
{
    set_name("KeyedLongStruct");
    uint32_t type_size = KeyedLongStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedLongStructPubSubType::~KeyedLongStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedLongStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedLongStruct* p_type =
            static_cast<const ::KeyedLongStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedLongStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedLongStruct* p_type =
                static_cast<::KeyedLongStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedLongStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedLongStruct* p_type =
                static_cast<const ::KeyedLongStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedLongStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedLongStruct());
}

void KeyedLongStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedLongStruct*>(data));
}

bool KeyedLongStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedLongStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedLongStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedLongStruct* p_type =
            static_cast<const ::KeyedLongStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedLongStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedLongStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedLongStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedLongStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedLongStructPubSubType::register_type_object_representation()
{
    register_KeyedLongStruct_type_identifier(type_identifiers_);
}

KeyedULongStructPubSubType::KeyedULongStructPubSubType()
{
    set_name("KeyedULongStruct");
    uint32_t type_size = KeyedULongStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedULongStructPubSubType::~KeyedULongStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedULongStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedULongStruct* p_type =
            static_cast<const ::KeyedULongStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedULongStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedULongStruct* p_type =
                static_cast<::KeyedULongStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedULongStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedULongStruct* p_type =
                static_cast<const ::KeyedULongStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedULongStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedULongStruct());
}

void KeyedULongStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedULongStruct*>(data));
}

bool KeyedULongStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedULongStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedULongStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedULongStruct* p_type =
            static_cast<const ::KeyedULongStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedULongStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedULongStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedULongStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedULongStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedULongStructPubSubType::register_type_object_representation()
{
    register_KeyedULongStruct_type_identifier(type_identifiers_);
}

KeyedLongLongStructPubSubType::KeyedLongLongStructPubSubType()
{
    set_name("KeyedLongLongStruct");
    uint32_t type_size = KeyedLongLongStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedLongLongStructPubSubType::~KeyedLongLongStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedLongLongStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedLongLongStruct* p_type =
            static_cast<const ::KeyedLongLongStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedLongLongStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedLongLongStruct* p_type =
                static_cast<::KeyedLongLongStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedLongLongStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedLongLongStruct* p_type =
                static_cast<const ::KeyedLongLongStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedLongLongStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedLongLongStruct());
}

void KeyedLongLongStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedLongLongStruct*>(data));
}

bool KeyedLongLongStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedLongLongStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedLongLongStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedLongLongStruct* p_type =
            static_cast<const ::KeyedLongLongStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedLongLongStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedLongLongStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedLongLongStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedLongLongStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedLongLongStructPubSubType::register_type_object_representation()
{
    register_KeyedLongLongStruct_type_identifier(type_identifiers_);
}

KeyedULongLongStructPubSubType::KeyedULongLongStructPubSubType()
{
    set_name("KeyedULongLongStruct");
    uint32_t type_size = KeyedULongLongStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedULongLongStructPubSubType::~KeyedULongLongStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedULongLongStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedULongLongStruct* p_type =
            static_cast<const ::KeyedULongLongStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedULongLongStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedULongLongStruct* p_type =
                static_cast<::KeyedULongLongStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedULongLongStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedULongLongStruct* p_type =
                static_cast<const ::KeyedULongLongStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedULongLongStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedULongLongStruct());
}

void KeyedULongLongStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedULongLongStruct*>(data));
}

bool KeyedULongLongStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedULongLongStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedULongLongStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedULongLongStruct* p_type =
            static_cast<const ::KeyedULongLongStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedULongLongStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedULongLongStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedULongLongStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedULongLongStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedULongLongStructPubSubType::register_type_object_representation()
{
    register_KeyedULongLongStruct_type_identifier(type_identifiers_);
}

KeyedFloatStructPubSubType::KeyedFloatStructPubSubType()
{
    set_name("KeyedFloatStruct");
    uint32_t type_size = KeyedFloatStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedFloatStructPubSubType::~KeyedFloatStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedFloatStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedFloatStruct* p_type =
            static_cast<const ::KeyedFloatStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedFloatStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedFloatStruct* p_type =
                static_cast<::KeyedFloatStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedFloatStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedFloatStruct* p_type =
                static_cast<const ::KeyedFloatStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedFloatStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedFloatStruct());
}

void KeyedFloatStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedFloatStruct*>(data));
}

bool KeyedFloatStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedFloatStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedFloatStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedFloatStruct* p_type =
            static_cast<const ::KeyedFloatStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedFloatStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedFloatStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedFloatStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedFloatStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedFloatStructPubSubType::register_type_object_representation()
{
    register_KeyedFloatStruct_type_identifier(type_identifiers_);
}

KeyedDoubleStructPubSubType::KeyedDoubleStructPubSubType()
{
    set_name("KeyedDoubleStruct");
    uint32_t type_size = KeyedDoubleStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedDoubleStructPubSubType::~KeyedDoubleStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedDoubleStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedDoubleStruct* p_type =
            static_cast<const ::KeyedDoubleStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedDoubleStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedDoubleStruct* p_type =
                static_cast<::KeyedDoubleStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedDoubleStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedDoubleStruct* p_type =
                static_cast<const ::KeyedDoubleStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedDoubleStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedDoubleStruct());
}

void KeyedDoubleStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedDoubleStruct*>(data));
}

bool KeyedDoubleStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedDoubleStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedDoubleStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedDoubleStruct* p_type =
            static_cast<const ::KeyedDoubleStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedDoubleStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedDoubleStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedDoubleStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedDoubleStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedDoubleStructPubSubType::register_type_object_representation()
{
    register_KeyedDoubleStruct_type_identifier(type_identifiers_);
}

KeyedLongDoubleStructPubSubType::KeyedLongDoubleStructPubSubType()
{
    set_name("KeyedLongDoubleStruct");
    uint32_t type_size = KeyedLongDoubleStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedLongDoubleStructPubSubType::~KeyedLongDoubleStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedLongDoubleStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedLongDoubleStruct* p_type =
            static_cast<const ::KeyedLongDoubleStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedLongDoubleStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedLongDoubleStruct* p_type =
                static_cast<::KeyedLongDoubleStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedLongDoubleStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedLongDoubleStruct* p_type =
                static_cast<const ::KeyedLongDoubleStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedLongDoubleStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedLongDoubleStruct());
}

void KeyedLongDoubleStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedLongDoubleStruct*>(data));
}

bool KeyedLongDoubleStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedLongDoubleStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedLongDoubleStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedLongDoubleStruct* p_type =
            static_cast<const ::KeyedLongDoubleStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedLongDoubleStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedLongDoubleStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedLongDoubleStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedLongDoubleStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedLongDoubleStructPubSubType::register_type_object_representation()
{
    register_KeyedLongDoubleStruct_type_identifier(type_identifiers_);
}

KeyedBooleanStructPubSubType::KeyedBooleanStructPubSubType()
{
    set_name("KeyedBooleanStruct");
    uint32_t type_size = KeyedBooleanStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedBooleanStructPubSubType::~KeyedBooleanStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedBooleanStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedBooleanStruct* p_type =
            static_cast<const ::KeyedBooleanStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedBooleanStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedBooleanStruct* p_type =
                static_cast<::KeyedBooleanStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedBooleanStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedBooleanStruct* p_type =
                static_cast<const ::KeyedBooleanStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedBooleanStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedBooleanStruct());
}

void KeyedBooleanStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedBooleanStruct*>(data));
}

bool KeyedBooleanStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedBooleanStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedBooleanStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedBooleanStruct* p_type =
            static_cast<const ::KeyedBooleanStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedBooleanStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedBooleanStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedBooleanStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedBooleanStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedBooleanStructPubSubType::register_type_object_representation()
{
    register_KeyedBooleanStruct_type_identifier(type_identifiers_);
}

KeyedOctetStructPubSubType::KeyedOctetStructPubSubType()
{
    set_name("KeyedOctetStruct");
    uint32_t type_size = KeyedOctetStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedOctetStructPubSubType::~KeyedOctetStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedOctetStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedOctetStruct* p_type =
            static_cast<const ::KeyedOctetStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedOctetStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedOctetStruct* p_type =
                static_cast<::KeyedOctetStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedOctetStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedOctetStruct* p_type =
                static_cast<const ::KeyedOctetStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedOctetStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedOctetStruct());
}

void KeyedOctetStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedOctetStruct*>(data));
}

bool KeyedOctetStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedOctetStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedOctetStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedOctetStruct* p_type =
            static_cast<const ::KeyedOctetStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedOctetStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedOctetStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedOctetStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedOctetStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedOctetStructPubSubType::register_type_object_representation()
{
    register_KeyedOctetStruct_type_identifier(type_identifiers_);
}

KeyedCharStructPubSubType::KeyedCharStructPubSubType()
{
    set_name("KeyedCharStruct");
    uint32_t type_size = KeyedCharStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedCharStructPubSubType::~KeyedCharStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedCharStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedCharStruct* p_type =
            static_cast<const ::KeyedCharStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedCharStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedCharStruct* p_type =
                static_cast<::KeyedCharStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedCharStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedCharStruct* p_type =
                static_cast<const ::KeyedCharStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedCharStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedCharStruct());
}

void KeyedCharStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedCharStruct*>(data));
}

bool KeyedCharStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedCharStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedCharStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedCharStruct* p_type =
            static_cast<const ::KeyedCharStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedCharStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedCharStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedCharStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedCharStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedCharStructPubSubType::register_type_object_representation()
{
    register_KeyedCharStruct_type_identifier(type_identifiers_);
}

KeyedWCharStructPubSubType::KeyedWCharStructPubSubType()
{
    set_name("KeyedWCharStruct");
    uint32_t type_size = KeyedWCharStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedWCharStructPubSubType::~KeyedWCharStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedWCharStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedWCharStruct* p_type =
            static_cast<const ::KeyedWCharStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedWCharStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedWCharStruct* p_type =
                static_cast<::KeyedWCharStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedWCharStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedWCharStruct* p_type =
                static_cast<const ::KeyedWCharStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedWCharStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedWCharStruct());
}

void KeyedWCharStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedWCharStruct*>(data));
}

bool KeyedWCharStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedWCharStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedWCharStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedWCharStruct* p_type =
            static_cast<const ::KeyedWCharStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedWCharStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedWCharStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedWCharStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedWCharStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedWCharStructPubSubType::register_type_object_representation()
{
    register_KeyedWCharStruct_type_identifier(type_identifiers_);
}

KeyedEmptyStructPubSubType::KeyedEmptyStructPubSubType()
{
    set_name("KeyedEmptyStruct");
    uint32_t type_size = KeyedEmptyStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedEmptyStructPubSubType::~KeyedEmptyStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedEmptyStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedEmptyStruct* p_type =
            static_cast<const ::KeyedEmptyStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedEmptyStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedEmptyStruct* p_type =
                static_cast<::KeyedEmptyStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedEmptyStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedEmptyStruct* p_type =
                static_cast<const ::KeyedEmptyStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedEmptyStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedEmptyStruct());
}

void KeyedEmptyStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedEmptyStruct*>(data));
}

bool KeyedEmptyStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedEmptyStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedEmptyStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedEmptyStruct* p_type =
            static_cast<const ::KeyedEmptyStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedEmptyStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedEmptyStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedEmptyStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedEmptyStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedEmptyStructPubSubType::register_type_object_representation()
{
    register_KeyedEmptyStruct_type_identifier(type_identifiers_);
}

KeyedEmptyInheritanceStructPubSubType::KeyedEmptyInheritanceStructPubSubType()
{
    set_name("KeyedEmptyInheritanceStruct");
    uint32_t type_size = KeyedEmptyInheritanceStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedEmptyInheritanceStructPubSubType::~KeyedEmptyInheritanceStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedEmptyInheritanceStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedEmptyInheritanceStruct* p_type =
            static_cast<const ::KeyedEmptyInheritanceStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedEmptyInheritanceStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedEmptyInheritanceStruct* p_type =
                static_cast<::KeyedEmptyInheritanceStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedEmptyInheritanceStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedEmptyInheritanceStruct* p_type =
                static_cast<const ::KeyedEmptyInheritanceStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedEmptyInheritanceStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedEmptyInheritanceStruct());
}

void KeyedEmptyInheritanceStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedEmptyInheritanceStruct*>(data));
}

bool KeyedEmptyInheritanceStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedEmptyInheritanceStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedEmptyInheritanceStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedEmptyInheritanceStruct* p_type =
            static_cast<const ::KeyedEmptyInheritanceStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedEmptyInheritanceStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedEmptyInheritanceStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedEmptyInheritanceStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedEmptyInheritanceStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedEmptyInheritanceStructPubSubType::register_type_object_representation()
{
    register_KeyedEmptyInheritanceStruct_type_identifier(type_identifiers_);
}

KeyedInheritanceStructPubSubType::KeyedInheritanceStructPubSubType()
{
    set_name("KeyedInheritanceStruct");
    uint32_t type_size = KeyedInheritanceStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedInheritanceStructPubSubType::~KeyedInheritanceStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedInheritanceStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedInheritanceStruct* p_type =
            static_cast<const ::KeyedInheritanceStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedInheritanceStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedInheritanceStruct* p_type =
                static_cast<::KeyedInheritanceStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedInheritanceStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedInheritanceStruct* p_type =
                static_cast<const ::KeyedInheritanceStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedInheritanceStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedInheritanceStruct());
}

void KeyedInheritanceStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedInheritanceStruct*>(data));
}

bool KeyedInheritanceStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedInheritanceStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedInheritanceStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedInheritanceStruct* p_type =
            static_cast<const ::KeyedInheritanceStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedInheritanceStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedInheritanceStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedInheritanceStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedInheritanceStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedInheritanceStructPubSubType::register_type_object_representation()
{
    register_KeyedInheritanceStruct_type_identifier(type_identifiers_);
}

InheritanceKeyedEmptyStructPubSubType::InheritanceKeyedEmptyStructPubSubType()
{
    set_name("InheritanceKeyedEmptyStruct");
    uint32_t type_size = InheritanceKeyedEmptyStruct_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

InheritanceKeyedEmptyStructPubSubType::~InheritanceKeyedEmptyStructPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool InheritanceKeyedEmptyStructPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::InheritanceKeyedEmptyStruct* p_type =
            static_cast<const ::InheritanceKeyedEmptyStruct*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool InheritanceKeyedEmptyStructPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::InheritanceKeyedEmptyStruct* p_type =
                static_cast<::InheritanceKeyedEmptyStruct*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t InheritanceKeyedEmptyStructPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::InheritanceKeyedEmptyStruct* p_type =
                static_cast<const ::InheritanceKeyedEmptyStruct*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* InheritanceKeyedEmptyStructPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::InheritanceKeyedEmptyStruct());
}

void InheritanceKeyedEmptyStructPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::InheritanceKeyedEmptyStruct*>(data));
}

bool InheritanceKeyedEmptyStructPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::InheritanceKeyedEmptyStruct data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool InheritanceKeyedEmptyStructPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::InheritanceKeyedEmptyStruct* p_type =
            static_cast<const ::InheritanceKeyedEmptyStruct*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            InheritanceKeyedEmptyStruct_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || InheritanceKeyedEmptyStruct_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* InheritanceKeyedEmptyStructPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(InheritanceKeyedEmptyStruct_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void InheritanceKeyedEmptyStructPubSubType::register_type_object_representation()
{
    register_InheritanceKeyedEmptyStruct_type_identifier(type_identifiers_);
}

KeyedFinalPubSubType::KeyedFinalPubSubType()
{
    set_name("KeyedFinal");
    uint32_t type_size = KeyedFinal_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedFinalPubSubType::~KeyedFinalPubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedFinalPubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedFinal* p_type =
            static_cast<const ::KeyedFinal*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedFinalPubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedFinal* p_type =
                static_cast<::KeyedFinal*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedFinalPubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedFinal* p_type =
                static_cast<const ::KeyedFinal*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedFinalPubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedFinal());
}

void KeyedFinalPubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedFinal*>(data));
}

bool KeyedFinalPubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedFinal data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedFinalPubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedFinal* p_type =
            static_cast<const ::KeyedFinal*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedFinal_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedFinal_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedFinalPubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedFinal_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedFinalPubSubType::register_type_object_representation()
{
    register_KeyedFinal_type_identifier(type_identifiers_);
}

KeyedAppendablePubSubType::KeyedAppendablePubSubType()
{
    set_name("KeyedAppendable");
    uint32_t type_size = KeyedAppendable_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedAppendablePubSubType::~KeyedAppendablePubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedAppendablePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedAppendable* p_type =
            static_cast<const ::KeyedAppendable*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedAppendablePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedAppendable* p_type =
                static_cast<::KeyedAppendable*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedAppendablePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedAppendable* p_type =
                static_cast<const ::KeyedAppendable*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedAppendablePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedAppendable());
}

void KeyedAppendablePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedAppendable*>(data));
}

bool KeyedAppendablePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedAppendable data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedAppendablePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedAppendable* p_type =
            static_cast<const ::KeyedAppendable*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedAppendable_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedAppendable_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedAppendablePubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedAppendable_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedAppendablePubSubType::register_type_object_representation()
{
    register_KeyedAppendable_type_identifier(type_identifiers_);
}

KeyedMutablePubSubType::KeyedMutablePubSubType()
{
    set_name("KeyedMutable");
    uint32_t type_size = KeyedMutable_max_cdr_typesize;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    max_serialized_type_size = type_size + 4; /*encapsulation*/
    is_compute_key_provided = true;
    key_buffer_ = nullptr;
    get_key_buffer_nts();
}

KeyedMutablePubSubType::~KeyedMutablePubSubType()
{
    if (key_buffer_ != nullptr)
    {
        free(key_buffer_);
    }
}

bool KeyedMutablePubSubType::serialize(
        const void* const data,
        SerializedPayload_t& payload,
        DataRepresentationId_t data_representation)
{
    const ::KeyedMutable* p_type =
            static_cast<const ::KeyedMutable*>(data);

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.max_size);
    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    ser.set_encoding_flag(
        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
        eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR :
        eprosima::fastcdr::EncodingAlgorithmFlag::PL_CDR2);

    try
    {
        // Serialize encapsulation
        ser.serialize_encapsulation();
        // Serialize the object.
        ser << *p_type;
        ser.set_dds_cdr_options({0, 0});
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    // Get the serialized length
    payload.length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

bool KeyedMutablePubSubType::deserialize(
        SerializedPayload_t& payload,
        void* data)
{
    try
    {
        // Convert DATA to pointer of your type
        ::KeyedMutable* p_type =
                static_cast<::KeyedMutable*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload.data), payload.length);

        // Object that deserializes the data.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload.encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        // Deserialize the object.
        deser >> *p_type;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return false;
    }

    return true;
}

uint32_t KeyedMutablePubSubType::calculate_serialized_size(
        const void* const data,
        DataRepresentationId_t data_representation)
{
    try
    {
        eprosima::fastcdr::CdrSizeCalculator calculator(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
        size_t current_alignment {0};
        const ::KeyedMutable* p_type =
                static_cast<const ::KeyedMutable*>(data);
        auto calc_size = calculator.calculate_serialized_size(*p_type, current_alignment);
        return static_cast<uint32_t>(calc_size) + 4u /*encapsulation*/;
    }
    catch (eprosima::fastcdr::exception::Exception& /*exception*/)
    {
        return 0;
    }
}

void* KeyedMutablePubSubType::create_data()
{
    return reinterpret_cast<void*>(new ::KeyedMutable());
}

void KeyedMutablePubSubType::delete_data(
        void* data)
{
    delete(reinterpret_cast<::KeyedMutable*>(data));
}

bool KeyedMutablePubSubType::compute_key(
        SerializedPayload_t& payload,
        InstanceHandle_t& handle,
        bool force_md5)
{
    ::KeyedMutable data;
    if (deserialize(payload, static_cast<void*>(&data)))
    {
        return compute_key(static_cast<void*>(&data), handle, force_md5);
    }
    return false;
}

bool KeyedMutablePubSubType::compute_key(
        const void* const data,
        InstanceHandle_t& handle,
        bool force_md5)
{
    std::lock_guard<std::mutex> guard(compute_key_mtx_);
    const ::KeyedMutable* p_type =
            static_cast<const ::KeyedMutable*>(data);

    // Ensure the key buffer is reserved
    unsigned char* key_buffer = get_key_buffer_nts();
    if (key_buffer == nullptr)
    {
        return false;
    }

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(key_buffer),
            KeyedMutable_max_key_cdr_typesize);

    // Object that serializes the data.
    eprosima::fastcdr::Cdr ser(
        fastbuffer,
        eprosima::fastcdr::Cdr::BIG_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv2);
    ser.set_encoding_flag(eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR2);
    eprosima::fastcdr::serialize_key(ser, *p_type);
    if (force_md5 || KeyedMutable_max_key_cdr_typesize > 16)
    {
        eprosima::fastdds::MD5 md5;
        md5.init();
        md5.update(key_buffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
        md5.finalize();
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = md5.digest[i];
        }
    }
    else
    {
        for (uint8_t i = 0; i < 16; ++i)
        {
            handle.value[i] = key_buffer[i];
        }
    }
    return true;
}

unsigned char* KeyedMutablePubSubType::get_key_buffer_nts()
{
    // If already reserved, return
    if (key_buffer_ != nullptr)
    {
        return key_buffer_;
    }

    // Allocate the key buffer
    uint32_t key_length = (std::max)(KeyedMutable_max_key_cdr_typesize, 16u);
    key_buffer_ = reinterpret_cast<unsigned char*>(calloc(key_length, 1u));
    return key_buffer_;
}

void KeyedMutablePubSubType::register_type_object_representation()
{
    register_KeyedMutable_type_identifier(type_identifiers_);
}

// Include auxiliary functions like for serializing/deserializing.
#include "keyCdrAux.ipp"
