// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file mapsCdrAux.ipp
 * This source file contains some declarations of CDR related functions.
 *
 * This file was generated by the tool fastddsgen (version: 4.1.0).
 */

#ifndef FAST_DDS_GENERATED__MAPSCDRAUX_IPP
#define FAST_DDS_GENERATED__MAPSCDRAUX_IPP

#include "mapsCdrAux.hpp"

#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

#include <fastdds/dds/core/policy/QosPolicies.hpp>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {


eProsima_user_DllExport bool is_MapShortShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortShort_cdr_plain(data_representation) &&
                sizeof(MapShortShort) == MapShortShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortShort));

            scdr.jump((array_size -1) * sizeof(MapShortShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortShort_cdr_plain(data_representation) &&
            sizeof(MapShortShort) == MapShortShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortShort));

            scdr.jump((array_size - 1) * sizeof(MapShortShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_short();

}



eProsima_user_DllExport bool is_MapShortUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortUShort_cdr_plain(data_representation) &&
                sizeof(MapShortUShort) == MapShortUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortUShort));

            scdr.jump((array_size -1) * sizeof(MapShortUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortUShort_cdr_plain(data_representation) &&
            sizeof(MapShortUShort) == MapShortUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortUShort));

            scdr.jump((array_size - 1) * sizeof(MapShortUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_ushort();

}



eProsima_user_DllExport bool is_MapShortLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLong_cdr_plain(data_representation) &&
                sizeof(MapShortLong) == MapShortLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortLong));

            scdr.jump((array_size -1) * sizeof(MapShortLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLong_cdr_plain(data_representation) &&
            sizeof(MapShortLong) == MapShortLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortLong));

            scdr.jump((array_size - 1) * sizeof(MapShortLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_long();

}



eProsima_user_DllExport bool is_MapShortULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortULong_cdr_plain(data_representation) &&
                sizeof(MapShortULong) == MapShortULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortULong));

            scdr.jump((array_size -1) * sizeof(MapShortULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortULong_cdr_plain(data_representation) &&
            sizeof(MapShortULong) == MapShortULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortULong));

            scdr.jump((array_size - 1) * sizeof(MapShortULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_ulong();

}



eProsima_user_DllExport bool is_MapShortLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLongLong_cdr_plain(data_representation) &&
                sizeof(MapShortLongLong) == MapShortLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortLongLong));

            scdr.jump((array_size -1) * sizeof(MapShortLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLongLong_cdr_plain(data_representation) &&
            sizeof(MapShortLongLong) == MapShortLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortLongLong));

            scdr.jump((array_size - 1) * sizeof(MapShortLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_longlong();

}



eProsima_user_DllExport bool is_MapShortULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortULongLong_cdr_plain(data_representation) &&
                sizeof(MapShortULongLong) == MapShortULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortULongLong));

            scdr.jump((array_size -1) * sizeof(MapShortULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortULongLong_cdr_plain(data_representation) &&
            sizeof(MapShortULongLong) == MapShortULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortULongLong));

            scdr.jump((array_size - 1) * sizeof(MapShortULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_ulonglong();

}



eProsima_user_DllExport bool is_MapShortFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortFloat_cdr_plain(data_representation) &&
                sizeof(MapShortFloat) == MapShortFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortFloat));

            scdr.jump((array_size -1) * sizeof(MapShortFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortFloat_cdr_plain(data_representation) &&
            sizeof(MapShortFloat) == MapShortFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortFloat));

            scdr.jump((array_size - 1) * sizeof(MapShortFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_float();

}



eProsima_user_DllExport bool is_MapShortDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortDouble_cdr_plain(data_representation) &&
                sizeof(MapShortDouble) == MapShortDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortDouble));

            scdr.jump((array_size -1) * sizeof(MapShortDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortDouble_cdr_plain(data_representation) &&
            sizeof(MapShortDouble) == MapShortDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortDouble));

            scdr.jump((array_size - 1) * sizeof(MapShortDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_double();

}



eProsima_user_DllExport bool is_MapShortLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLongDouble_cdr_plain(data_representation) &&
                sizeof(MapShortLongDouble) == MapShortLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortLongDouble));

            scdr.jump((array_size -1) * sizeof(MapShortLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortLongDouble_cdr_plain(data_representation) &&
            sizeof(MapShortLongDouble) == MapShortLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapShortLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_longdouble();

}



eProsima_user_DllExport bool is_MapShortBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortBoolean_cdr_plain(data_representation) &&
                sizeof(MapShortBoolean) == MapShortBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortBoolean));

            scdr.jump((array_size -1) * sizeof(MapShortBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortBoolean_cdr_plain(data_representation) &&
            sizeof(MapShortBoolean) == MapShortBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortBoolean));

            scdr.jump((array_size - 1) * sizeof(MapShortBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_boolean();

}



eProsima_user_DllExport bool is_MapShortOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortOctet_cdr_plain(data_representation) &&
                sizeof(MapShortOctet) == MapShortOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortOctet));

            scdr.jump((array_size -1) * sizeof(MapShortOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortOctet_cdr_plain(data_representation) &&
            sizeof(MapShortOctet) == MapShortOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortOctet));

            scdr.jump((array_size - 1) * sizeof(MapShortOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_octet();

}



eProsima_user_DllExport bool is_MapShortChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortChar_cdr_plain(data_representation) &&
                sizeof(MapShortChar) == MapShortChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortChar));

            scdr.jump((array_size -1) * sizeof(MapShortChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortChar_cdr_plain(data_representation) &&
            sizeof(MapShortChar) == MapShortChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortChar));

            scdr.jump((array_size - 1) * sizeof(MapShortChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_char();

}



eProsima_user_DllExport bool is_MapShortWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortWChar_cdr_plain(data_representation) &&
                sizeof(MapShortWChar) == MapShortWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortWChar));

            scdr.jump((array_size -1) * sizeof(MapShortWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortWChar_cdr_plain(data_representation) &&
            sizeof(MapShortWChar) == MapShortWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortWChar));

            scdr.jump((array_size - 1) * sizeof(MapShortWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_wchar();

}



eProsima_user_DllExport bool is_MapShortString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortString_cdr_plain(data_representation) &&
                sizeof(MapShortString) == MapShortString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortString));

            scdr.jump((array_size -1) * sizeof(MapShortString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortString_cdr_plain(data_representation) &&
            sizeof(MapShortString) == MapShortString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortString));

            scdr.jump((array_size - 1) * sizeof(MapShortString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_string();

}



eProsima_user_DllExport bool is_MapShortWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortWString_cdr_plain(data_representation) &&
                sizeof(MapShortWString) == MapShortWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortWString));

            scdr.jump((array_size -1) * sizeof(MapShortWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortWString_cdr_plain(data_representation) &&
            sizeof(MapShortWString) == MapShortWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortWString));

            scdr.jump((array_size - 1) * sizeof(MapShortWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_wstring();

}



eProsima_user_DllExport bool is_MapShortInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasBoundedStringHelper) == MapShortInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasBoundedStringHelper) == MapShortInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapShortInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasBoundedWStringHelper) == MapShortInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasBoundedWStringHelper) == MapShortInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapShortInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerEnumHelper) == MapShortInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerEnumHelper) == MapShortInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_innerenumhelper();

}



eProsima_user_DllExport bool is_MapShortInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerBitMaskHelper) == MapShortInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerBitMaskHelper) == MapShortInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapShortInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasHelper) == MapShortInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasHelper) == MapShortInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliashelper();

}



eProsima_user_DllExport bool is_MapShortInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasArrayHelper) == MapShortInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasArrayHelper) == MapShortInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapShortInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasSequenceHelper) == MapShortInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasSequenceHelper) == MapShortInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapShortInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerAliasMapHelper) == MapShortInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerAliasMapHelper) == MapShortInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapShortInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerUnionHelper) == MapShortInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerUnionHelper) == MapShortInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_innerunionhelper();

}



eProsima_user_DllExport bool is_MapShortInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerStructureHelper) == MapShortInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerStructureHelper) == MapShortInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapShortInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapShortInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_short_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_short_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapShortInnerBitsetHelper) == MapShortInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapShortInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapShortInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapShortInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_short_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapShortInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapShortInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapShortInnerBitsetHelper) == MapShortInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapShortInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapShortInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapShortInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_short_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapUShortShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortShort_cdr_plain(data_representation) &&
                sizeof(MapUShortShort) == MapUShortShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortShort));

            scdr.jump((array_size -1) * sizeof(MapUShortShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortShort_cdr_plain(data_representation) &&
            sizeof(MapUShortShort) == MapUShortShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortShort));

            scdr.jump((array_size - 1) * sizeof(MapUShortShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_short();

}



eProsima_user_DllExport bool is_MapUShortUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortUShort_cdr_plain(data_representation) &&
                sizeof(MapUShortUShort) == MapUShortUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortUShort));

            scdr.jump((array_size -1) * sizeof(MapUShortUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortUShort_cdr_plain(data_representation) &&
            sizeof(MapUShortUShort) == MapUShortUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortUShort));

            scdr.jump((array_size - 1) * sizeof(MapUShortUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_ushort();

}



eProsima_user_DllExport bool is_MapUShortLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLong_cdr_plain(data_representation) &&
                sizeof(MapUShortLong) == MapUShortLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortLong));

            scdr.jump((array_size -1) * sizeof(MapUShortLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLong_cdr_plain(data_representation) &&
            sizeof(MapUShortLong) == MapUShortLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortLong));

            scdr.jump((array_size - 1) * sizeof(MapUShortLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_long();

}



eProsima_user_DllExport bool is_MapUShortULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortULong_cdr_plain(data_representation) &&
                sizeof(MapUShortULong) == MapUShortULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortULong));

            scdr.jump((array_size -1) * sizeof(MapUShortULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortULong_cdr_plain(data_representation) &&
            sizeof(MapUShortULong) == MapUShortULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortULong));

            scdr.jump((array_size - 1) * sizeof(MapUShortULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_ulong();

}



eProsima_user_DllExport bool is_MapUShortLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLongLong_cdr_plain(data_representation) &&
                sizeof(MapUShortLongLong) == MapUShortLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortLongLong));

            scdr.jump((array_size -1) * sizeof(MapUShortLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLongLong_cdr_plain(data_representation) &&
            sizeof(MapUShortLongLong) == MapUShortLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortLongLong));

            scdr.jump((array_size - 1) * sizeof(MapUShortLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_longlong();

}



eProsima_user_DllExport bool is_MapUShortULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortULongLong_cdr_plain(data_representation) &&
                sizeof(MapUShortULongLong) == MapUShortULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortULongLong));

            scdr.jump((array_size -1) * sizeof(MapUShortULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortULongLong_cdr_plain(data_representation) &&
            sizeof(MapUShortULongLong) == MapUShortULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortULongLong));

            scdr.jump((array_size - 1) * sizeof(MapUShortULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_ulonglong();

}



eProsima_user_DllExport bool is_MapUShortFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortFloat_cdr_plain(data_representation) &&
                sizeof(MapUShortFloat) == MapUShortFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortFloat));

            scdr.jump((array_size -1) * sizeof(MapUShortFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortFloat_cdr_plain(data_representation) &&
            sizeof(MapUShortFloat) == MapUShortFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortFloat));

            scdr.jump((array_size - 1) * sizeof(MapUShortFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_float();

}



eProsima_user_DllExport bool is_MapUShortDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortDouble_cdr_plain(data_representation) &&
                sizeof(MapUShortDouble) == MapUShortDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortDouble));

            scdr.jump((array_size -1) * sizeof(MapUShortDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortDouble_cdr_plain(data_representation) &&
            sizeof(MapUShortDouble) == MapUShortDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortDouble));

            scdr.jump((array_size - 1) * sizeof(MapUShortDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_double();

}



eProsima_user_DllExport bool is_MapUShortLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLongDouble_cdr_plain(data_representation) &&
                sizeof(MapUShortLongDouble) == MapUShortLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortLongDouble));

            scdr.jump((array_size -1) * sizeof(MapUShortLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortLongDouble_cdr_plain(data_representation) &&
            sizeof(MapUShortLongDouble) == MapUShortLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapUShortLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_longdouble();

}



eProsima_user_DllExport bool is_MapUShortBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortBoolean_cdr_plain(data_representation) &&
                sizeof(MapUShortBoolean) == MapUShortBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortBoolean));

            scdr.jump((array_size -1) * sizeof(MapUShortBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortBoolean_cdr_plain(data_representation) &&
            sizeof(MapUShortBoolean) == MapUShortBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortBoolean));

            scdr.jump((array_size - 1) * sizeof(MapUShortBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_boolean();

}



eProsima_user_DllExport bool is_MapUShortOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortOctet_cdr_plain(data_representation) &&
                sizeof(MapUShortOctet) == MapUShortOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortOctet));

            scdr.jump((array_size -1) * sizeof(MapUShortOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortOctet_cdr_plain(data_representation) &&
            sizeof(MapUShortOctet) == MapUShortOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortOctet));

            scdr.jump((array_size - 1) * sizeof(MapUShortOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_octet();

}



eProsima_user_DllExport bool is_MapUShortChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortChar_cdr_plain(data_representation) &&
                sizeof(MapUShortChar) == MapUShortChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortChar));

            scdr.jump((array_size -1) * sizeof(MapUShortChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortChar_cdr_plain(data_representation) &&
            sizeof(MapUShortChar) == MapUShortChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortChar));

            scdr.jump((array_size - 1) * sizeof(MapUShortChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_char();

}



eProsima_user_DllExport bool is_MapUShortWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortWChar_cdr_plain(data_representation) &&
                sizeof(MapUShortWChar) == MapUShortWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortWChar));

            scdr.jump((array_size -1) * sizeof(MapUShortWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortWChar_cdr_plain(data_representation) &&
            sizeof(MapUShortWChar) == MapUShortWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortWChar));

            scdr.jump((array_size - 1) * sizeof(MapUShortWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_wchar();

}



eProsima_user_DllExport bool is_MapUShortString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortString_cdr_plain(data_representation) &&
                sizeof(MapUShortString) == MapUShortString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortString));

            scdr.jump((array_size -1) * sizeof(MapUShortString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortString_cdr_plain(data_representation) &&
            sizeof(MapUShortString) == MapUShortString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortString));

            scdr.jump((array_size - 1) * sizeof(MapUShortString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_string();

}



eProsima_user_DllExport bool is_MapUShortWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortWString_cdr_plain(data_representation) &&
                sizeof(MapUShortWString) == MapUShortWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortWString));

            scdr.jump((array_size -1) * sizeof(MapUShortWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortWString_cdr_plain(data_representation) &&
            sizeof(MapUShortWString) == MapUShortWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortWString));

            scdr.jump((array_size - 1) * sizeof(MapUShortWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_wstring();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasBoundedStringHelper) == MapUShortInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasBoundedStringHelper) == MapUShortInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasBoundedWStringHelper) == MapUShortInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasBoundedWStringHelper) == MapUShortInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerEnumHelper) == MapUShortInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerEnumHelper) == MapUShortInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_innerenumhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerBitMaskHelper) == MapUShortInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerBitMaskHelper) == MapUShortInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasHelper) == MapUShortInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasHelper) == MapUShortInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliashelper();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasArrayHelper) == MapUShortInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasArrayHelper) == MapUShortInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasSequenceHelper) == MapUShortInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasSequenceHelper) == MapUShortInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapUShortInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerAliasMapHelper) == MapUShortInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerAliasMapHelper) == MapUShortInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapUShortInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerUnionHelper) == MapUShortInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerUnionHelper) == MapUShortInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_innerunionhelper();

}



eProsima_user_DllExport bool is_MapUShortInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerStructureHelper) == MapUShortInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerStructureHelper) == MapUShortInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapUShortInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapUShortInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ushort_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ushort_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapUShortInnerBitsetHelper) == MapUShortInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapUShortInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapUShortInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapUShortInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ushort_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapUShortInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapUShortInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapUShortInnerBitsetHelper) == MapUShortInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapUShortInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapUShortInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapUShortInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ushort_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapLongShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongShort_cdr_plain(data_representation) &&
                sizeof(MapLongShort) == MapLongShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongShort));

            scdr.jump((array_size -1) * sizeof(MapLongShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongShort_cdr_plain(data_representation) &&
            sizeof(MapLongShort) == MapLongShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongShort));

            scdr.jump((array_size - 1) * sizeof(MapLongShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_short();

}



eProsima_user_DllExport bool is_MapLongUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongUShort_cdr_plain(data_representation) &&
                sizeof(MapLongUShort) == MapLongUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongUShort));

            scdr.jump((array_size -1) * sizeof(MapLongUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongUShort_cdr_plain(data_representation) &&
            sizeof(MapLongUShort) == MapLongUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongUShort));

            scdr.jump((array_size - 1) * sizeof(MapLongUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_ushort();

}



eProsima_user_DllExport bool is_MapLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLong_cdr_plain(data_representation) &&
                sizeof(MapLongLong) == MapLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLong));

            scdr.jump((array_size -1) * sizeof(MapLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLong_cdr_plain(data_representation) &&
            sizeof(MapLongLong) == MapLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLong));

            scdr.jump((array_size - 1) * sizeof(MapLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_long();

}



eProsima_user_DllExport bool is_MapLongULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongULong_cdr_plain(data_representation) &&
                sizeof(MapLongULong) == MapLongULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongULong));

            scdr.jump((array_size -1) * sizeof(MapLongULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongULong_cdr_plain(data_representation) &&
            sizeof(MapLongULong) == MapLongULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongULong));

            scdr.jump((array_size - 1) * sizeof(MapLongULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_ulong();

}



eProsima_user_DllExport bool is_MapLongKeyLongLongValue_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongKeyLongLongValue& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongLongValue& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongLongValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongKeyLongLongValue_cdr_plain(data_representation) &&
                sizeof(MapLongKeyLongLongValue) == MapLongKeyLongLongValue_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongKeyLongLongValue));

            scdr.jump((array_size -1) * sizeof(MapLongKeyLongLongValue));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongKeyLongLongValue& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongKeyLongLongValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongKeyLongLongValue_cdr_plain(data_representation) &&
            sizeof(MapLongKeyLongLongValue) == MapLongKeyLongLongValue_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongKeyLongLongValue));

            scdr.jump((array_size - 1) * sizeof(MapLongKeyLongLongValue));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongLongValue& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_longlong();

}



eProsima_user_DllExport bool is_MapLongULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongULongLong_cdr_plain(data_representation) &&
                sizeof(MapLongULongLong) == MapLongULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongULongLong));

            scdr.jump((array_size -1) * sizeof(MapLongULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongULongLong_cdr_plain(data_representation) &&
            sizeof(MapLongULongLong) == MapLongULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongULongLong));

            scdr.jump((array_size - 1) * sizeof(MapLongULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_ulonglong();

}



eProsima_user_DllExport bool is_MapLongFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongFloat_cdr_plain(data_representation) &&
                sizeof(MapLongFloat) == MapLongFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongFloat));

            scdr.jump((array_size -1) * sizeof(MapLongFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongFloat_cdr_plain(data_representation) &&
            sizeof(MapLongFloat) == MapLongFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongFloat));

            scdr.jump((array_size - 1) * sizeof(MapLongFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_float();

}



eProsima_user_DllExport bool is_MapLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongDouble_cdr_plain(data_representation) &&
                sizeof(MapLongDouble) == MapLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongDouble));

            scdr.jump((array_size -1) * sizeof(MapLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongDouble_cdr_plain(data_representation) &&
            sizeof(MapLongDouble) == MapLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_double();

}



eProsima_user_DllExport bool is_MapLongKeyLongDoubleValue_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongKeyLongDoubleValue& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongDoubleValue& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongDoubleValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongKeyLongDoubleValue_cdr_plain(data_representation) &&
                sizeof(MapLongKeyLongDoubleValue) == MapLongKeyLongDoubleValue_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongKeyLongDoubleValue));

            scdr.jump((array_size -1) * sizeof(MapLongKeyLongDoubleValue));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongKeyLongDoubleValue& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongKeyLongDoubleValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongKeyLongDoubleValue_cdr_plain(data_representation) &&
            sizeof(MapLongKeyLongDoubleValue) == MapLongKeyLongDoubleValue_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongKeyLongDoubleValue));

            scdr.jump((array_size - 1) * sizeof(MapLongKeyLongDoubleValue));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongKeyLongDoubleValue& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_longdouble();

}



eProsima_user_DllExport bool is_MapLongBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongBoolean_cdr_plain(data_representation) &&
                sizeof(MapLongBoolean) == MapLongBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongBoolean));

            scdr.jump((array_size -1) * sizeof(MapLongBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongBoolean_cdr_plain(data_representation) &&
            sizeof(MapLongBoolean) == MapLongBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongBoolean));

            scdr.jump((array_size - 1) * sizeof(MapLongBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_boolean();

}



eProsima_user_DllExport bool is_MapLongOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongOctet_cdr_plain(data_representation) &&
                sizeof(MapLongOctet) == MapLongOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongOctet));

            scdr.jump((array_size -1) * sizeof(MapLongOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongOctet_cdr_plain(data_representation) &&
            sizeof(MapLongOctet) == MapLongOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongOctet));

            scdr.jump((array_size - 1) * sizeof(MapLongOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_octet();

}



eProsima_user_DllExport bool is_MapLongChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongChar_cdr_plain(data_representation) &&
                sizeof(MapLongChar) == MapLongChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongChar));

            scdr.jump((array_size -1) * sizeof(MapLongChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongChar_cdr_plain(data_representation) &&
            sizeof(MapLongChar) == MapLongChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongChar));

            scdr.jump((array_size - 1) * sizeof(MapLongChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_char();

}



eProsima_user_DllExport bool is_MapLongWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongWChar_cdr_plain(data_representation) &&
                sizeof(MapLongWChar) == MapLongWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongWChar));

            scdr.jump((array_size -1) * sizeof(MapLongWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongWChar_cdr_plain(data_representation) &&
            sizeof(MapLongWChar) == MapLongWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongWChar));

            scdr.jump((array_size - 1) * sizeof(MapLongWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_wchar();

}



eProsima_user_DllExport bool is_MapLongString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongString_cdr_plain(data_representation) &&
                sizeof(MapLongString) == MapLongString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongString));

            scdr.jump((array_size -1) * sizeof(MapLongString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongString_cdr_plain(data_representation) &&
            sizeof(MapLongString) == MapLongString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongString));

            scdr.jump((array_size - 1) * sizeof(MapLongString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_string();

}



eProsima_user_DllExport bool is_MapLongWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongWString_cdr_plain(data_representation) &&
                sizeof(MapLongWString) == MapLongWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongWString));

            scdr.jump((array_size -1) * sizeof(MapLongWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongWString_cdr_plain(data_representation) &&
            sizeof(MapLongWString) == MapLongWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongWString));

            scdr.jump((array_size - 1) * sizeof(MapLongWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_wstring();

}



eProsima_user_DllExport bool is_MapLongInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasBoundedStringHelper) == MapLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasBoundedStringHelper) == MapLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapLongInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasBoundedWStringHelper) == MapLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasBoundedWStringHelper) == MapLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapLongInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerEnumHelper) == MapLongInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerEnumHelper) == MapLongInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_innerenumhelper();

}



eProsima_user_DllExport bool is_MapLongInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerBitMaskHelper) == MapLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerBitMaskHelper) == MapLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapLongInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasHelper) == MapLongInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasHelper) == MapLongInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliashelper();

}



eProsima_user_DllExport bool is_MapLongInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasArrayHelper) == MapLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasArrayHelper) == MapLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapLongInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasSequenceHelper) == MapLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasSequenceHelper) == MapLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapLongInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerAliasMapHelper) == MapLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerAliasMapHelper) == MapLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapLongInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerUnionHelper) == MapLongInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerUnionHelper) == MapLongInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_innerunionhelper();

}



eProsima_user_DllExport bool is_MapLongInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerStructureHelper) == MapLongInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerStructureHelper) == MapLongInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapLongInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_long_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_long_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapLongInnerBitsetHelper) == MapLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapLongInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_long_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapLongInnerBitsetHelper) == MapLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_long_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapULongShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongShort_cdr_plain(data_representation) &&
                sizeof(MapULongShort) == MapULongShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongShort));

            scdr.jump((array_size -1) * sizeof(MapULongShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongShort_cdr_plain(data_representation) &&
            sizeof(MapULongShort) == MapULongShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongShort));

            scdr.jump((array_size - 1) * sizeof(MapULongShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_short();

}



eProsima_user_DllExport bool is_MapULongUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongUShort_cdr_plain(data_representation) &&
                sizeof(MapULongUShort) == MapULongUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongUShort));

            scdr.jump((array_size -1) * sizeof(MapULongUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongUShort_cdr_plain(data_representation) &&
            sizeof(MapULongUShort) == MapULongUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongUShort));

            scdr.jump((array_size - 1) * sizeof(MapULongUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_ushort();

}



eProsima_user_DllExport bool is_MapULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLong_cdr_plain(data_representation) &&
                sizeof(MapULongLong) == MapULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLong));

            scdr.jump((array_size -1) * sizeof(MapULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLong_cdr_plain(data_representation) &&
            sizeof(MapULongLong) == MapULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLong));

            scdr.jump((array_size - 1) * sizeof(MapULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_long();

}



eProsima_user_DllExport bool is_MapULongULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongULong_cdr_plain(data_representation) &&
                sizeof(MapULongULong) == MapULongULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongULong));

            scdr.jump((array_size -1) * sizeof(MapULongULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongULong_cdr_plain(data_representation) &&
            sizeof(MapULongULong) == MapULongULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongULong));

            scdr.jump((array_size - 1) * sizeof(MapULongULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_ulong();

}



eProsima_user_DllExport bool is_MapKeyULongValueLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapKeyULongValueLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongValueLongLong_cdr_plain(data_representation) &&
                sizeof(MapKeyULongValueLongLong) == MapKeyULongValueLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapKeyULongValueLongLong));

            scdr.jump((array_size -1) * sizeof(MapKeyULongValueLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapKeyULongValueLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapKeyULongValueLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongValueLongLong_cdr_plain(data_representation) &&
            sizeof(MapKeyULongValueLongLong) == MapKeyULongValueLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapKeyULongValueLongLong));

            scdr.jump((array_size - 1) * sizeof(MapKeyULongValueLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_longlong();

}



eProsima_user_DllExport bool is_MapULongULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongULongLong_cdr_plain(data_representation) &&
                sizeof(MapULongULongLong) == MapULongULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongULongLong));

            scdr.jump((array_size -1) * sizeof(MapULongULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongULongLong_cdr_plain(data_representation) &&
            sizeof(MapULongULongLong) == MapULongULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongULongLong));

            scdr.jump((array_size - 1) * sizeof(MapULongULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_ulonglong();

}



eProsima_user_DllExport bool is_MapULongFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongFloat_cdr_plain(data_representation) &&
                sizeof(MapULongFloat) == MapULongFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongFloat));

            scdr.jump((array_size -1) * sizeof(MapULongFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongFloat_cdr_plain(data_representation) &&
            sizeof(MapULongFloat) == MapULongFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongFloat));

            scdr.jump((array_size - 1) * sizeof(MapULongFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_float();

}



eProsima_user_DllExport bool is_MapULongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongDouble_cdr_plain(data_representation) &&
                sizeof(MapULongDouble) == MapULongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongDouble));

            scdr.jump((array_size -1) * sizeof(MapULongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongDouble_cdr_plain(data_representation) &&
            sizeof(MapULongDouble) == MapULongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongDouble));

            scdr.jump((array_size - 1) * sizeof(MapULongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_double();

}



eProsima_user_DllExport bool is_MapKeyULongValueLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapKeyULongValueLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongValueLongDouble_cdr_plain(data_representation) &&
                sizeof(MapKeyULongValueLongDouble) == MapKeyULongValueLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapKeyULongValueLongDouble));

            scdr.jump((array_size -1) * sizeof(MapKeyULongValueLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapKeyULongValueLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapKeyULongValueLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongValueLongDouble_cdr_plain(data_representation) &&
            sizeof(MapKeyULongValueLongDouble) == MapKeyULongValueLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapKeyULongValueLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapKeyULongValueLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongValueLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_longdouble();

}



eProsima_user_DllExport bool is_MapULongBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongBoolean_cdr_plain(data_representation) &&
                sizeof(MapULongBoolean) == MapULongBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongBoolean));

            scdr.jump((array_size -1) * sizeof(MapULongBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongBoolean_cdr_plain(data_representation) &&
            sizeof(MapULongBoolean) == MapULongBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongBoolean));

            scdr.jump((array_size - 1) * sizeof(MapULongBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_boolean();

}



eProsima_user_DllExport bool is_MapULongOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongOctet_cdr_plain(data_representation) &&
                sizeof(MapULongOctet) == MapULongOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongOctet));

            scdr.jump((array_size -1) * sizeof(MapULongOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongOctet_cdr_plain(data_representation) &&
            sizeof(MapULongOctet) == MapULongOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongOctet));

            scdr.jump((array_size - 1) * sizeof(MapULongOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_octet();

}



eProsima_user_DllExport bool is_MapULongChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongChar_cdr_plain(data_representation) &&
                sizeof(MapULongChar) == MapULongChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongChar));

            scdr.jump((array_size -1) * sizeof(MapULongChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongChar_cdr_plain(data_representation) &&
            sizeof(MapULongChar) == MapULongChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongChar));

            scdr.jump((array_size - 1) * sizeof(MapULongChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_char();

}



eProsima_user_DllExport bool is_MapULongWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongWChar_cdr_plain(data_representation) &&
                sizeof(MapULongWChar) == MapULongWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongWChar));

            scdr.jump((array_size -1) * sizeof(MapULongWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongWChar_cdr_plain(data_representation) &&
            sizeof(MapULongWChar) == MapULongWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongWChar));

            scdr.jump((array_size - 1) * sizeof(MapULongWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_wchar();

}



eProsima_user_DllExport bool is_MapULongString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongString_cdr_plain(data_representation) &&
                sizeof(MapULongString) == MapULongString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongString));

            scdr.jump((array_size -1) * sizeof(MapULongString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongString_cdr_plain(data_representation) &&
            sizeof(MapULongString) == MapULongString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongString));

            scdr.jump((array_size - 1) * sizeof(MapULongString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_string();

}



eProsima_user_DllExport bool is_MapULongWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongWString_cdr_plain(data_representation) &&
                sizeof(MapULongWString) == MapULongWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongWString));

            scdr.jump((array_size -1) * sizeof(MapULongWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongWString_cdr_plain(data_representation) &&
            sizeof(MapULongWString) == MapULongWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongWString));

            scdr.jump((array_size - 1) * sizeof(MapULongWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_wstring();

}



eProsima_user_DllExport bool is_MapULongInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasBoundedStringHelper) == MapULongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasBoundedStringHelper) == MapULongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapULongInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasBoundedWStringHelper) == MapULongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasBoundedWStringHelper) == MapULongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapULongInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerEnumHelper) == MapULongInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerEnumHelper) == MapULongInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_innerenumhelper();

}



eProsima_user_DllExport bool is_MapULongInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerBitMaskHelper) == MapULongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerBitMaskHelper) == MapULongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapULongInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasHelper) == MapULongInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasHelper) == MapULongInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliashelper();

}



eProsima_user_DllExport bool is_MapULongInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasArrayHelper) == MapULongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasArrayHelper) == MapULongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapULongInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasSequenceHelper) == MapULongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasSequenceHelper) == MapULongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapULongInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerAliasMapHelper) == MapULongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerAliasMapHelper) == MapULongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapULongInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerUnionHelper) == MapULongInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerUnionHelper) == MapULongInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_innerunionhelper();

}



eProsima_user_DllExport bool is_MapULongInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerStructureHelper) == MapULongInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerStructureHelper) == MapULongInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapULongInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_ulong_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_ulong_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapULongInnerBitsetHelper) == MapULongInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapULongInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_ulong_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapULongInnerBitsetHelper) == MapULongInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_ulong_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapLongLongShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongShort_cdr_plain(data_representation) &&
                sizeof(MapLongLongShort) == MapLongLongShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongShort));

            scdr.jump((array_size -1) * sizeof(MapLongLongShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongShort_cdr_plain(data_representation) &&
            sizeof(MapLongLongShort) == MapLongLongShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongShort));

            scdr.jump((array_size - 1) * sizeof(MapLongLongShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_short();

}



eProsima_user_DllExport bool is_MapLongLongUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongUShort_cdr_plain(data_representation) &&
                sizeof(MapLongLongUShort) == MapLongLongUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongUShort));

            scdr.jump((array_size -1) * sizeof(MapLongLongUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongUShort_cdr_plain(data_representation) &&
            sizeof(MapLongLongUShort) == MapLongLongUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongUShort));

            scdr.jump((array_size - 1) * sizeof(MapLongLongUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_ushort();

}



eProsima_user_DllExport bool is_MapLongLongKeyLongValue_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongKeyLongValue& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyLongValue& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyLongValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongKeyLongValue_cdr_plain(data_representation) &&
                sizeof(MapLongLongKeyLongValue) == MapLongLongKeyLongValue_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongKeyLongValue));

            scdr.jump((array_size -1) * sizeof(MapLongLongKeyLongValue));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongKeyLongValue& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongKeyLongValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongKeyLongValue_cdr_plain(data_representation) &&
            sizeof(MapLongLongKeyLongValue) == MapLongLongKeyLongValue_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongKeyLongValue));

            scdr.jump((array_size - 1) * sizeof(MapLongLongKeyLongValue));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyLongValue& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_long();

}



eProsima_user_DllExport bool is_MapLongLongULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongULong_cdr_plain(data_representation) &&
                sizeof(MapLongLongULong) == MapLongLongULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongULong));

            scdr.jump((array_size -1) * sizeof(MapLongLongULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongULong_cdr_plain(data_representation) &&
            sizeof(MapLongLongULong) == MapLongLongULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongULong));

            scdr.jump((array_size - 1) * sizeof(MapLongLongULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_ulong();

}



eProsima_user_DllExport bool is_MapLongLongLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongLongLong_cdr_plain(data_representation) &&
                sizeof(MapLongLongLongLong) == MapLongLongLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongLongLong));

            scdr.jump((array_size -1) * sizeof(MapLongLongLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongLongLong_cdr_plain(data_representation) &&
            sizeof(MapLongLongLongLong) == MapLongLongLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongLongLong));

            scdr.jump((array_size - 1) * sizeof(MapLongLongLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_longlong();

}



eProsima_user_DllExport bool is_MapLongLongULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongULongLong_cdr_plain(data_representation) &&
                sizeof(MapLongLongULongLong) == MapLongLongULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongULongLong));

            scdr.jump((array_size -1) * sizeof(MapLongLongULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongULongLong_cdr_plain(data_representation) &&
            sizeof(MapLongLongULongLong) == MapLongLongULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongULongLong));

            scdr.jump((array_size - 1) * sizeof(MapLongLongULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_ulonglong();

}



eProsima_user_DllExport bool is_MapLongLongFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongFloat_cdr_plain(data_representation) &&
                sizeof(MapLongLongFloat) == MapLongLongFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongFloat));

            scdr.jump((array_size -1) * sizeof(MapLongLongFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongFloat_cdr_plain(data_representation) &&
            sizeof(MapLongLongFloat) == MapLongLongFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongFloat));

            scdr.jump((array_size - 1) * sizeof(MapLongLongFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_float();

}



eProsima_user_DllExport bool is_MapLongLongKeyDoubleValue_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongKeyDoubleValue& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyDoubleValue& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyDoubleValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongKeyDoubleValue_cdr_plain(data_representation) &&
                sizeof(MapLongLongKeyDoubleValue) == MapLongLongKeyDoubleValue_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongKeyDoubleValue));

            scdr.jump((array_size -1) * sizeof(MapLongLongKeyDoubleValue));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongKeyDoubleValue& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongKeyDoubleValue* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongKeyDoubleValue_cdr_plain(data_representation) &&
            sizeof(MapLongLongKeyDoubleValue) == MapLongLongKeyDoubleValue_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongKeyDoubleValue));

            scdr.jump((array_size - 1) * sizeof(MapLongLongKeyDoubleValue));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongKeyDoubleValue& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_double();

}



eProsima_user_DllExport bool is_MapLongLongLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongLongDouble_cdr_plain(data_representation) &&
                sizeof(MapLongLongLongDouble) == MapLongLongLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongLongDouble));

            scdr.jump((array_size -1) * sizeof(MapLongLongLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongLongDouble_cdr_plain(data_representation) &&
            sizeof(MapLongLongLongDouble) == MapLongLongLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapLongLongLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_longdouble();

}



eProsima_user_DllExport bool is_MapLongLongBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongBoolean_cdr_plain(data_representation) &&
                sizeof(MapLongLongBoolean) == MapLongLongBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongBoolean));

            scdr.jump((array_size -1) * sizeof(MapLongLongBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongBoolean_cdr_plain(data_representation) &&
            sizeof(MapLongLongBoolean) == MapLongLongBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongBoolean));

            scdr.jump((array_size - 1) * sizeof(MapLongLongBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_boolean();

}



eProsima_user_DllExport bool is_MapLongLongOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongOctet_cdr_plain(data_representation) &&
                sizeof(MapLongLongOctet) == MapLongLongOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongOctet));

            scdr.jump((array_size -1) * sizeof(MapLongLongOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongOctet_cdr_plain(data_representation) &&
            sizeof(MapLongLongOctet) == MapLongLongOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongOctet));

            scdr.jump((array_size - 1) * sizeof(MapLongLongOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_octet();

}



eProsima_user_DllExport bool is_MapLongLongChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongChar_cdr_plain(data_representation) &&
                sizeof(MapLongLongChar) == MapLongLongChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongChar));

            scdr.jump((array_size -1) * sizeof(MapLongLongChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongChar_cdr_plain(data_representation) &&
            sizeof(MapLongLongChar) == MapLongLongChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongChar));

            scdr.jump((array_size - 1) * sizeof(MapLongLongChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_char();

}



eProsima_user_DllExport bool is_MapLongLongWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongWChar_cdr_plain(data_representation) &&
                sizeof(MapLongLongWChar) == MapLongLongWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongWChar));

            scdr.jump((array_size -1) * sizeof(MapLongLongWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongWChar_cdr_plain(data_representation) &&
            sizeof(MapLongLongWChar) == MapLongLongWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongWChar));

            scdr.jump((array_size - 1) * sizeof(MapLongLongWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_wchar();

}



eProsima_user_DllExport bool is_MapLongLongString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongString_cdr_plain(data_representation) &&
                sizeof(MapLongLongString) == MapLongLongString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongString));

            scdr.jump((array_size -1) * sizeof(MapLongLongString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongString_cdr_plain(data_representation) &&
            sizeof(MapLongLongString) == MapLongLongString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongString));

            scdr.jump((array_size - 1) * sizeof(MapLongLongString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_string();

}



eProsima_user_DllExport bool is_MapLongLongWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongWString_cdr_plain(data_representation) &&
                sizeof(MapLongLongWString) == MapLongLongWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongWString));

            scdr.jump((array_size -1) * sizeof(MapLongLongWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongWString_cdr_plain(data_representation) &&
            sizeof(MapLongLongWString) == MapLongLongWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongWString));

            scdr.jump((array_size - 1) * sizeof(MapLongLongWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_wstring();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasBoundedStringHelper) == MapLongLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasBoundedStringHelper) == MapLongLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasBoundedWStringHelper) == MapLongLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasBoundedWStringHelper) == MapLongLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerEnumHelper) == MapLongLongInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerEnumHelper) == MapLongLongInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_innerenumhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerBitMaskHelper) == MapLongLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerBitMaskHelper) == MapLongLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasHelper) == MapLongLongInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasHelper) == MapLongLongInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliashelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasArrayHelper) == MapLongLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasArrayHelper) == MapLongLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasSequenceHelper) == MapLongLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasSequenceHelper) == MapLongLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerAliasMapHelper) == MapLongLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerAliasMapHelper) == MapLongLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerUnionHelper) == MapLongLongInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerUnionHelper) == MapLongLongInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_innerunionhelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerStructureHelper) == MapLongLongInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerStructureHelper) == MapLongLongInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapLongLongInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapLongLongInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_longlong_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_longlong_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapLongLongInnerBitsetHelper) == MapLongLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapLongLongInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapLongLongInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapLongLongInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_longlong_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapLongLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapLongLongInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapLongLongInnerBitsetHelper) == MapLongLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapLongLongInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapLongLongInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapLongLongInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_longlong_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapULongLongShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongShort_cdr_plain(data_representation) &&
                sizeof(MapULongLongShort) == MapULongLongShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongShort));

            scdr.jump((array_size -1) * sizeof(MapULongLongShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongShort_cdr_plain(data_representation) &&
            sizeof(MapULongLongShort) == MapULongLongShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongShort));

            scdr.jump((array_size - 1) * sizeof(MapULongLongShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_short();

}



eProsima_user_DllExport bool is_MapULongLongUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_u_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_u_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongUShort_cdr_plain(data_representation) &&
                sizeof(MapULongLongUShort) == MapULongLongUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongUShort));

            scdr.jump((array_size -1) * sizeof(MapULongLongUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_u_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongUShort_cdr_plain(data_representation) &&
            sizeof(MapULongLongUShort) == MapULongLongUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongUShort));

            scdr.jump((array_size - 1) * sizeof(MapULongLongUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_u_short();

}



eProsima_user_DllExport bool is_MapULongLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLong_cdr_plain(data_representation) &&
                sizeof(MapULongLongLong) == MapULongLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongLong));

            scdr.jump((array_size -1) * sizeof(MapULongLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLong_cdr_plain(data_representation) &&
            sizeof(MapULongLongLong) == MapULongLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongLong));

            scdr.jump((array_size - 1) * sizeof(MapULongLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_long();

}



eProsima_user_DllExport bool is_MapULongLongULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_u_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_u_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongULong_cdr_plain(data_representation) &&
                sizeof(MapULongLongULong) == MapULongLongULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongULong));

            scdr.jump((array_size -1) * sizeof(MapULongLongULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_u_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongULong_cdr_plain(data_representation) &&
            sizeof(MapULongLongULong) == MapULongLongULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongULong));

            scdr.jump((array_size - 1) * sizeof(MapULongLongULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_u_long();

}



eProsima_user_DllExport bool is_MapULongLongLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_long_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_long_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLongLong_cdr_plain(data_representation) &&
                sizeof(MapULongLongLongLong) == MapULongLongLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongLongLong));

            scdr.jump((array_size -1) * sizeof(MapULongLongLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_long_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLongLong_cdr_plain(data_representation) &&
            sizeof(MapULongLongLongLong) == MapULongLongLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongLongLong));

            scdr.jump((array_size - 1) * sizeof(MapULongLongLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_long_long();

}



eProsima_user_DllExport bool is_MapULongLongULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_u_long_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_u_long_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongULongLong_cdr_plain(data_representation) &&
                sizeof(MapULongLongULongLong) == MapULongLongULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongULongLong));

            scdr.jump((array_size -1) * sizeof(MapULongLongULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_u_long_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongULongLong_cdr_plain(data_representation) &&
            sizeof(MapULongLongULongLong) == MapULongLongULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongULongLong));

            scdr.jump((array_size - 1) * sizeof(MapULongLongULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_u_long_long();

}



eProsima_user_DllExport bool is_MapULongLongFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongFloat_cdr_plain(data_representation) &&
                sizeof(MapULongLongFloat) == MapULongLongFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongFloat));

            scdr.jump((array_size -1) * sizeof(MapULongLongFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongFloat_cdr_plain(data_representation) &&
            sizeof(MapULongLongFloat) == MapULongLongFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongFloat));

            scdr.jump((array_size - 1) * sizeof(MapULongLongFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_float();

}



eProsima_user_DllExport bool is_MapKeyULongLongValueDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapKeyULongLongValueDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongLongValueDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongLongValueDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongLongValueDouble_cdr_plain(data_representation) &&
                sizeof(MapKeyULongLongValueDouble) == MapKeyULongLongValueDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapKeyULongLongValueDouble));

            scdr.jump((array_size -1) * sizeof(MapKeyULongLongValueDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapKeyULongLongValueDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapKeyULongLongValueDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapKeyULongLongValueDouble_cdr_plain(data_representation) &&
            sizeof(MapKeyULongLongValueDouble) == MapKeyULongLongValueDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapKeyULongLongValueDouble));

            scdr.jump((array_size - 1) * sizeof(MapKeyULongLongValueDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapKeyULongLongValueDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_double();

}



eProsima_user_DllExport bool is_MapULongLongLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_long_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_long_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLongDouble_cdr_plain(data_representation) &&
                sizeof(MapULongLongLongDouble) == MapULongLongLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongLongDouble));

            scdr.jump((array_size -1) * sizeof(MapULongLongLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_long_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongLongDouble_cdr_plain(data_representation) &&
            sizeof(MapULongLongLongDouble) == MapULongLongLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapULongLongLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_long_double();

}



eProsima_user_DllExport bool is_MapULongLongBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongBoolean_cdr_plain(data_representation) &&
                sizeof(MapULongLongBoolean) == MapULongLongBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongBoolean));

            scdr.jump((array_size -1) * sizeof(MapULongLongBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongBoolean_cdr_plain(data_representation) &&
            sizeof(MapULongLongBoolean) == MapULongLongBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongBoolean));

            scdr.jump((array_size - 1) * sizeof(MapULongLongBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_boolean();

}



eProsima_user_DllExport bool is_MapULongLongOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongOctet_cdr_plain(data_representation) &&
                sizeof(MapULongLongOctet) == MapULongLongOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongOctet));

            scdr.jump((array_size -1) * sizeof(MapULongLongOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongOctet_cdr_plain(data_representation) &&
            sizeof(MapULongLongOctet) == MapULongLongOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongOctet));

            scdr.jump((array_size - 1) * sizeof(MapULongLongOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_octet();

}



eProsima_user_DllExport bool is_MapULongLongChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongChar_cdr_plain(data_representation) &&
                sizeof(MapULongLongChar) == MapULongLongChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongChar));

            scdr.jump((array_size -1) * sizeof(MapULongLongChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongChar_cdr_plain(data_representation) &&
            sizeof(MapULongLongChar) == MapULongLongChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongChar));

            scdr.jump((array_size - 1) * sizeof(MapULongLongChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_char();

}



eProsima_user_DllExport bool is_MapULongLongWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongWChar_cdr_plain(data_representation) &&
                sizeof(MapULongLongWChar) == MapULongLongWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongWChar));

            scdr.jump((array_size -1) * sizeof(MapULongLongWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongWChar_cdr_plain(data_representation) &&
            sizeof(MapULongLongWChar) == MapULongLongWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongWChar));

            scdr.jump((array_size - 1) * sizeof(MapULongLongWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_wchar();

}



eProsima_user_DllExport bool is_MapULongLongString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongString_cdr_plain(data_representation) &&
                sizeof(MapULongLongString) == MapULongLongString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongString));

            scdr.jump((array_size -1) * sizeof(MapULongLongString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongString_cdr_plain(data_representation) &&
            sizeof(MapULongLongString) == MapULongLongString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongString));

            scdr.jump((array_size - 1) * sizeof(MapULongLongString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_string();

}



eProsima_user_DllExport bool is_MapULongLongWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongWString_cdr_plain(data_representation) &&
                sizeof(MapULongLongWString) == MapULongLongWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongWString));

            scdr.jump((array_size -1) * sizeof(MapULongLongWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongWString_cdr_plain(data_representation) &&
            sizeof(MapULongLongWString) == MapULongLongWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongWString));

            scdr.jump((array_size - 1) * sizeof(MapULongLongWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_wstring();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_bounded_string_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_bounded_string_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasBoundedStringHelper) == MapULongLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_bounded_string_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasBoundedStringHelper) == MapULongLongInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_bounded_string_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_bounded_wstring_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_bounded_wstring_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasBoundedWStringHelper) == MapULongLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_bounded_wstring_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasBoundedWStringHelper) == MapULongLongInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_bounded_wstring_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_enum_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_enum_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerEnumHelper) == MapULongLongInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_enum_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerEnumHelper) == MapULongLongInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_enum_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_bit_mask_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_bit_mask_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerBitMaskHelper) == MapULongLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_bit_mask_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerBitMaskHelper) == MapULongLongInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_bit_mask_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasHelper) == MapULongLongInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasHelper) == MapULongLongInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_array_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_array_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasArrayHelper) == MapULongLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_array_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasArrayHelper) == MapULongLongInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_array_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_sequence_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_sequence_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasSequenceHelper) == MapULongLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_sequence_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasSequenceHelper) == MapULongLongInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_sequence_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_alias_map_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_alias_map_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerAliasMapHelper) == MapULongLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_alias_map_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerAliasMapHelper) == MapULongLongInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_alias_map_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_union_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_union_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerUnionHelper) == MapULongLongInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_union_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerUnionHelper) == MapULongLongInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_union_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_structure_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_structure_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerStructureHelper) == MapULongLongInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_structure_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerStructureHelper) == MapULongLongInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_structure_helper();

}



eProsima_user_DllExport bool is_MapULongLongInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapULongLongInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_u_long_long_inner_bitset_helper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_u_long_long_inner_bitset_helper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapULongLongInnerBitsetHelper) == MapULongLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapULongLongInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapULongLongInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapULongLongInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_u_long_long_inner_bitset_helper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapULongLongInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapULongLongInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapULongLongInnerBitsetHelper) == MapULongLongInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapULongLongInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapULongLongInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapULongLongInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_u_long_long_inner_bitset_helper();

}



eProsima_user_DllExport bool is_MapStringShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringShort_cdr_plain(data_representation) &&
                sizeof(MapStringShort) == MapStringShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringShort));

            scdr.jump((array_size -1) * sizeof(MapStringShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringShort_cdr_plain(data_representation) &&
            sizeof(MapStringShort) == MapStringShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringShort));

            scdr.jump((array_size - 1) * sizeof(MapStringShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_short();

}



eProsima_user_DllExport bool is_MapStringUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringUShort_cdr_plain(data_representation) &&
                sizeof(MapStringUShort) == MapStringUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringUShort));

            scdr.jump((array_size -1) * sizeof(MapStringUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringUShort_cdr_plain(data_representation) &&
            sizeof(MapStringUShort) == MapStringUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringUShort));

            scdr.jump((array_size - 1) * sizeof(MapStringUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_ushort();

}



eProsima_user_DllExport bool is_MapStringLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLong_cdr_plain(data_representation) &&
                sizeof(MapStringLong) == MapStringLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringLong));

            scdr.jump((array_size -1) * sizeof(MapStringLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLong_cdr_plain(data_representation) &&
            sizeof(MapStringLong) == MapStringLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringLong));

            scdr.jump((array_size - 1) * sizeof(MapStringLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_long();

}



eProsima_user_DllExport bool is_MapStringULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringULong_cdr_plain(data_representation) &&
                sizeof(MapStringULong) == MapStringULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringULong));

            scdr.jump((array_size -1) * sizeof(MapStringULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringULong_cdr_plain(data_representation) &&
            sizeof(MapStringULong) == MapStringULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringULong));

            scdr.jump((array_size - 1) * sizeof(MapStringULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_ulong();

}



eProsima_user_DllExport bool is_MapStringLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLongLong_cdr_plain(data_representation) &&
                sizeof(MapStringLongLong) == MapStringLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringLongLong));

            scdr.jump((array_size -1) * sizeof(MapStringLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLongLong_cdr_plain(data_representation) &&
            sizeof(MapStringLongLong) == MapStringLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringLongLong));

            scdr.jump((array_size - 1) * sizeof(MapStringLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_longlong();

}



eProsima_user_DllExport bool is_MapStringULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringULongLong_cdr_plain(data_representation) &&
                sizeof(MapStringULongLong) == MapStringULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringULongLong));

            scdr.jump((array_size -1) * sizeof(MapStringULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringULongLong_cdr_plain(data_representation) &&
            sizeof(MapStringULongLong) == MapStringULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringULongLong));

            scdr.jump((array_size - 1) * sizeof(MapStringULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_ulonglong();

}



eProsima_user_DllExport bool is_MapStringFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringFloat_cdr_plain(data_representation) &&
                sizeof(MapStringFloat) == MapStringFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringFloat));

            scdr.jump((array_size -1) * sizeof(MapStringFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringFloat_cdr_plain(data_representation) &&
            sizeof(MapStringFloat) == MapStringFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringFloat));

            scdr.jump((array_size - 1) * sizeof(MapStringFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_float();

}



eProsima_user_DllExport bool is_MapStringDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringDouble_cdr_plain(data_representation) &&
                sizeof(MapStringDouble) == MapStringDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringDouble));

            scdr.jump((array_size -1) * sizeof(MapStringDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringDouble_cdr_plain(data_representation) &&
            sizeof(MapStringDouble) == MapStringDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringDouble));

            scdr.jump((array_size - 1) * sizeof(MapStringDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_double();

}



eProsima_user_DllExport bool is_MapStringLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLongDouble_cdr_plain(data_representation) &&
                sizeof(MapStringLongDouble) == MapStringLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringLongDouble));

            scdr.jump((array_size -1) * sizeof(MapStringLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringLongDouble_cdr_plain(data_representation) &&
            sizeof(MapStringLongDouble) == MapStringLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapStringLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_longdouble();

}



eProsima_user_DllExport bool is_MapStringBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringBoolean_cdr_plain(data_representation) &&
                sizeof(MapStringBoolean) == MapStringBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringBoolean));

            scdr.jump((array_size -1) * sizeof(MapStringBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringBoolean_cdr_plain(data_representation) &&
            sizeof(MapStringBoolean) == MapStringBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringBoolean));

            scdr.jump((array_size - 1) * sizeof(MapStringBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_boolean();

}



eProsima_user_DllExport bool is_MapStringOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringOctet_cdr_plain(data_representation) &&
                sizeof(MapStringOctet) == MapStringOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringOctet));

            scdr.jump((array_size -1) * sizeof(MapStringOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringOctet_cdr_plain(data_representation) &&
            sizeof(MapStringOctet) == MapStringOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringOctet));

            scdr.jump((array_size - 1) * sizeof(MapStringOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_octet();

}



eProsima_user_DllExport bool is_MapStringChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringChar_cdr_plain(data_representation) &&
                sizeof(MapStringChar) == MapStringChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringChar));

            scdr.jump((array_size -1) * sizeof(MapStringChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringChar_cdr_plain(data_representation) &&
            sizeof(MapStringChar) == MapStringChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringChar));

            scdr.jump((array_size - 1) * sizeof(MapStringChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_char();

}



eProsima_user_DllExport bool is_MapStringWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringWChar_cdr_plain(data_representation) &&
                sizeof(MapStringWChar) == MapStringWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringWChar));

            scdr.jump((array_size -1) * sizeof(MapStringWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringWChar_cdr_plain(data_representation) &&
            sizeof(MapStringWChar) == MapStringWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringWChar));

            scdr.jump((array_size - 1) * sizeof(MapStringWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_wchar();

}



eProsima_user_DllExport bool is_MapStringString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringString_cdr_plain(data_representation) &&
                sizeof(MapStringString) == MapStringString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringString));

            scdr.jump((array_size -1) * sizeof(MapStringString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringString_cdr_plain(data_representation) &&
            sizeof(MapStringString) == MapStringString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringString));

            scdr.jump((array_size - 1) * sizeof(MapStringString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_string();

}



eProsima_user_DllExport bool is_MapStringWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringWString_cdr_plain(data_representation) &&
                sizeof(MapStringWString) == MapStringWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringWString));

            scdr.jump((array_size -1) * sizeof(MapStringWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringWString_cdr_plain(data_representation) &&
            sizeof(MapStringWString) == MapStringWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringWString));

            scdr.jump((array_size - 1) * sizeof(MapStringWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_wstring();

}



eProsima_user_DllExport bool is_MapStringInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasBoundedStringHelper) == MapStringInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasBoundedStringHelper) == MapStringInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapStringInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasBoundedWStringHelper) == MapStringInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasBoundedWStringHelper) == MapStringInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapStringInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerEnumHelper) == MapStringInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerEnumHelper) == MapStringInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_innerenumhelper();

}



eProsima_user_DllExport bool is_MapStringInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerBitMaskHelper) == MapStringInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerBitMaskHelper) == MapStringInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapStringInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasHelper) == MapStringInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasHelper) == MapStringInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliashelper();

}



eProsima_user_DllExport bool is_MapStringInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasArrayHelper) == MapStringInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasArrayHelper) == MapStringInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapStringInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasSequenceHelper) == MapStringInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasSequenceHelper) == MapStringInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapStringInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerAliasMapHelper) == MapStringInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerAliasMapHelper) == MapStringInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapStringInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerUnionHelper) == MapStringInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerUnionHelper) == MapStringInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_innerunionhelper();

}



eProsima_user_DllExport bool is_MapStringInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerStructureHelper) == MapStringInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerStructureHelper) == MapStringInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapStringInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStringInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_string_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_string_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapStringInnerBitsetHelper) == MapStringInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapStringInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapStringInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStringInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_string_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapStringInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapStringInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapStringInnerBitsetHelper) == MapStringInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapStringInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapStringInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStringInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_string_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapWStringShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringShort_cdr_plain(data_representation) &&
                sizeof(MapWStringShort) == MapWStringShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringShort));

            scdr.jump((array_size -1) * sizeof(MapWStringShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringShort_cdr_plain(data_representation) &&
            sizeof(MapWStringShort) == MapWStringShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringShort));

            scdr.jump((array_size - 1) * sizeof(MapWStringShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_short();

}



eProsima_user_DllExport bool is_MapWStringUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringUShort_cdr_plain(data_representation) &&
                sizeof(MapWStringUShort) == MapWStringUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringUShort));

            scdr.jump((array_size -1) * sizeof(MapWStringUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringUShort_cdr_plain(data_representation) &&
            sizeof(MapWStringUShort) == MapWStringUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringUShort));

            scdr.jump((array_size - 1) * sizeof(MapWStringUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_ushort();

}



eProsima_user_DllExport bool is_MapWStringLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLong_cdr_plain(data_representation) &&
                sizeof(MapWStringLong) == MapWStringLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringLong));

            scdr.jump((array_size -1) * sizeof(MapWStringLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLong_cdr_plain(data_representation) &&
            sizeof(MapWStringLong) == MapWStringLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringLong));

            scdr.jump((array_size - 1) * sizeof(MapWStringLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_long();

}



eProsima_user_DllExport bool is_MapWStringULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringULong_cdr_plain(data_representation) &&
                sizeof(MapWStringULong) == MapWStringULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringULong));

            scdr.jump((array_size -1) * sizeof(MapWStringULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringULong_cdr_plain(data_representation) &&
            sizeof(MapWStringULong) == MapWStringULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringULong));

            scdr.jump((array_size - 1) * sizeof(MapWStringULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_ulong();

}



eProsima_user_DllExport bool is_MapWStringLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLongLong_cdr_plain(data_representation) &&
                sizeof(MapWStringLongLong) == MapWStringLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringLongLong));

            scdr.jump((array_size -1) * sizeof(MapWStringLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLongLong_cdr_plain(data_representation) &&
            sizeof(MapWStringLongLong) == MapWStringLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringLongLong));

            scdr.jump((array_size - 1) * sizeof(MapWStringLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_longlong();

}



eProsima_user_DllExport bool is_MapWStringULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringULongLong_cdr_plain(data_representation) &&
                sizeof(MapWStringULongLong) == MapWStringULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringULongLong));

            scdr.jump((array_size -1) * sizeof(MapWStringULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringULongLong_cdr_plain(data_representation) &&
            sizeof(MapWStringULongLong) == MapWStringULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringULongLong));

            scdr.jump((array_size - 1) * sizeof(MapWStringULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_ulonglong();

}



eProsima_user_DllExport bool is_MapWStringFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringFloat_cdr_plain(data_representation) &&
                sizeof(MapWStringFloat) == MapWStringFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringFloat));

            scdr.jump((array_size -1) * sizeof(MapWStringFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringFloat_cdr_plain(data_representation) &&
            sizeof(MapWStringFloat) == MapWStringFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringFloat));

            scdr.jump((array_size - 1) * sizeof(MapWStringFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_float();

}



eProsima_user_DllExport bool is_MapWStringDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringDouble_cdr_plain(data_representation) &&
                sizeof(MapWStringDouble) == MapWStringDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringDouble));

            scdr.jump((array_size -1) * sizeof(MapWStringDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringDouble_cdr_plain(data_representation) &&
            sizeof(MapWStringDouble) == MapWStringDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringDouble));

            scdr.jump((array_size - 1) * sizeof(MapWStringDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_double();

}



eProsima_user_DllExport bool is_MapWStringLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLongDouble_cdr_plain(data_representation) &&
                sizeof(MapWStringLongDouble) == MapWStringLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringLongDouble));

            scdr.jump((array_size -1) * sizeof(MapWStringLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringLongDouble_cdr_plain(data_representation) &&
            sizeof(MapWStringLongDouble) == MapWStringLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapWStringLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_longdouble();

}



eProsima_user_DllExport bool is_MapWStringBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringBoolean_cdr_plain(data_representation) &&
                sizeof(MapWStringBoolean) == MapWStringBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringBoolean));

            scdr.jump((array_size -1) * sizeof(MapWStringBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringBoolean_cdr_plain(data_representation) &&
            sizeof(MapWStringBoolean) == MapWStringBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringBoolean));

            scdr.jump((array_size - 1) * sizeof(MapWStringBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_boolean();

}



eProsima_user_DllExport bool is_MapWStringOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringOctet_cdr_plain(data_representation) &&
                sizeof(MapWStringOctet) == MapWStringOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringOctet));

            scdr.jump((array_size -1) * sizeof(MapWStringOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringOctet_cdr_plain(data_representation) &&
            sizeof(MapWStringOctet) == MapWStringOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringOctet));

            scdr.jump((array_size - 1) * sizeof(MapWStringOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_octet();

}



eProsima_user_DllExport bool is_MapWStringChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringChar_cdr_plain(data_representation) &&
                sizeof(MapWStringChar) == MapWStringChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringChar));

            scdr.jump((array_size -1) * sizeof(MapWStringChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringChar_cdr_plain(data_representation) &&
            sizeof(MapWStringChar) == MapWStringChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringChar));

            scdr.jump((array_size - 1) * sizeof(MapWStringChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_char();

}



eProsima_user_DllExport bool is_MapWStringWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringWChar_cdr_plain(data_representation) &&
                sizeof(MapWStringWChar) == MapWStringWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringWChar));

            scdr.jump((array_size -1) * sizeof(MapWStringWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringWChar_cdr_plain(data_representation) &&
            sizeof(MapWStringWChar) == MapWStringWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringWChar));

            scdr.jump((array_size - 1) * sizeof(MapWStringWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_wchar();

}



eProsima_user_DllExport bool is_MapWStringString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringString_cdr_plain(data_representation) &&
                sizeof(MapWStringString) == MapWStringString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringString));

            scdr.jump((array_size -1) * sizeof(MapWStringString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringString_cdr_plain(data_representation) &&
            sizeof(MapWStringString) == MapWStringString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringString));

            scdr.jump((array_size - 1) * sizeof(MapWStringString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_string();

}



eProsima_user_DllExport bool is_MapWStringWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringWString_cdr_plain(data_representation) &&
                sizeof(MapWStringWString) == MapWStringWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringWString));

            scdr.jump((array_size -1) * sizeof(MapWStringWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringWString_cdr_plain(data_representation) &&
            sizeof(MapWStringWString) == MapWStringWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringWString));

            scdr.jump((array_size - 1) * sizeof(MapWStringWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_wstring();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasBoundedStringHelper) == MapWStringInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasBoundedStringHelper) == MapWStringInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasBoundedWStringHelper) == MapWStringInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasBoundedWStringHelper) == MapWStringInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerEnumHelper) == MapWStringInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerEnumHelper) == MapWStringInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_innerenumhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerBitMaskHelper) == MapWStringInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerBitMaskHelper) == MapWStringInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasHelper) == MapWStringInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasHelper) == MapWStringInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliashelper();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasArrayHelper) == MapWStringInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasArrayHelper) == MapWStringInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasSequenceHelper) == MapWStringInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasSequenceHelper) == MapWStringInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapWStringInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerAliasMapHelper) == MapWStringInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerAliasMapHelper) == MapWStringInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapWStringInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerUnionHelper) == MapWStringInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerUnionHelper) == MapWStringInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_innerunionhelper();

}



eProsima_user_DllExport bool is_MapWStringInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerStructureHelper) == MapWStringInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerStructureHelper) == MapWStringInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapWStringInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapWStringInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_wstring_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_wstring_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapWStringInnerBitsetHelper) == MapWStringInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapWStringInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapWStringInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapWStringInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_wstring_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapWStringInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapWStringInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapWStringInnerBitsetHelper) == MapWStringInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapWStringInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapWStringInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapWStringInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_wstring_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperShort_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperShort) == MapInnerAliasBoundedStringHelperShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperShort));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperShort_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperShort) == MapInnerAliasBoundedStringHelperShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperShort));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_short();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperUShort_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperUShort) == MapInnerAliasBoundedStringHelperUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperUShort));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperUShort_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperUShort) == MapInnerAliasBoundedStringHelperUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperUShort));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_ushort();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperLong) == MapInnerAliasBoundedStringHelperLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperLong) == MapInnerAliasBoundedStringHelperLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_long();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperULong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperULong) == MapInnerAliasBoundedStringHelperULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperULong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperULong) == MapInnerAliasBoundedStringHelperULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_ulong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLongLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperLongLong) == MapInnerAliasBoundedStringHelperLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLongLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperLongLong) == MapInnerAliasBoundedStringHelperLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_longlong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperULongLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperULongLong) == MapInnerAliasBoundedStringHelperULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULongLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperULongLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperULongLong) == MapInnerAliasBoundedStringHelperULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULongLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_ulonglong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperFloat_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperFloat) == MapInnerAliasBoundedStringHelperFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperFloat));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperFloat_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperFloat) == MapInnerAliasBoundedStringHelperFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperFloat));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_float();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperDouble_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperDouble) == MapInnerAliasBoundedStringHelperDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperDouble));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperDouble_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperDouble) == MapInnerAliasBoundedStringHelperDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperDouble));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_double();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLongDouble_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperLongDouble) == MapInnerAliasBoundedStringHelperLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongDouble));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperLongDouble_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperLongDouble) == MapInnerAliasBoundedStringHelperLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_longdouble();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperBoolean_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperBoolean) == MapInnerAliasBoundedStringHelperBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperBoolean));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperBoolean_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperBoolean) == MapInnerAliasBoundedStringHelperBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperBoolean));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_boolean();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperOctet_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperOctet) == MapInnerAliasBoundedStringHelperOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperOctet));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperOctet_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperOctet) == MapInnerAliasBoundedStringHelperOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperOctet));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_octet();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperChar_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperChar) == MapInnerAliasBoundedStringHelperChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperChar));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperChar_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperChar) == MapInnerAliasBoundedStringHelperChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperChar));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_char();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperWChar_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperWChar) == MapInnerAliasBoundedStringHelperWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWChar));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperWChar_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperWChar) == MapInnerAliasBoundedStringHelperWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWChar));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_wchar();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperString_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperString) == MapInnerAliasBoundedStringHelperString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperString));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperString_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperString) == MapInnerAliasBoundedStringHelperString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperString));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_string();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperWString_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperWString) == MapInnerAliasBoundedStringHelperWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWString));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperWString_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperWString) == MapInnerAliasBoundedStringHelperWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWString));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_wstring();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper) == MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper) == MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper) == MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper) == MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper) == MapInnerAliasBoundedStringHelperInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper) == MapInnerAliasBoundedStringHelperInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_innerenumhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper) == MapInnerAliasBoundedStringHelperInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper) == MapInnerAliasBoundedStringHelperInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper) == MapInnerAliasBoundedStringHelperInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper) == MapInnerAliasBoundedStringHelperInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliashelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper) == MapInnerAliasBoundedStringHelperInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper) == MapInnerAliasBoundedStringHelperInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper) == MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper) == MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper) == MapInnerAliasBoundedStringHelperInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper) == MapInnerAliasBoundedStringHelperInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper) == MapInnerAliasBoundedStringHelperInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper) == MapInnerAliasBoundedStringHelperInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_innerunionhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper) == MapInnerAliasBoundedStringHelperInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper) == MapInnerAliasBoundedStringHelperInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedStringHelperInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedStringHelperInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedstringhelper_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedstringhelper_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper) == MapInnerAliasBoundedStringHelperInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedStringHelperInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedstringhelper_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedStringHelperInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedStringHelperInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper) == MapInnerAliasBoundedStringHelperInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedStringHelperInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedStringHelperInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedstringhelper_innerbitsethelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperShort_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperShort) == MapInnerAliasBoundedWStringHelperShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperShort));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperShort_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperShort) == MapInnerAliasBoundedWStringHelperShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperShort));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_short();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperUShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperUShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperUShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperUShort_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperUShort) == MapInnerAliasBoundedWStringHelperUShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperUShort));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperUShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperUShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperUShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperUShort_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperUShort) == MapInnerAliasBoundedWStringHelperUShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperUShort));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperUShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperUShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_ushort();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperLong) == MapInnerAliasBoundedWStringHelperLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperLong) == MapInnerAliasBoundedWStringHelperLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_long();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperULong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperULong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperULong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperULong) == MapInnerAliasBoundedWStringHelperULong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperULong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperULong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperULong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperULong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperULong) == MapInnerAliasBoundedWStringHelperULong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_ulong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLongLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperLongLong) == MapInnerAliasBoundedWStringHelperLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLongLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperLongLong) == MapInnerAliasBoundedWStringHelperLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_longlong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperULongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperULongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperULongLong_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperULongLong) == MapInnerAliasBoundedWStringHelperULongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULongLong));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperULongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperULongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperULongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperULongLong_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperULongLong) == MapInnerAliasBoundedWStringHelperULongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULongLong));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperULongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperULongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_ulonglong();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperFloat_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperFloat) == MapInnerAliasBoundedWStringHelperFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperFloat));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperFloat_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperFloat) == MapInnerAliasBoundedWStringHelperFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperFloat));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_float();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperDouble_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperDouble) == MapInnerAliasBoundedWStringHelperDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperDouble));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperDouble_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperDouble) == MapInnerAliasBoundedWStringHelperDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperDouble));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_double();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLongDouble_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperLongDouble) == MapInnerAliasBoundedWStringHelperLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongDouble));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperLongDouble_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperLongDouble) == MapInnerAliasBoundedWStringHelperLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongDouble));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_longdouble();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperBoolean_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperBoolean) == MapInnerAliasBoundedWStringHelperBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperBoolean));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperBoolean_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperBoolean) == MapInnerAliasBoundedWStringHelperBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperBoolean));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_boolean();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperOctet_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperOctet) == MapInnerAliasBoundedWStringHelperOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperOctet));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperOctet_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperOctet) == MapInnerAliasBoundedWStringHelperOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperOctet));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_octet();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_char()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperChar_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperChar) == MapInnerAliasBoundedWStringHelperChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperChar));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperChar_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperChar) == MapInnerAliasBoundedWStringHelperChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperChar));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_char();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperWChar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperWChar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWChar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_wchar()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperWChar_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperWChar) == MapInnerAliasBoundedWStringHelperWChar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWChar));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperWChar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperWChar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperWChar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperWChar_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperWChar) == MapInnerAliasBoundedWStringHelperWChar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWChar));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWChar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWChar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_wchar();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperString_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperString) == MapInnerAliasBoundedWStringHelperString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperString));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperString_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperString) == MapInnerAliasBoundedWStringHelperString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperString));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_string();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperWString_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperWString) == MapInnerAliasBoundedWStringHelperWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWString));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperWString_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperWString) == MapInnerAliasBoundedWStringHelperWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWString));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_wstring();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper) == MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper) == MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliasboundedstringhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper) == MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper) == MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliasboundedwstringhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerEnumHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerEnumHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_innerenumhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerEnumHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_innerenumhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerEnumHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper) == MapInnerAliasBoundedWStringHelperInnerEnumHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerEnumHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_innerenumhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerEnumHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerEnumHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper) == MapInnerAliasBoundedWStringHelperInnerEnumHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerEnumHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerEnumHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_innerenumhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerBitMaskHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerBitMaskHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_innerbitmaskhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitMaskHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_innerbitmaskhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerBitMaskHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper) == MapInnerAliasBoundedWStringHelperInnerBitMaskHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerBitMaskHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_innerbitmaskhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerBitMaskHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerBitMaskHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper) == MapInnerAliasBoundedWStringHelperInnerBitMaskHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitMaskHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitMaskHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_innerbitmaskhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliashelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliashelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper) == MapInnerAliasBoundedWStringHelperInnerAliasHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliashelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper) == MapInnerAliasBoundedWStringHelperInnerAliasHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliashelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper) == MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper) == MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliasarrayhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliassequencehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliassequencehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper) == MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliassequencehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper) == MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliassequencehelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerAliasMapHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerAliasMapHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_inneraliasmaphelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasMapHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_inneraliasmaphelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasMapHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper) == MapInnerAliasBoundedWStringHelperInnerAliasMapHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerAliasMapHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_inneraliasmaphelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerAliasMapHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerAliasMapHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper) == MapInnerAliasBoundedWStringHelperInnerAliasMapHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerAliasMapHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerAliasMapHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_inneraliasmaphelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerUnionHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerUnionHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_innerunionhelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerUnionHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_innerunionhelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerUnionHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper) == MapInnerAliasBoundedWStringHelperInnerUnionHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerUnionHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_innerunionhelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerUnionHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerUnionHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper) == MapInnerAliasBoundedWStringHelperInnerUnionHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerUnionHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerUnionHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_innerunionhelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerStructureHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerStructureHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_innerstructurehelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerStructureHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_innerstructurehelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerStructureHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper) == MapInnerAliasBoundedWStringHelperInnerStructureHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerStructureHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_innerstructurehelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerStructureHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerStructureHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper) == MapInnerAliasBoundedWStringHelperInnerStructureHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerStructureHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerStructureHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_innerstructurehelper();

}



eProsima_user_DllExport bool is_MapInnerAliasBoundedWStringHelperInnerBitsetHelper_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapInnerAliasBoundedWStringHelperInnerBitsetHelper& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map_inneraliasboundedwstringhelper_innerbitsethelper(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitsetHelper& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map_inneraliasboundedwstringhelper_innerbitsethelper()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerBitsetHelper_cdr_plain(data_representation) &&
                sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper) == MapInnerAliasBoundedWStringHelperInnerBitsetHelper_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper));

            scdr.jump((array_size -1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapInnerAliasBoundedWStringHelperInnerBitsetHelper& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map_inneraliasboundedwstringhelper_innerbitsethelper();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        MapInnerAliasBoundedWStringHelperInnerBitsetHelper* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_MapInnerAliasBoundedWStringHelperInnerBitsetHelper_cdr_plain(data_representation) &&
            sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper) == MapInnerAliasBoundedWStringHelperInnerBitsetHelper_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper));

            scdr.jump((array_size - 1) * sizeof(MapInnerAliasBoundedWStringHelperInnerBitsetHelper));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapInnerAliasBoundedWStringHelperInnerBitsetHelper& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map_inneraliasboundedwstringhelper_innerbitsethelper();

}



eProsima_user_DllExport bool is_BoundedSmallMap_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BoundedSmallMap& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_small_map(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.var_unbounded_string_long_bounded_small_map(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.var_long_unbounded_string_bounded_small_map(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedSmallMap& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_small_map()
        << eprosima::fastcdr::MemberId(1) << data.var_unbounded_string_long_bounded_small_map()
        << eprosima::fastcdr::MemberId(2) << data.var_long_unbounded_string_bounded_small_map()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedSmallMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_BoundedSmallMap_cdr_plain(data_representation) &&
                sizeof(BoundedSmallMap) == BoundedSmallMap_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(BoundedSmallMap));

            scdr.jump((array_size -1) * sizeof(BoundedSmallMap));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        BoundedSmallMap& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_small_map();
                                            break;

                                        case 1:
                                                dcdr >> data.var_unbounded_string_long_bounded_small_map();
                                            break;

                                        case 2:
                                                dcdr >> data.var_long_unbounded_string_bounded_small_map();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        BoundedSmallMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_BoundedSmallMap_cdr_plain(data_representation) &&
            sizeof(BoundedSmallMap) == BoundedSmallMap_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(BoundedSmallMap));

            scdr.jump((array_size - 1) * sizeof(BoundedSmallMap));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedSmallMap& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_small_map();

                        scdr << data.var_unbounded_string_long_bounded_small_map();

                        scdr << data.var_long_unbounded_string_bounded_small_map();

}



eProsima_user_DllExport bool is_BoundedLargeMap_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BoundedLargeMap& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_large_map(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.var_unbounded_string_long_bounded_large_map(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.var_long_unbounded_string_bounded_large_map(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedLargeMap& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_large_map()
        << eprosima::fastcdr::MemberId(1) << data.var_unbounded_string_long_bounded_large_map()
        << eprosima::fastcdr::MemberId(2) << data.var_long_unbounded_string_bounded_large_map()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedLargeMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_BoundedLargeMap_cdr_plain(data_representation) &&
                sizeof(BoundedLargeMap) == BoundedLargeMap_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(BoundedLargeMap));

            scdr.jump((array_size -1) * sizeof(BoundedLargeMap));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        BoundedLargeMap& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_large_map();
                                            break;

                                        case 1:
                                                dcdr >> data.var_unbounded_string_long_bounded_large_map();
                                            break;

                                        case 2:
                                                dcdr >> data.var_long_unbounded_string_bounded_large_map();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        BoundedLargeMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_BoundedLargeMap_cdr_plain(data_representation) &&
            sizeof(BoundedLargeMap) == BoundedLargeMap_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(BoundedLargeMap));

            scdr.jump((array_size - 1) * sizeof(BoundedLargeMap));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const BoundedLargeMap& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_large_map();

                        scdr << data.var_unbounded_string_long_bounded_large_map();

                        scdr << data.var_long_unbounded_string_bounded_large_map();

}



} // namespace fastcdr
} // namespace eprosima

#endif // FAST_DDS_GENERATED__MAPSCDRAUX_IPP

