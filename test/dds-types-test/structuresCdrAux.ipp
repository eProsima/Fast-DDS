// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file structuresCdrAux.ipp
 * This source file contains some declarations of CDR related functions.
 *
 * This file was generated by the tool fastddsgen (version: 4.1.0).
 */

#ifndef FAST_DDS_GENERATED__STRUCTURESCDRAUX_IPP
#define FAST_DDS_GENERATED__STRUCTURESCDRAUX_IPP

#include "structuresCdrAux.hpp"

#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

#include <fastdds/dds/core/policy/QosPolicies.hpp>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {


eProsima_user_DllExport bool is_StructShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructShort_cdr_plain(data_representation) &&
                sizeof(StructShort) == StructShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructShort));

            scdr.jump((array_size -1) * sizeof(StructShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructShort_cdr_plain(data_representation) &&
            sizeof(StructShort) == StructShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructShort));

            scdr.jump((array_size - 1) * sizeof(StructShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_short();

}



eProsima_user_DllExport bool is_StructUnsignedShort_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructUnsignedShort& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_ushort(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedShort& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_ushort()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedShort_cdr_plain(data_representation) &&
                sizeof(StructUnsignedShort) == StructUnsignedShort_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructUnsignedShort));

            scdr.jump((array_size -1) * sizeof(StructUnsignedShort));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructUnsignedShort& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_ushort();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructUnsignedShort* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedShort_cdr_plain(data_representation) &&
            sizeof(StructUnsignedShort) == StructUnsignedShort_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructUnsignedShort));

            scdr.jump((array_size - 1) * sizeof(StructUnsignedShort));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedShort& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_ushort();

}



eProsima_user_DllExport bool is_StructLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_long(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_long()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLong_cdr_plain(data_representation) &&
                sizeof(StructLong) == StructLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructLong));

            scdr.jump((array_size -1) * sizeof(StructLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_long();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLong_cdr_plain(data_representation) &&
            sizeof(StructLong) == StructLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructLong));

            scdr.jump((array_size - 1) * sizeof(StructLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_long();

}



eProsima_user_DllExport bool is_StructUnsignedLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructUnsignedLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_ulong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_ulong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedLong_cdr_plain(data_representation) &&
                sizeof(StructUnsignedLong) == StructUnsignedLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructUnsignedLong));

            scdr.jump((array_size -1) * sizeof(StructUnsignedLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructUnsignedLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_ulong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructUnsignedLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedLong_cdr_plain(data_representation) &&
            sizeof(StructUnsignedLong) == StructUnsignedLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructUnsignedLong));

            scdr.jump((array_size - 1) * sizeof(StructUnsignedLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_ulong();

}



eProsima_user_DllExport bool is_StructLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_longlong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_longlong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLongLong_cdr_plain(data_representation) &&
                sizeof(StructLongLong) == StructLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructLongLong));

            scdr.jump((array_size -1) * sizeof(StructLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_longlong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLongLong_cdr_plain(data_representation) &&
            sizeof(StructLongLong) == StructLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructLongLong));

            scdr.jump((array_size - 1) * sizeof(StructLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_longlong();

}



eProsima_user_DllExport bool is_StructUnsignedLongLong_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructUnsignedLongLong& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_ulonglong(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLongLong& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_ulonglong()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedLongLong_cdr_plain(data_representation) &&
                sizeof(StructUnsignedLongLong) == StructUnsignedLongLong_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructUnsignedLongLong));

            scdr.jump((array_size -1) * sizeof(StructUnsignedLongLong));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructUnsignedLongLong& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_ulonglong();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructUnsignedLongLong* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnsignedLongLong_cdr_plain(data_representation) &&
            sizeof(StructUnsignedLongLong) == StructUnsignedLongLong_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructUnsignedLongLong));

            scdr.jump((array_size - 1) * sizeof(StructUnsignedLongLong));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnsignedLongLong& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_ulonglong();

}



eProsima_user_DllExport bool is_StructFloat_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructFloat& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_float(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructFloat& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_float()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructFloat_cdr_plain(data_representation) &&
                sizeof(StructFloat) == StructFloat_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructFloat));

            scdr.jump((array_size -1) * sizeof(StructFloat));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructFloat& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_float();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructFloat* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructFloat_cdr_plain(data_representation) &&
            sizeof(StructFloat) == StructFloat_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructFloat));

            scdr.jump((array_size - 1) * sizeof(StructFloat));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructFloat& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_float();

}



eProsima_user_DllExport bool is_StructDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_double(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_double()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructDouble_cdr_plain(data_representation) &&
                sizeof(StructDouble) == StructDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructDouble));

            scdr.jump((array_size -1) * sizeof(StructDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_double();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructDouble_cdr_plain(data_representation) &&
            sizeof(StructDouble) == StructDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructDouble));

            scdr.jump((array_size - 1) * sizeof(StructDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_double();

}



eProsima_user_DllExport bool is_StructLongDouble_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructLongDouble& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_longdouble(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongDouble& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_longdouble()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLongDouble_cdr_plain(data_representation) &&
                sizeof(StructLongDouble) == StructLongDouble_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructLongDouble));

            scdr.jump((array_size -1) * sizeof(StructLongDouble));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructLongDouble& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_longdouble();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructLongDouble* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructLongDouble_cdr_plain(data_representation) &&
            sizeof(StructLongDouble) == StructLongDouble_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructLongDouble));

            scdr.jump((array_size - 1) * sizeof(StructLongDouble));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructLongDouble& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_longdouble();

}



eProsima_user_DllExport bool is_StructBoolean_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructBoolean& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_boolean(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoolean& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_boolean()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoolean_cdr_plain(data_representation) &&
                sizeof(StructBoolean) == StructBoolean_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructBoolean));

            scdr.jump((array_size -1) * sizeof(StructBoolean));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructBoolean& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_boolean();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructBoolean* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoolean_cdr_plain(data_representation) &&
            sizeof(StructBoolean) == StructBoolean_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructBoolean));

            scdr.jump((array_size - 1) * sizeof(StructBoolean));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoolean& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_boolean();

}



eProsima_user_DllExport bool is_StructOctet_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructOctet& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructOctet& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_octet()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructOctet_cdr_plain(data_representation) &&
                sizeof(StructOctet) == StructOctet_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructOctet));

            scdr.jump((array_size -1) * sizeof(StructOctet));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructOctet& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructOctet* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructOctet_cdr_plain(data_representation) &&
            sizeof(StructOctet) == StructOctet_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructOctet));

            scdr.jump((array_size - 1) * sizeof(StructOctet));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructOctet& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_octet();

}



eProsima_user_DllExport bool is_StructChar8_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructChar8& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_char8(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar8& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_char8()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar8* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructChar8_cdr_plain(data_representation) &&
                sizeof(StructChar8) == StructChar8_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructChar8));

            scdr.jump((array_size -1) * sizeof(StructChar8));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructChar8& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_char8();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructChar8* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructChar8_cdr_plain(data_representation) &&
            sizeof(StructChar8) == StructChar8_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructChar8));

            scdr.jump((array_size - 1) * sizeof(StructChar8));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar8& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_char8();

}



eProsima_user_DllExport bool is_StructChar16_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructChar16& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_char16(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar16& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_char16()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar16* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructChar16_cdr_plain(data_representation) &&
                sizeof(StructChar16) == StructChar16_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructChar16));

            scdr.jump((array_size -1) * sizeof(StructChar16));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructChar16& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_char16();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructChar16* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructChar16_cdr_plain(data_representation) &&
            sizeof(StructChar16) == StructChar16_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructChar16));

            scdr.jump((array_size - 1) * sizeof(StructChar16));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructChar16& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_char16();

}



eProsima_user_DllExport bool is_StructString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructString_cdr_plain(data_representation) &&
                sizeof(StructString) == StructString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructString));

            scdr.jump((array_size -1) * sizeof(StructString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructString_cdr_plain(data_representation) &&
            sizeof(StructString) == StructString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructString));

            scdr.jump((array_size - 1) * sizeof(StructString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_string();

}



eProsima_user_DllExport bool is_StructWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructWString_cdr_plain(data_representation) &&
                sizeof(StructWString) == StructWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructWString));

            scdr.jump((array_size -1) * sizeof(StructWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructWString_cdr_plain(data_representation) &&
            sizeof(StructWString) == StructWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructWString));

            scdr.jump((array_size - 1) * sizeof(StructWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_wstring();

}



eProsima_user_DllExport bool is_StructBoundedString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructBoundedString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_bounded_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_bounded_string()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoundedString_cdr_plain(data_representation) &&
                sizeof(StructBoundedString) == StructBoundedString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructBoundedString));

            scdr.jump((array_size -1) * sizeof(StructBoundedString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructBoundedString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_bounded_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructBoundedString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoundedString_cdr_plain(data_representation) &&
            sizeof(StructBoundedString) == StructBoundedString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructBoundedString));

            scdr.jump((array_size - 1) * sizeof(StructBoundedString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_bounded_string();

}



eProsima_user_DllExport bool is_StructBoundedWString_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructBoundedWString& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_bounded_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedWString& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_bounded_wstring()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoundedWString_cdr_plain(data_representation) &&
                sizeof(StructBoundedWString) == StructBoundedWString_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructBoundedWString));

            scdr.jump((array_size -1) * sizeof(StructBoundedWString));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructBoundedWString& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_bounded_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructBoundedWString* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBoundedWString_cdr_plain(data_representation) &&
            sizeof(StructBoundedWString) == StructBoundedWString_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructBoundedWString));

            scdr.jump((array_size - 1) * sizeof(StructBoundedWString));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructBoundedWString& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_bounded_wstring();

}



eProsima_user_DllExport bool is_StructEnum_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructEnum& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_enum(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructEnum& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_enum()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructEnum* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructEnum_cdr_plain(data_representation) &&
                sizeof(StructEnum) == StructEnum_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructEnum));

            scdr.jump((array_size -1) * sizeof(StructEnum));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructEnum& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_enum();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructEnum* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructEnum_cdr_plain(data_representation) &&
            sizeof(StructEnum) == StructEnum_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructEnum));

            scdr.jump((array_size - 1) * sizeof(StructEnum));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructEnum& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_enum();

}



eProsima_user_DllExport bool is_StructBitMask_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructBitMask& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_bitmask(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitMask& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_bitmask()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitMask* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBitMask_cdr_plain(data_representation) &&
                sizeof(StructBitMask) == StructBitMask_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructBitMask));

            scdr.jump((array_size -1) * sizeof(StructBitMask));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructBitMask& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_bitmask();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructBitMask* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBitMask_cdr_plain(data_representation) &&
            sizeof(StructBitMask) == StructBitMask_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructBitMask));

            scdr.jump((array_size - 1) * sizeof(StructBitMask));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitMask& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_bitmask();

}



eProsima_user_DllExport bool is_StructAlias_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructAlias& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_alias(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructAlias& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_alias()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructAlias* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructAlias_cdr_plain(data_representation) &&
                sizeof(StructAlias) == StructAlias_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructAlias));

            scdr.jump((array_size -1) * sizeof(StructAlias));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructAlias& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_alias();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructAlias* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructAlias_cdr_plain(data_representation) &&
            sizeof(StructAlias) == StructAlias_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructAlias));

            scdr.jump((array_size - 1) * sizeof(StructAlias));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructAlias& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_alias();

}



eProsima_user_DllExport bool is_StructShortArray_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructShortArray& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_array_short(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructShortArray& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_array_short()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructShortArray* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructShortArray_cdr_plain(data_representation) &&
                sizeof(StructShortArray) == StructShortArray_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructShortArray));

            scdr.jump((array_size -1) * sizeof(StructShortArray));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructShortArray& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_array_short();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructShortArray* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructShortArray_cdr_plain(data_representation) &&
            sizeof(StructShortArray) == StructShortArray_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructShortArray));

            scdr.jump((array_size - 1) * sizeof(StructShortArray));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructShortArray& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_array_short();

}



eProsima_user_DllExport bool is_StructSequence_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructSequence& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_sequence(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructSequence& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_sequence()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructSequence* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructSequence_cdr_plain(data_representation) &&
                sizeof(StructSequence) == StructSequence_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructSequence));

            scdr.jump((array_size -1) * sizeof(StructSequence));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructSequence& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_sequence();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructSequence* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructSequence_cdr_plain(data_representation) &&
            sizeof(StructSequence) == StructSequence_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructSequence));

            scdr.jump((array_size - 1) * sizeof(StructSequence));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructSequence& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_sequence();

}



eProsima_user_DllExport bool is_StructMap_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructMap& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_map(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructMap& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_map()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructMap_cdr_plain(data_representation) &&
                sizeof(StructMap) == StructMap_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructMap));

            scdr.jump((array_size -1) * sizeof(StructMap));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructMap& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_map();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructMap* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructMap_cdr_plain(data_representation) &&
            sizeof(StructMap) == StructMap_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructMap));

            scdr.jump((array_size - 1) * sizeof(StructMap));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructMap& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_map();

}



eProsima_user_DllExport bool is_StructUnion_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructUnion& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_union(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnion& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_union()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnion* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnion_cdr_plain(data_representation) &&
                sizeof(StructUnion) == StructUnion_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructUnion));

            scdr.jump((array_size -1) * sizeof(StructUnion));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructUnion& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_union();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructUnion* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructUnion_cdr_plain(data_representation) &&
            sizeof(StructUnion) == StructUnion_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructUnion));

            scdr.jump((array_size - 1) * sizeof(StructUnion));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructUnion& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_union();

}



eProsima_user_DllExport bool is_StructStructure_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructStructure& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_structure(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructStructure& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_structure()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructStructure* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructStructure_cdr_plain(data_representation) &&
                sizeof(StructStructure) == StructStructure_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructStructure));

            scdr.jump((array_size -1) * sizeof(StructStructure));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructStructure& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_structure();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructStructure* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructStructure_cdr_plain(data_representation) &&
            sizeof(StructStructure) == StructStructure_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructStructure));

            scdr.jump((array_size - 1) * sizeof(StructStructure));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructStructure& data)
{
            extern void serialize_key(
                    Cdr& scdr,
                    const InnerStructureHelper& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.var_structure());

}



eProsima_user_DllExport bool is_StructBitset_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructBitset& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_bitset(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitset& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_bitset()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitset* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBitset_cdr_plain(data_representation) &&
                sizeof(StructBitset) == StructBitset_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructBitset));

            scdr.jump((array_size -1) * sizeof(StructBitset));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructBitset& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_bitset();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructBitset* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructBitset_cdr_plain(data_representation) &&
            sizeof(StructBitset) == StructBitset_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructBitset));

            scdr.jump((array_size - 1) * sizeof(StructBitset));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructBitset& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.var_bitset();

}



eProsima_user_DllExport bool is_StructEmpty_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructEmpty& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructEmpty& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const StructEmpty* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructEmpty_cdr_plain(data_representation) &&
                sizeof(StructEmpty) == StructEmpty_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(StructEmpty));

            scdr.jump((array_size -1) * sizeof(StructEmpty));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructEmpty& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                static_cast<void>(data);
                static_cast<void>(dcdr);
                static_cast<void>(mid);
                return false;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        StructEmpty* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_StructEmpty_cdr_plain(data_representation) &&
            sizeof(StructEmpty) == StructEmpty_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(StructEmpty));

            scdr.jump((array_size - 1) * sizeof(StructEmpty));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructEmpty& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
}



eProsima_user_DllExport bool is_Structures_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const Structures& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_StructShort(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.var_StructUnsignedShort(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.var_StructLong(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.var_StructUnsignedLong(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.var_StructLongLong(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.var_StructUnsignedLongLong(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.var_StructFloat(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.var_StructDouble(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.var_StructLongDouble(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.var_StructBoolean(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.var_StructOctet(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                data.var_StructChar8(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                data.var_StructChar16(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                data.var_StructString(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(14),
                data.var_StructWString(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(15),
                data.var_StructBoundedString(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(16),
                data.var_StructBoundedWString(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(17),
                data.var_StructEnum(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(18),
                data.var_StructBitMask(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(19),
                data.var_StructAlias(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(20),
                data.var_StructShortArray(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(21),
                data.var_StructSequence(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(22),
                data.var_StructMap(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(23),
                data.var_StructUnion(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(24),
                data.var_StructStructure(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(25),
                data.var_StructBitset(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(26),
                data.var_StructEmpty(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const Structures& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_StructShort()
        << eprosima::fastcdr::MemberId(1) << data.var_StructUnsignedShort()
        << eprosima::fastcdr::MemberId(2) << data.var_StructLong()
        << eprosima::fastcdr::MemberId(3) << data.var_StructUnsignedLong()
        << eprosima::fastcdr::MemberId(4) << data.var_StructLongLong()
        << eprosima::fastcdr::MemberId(5) << data.var_StructUnsignedLongLong()
        << eprosima::fastcdr::MemberId(6) << data.var_StructFloat()
        << eprosima::fastcdr::MemberId(7) << data.var_StructDouble()
        << eprosima::fastcdr::MemberId(8) << data.var_StructLongDouble()
        << eprosima::fastcdr::MemberId(9) << data.var_StructBoolean()
        << eprosima::fastcdr::MemberId(10) << data.var_StructOctet()
        << eprosima::fastcdr::MemberId(11) << data.var_StructChar8()
        << eprosima::fastcdr::MemberId(12) << data.var_StructChar16()
        << eprosima::fastcdr::MemberId(13) << data.var_StructString()
        << eprosima::fastcdr::MemberId(14) << data.var_StructWString()
        << eprosima::fastcdr::MemberId(15) << data.var_StructBoundedString()
        << eprosima::fastcdr::MemberId(16) << data.var_StructBoundedWString()
        << eprosima::fastcdr::MemberId(17) << data.var_StructEnum()
        << eprosima::fastcdr::MemberId(18) << data.var_StructBitMask()
        << eprosima::fastcdr::MemberId(19) << data.var_StructAlias()
        << eprosima::fastcdr::MemberId(20) << data.var_StructShortArray()
        << eprosima::fastcdr::MemberId(21) << data.var_StructSequence()
        << eprosima::fastcdr::MemberId(22) << data.var_StructMap()
        << eprosima::fastcdr::MemberId(23) << data.var_StructUnion()
        << eprosima::fastcdr::MemberId(24) << data.var_StructStructure()
        << eprosima::fastcdr::MemberId(25) << data.var_StructBitset()
        << eprosima::fastcdr::MemberId(26) << data.var_StructEmpty()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const Structures* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_Structures_cdr_plain(data_representation) &&
                sizeof(Structures) == Structures_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(Structures));

            scdr.jump((array_size -1) * sizeof(Structures));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        Structures& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_StructShort();
                                            break;

                                        case 1:
                                                dcdr >> data.var_StructUnsignedShort();
                                            break;

                                        case 2:
                                                dcdr >> data.var_StructLong();
                                            break;

                                        case 3:
                                                dcdr >> data.var_StructUnsignedLong();
                                            break;

                                        case 4:
                                                dcdr >> data.var_StructLongLong();
                                            break;

                                        case 5:
                                                dcdr >> data.var_StructUnsignedLongLong();
                                            break;

                                        case 6:
                                                dcdr >> data.var_StructFloat();
                                            break;

                                        case 7:
                                                dcdr >> data.var_StructDouble();
                                            break;

                                        case 8:
                                                dcdr >> data.var_StructLongDouble();
                                            break;

                                        case 9:
                                                dcdr >> data.var_StructBoolean();
                                            break;

                                        case 10:
                                                dcdr >> data.var_StructOctet();
                                            break;

                                        case 11:
                                                dcdr >> data.var_StructChar8();
                                            break;

                                        case 12:
                                                dcdr >> data.var_StructChar16();
                                            break;

                                        case 13:
                                                dcdr >> data.var_StructString();
                                            break;

                                        case 14:
                                                dcdr >> data.var_StructWString();
                                            break;

                                        case 15:
                                                dcdr >> data.var_StructBoundedString();
                                            break;

                                        case 16:
                                                dcdr >> data.var_StructBoundedWString();
                                            break;

                                        case 17:
                                                dcdr >> data.var_StructEnum();
                                            break;

                                        case 18:
                                                dcdr >> data.var_StructBitMask();
                                            break;

                                        case 19:
                                                dcdr >> data.var_StructAlias();
                                            break;

                                        case 20:
                                                dcdr >> data.var_StructShortArray();
                                            break;

                                        case 21:
                                                dcdr >> data.var_StructSequence();
                                            break;

                                        case 22:
                                                dcdr >> data.var_StructMap();
                                            break;

                                        case 23:
                                                dcdr >> data.var_StructUnion();
                                            break;

                                        case 24:
                                                dcdr >> data.var_StructStructure();
                                            break;

                                        case 25:
                                                dcdr >> data.var_StructBitset();
                                            break;

                                        case 26:
                                                dcdr >> data.var_StructEmpty();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        Structures* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_Structures_cdr_plain(data_representation) &&
            sizeof(Structures) == Structures_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(Structures));

            scdr.jump((array_size - 1) * sizeof(Structures));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const Structures& data)
{
            extern void serialize_key(
                    Cdr& scdr,
                    const StructShort& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructUnsignedShort& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructLong& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructUnsignedLong& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructLongLong& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructUnsignedLongLong& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructFloat& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructDouble& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructLongDouble& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructBoolean& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructOctet& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructChar8& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructChar16& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructString& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructWString& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructBoundedString& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructBoundedWString& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructEnum& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructBitMask& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructAlias& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructShortArray& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructSequence& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructMap& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructUnion& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructStructure& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructBitset& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const StructEmpty& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.var_StructShort());

                        serialize_key(scdr, data.var_StructUnsignedShort());

                        serialize_key(scdr, data.var_StructLong());

                        serialize_key(scdr, data.var_StructUnsignedLong());

                        serialize_key(scdr, data.var_StructLongLong());

                        serialize_key(scdr, data.var_StructUnsignedLongLong());

                        serialize_key(scdr, data.var_StructFloat());

                        serialize_key(scdr, data.var_StructDouble());

                        serialize_key(scdr, data.var_StructLongDouble());

                        serialize_key(scdr, data.var_StructBoolean());

                        serialize_key(scdr, data.var_StructOctet());

                        serialize_key(scdr, data.var_StructChar8());

                        serialize_key(scdr, data.var_StructChar16());

                        serialize_key(scdr, data.var_StructString());

                        serialize_key(scdr, data.var_StructWString());

                        serialize_key(scdr, data.var_StructBoundedString());

                        serialize_key(scdr, data.var_StructBoundedWString());

                        serialize_key(scdr, data.var_StructEnum());

                        serialize_key(scdr, data.var_StructBitMask());

                        serialize_key(scdr, data.var_StructAlias());

                        serialize_key(scdr, data.var_StructShortArray());

                        serialize_key(scdr, data.var_StructSequence());

                        serialize_key(scdr, data.var_StructMap());

                        serialize_key(scdr, data.var_StructUnion());

                        serialize_key(scdr, data.var_StructStructure());

                        serialize_key(scdr, data.var_StructBitset());

                        serialize_key(scdr, data.var_StructEmpty());

}



eProsima_user_DllExport bool is_testing_1_foo_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const testing_1::foo& data,
        size_t& current_alignment)
{
    using namespace testing_1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.b(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const testing_1::foo& data)
{
    using namespace testing_1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.a()
        << eprosima::fastcdr::MemberId(1) << data.b()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const testing_1::foo* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_testing_1_foo_cdr_plain(data_representation) &&
                sizeof(testing_1::foo) == testing_1_foo_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(testing_1::foo));

            scdr.jump((array_size -1) * sizeof(testing_1::foo));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        testing_1::foo& data)
{
    using namespace testing_1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.a();
                                            break;

                                        case 1:
                                                dcdr >> data.b();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        testing_1::foo* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_testing_1_foo_cdr_plain(data_representation) &&
            sizeof(testing_1::foo) == testing_1_foo_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(testing_1::foo));

            scdr.jump((array_size - 1) * sizeof(testing_1::foo));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const testing_1::foo& data)
{
    using namespace testing_1;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.a();

                        scdr << data.b();

}



eProsima_user_DllExport bool is_testing_2_foo_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const testing_2::foo& data,
        size_t& current_alignment)
{
    using namespace testing_2;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.d(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const testing_2::foo& data)
{
    using namespace testing_2;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.d()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const testing_2::foo* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_testing_2_foo_cdr_plain(data_representation) &&
                sizeof(testing_2::foo) == testing_2_foo_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(testing_2::foo));

            scdr.jump((array_size -1) * sizeof(testing_2::foo));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        testing_2::foo& data)
{
    using namespace testing_2;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.d();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        testing_2::foo* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_testing_2_foo_cdr_plain(data_representation) &&
            sizeof(testing_2::foo) == testing_2_foo_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(testing_2::foo));

            scdr.jump((array_size - 1) * sizeof(testing_2::foo));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const testing_2::foo& data)
{
    using namespace testing_2;

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.d();

}



eProsima_user_DllExport bool is_bar_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const bar& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.e(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const bar& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.e()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const bar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_bar_cdr_plain(data_representation) &&
                sizeof(bar) == bar_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(bar));

            scdr.jump((array_size -1) * sizeof(bar));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        bar& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.e();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        bar* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_bar_cdr_plain(data_representation) &&
            sizeof(bar) == bar_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(bar));

            scdr.jump((array_size - 1) * sizeof(bar));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const bar& data)
{

    static_cast<void>(scdr);
    static_cast<void>(data);
                        scdr << data.e();

}



eProsima_user_DllExport bool is_root1_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const root1& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.foo_struct(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const root1& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.foo_struct()
        << eprosima::fastcdr::MemberId(1) << data.c()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const root1* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root1_cdr_plain(data_representation) &&
                sizeof(root1) == root1_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(root1));

            scdr.jump((array_size -1) * sizeof(root1));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        root1& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.foo_struct();
                                            break;

                                        case 1:
                                                dcdr >> data.c();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        root1* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root1_cdr_plain(data_representation) &&
            sizeof(root1) == root1_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(root1));

            scdr.jump((array_size - 1) * sizeof(root1));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const root1& data)
{
            extern void serialize_key(
                    Cdr& scdr,
                    const testing_1::foo& data);



    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.foo_struct());

                        scdr << data.c();

}



eProsima_user_DllExport bool is_root2_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const root2& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.foo_struct(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.bar_struct(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const root2& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.foo_struct()
        << eprosima::fastcdr::MemberId(1) << data.bar_struct()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const root2* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root2_cdr_plain(data_representation) &&
                sizeof(root2) == root2_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(root2));

            scdr.jump((array_size -1) * sizeof(root2));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        root2& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.foo_struct();
                                            break;

                                        case 1:
                                                dcdr >> data.bar_struct();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        root2* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root2_cdr_plain(data_representation) &&
            sizeof(root2) == root2_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(root2));

            scdr.jump((array_size - 1) * sizeof(root2));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const root2& data)
{
            extern void serialize_key(
                    Cdr& scdr,
                    const testing_2::foo& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const bar& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.foo_struct());

                        serialize_key(scdr, data.bar_struct());

}



eProsima_user_DllExport bool is_root_cdr_plain(
        eprosima::fastdds::dds::DataRepresentationId_t data_representation)
{
    static_cast<void>(data_representation);
    return false;
}

template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const root& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.var_root1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.var_root2(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const root& data)
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.var_root1()
        << eprosima::fastcdr::MemberId(1) << data.var_root2()
;
    scdr.end_serialize_type(current_state);
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void serialize_array(
        eprosima::fastcdr::Cdr& scdr,
        const root* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root_cdr_plain(data_representation) &&
                sizeof(root) == root_max_cdr_typesize)
        {
            // Serialize the first element
            // to ensure correct alignment
            scdr.serialize(
                array_ptr[0]);

            ++array_ptr;

            std::memcpy(
                scdr.get_current_position(),
                array_ptr,
                (array_size - 1) * sizeof(root));

            scdr.jump((array_size -1) * sizeof(root));
        }
        else
        {
            scdr.serialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        root& data)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.var_root1();
                                            break;

                                        case 1:
                                                dcdr >> data.var_root2();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

#if FASTCDR_VERSION_MAJOR > 2
template<>
eProsima_user_DllExport void deserialize_array(
        eprosima::fastcdr::Cdr& scdr,
        root* array_ptr,
        const std::size_t array_size)
{
    if (array_size > 0)
    {
        using namespace ::eprosima::fastdds::dds;
        DataRepresentationId_t data_representation = (scdr.get_cdr_version() == eprosima::fastcdr::CdrVersion::XCDRv1 ?
                    DataRepresentationId_t::XCDR_DATA_REPRESENTATION : DataRepresentationId_t::XCDR2_DATA_REPRESENTATION);

        if (is_root_cdr_plain(data_representation) &&
            sizeof(root) == root_max_cdr_typesize)
        {
            // Deserialize the first element
            // accounting for alignment
            scdr.deserialize_array(&array_ptr[0], 1);
            ++array_ptr;

            std::memcpy(
                reinterpret_cast<char*>(array_ptr),
                scdr.get_current_position(),
                (array_size - 1) * sizeof(root));

            scdr.jump((array_size - 1) * sizeof(root));
        }
        else
        {
            scdr.deserialize_array(array_ptr, array_size);
        }
    }
}
#endif // FASTCDR_VERSION_MAJOR > 2

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const root& data)
{
            extern void serialize_key(
                    Cdr& scdr,
                    const root1& data);

            extern void serialize_key(
                    Cdr& scdr,
                    const root2& data);


    static_cast<void>(scdr);
    static_cast<void>(data);
                        serialize_key(scdr, data.var_root1());

                        serialize_key(scdr, data.var_root2());

}



} // namespace fastcdr
} // namespace eprosima

#endif // FAST_DDS_GENERATED__STRUCTURESCDRAUX_IPP

