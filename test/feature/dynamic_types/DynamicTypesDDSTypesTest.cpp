// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <fastrtps/types/TypesBase.h>
#include <gtest/gtest.h>
#include <fastrtps/types/DynamicTypeBuilderFactory.h>
#include <fastrtps/types/DynamicTypeBuilder.h>
#include <fastrtps/types/DynamicTypeBuilderPtr.h>
#include <fastrtps/types/DynamicDataFactory.h>
#include <fastrtps/types/TypeDescriptor.h>
#include <fastrtps/types/MemberDescriptor.h>
#include <fastrtps/types/DynamicType.h>
#include <fastrtps/types/DynamicPubSubType.h>
#include <fastrtps/types/DynamicTypePtr.h>
#include <fastrtps/types/DynamicData.h>
#include <fastrtps/types/DynamicDataPtr.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastdds/dds/log/Log.hpp>
#include <fastrtps/xmlparser/XMLProfileManager.h>
#include <tinyxml2.h>


#include "idl/dds-types-test/aliasesPubSubTypes.h"
#include "idl/dds-types-test/aliasesTypeObject.h"
#include "idl/dds-types-test/appendablePubSubTypes.h"
#include "idl/dds-types-test/appendableTypeObject.h"
#include "idl/dds-types-test/arraysPubSubTypes.h"
#include "idl/dds-types-test/arraysTypeObject.h"
#include "idl/dds-types-test/bitsetsPubSubTypes.h"
#include "idl/dds-types-test/bitsetsTypeObject.h"
#include "idl/dds-types-test/declarationsPubSubTypes.h"
#include "idl/dds-types-test/declarationsTypeObject.h"
#include "idl/dds-types-test/enumerationsPubSubTypes.h"
#include "idl/dds-types-test/enumerationsTypeObject.h"
#include "idl/dds-types-test/finalPubSubTypes.h"
#include "idl/dds-types-test/finalTypeObject.h"
#include "idl/dds-types-test/inheritancePubSubTypes.h"
#include "idl/dds-types-test/inheritanceTypeObject.h"
#include "idl/dds-types-test/mapsPubSubTypes.h"
#include "idl/dds-types-test/mapsTypeObject.h"
#include "idl/dds-types-test/primitivesPubSubTypes.h"
#include "idl/dds-types-test/primitivesTypeObject.h"
#include "idl/dds-types-test/sequencesPubSubTypes.h"
#include "idl/dds-types-test/sequencesTypeObject.h"
#include "idl/dds-types-test/stringsPubSubTypes.h"
#include "idl/dds-types-test/stringsTypeObject.h"
#include "idl/dds-types-test/structuresPubSubTypes.h"
#include "idl/dds-types-test/structuresTypeObject.h"
#include "idl/dds-types-test/unionsPubSubTypes.h"
#include "idl/dds-types-test/unionsTypeObject.h"

#include <iostream>

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;
using namespace eprosima::fastrtps::types;
#include <unordered_map>
#include <functional>
#include <vector>
#include <algorithm>

class DynamicTypesDDSTypesTest : public ::testing::Test
{
    const std::string config_file_ = "types_profile.xml";

public:

    DynamicTypesDDSTypesTest()
    {
    }

    ~DynamicTypesDDSTypesTest()
    {
        eprosima::fastdds::dds::Log::KillThread();
    }

    virtual void TearDown()
    {
        DynamicDataFactory::delete_instance();
        DynamicTypeBuilderFactory::delete_instance();
    }

    const std::string& config_file()
    {
        return config_file_;
    }

};

enum class ExpectedType {
    Short,
    UShort,
    Long,
    ULong,
    LongLong,
    ULongLong,
    Float,
    Double,
    LongDouble,
    Boolean,
    Octet,
    Char,
    WChar,
    String,
    WString,
    Enum,
    Bitmask,
    Array
};

using SetMethod = std::function<ReturnCode_t(DynamicData*, const void*, MemberId)>;
using GetMethod = std::function<ReturnCode_t(DynamicData*, void*, MemberId)>;

std::map<ExpectedType, SetMethod> setTypeToMethod = {
    {ExpectedType::Short, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_int16_value(*static_cast<const int16_t*>(value), member_id);
    }},
    {ExpectedType::UShort, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_uint16_value(*static_cast<const uint16_t*>(value), member_id);
    }},
    {ExpectedType::Long, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_int32_value(*static_cast<const int32_t*>(value), member_id);
    }},
    {ExpectedType::ULong, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_uint32_value(*static_cast<const uint32_t*>(value), member_id);
    }},
    {ExpectedType::LongLong, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_int64_value(*static_cast<const int64_t*>(value), member_id);
    }},
    {ExpectedType::ULongLong, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_uint64_value(*static_cast<const uint64_t*>(value), member_id);
    }},
    {ExpectedType::Float, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_float32_value(*static_cast<const float*>(value), member_id);
    }},
    {ExpectedType::Double, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_float64_value(*static_cast<const double*>(value), member_id);
    }},
    {ExpectedType::LongDouble, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_float128_value(*static_cast<const long double*>(value), member_id);
    }},
    {ExpectedType::Boolean, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_bool_value(*static_cast<const bool*>(value), member_id);
    }},
    {ExpectedType::Octet, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_byte_value(*static_cast<const octet*>(value), member_id);
    }},
    {ExpectedType::Char, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_char8_value(*static_cast<const char*>(value), member_id);
    }},
    {ExpectedType::WChar, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_char16_value(*static_cast<const wchar_t*>(value), member_id);
    }},
    {ExpectedType::String, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_string_value(*static_cast<const std::string*>(value), member_id);
    }},
    {ExpectedType::WString, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_wstring_value(*static_cast<const std::wstring*>(value), member_id);
    }},
    {ExpectedType::Enum, [](DynamicData* data, const void* value, MemberId member_id) {
        return data->set_enum_value(*static_cast<const std::string*>(value), member_id);
    }},
    {ExpectedType::Bitmask, [](DynamicData* data, const void* value, MemberId member_id) {
        // if(member_id == 0){
        //     return data->set_int16_value(*static_cast<const int16_t*>(value), 0);
        // }        
        return data->set_bitmask_value(*static_cast<const uint64_t*>(value));
    }}
};

std::map<ExpectedType, GetMethod> getTypeToMethod = {
    {ExpectedType::Short, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_int16_value(*static_cast<int16_t*>(value), member_id);
    }},
    {ExpectedType::UShort, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_uint16_value(*static_cast<uint16_t*>(value), member_id);
    }},
    {ExpectedType::Long, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_int32_value(*static_cast<int32_t*>(value), member_id);
    }},
    {ExpectedType::ULong, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_uint32_value(*static_cast<uint32_t*>(value), member_id);
    }},
    {ExpectedType::LongLong, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_int64_value(*static_cast<int64_t*>(value), member_id);
    }},
    {ExpectedType::ULongLong, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_uint64_value(*static_cast<uint64_t*>(value), member_id);
    }},
    {ExpectedType::Float, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_float32_value(*static_cast<float*>(value), member_id);
    }},
    {ExpectedType::Double, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_float64_value(*static_cast<double*>(value), member_id);
    }},
    {ExpectedType::LongDouble, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_float128_value(*static_cast<long double*>(value), member_id);
    }},
    {ExpectedType::Boolean, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_bool_value(*static_cast<bool*>(value), member_id);
    }},
    {ExpectedType::Octet, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_byte_value(*static_cast<octet*>(value), member_id);
    }},
    {ExpectedType::Char, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_char8_value(*static_cast<char*>(value), member_id);
    }},
    {ExpectedType::WChar, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_char16_value(*static_cast<wchar_t*>(value), member_id);
    }},
    {ExpectedType::String, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_string_value(*static_cast<std::string*>(value), member_id);
    }},
    {ExpectedType::WString, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_wstring_value(*static_cast<std::wstring*>(value), member_id);
    }},
    {ExpectedType::Enum, [](DynamicData* data, void* value, MemberId member_id) {
        return data->get_enum_value(*static_cast<std::string*>(value), member_id);
    }},
    {ExpectedType::Bitmask, [](DynamicData* data, void* value, MemberId member_id) {
        // if(member_id == 0){
        //     return data->get_int16_value(*static_cast<int16_t*>(value), 0);
        // }
        return data->get_bitmask_value(*static_cast<uint64_t*>(value));
    }}
};


void check_set_values(DynamicData* data, const std::vector<ExpectedType>& expected_types, void* type_value, MemberId member_id = MEMBER_ID_INVALID)
{
    for (const auto& typeMethodPair : setTypeToMethod) {
        ExpectedType currentType = typeMethodPair.first;
        SetMethod setMethod = typeMethodPair.second;

        if (std::find(expected_types.begin(), expected_types.end(), currentType) != expected_types.end()) {
            //ASSERT_FALSE(setMethod(data, type_value, 0) == ReturnCode_t::RETCODE_OK);
            ASSERT_TRUE(setMethod(data, type_value, member_id) == ReturnCode_t::RETCODE_OK);
        } else {
            if ((std::find(expected_types.begin(), expected_types.end(), ExpectedType::Bitmask) != expected_types.end()) &&
            currentType == ExpectedType::Boolean) {
                //Bitmasks can also use set_boolean_value
            }else{
                ASSERT_FALSE(setMethod(data, type_value, member_id) == ReturnCode_t::RETCODE_OK);
            }
        }
    }
}

void check_get_values(DynamicData* data, const std::vector<ExpectedType>& expected_types, void* type_value, MemberId member_id = MEMBER_ID_INVALID)
{
    for (const auto& typeMethodPair : getTypeToMethod) {
        ExpectedType currentType = typeMethodPair.first;
        GetMethod getMethod = typeMethodPair.second;

        if (std::find(expected_types.begin(), expected_types.end(), currentType) != expected_types.end()) {
            //ASSERT_FALSE(getMethod(data, type_value, 0) == ReturnCode_t::RETCODE_OK);
            ASSERT_TRUE(getMethod(data, type_value, member_id) == ReturnCode_t::RETCODE_OK);
        } else {
            ASSERT_FALSE(getMethod(data, type_value, member_id) == ReturnCode_t::RETCODE_OK);
        }
    }
}

/*********
 * ALIASES
**********/
#pragma region ALIASES

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasInt16)
{
    {
        std::string name = "AliasInt16";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasInt16");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 2;
        int16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasInt16 walias;
        AliasInt16PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasUInt16)
{
    {
        std::string name = "AliasUInt16";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasUInt16");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint16_t test_value_1 = 2;
        uint16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasUint16 walias;
        AliasUint16PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasInt32)
{
    {
        std::string name = "AliasInt32";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasInt32");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 2;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasInt32 walias;
        AliasInt32PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasUInt32)
{
    {
        std::string name = "AliasUInt32";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasUInt32");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint32_t test_value_1 = 2;
        uint32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasUInt32 walias;
        AliasUInt32PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasInt64)
{
    {
        std::string name = "AliasInt64";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasInt64");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int64_t test_value_1 = 2;
        int64_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasInt64 walias;
        AliasInt64PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasUInt64)
{
    {
        std::string name = "AliasUInt64";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasUInt64");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 2;
        uint64_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasUInt64 walias;
        AliasUInt64PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasFloat32)
{
    {
        std::string name = "AliasFloat32";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasFloat32");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        float test_value_1 = 123.0f;
        float test_value_2 = 0.0f;

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasFloat32 walias;
        AliasFloat32PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasFloat64)
{
    {
        std::string name = "AliasFloat64";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasFloat64");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasFloat64 walias;
        AliasFloat64PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasFloat128)
{
    {
        std::string name = "AliasFloat128";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasFloat128");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasFloat128 walias;
        AliasFloat128PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasBool)
{
    {
        std::string name = "AliasBool";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasBool");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        bool test_value_1 = true;
        bool test_value_2 = false;

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasBool walias;
        AliasBoolPubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasOctet)
{
    {
        std::string name = "AliasOctet";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasOctet");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        octet test_value_1 = 255;
        octet test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasOctet walias;
        AliasOctetPubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasChar8)
{
    {
        std::string name = "AliasChar8";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasChar8");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        char test_value_1 = 'a';
        char test_value_2 = 'b';

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasChar8 walias;
        AliasChar8PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasChar16)
{
    {
        std::string name = "AliasChar16";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasChar16");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasChar16 walias;
        AliasChar16PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasString8)
{
    {
        std::string name = "AliasString8";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasString8");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasString8 walias;
        AliasString8PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasString16)
{
    {
        std::string name = "AliasString16";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        ASSERT_TRUE(base_builder != nullptr);
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasString16");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasString16 walias;
        AliasString16PubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasEnum)
{
    {
        std::string name = "AliasEnum";
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        ASSERT_TRUE(base_builder != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(base_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(base_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasEnum");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        ASSERT_FALSE(data->set_int32_value(0, MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        // Try to set an invalid value.
        ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasEnum walias;
        AliasEnumPubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_AliasBitmask)
{
    uint32_t limit = 5;
    {
        std::string name = "AliasBitmask";     
        DynamicTypeBuilder_ptr base_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        ASSERT_TRUE(base_builder != nullptr);
        
        // Add members to the bitmask
        ASSERT_TRUE(base_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(base_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(base_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 
        
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "AliasBitmask");
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        MemberId test_member_id;
        test_member_id = data->get_member_id_by_name("FLAG0");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id = data->get_member_id_by_name("FLAG1");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id = data->get_member_id_by_name("FLAG4");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id= data->get_member_id_by_name("FLAG5");
        ASSERT_FALSE(test_member_id != MEMBER_ID_INVALID);

        uint64_t test_bitmask_value_1 = 55;// 00110111
        uint64_t test_bitmask_value_2;

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(data, expected_types, &test_bitmask_value_1);
        check_get_values(data, expected_types, &test_bitmask_value_2);

        ASSERT_TRUE(test_bitmask_value_1 == test_bitmask_value_2);
        ASSERT_TRUE(data->get_bool_value("FLAG0"));
        ASSERT_TRUE(data->get_bool_value("FLAG1"));
        ASSERT_TRUE(data->get_bool_value("FLAG4"));

        // Over the limit
        ASSERT_FALSE(data->set_bool_value(true, limit + 1) == ReturnCode_t::RETCODE_OK);

        bool test_value_1 = true;
        bool test_value_2 = false;

        ASSERT_TRUE(data->get_bool_value(test_value_2, 2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_2 == true);
        ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_2 == data->get_bool_value("FLAG0"));

        bool test3 = data->get_bool_value("FLAG0");
        ASSERT_TRUE(test_value_1 == test3);
        ASSERT_TRUE(data->set_bool_value(true, "FLAG4") == ReturnCode_t::RETCODE_OK);
        bool test4 = data->get_bool_value("FLAG4");
        ASSERT_TRUE(test4 == true);

        test_value_1 = false;
        ASSERT_TRUE(data->set_bool_value(test_value_1, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        AliasBitmask walias;
        AliasBitmaskPubSubType waliaspb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(waliaspb.deserialize(&dynamic_payload, &walias));

        uint32_t static_payloadSize = static_cast<uint32_t>(waliaspb.getSerializedSizeProvider(&walias)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(waliaspb.serialize(&walias, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion


/********
 * ARRAYS
*********/
#pragma region ARRAYS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayShort)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayShort warray;
        ArrayShortPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayUShort)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayUShort warray;
        ArrayUShortPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLong)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayLong warray;
        ArrayLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayULong)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayULong warray;
        ArrayULongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLongLong)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayLongLong warray;
        ArrayLongLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayULongLong)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayULongLong warray;
        ArrayULongLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayFloat)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        float test_value_1 = 123.0f;
        float test_value_2 = 0.0f;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayFloat warray;
        ArrayFloatPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayDouble)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayDouble warray;
        ArrayDoublePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLongDouble)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float128_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float128_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayLongDouble warray;
        ArrayLongDoublePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoolean)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        bool test_value_1 = true;
        bool test_value_2 = false;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_bool_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_bool_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBoolean warray;
        ArrayBooleanPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayOctet)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        octet test_value_1 = 255;
        octet test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_byte_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_byte_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayOctet warray;
        ArrayOctetPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayChar)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        char test_value_1 = 'a';
        char test_value_2 = 'b';

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_char8_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_char8_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayChar warray;
        ArrayCharPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayWChar)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_char16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_char16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayWChar warray;
        ArrayWCharPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayString)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayString warray;
        ArrayStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayWString)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayWString warray;
        ArrayWStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoundedString)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "A";
        std::string test_value_2 = "";

        ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBoundedString warray;
        ArrayBoundedStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoundedWString)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";

        ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBoundedWString warray;
        ArrayBoundedWStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayEnum)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Try to set an invalid value.
        ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_enum_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_enum_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayEnum warray;
        ArrayEnumPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBitMask)
{
    std::vector<uint32_t> length = { 10 };
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBitMask warray;
        ArrayBitMaskPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayAlias)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(alias_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayAlias warray;
        ArrayAliasPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayShortArray)
{
    std::vector<uint32_t> length = { 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        ASSERT_TRUE(array_type_builder != nullptr);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type != nullptr);

        DynamicTypeBuilder_ptr parent_array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(array_type_builder.get(), length);
        ASSERT_TRUE(parent_array_type_builder != nullptr);
        DynamicType_ptr parent_array_type = parent_array_type_builder->build();
        ASSERT_TRUE(parent_array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(parent_array_type);

        MemberId newId;
        ASSERT_FALSE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2(0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(parent_array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(parent_array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayShortArray seq;
        ArrayShortArrayPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArraySequence)
{
    std::vector<uint32_t> length = { 10 };
    uint32_t seq_length = 10;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), seq_length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(seq_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArraySequence warray;
        ArraySequencePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMap)
{
    std::vector<uint32_t> length = { 10 };
    uint32_t map_length = 10;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), map_length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(map_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMap warray;
        ArrayMapPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayUnion)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(union_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayUnion warray;
        ArrayUnionPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayStructure)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBitset)
{
    std::vector<uint32_t> length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(bitset_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = bitset_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(bitset_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBitset warray;
        ArrayBitsetPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionShort)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionShort warray;
        ArrayMultiDimensionShortPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionUShort)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_uint16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionUShort warray;
        ArrayMultiDimensionUShortPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLong)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionLong warray;
        ArrayMultiDimensionLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionULong)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_uint32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionULong warray;
        ArrayMultiDimensionULongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLongLong)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_int64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionLongLong warray;
        ArrayMultiDimensionLongLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionULongLong)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_uint64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_uint64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionULongLong warray;
        ArrayMultiDimensionULongLongPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionFloat)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_float32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionFloat warray;
        ArrayMultiDimensionFloatPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionDouble)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_float64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionDouble warray;
        ArrayMultiDimensionDoublePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLongDouble)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_float128_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_float128_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_float128_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionLongDouble warray;
        ArrayMultiDimensionLongDoublePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoolean)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        bool test_value_1 = true;
        bool test_value_2 = false;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_bool_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_bool_value(test_value_1, 100000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_bool_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionBoolean warray;
        ArrayMultiDimensionBooleanPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionOctet)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        octet test_value_1 = 255;
        octet test_value_2 = 0;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_byte_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_byte_value(test_value_1, 100000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_byte_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionOctet warray;
        ArrayMultiDimensionOctetPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionChar)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_char8_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_char8_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_char8_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionChar warray;
        ArrayMultiDimensionCharPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionWChar)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_char16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_char16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_char16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionWChar warray;
        ArrayMultiDimensionWCharPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionString)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_string_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionString warray;
        ArrayMultiDimensionStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionWString)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";
        
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionWString warray;
        ArrayMultiDimensionWStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoundedString)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "A";
        std::string test_value_2 = "";

        ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);
     
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_string_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionBoundedString warray;
        ArrayMultiDimensionBoundedStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoundedWString)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";

        ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);
     
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionBoundedWString warray;
        ArrayMultiDimensionBoundedWStringPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionEnum)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Try to set an invalid value.
        ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_enum_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_enum_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_enum_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionEnum warray;
        ArrayMultiDimensionEnumPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBitMask)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayBitMask warray;
        ArrayBitMaskPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionAlias)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(alias_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Get an index in the multidimensional array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
        // TO CHECK // ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionAlias warray;
        ArrayMultiDimensionAliasPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionSequence)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    uint32_t seq_length = 10;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), seq_length);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type_builder != nullptr);
        ASSERT_TRUE(seq_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(seq_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArraySequence warray;
        ArraySequencePubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionMap)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    uint32_t map_length = 10;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), map_length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(map_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionMap warray;
        ArrayMultiDimensionMapPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionUnion)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(union_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionUnion warray;
        ArrayMultiDimensionUnionPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionStructure)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBitset)
{
    std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(bitset_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = bitset_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(bitset_type_builder.get(), arrays_lengths);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1, 1, 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(testPos);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(testPos);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ArrayMultiDimensionBitset warray;
        ArrayMultiDimensionBitsetPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedSmallArrays)
{
    std::vector<uint32_t> length = { 1 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int16_value(test_value_1, 2) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BoundedSmallArrays warray;
        BoundedSmallArraysPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedBigArrays)
{
    std::vector<uint32_t> length = { 41925 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
        DynamicType_ptr array_type = array_type_builder->build();
        ASSERT_TRUE(array_type_builder != nullptr);
        ASSERT_TRUE(array_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = data->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, testPos);
        check_get_values(data, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(data->set_int16_value(test_value_1, 2) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(array_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BoundedBigArrays warray;
        BoundedBigArraysPubSubType warraypb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

        uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*********
 * BITSETS
**********/
#pragma region BITSETS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BitsetStruct)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(bitset_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = bitset_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(bitset_type);
        ASSERT_TRUE(data != nullptr);

        ASSERT_FALSE(data->set_int32_value(10, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->set_string_value("", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(data->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(data->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(data->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(data->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(bitset_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(bitset_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BitsetStruct wbitset;
        BitsetStructPubSubType wbitsetpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
        ASSERT_TRUE(wbitsetpb.deserialize(&dynamic_payload, &wbitset));

        uint32_t static_payloadSize = static_cast<uint32_t>(wbitsetpb.getSerializedSizeProvider(&wbitset)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wbitsetpb.serialize(&wbitset, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(bitset_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);

    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/**************
 * DECLARATIONS
***************/
#pragma region DECLARATIONS


#pragma endregion

/**************
 * ENUMERATIONS
***************/
#pragma region ENUMERATIONS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_Enum)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        ASSERT_TRUE(created_builder != nullptr);
        
        // Add three members to the enum.
        ASSERT_TRUE(created_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(created_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(created_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(created_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        // Try to set an invalid value.
        ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        EnumStructure wenum;
        EnumStructurePubSubType wenumpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wenumpb.deserialize(&dynamic_payload, &wenum));

        uint32_t static_payloadSize = static_cast<uint32_t>(wenumpb.getSerializedSizeProvider(&wenum)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wenumpb.serialize(&wenum, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_Bitmask)
{
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(base_type_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        MemberId test_member_id;
        test_member_id = data->get_member_id_by_name("FLAG0");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id = data->get_member_id_by_name("FLAG1");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id = data->get_member_id_by_name("FLAG4");
        ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
        test_member_id= data->get_member_id_by_name("FLAG5");
        ASSERT_FALSE(test_member_id != MEMBER_ID_INVALID);

        uint64_t test_bitmask_value_1 = 55;// 00110111
        uint64_t test_bitmask_value_2;

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(data, expected_types, &test_bitmask_value_1);
        check_get_values(data, expected_types, &test_bitmask_value_2);

        ASSERT_TRUE(test_bitmask_value_1 == test_bitmask_value_2);
        ASSERT_TRUE(data->get_bool_value("FLAG0"));
        ASSERT_TRUE(data->get_bool_value("FLAG1"));
        ASSERT_TRUE(data->get_bool_value("FLAG4"));

        // Over the limit
        ASSERT_FALSE(data->set_bool_value(true, limit + 1) == ReturnCode_t::RETCODE_OK);

        bool test_value_1 = true;
        bool test_value_2 = false;

        ASSERT_TRUE(data->get_bool_value(test_value_2, 2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_2 == true);
        ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_2 == data->get_bool_value("FLAG0"));

        bool test3 = data->get_bool_value("FLAG0");
        ASSERT_TRUE(test_value_1 == test3);
        ASSERT_TRUE(data->set_bool_value(true, "FLAG4") == ReturnCode_t::RETCODE_OK);
        bool test4 = data->get_bool_value("FLAG4");
        ASSERT_TRUE(test4 == true);

        test_value_1 = false;
        ASSERT_TRUE(data->set_bool_value(test_value_1, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BitMaskStructure wbitmask;
        BitMaskStructurePubSubType wbitmaskpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wbitmaskpb.deserialize(&dynamic_payload, &wbitmask));

        uint32_t static_payloadSize = static_cast<uint32_t>(wbitmaskpb.getSerializedSizeProvider(&wbitmask)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wbitmaskpb.serialize(&wbitmask, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*************
 * INHERITANCE
*************/
#pragma region INHERITANCE
TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperChild)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperChildChild)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperEmptyChild)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerEmptyStructureHelperChild)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerBitsetHelperChild)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerBitsetHelperChildChild)
{
    //TODO
}

#pragma endregion

/******
 * MAPS
******/
#pragma region MAPS

/***********
 * KEY_SHORT
***********/
#pragma region KEY_SHORT

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);  

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortShort wmap;
        MapShortShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);
        
        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortUShort wmap;
        MapShortUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortLong wmap;
        MapShortLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortULong wmap;
        MapShortULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortLongLong wmap;
        MapShortLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortULongLong wmap;
        MapShortULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortFloat wmap;
        MapShortFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortDouble wmap;
        MapShortDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortLongDouble wmap;
        MapShortLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortBoolean wmap;
        MapShortBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortOctet wmap;
        MapShortOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortChar wmap;
        MapShortCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortWChar wmap;
        MapShortWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortString wmap;
        MapShortStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortWString wmap;
        MapShortWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasBoundedStringHelper wmap;
        MapShortInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasBoundedStringHelper wmap;
        MapShortInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerEnumHelper wmap;
        MapShortInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerEnumHelper wmap;
        MapShortInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasHelper wmap;
        MapShortInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasArrayHelper wmap;
        MapShortInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasSequenceHelper wmap;
        MapShortInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerAliasMapHelper wmap;
        MapShortInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerUnionHelper wmap;
        MapShortInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapShortInnerBitsetHelper wmap;
        MapShortInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/************
 * KEY_USHORT
************/
#pragma region KEY_USHORT

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortShort wmap;
        MapUShortShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortUShort wmap;
        MapUShortUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortLong wmap;
        MapUShortLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortULong wmap;
        MapUShortULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortLongLong wmap;
        MapUShortLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortULongLong wmap;
        MapUShortULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortFloat wmap;
        MapUShortFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortDouble wmap;
        MapUShortDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortLongDouble wmap;
        MapUShortLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortBoolean wmap;
        MapUShortBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortOctet wmap;
        MapUShortOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortChar wmap;
        MapUShortCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortWChar wmap;
        MapUShortWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortString wmap;
        MapUShortStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortWString wmap;
        MapUShortWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
      
        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasBoundedStringHelper wmap;
        MapUShortInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasBoundedStringHelper wmap;
        MapUShortInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerEnumHelper wmap;
        MapUShortInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerEnumHelper wmap;
        MapUShortInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasHelper wmap;
        MapUShortInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasArrayHelper wmap;
        MapUShortInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasSequenceHelper wmap;
        MapUShortInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerAliasMapHelper wmap;
        MapUShortInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerUnionHelper wmap;
        MapUShortInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint16_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapUShortInnerBitsetHelper wmap;
        MapUShortInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/**********
 * KEY_LONG
**********/
#pragma region KEY_LONG

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongShort wmap;
        MapLongShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongUShort wmap;
        MapLongUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLong wmap;
        MapLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongULong wmap;
        MapLongULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongKeyLongLongValue)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongKeyLongLongValue wmap;
        MapLongKeyLongLongValuePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongULongLong wmap;
        MapLongULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongFloat wmap;
        MapLongFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongDouble wmap;
        MapLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongKeyLongDoubleValue)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongKeyLongDoubleValue wmap;
        MapLongKeyLongDoubleValuePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongBoolean wmap;
        MapLongBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongOctet wmap;
        MapLongOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongChar wmap;
        MapLongCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongWChar wmap;
        MapLongWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongString wmap;
        MapLongStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongWString wmap;
        MapLongWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasBoundedStringHelper wmap;
        MapLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasBoundedStringHelper wmap;
        MapLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerEnumHelper wmap;
        MapLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerEnumHelper wmap;
        MapLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasHelper wmap;
        MapLongInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasArrayHelper wmap;
        MapLongInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasSequenceHelper wmap;
        MapLongInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerAliasMapHelper wmap;
        MapLongInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerUnionHelper wmap;
        MapLongInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongInnerBitsetHelper wmap;
        MapLongInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/***********
 * KEY_ULONG
***********/
#pragma region KEY_ULONG

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongShort wmap;
        MapULongShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongUShort wmap;
        MapULongUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLong wmap;
        MapULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongULong wmap;
        MapULongULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongLong wmap;
        MapULongLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongULongLong wmap;
        MapULongULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongFloat wmap;
        MapULongFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongDouble wmap;
        MapULongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongValueLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapKeyULongValueLongDouble wmap;
        MapKeyULongValueLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongBoolean wmap;
        MapULongBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongOctet wmap;
        MapULongOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongChar wmap;
        MapULongCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongWChar wmap;
        MapULongWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongString wmap;
        MapULongStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongWString wmap;
        MapULongWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasBoundedStringHelper wmap;
        MapULongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasBoundedStringHelper wmap;
        MapULongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerEnumHelper wmap;
        MapULongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerEnumHelper wmap;
        MapULongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasHelper wmap;
        MapULongInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasArrayHelper wmap;
        MapULongInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasSequenceHelper wmap;
        MapULongInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerAliasMapHelper wmap;
        MapULongInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerUnionHelper wmap;
        MapULongInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongInnerBitsetHelper wmap;
        MapULongInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/**************
 * KEY_LONGLONG
**************/
#pragma region KEY_LONGLONG

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongShort wmap;
        MapLongLongShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongUShort wmap;
        MapLongLongUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongKeyLongValue)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test..
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongKeyLongValue wmap;
        MapLongLongKeyLongValuePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongULong wmap;
        MapLongLongULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongLongLong wmap;
        MapLongLongLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongULongLong wmap;
        MapLongLongULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongFloat wmap;
        MapLongLongFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongKeyDoubleValue)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongKeyDoubleValue wmap;
        MapLongLongKeyDoubleValuePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongLongDouble wmap;
        MapLongLongLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongBoolean wmap;
        MapLongLongBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongOctet wmap;
        MapLongLongOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongChar wmap;
        MapLongLongCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongWChar wmap;
        MapLongLongWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongString wmap;
        MapLongLongStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongWString wmap;
        MapLongLongWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasBoundedStringHelper wmap;
        MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasBoundedStringHelper wmap;
        MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerEnumHelper wmap;
        MapLongLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerEnumHelper wmap;
        MapLongLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasHelper wmap;
        MapLongLongInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasArrayHelper wmap;
        MapLongLongInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasSequenceHelper wmap;
        MapLongLongInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasMapHelper wmap;
        MapLongLongInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerUnionHelper wmap;
        MapLongLongInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerBitsetHelper wmap;
        MapLongLongInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/***************
 * KEY_ULONGLONG
***************/
#pragma region KEY_ULONGLONG

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongShort wmap;
        MapULongLongShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongUShort wmap;
        MapLongLongUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongValueLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapKeyULongValueLongLong wmap;
        MapKeyULongValueLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongULong wmap;
        MapLongLongULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongLongLong wmap;
        MapLongLongLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongULongLong wmap;
        MapLongLongULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongFloat wmap;
        MapLongLongFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongLongValueDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapKeyULongLongValueDouble wmap;
        MapKeyULongLongValueDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongLongDouble wmap;
        MapLongLongLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongBoolean wmap;
        MapLongLongBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongOctet wmap;
        MapLongLongOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongChar wmap;
        MapLongLongCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongWChar wmap;
        MapLongLongWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongString wmap;
        MapLongLongStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongWString wmap;
        MapLongLongWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasBoundedStringHelper wmap;
        MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerAliasBoundedStringHelper wmap;
        MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLongInnerEnumHelper wmap;
        MapLongLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerEnumHelper wmap;
        MapULongLongInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerAliasHelper wmap;
        MapULongLongInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerAliasArrayHelper wmap;
        MapULongLongInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerAliasSequenceHelper wmap;
        MapULongLongInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerAliasMapHelper wmap;
        MapULongLongInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerUnionHelper wmap;
        MapULongLongInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_uint64_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapULongLongInnerBitsetHelper wmap;
        MapULongLongInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/************
 * KEY_STRING
************/
#pragma region KEY_STRING

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringShort wmap;
        MapStringShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringUShort wmap;
        MapStringUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLong wmap;
        MapStringLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringULong wmap;
        MapStringULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLongLong wmap;
        MapStringLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringULongLong wmap;
        MapStringULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringFloat wmap;
        MapStringFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringDouble wmap;
        MapStringDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLongDouble wmap;
        MapStringLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringBoolean wmap;
        MapStringBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringOctet wmap;
        MapStringOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringChar wmap;
        MapStringCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringWChar wmap;
        MapStringWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringString wmap;
        MapStringStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringWString wmap;
        MapStringWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasBoundedStringHelper wmap;
        MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasBoundedStringHelper wmap;
        MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerEnumHelper wmap;
        MapStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerEnumHelper wmap;
        MapStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasHelper wmap;
        MapStringInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasArrayHelper wmap;
        MapStringInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasSequenceHelper wmap;
        MapStringInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasMapHelper wmap;
        MapStringInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerUnionHelper wmap;
        MapStringInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerBitsetHelper wmap;
        MapStringInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*************
 * KEY_WSTRING
*************/
#pragma region KEY_WSTRING

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringShort wmap;
        MapWStringShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringUShort wmap;
        MapWStringUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLong wmap;
        MapWStringLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringULong wmap;
        MapWStringULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLongLong wmap;
        MapWStringLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringULongLong wmap;
        MapWStringULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringFloat wmap;
        MapWStringFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringDouble wmap;
        MapWStringDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLongDouble wmap;
        MapWStringLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringBoolean wmap;
        MapWStringBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringOctet wmap;
        MapWStringOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringChar wmap;
        MapWStringCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringWChar wmap;
        MapWStringWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringString wmap;
        MapWStringStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringWString wmap;
        MapWStringWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasBoundedStringHelper wmap;
        MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasBoundedStringHelper wmap;
        MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerEnumHelper wmap;
        MapWStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerEnumHelper wmap;
        MapWStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasHelper wmap;
        MapWStringInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasArrayHelper wmap;
        MapWStringInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasSequenceHelper wmap;
        MapWStringInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasMapHelper wmap;
        MapWStringInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerUnionHelper wmap;
        MapWStringInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerBitsetHelper wmap;
        MapWStringInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*******************
 * KEY_BOUNDEDSTRING
*******************/
#pragma region KEY_BOUNDEDSTRING

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringShort wmap;
        MapStringShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringUShort wmap;
        MapStringUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLong wmap;
        MapStringLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringULong wmap;
        MapStringULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLongLong wmap;
        MapStringLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringULongLong wmap;
        MapStringULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringFloat wmap;
        MapStringFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringDouble wmap;
        MapStringDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringLongDouble wmap;
        MapStringLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringBoolean wmap;
        MapStringBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringOctet wmap;
        MapStringOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringChar wmap;
        MapStringCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringWChar wmap;
        MapStringWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringString wmap;
        MapStringStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringWString wmap;
        MapStringWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasBoundedStringHelper wmap;
        MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerAliasBoundedStringHelper wmap;
        MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapStringInnerEnumHelper wmap;
        MapStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerBitMaskHelper wmap;
        MapInnerAliasBoundedStringHelperInnerBitMaskHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerAliasHelper wmap;
        MapInnerAliasBoundedStringHelperInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerAliasArrayHelper wmap;
        MapInnerAliasBoundedStringHelperInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper wmap;
        MapInnerAliasBoundedStringHelperInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerAliasMapHelper wmap;
        MapInnerAliasBoundedStringHelperInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerUnionHelper wmap;
        MapInnerAliasBoundedStringHelperInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_string_value("2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedStringHelperInnerBitsetHelper wmap;
        MapInnerAliasBoundedStringHelperInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*******************
 * KEY_BOUNDEDWSTRING
*******************/
#pragma region KEY_BOUNDEDWSTRING

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringShort wmap;
        MapWStringShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringUShort wmap;
        MapWStringUShortPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLong wmap;
        MapWStringLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringULong wmap;
        MapWStringULongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLongLong wmap;
        MapWStringLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringULongLong wmap;
        MapWStringULongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringFloat wmap;
        MapWStringFloatPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringDouble wmap;
        MapWStringDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringLongDouble wmap;
        MapWStringLongDoublePubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringBoolean wmap;
        MapWStringBooleanPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringOctet wmap;
        MapWStringOctetPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringChar wmap;
        MapWStringCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringWChar wmap;
        MapWStringWCharPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringString wmap;
        MapWStringStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringWString wmap;
        MapWStringWStringPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasBoundedStringHelper wmap;
        MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";
                
        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerAliasBoundedStringHelper wmap;
        MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerEnumHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapWStringInnerEnumHelper wmap;
        MapWStringInnerEnumHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerBitMaskHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(loaned_value1, expected_types, &test_value_1);
        check_get_values(loaned_value1, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerBitMaskHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerBitMaskHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);
        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerAliasHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerAliasHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId testPos(0);
        testPos = loaned_value1->get_array_index(vPosition);
        ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
        check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerAliasArrayHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, newId);
        check_get_values(loaned_value1, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasMapHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_key_type = inner_key_type_builder->build();
        ASSERT_TRUE(inner_key_type_builder != nullptr);
        ASSERT_TRUE(inner_key_type != nullptr);

        DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr inner_value_type = inner_value_type_builder->build();
        ASSERT_TRUE(inner_value_type_builder != nullptr);
        ASSERT_TRUE(inner_value_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId;
        MemberId inner_valueId;
        DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        MemberId inner_keyId2;
        MemberId inner_valueId2;
        inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
        inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
        check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 2);
        ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 1);
        ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(loaned_value1->get_item_count() == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerAliasMapHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerAliasMapHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerUnionHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;
        
        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerUnionHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerUnionHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerBitsetHelper)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(value_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = value_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Loan Complex values.
        DynamicData* loaned_value1 = data->loan_value(valueId);
        ASSERT_TRUE(loaned_value1 != nullptr);
        DynamicData* loaned_value2 = data->loan_value(valueId);
        ASSERT_FALSE(loaned_value2 != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapInnerAliasBoundedWStringHelperInnerBitsetHelper wmap;
        MapInnerAliasBoundedWStringHelperInnerBitsetHelperPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/*******************
 * BOUNDED_MAPS
*******************/
#pragma region BOUNDED_MAPS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedSmallMap)
{
    uint32_t length = 1;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Try to Add one more than the limit
        MemberId keyId2;
        MemberId valueId2;
        DynamicData* key_data2 = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_FALSE(data->insert_map_data(key_data2, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLong wmap;
        MapLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedLargeMap)
{
    uint32_t length = 41925;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        // Try to Add one more than the limit
        for(uint32_t i = 1; i < length; i++)
        {
            MemberId keyId2;
            MemberId valueId2;
            DynamicData* key_data2 = DynamicDataFactory::get_instance()->create_data(key_type);
            ASSERT_TRUE(data->insert_map_data(key_data2, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        }
        MemberId keyId3;
        MemberId valueId3;
        DynamicData* key_data3 = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_FALSE(data->insert_map_data(key_data3, keyId3, valueId3) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, valueId);
        check_get_values(data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 2);
        ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 1);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_item_count() == 0);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(map_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        MapLongLong wmap;
        MapLongLongPubSubType wmappb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

        uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

#pragma endregion

/************
 * PRIMITIVES
*************/
#pragma region PRIMITIVES

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ShortStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ShortStruct wshort;
        ShortStructPubSubType wshortpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wshortpb.deserialize(&dynamic_payload, &wshort));

        uint32_t static_payloadSize = static_cast<uint32_t>(wshortpb.getSerializedSizeProvider(&wshort)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wshortpb.serialize(&wshort, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UShortStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UShortStruct wshort;
        UShortStructPubSubType wshortpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wshortpb.deserialize(&dynamic_payload, &wshort));

        uint32_t static_payloadSize = static_cast<uint32_t>(wshortpb.getSerializedSizeProvider(&wshort)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wshortpb.serialize(&wshort, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_LongStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        LongStruct wlong;
        LongStructPubSubType wlongpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wlongpb.deserialize(&dynamic_payload, &wlong));

        uint32_t static_payloadSize = static_cast<uint32_t>(wlongpb.getSerializedSizeProvider(&wlong)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wlongpb.serialize(&wlong, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ULongStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ULongStruct wlong;
        ULongStructPubSubType wlongpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wlongpb.deserialize(&dynamic_payload, &wlong));

        uint32_t static_payloadSize = static_cast<uint32_t>(wlongpb.getSerializedSizeProvider(&wlong)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wlongpb.serialize(&wlong, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_LongLongStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        LongLongStruct wlonglong;
        LongLongStructPubSubType wlonglongpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wlonglongpb.deserialize(&dynamic_payload, &wlonglong));

        uint32_t static_payloadSize = static_cast<uint32_t>(wlonglongpb.getSerializedSizeProvider(&wlonglong)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wlonglongpb.serialize(&wlonglong, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ULongLongStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        ULongLongStruct wlonglong;
        ULongLongStructPubSubType wlonglongpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wlonglongpb.deserialize(&dynamic_payload, &wlonglong));

        uint32_t static_payloadSize = static_cast<uint32_t>(wlonglongpb.getSerializedSizeProvider(&wlonglong)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wlonglongpb.serialize(&wlonglong, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_FloatStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        FloatStruct wfloat;
        FloatStructPubSubType wfloatpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wfloatpb.deserialize(&dynamic_payload, &wfloat));

        uint32_t static_payloadSize = static_cast<uint32_t>(wfloatpb.getSerializedSizeProvider(&wfloat)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wfloatpb.serialize(&wfloat, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_DoubleStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        DoubleStruct wdouble;
        DoubleStructPubSubType wdoublepb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wdoublepb.deserialize(&dynamic_payload, &wdouble));

        uint32_t static_payloadSize = static_cast<uint32_t>(wdoublepb.getSerializedSizeProvider(&wdouble)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wdoublepb.serialize(&wdouble, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_LongDoubleStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        LongDoubleStruct wldouble;
        LongDoubleStructPubSubType wldoublepb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wldoublepb.deserialize(&dynamic_payload, &wldouble));

        uint32_t static_payloadSize = static_cast<uint32_t>(wldoublepb.getSerializedSizeProvider(&wldouble)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wldoublepb.serialize(&wldouble, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BooleanStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        bool test_value_1 = true;
        bool test_value_2 = false;

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BooleanStruct wbool;
        BooleanStructPubSubType wboolpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wboolpb.deserialize(&dynamic_payload, &wbool));

        uint32_t static_payloadSize = static_cast<uint32_t>(wboolpb.getSerializedSizeProvider(&wbool)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wboolpb.serialize(&wbool, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_OctetStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        octet test_value_1 = 255;
        octet test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        OctetStruct wchar;
        OctetStructPubSubType wcharpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wcharpb.deserialize(&dynamic_payload, &wchar));

        uint32_t static_payloadSize = static_cast<uint32_t>(wcharpb.getSerializedSizeProvider(&wchar)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wcharpb.serialize(&wchar, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_CharStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        char test_value_1 = 'a';
        char test_value_2 = 'b';

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);


        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        CharStruct wchar;
        CharStructPubSubType wcharpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wcharpb.deserialize(&dynamic_payload, &wchar));

        uint32_t static_payloadSize = static_cast<uint32_t>(wcharpb.getSerializedSizeProvider(&wchar)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wcharpb.serialize(&wchar, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }

    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_WCharStruct)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        WCharStruct wchar;
        WCharStructPubSubType wcharpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wcharpb.deserialize(&dynamic_payload, &wchar));

        uint32_t static_payloadSize = static_cast<uint32_t>(wcharpb.getSerializedSizeProvider(&wchar)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wcharpb.serialize(&wchar, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/***********
 * SEQUENCES
***********/
#pragma region SEQUENCES
TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceShort seq;
        SequenceShortPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceUShort)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_uint16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_uint16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_uint16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceUShort seq;
        SequenceUShortPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceLong seq;
        SequenceLongPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceULong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_uint32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_uint32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_uint32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceULong seq;
        SequenceULongPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceLongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int64_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int64_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int64_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int64_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceLongLong seq;
        SequenceLongLongPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceULongLong)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_uint64_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_uint64_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_uint64_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_uint64_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceULongLong seq;
        SequenceULongLongPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceFloat)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        float_t test_value_1 = 123.0f;
        float_t test_value_2 = 0.0f;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_float32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_float32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_float32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceFloat seq;
        SequenceFloatPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float64_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_float64_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_float64_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_float64_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceDouble seq;
        SequenceDoublePubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceLongDouble)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_float128_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_float128_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_float128_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_float128_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceLongDouble seq;
        SequenceLongDoublePubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceBoolean)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        bool test_value_1 = true;
        bool test_value_2 = false;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_bool_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_bool_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_bool_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_bool_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceBoolean seq;
        SequenceBooleanPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceOctet)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        octet test_value_1 = 255;
        octet test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_byte_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_byte_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_byte_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_byte_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceOctet seq;
        SequenceOctetPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);
        // Set and get a value.
        char test_value_1 = 'a';
        char test_value_2 = 'b';

        // Try to write on an empty position
        ASSERT_FALSE(data->set_char8_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_char8_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_char8_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_char8_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceChar seq;
        SequenceCharPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceWChar)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';

        // Try to write on an empty position
        ASSERT_FALSE(data->set_char16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_char16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_char16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_char16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceWChar seq;
        SequenceWCharPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_string_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_string_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_string_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceString seq;
        SequenceStringPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceWString)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_wstring_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_wstring_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_wstring_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceWString seq;
        SequenceWStringPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceStringBounded)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "A";
        std::string test_value_2 = "";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_string_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", newId) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_string_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_string_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_string_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceStringBounded seq;
        SequenceStringBoundedPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceWStringBounded)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";

        // Try to write on an empty position
        ASSERT_FALSE(data->set_wstring_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", newId) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_wstring_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_wstring_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_wstring_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceWStringBounded seq;
        SequenceWStringBoundedPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceEnum)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        // Try to set an invalid value.
        ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        // Try to write on an empty position
        ASSERT_FALSE(data->set_enum_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_enum_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_enum_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_enum_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceEnum seq;
        SequenceEnumPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceBitMask)
{
    // uint32_t limit = 5;
    // uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    // {
    //     DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
    //     ASSERT_TRUE(base_type_builder != nullptr);

    //     // Add members to the bitmask
    //     ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
    //     // Try to add a descriptor with the same name
    //     ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
    //     // Out of bounds
    //     ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 
            
    //     DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
    //     ASSERT_TRUE(seq_type_builder != nullptr);
    //     DynamicType_ptr seq_type = seq_type_builder->build();
    //     ASSERT_TRUE(seq_type != nullptr);

    //     DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);

    //     // Set and get a value.
    //     uint64_t test_bitmask_value_1 = 55;// 00110111
    //     uint64_t test_bitmask_value_2;

    //     // Try to write on an empty position
    //     ASSERT_FALSE(data->set_bitmask_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

    //     MemberId newId;
    //     ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
    //     MemberId newId2;
    //     ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

    //     std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
    //     check_set_values(data, expected_types, &test_value_1, newId);
    //     check_get_values(data, expected_types, &test_value_2, newId);
    //     ASSERT_TRUE(test_value_1 == test_value_2);

    //     // Remove the elements.
    //     ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

    //     // New Insert Methods
    //     ASSERT_TRUE(data->insert_bitmask_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(data->get_bitmask_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(test_value_1 == test_value_2);
    //     ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

    //     // Check that the sequence is empty.
    //     ASSERT_FALSE(data->get_bitmask_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

    //     // Serialize <-> Deserialize Test
    //     DynamicPubSubType pubsubType(seq_type);
    //     uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
    //     SerializedPayload_t payload(payloadSize);
    //     ASSERT_TRUE(pubsubType.serialize(data, &payload));
    //     ASSERT_TRUE(payload.length == payloadSize);

    //     DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
    //     ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
    //     ASSERT_TRUE(data2->equals(data));

    //     // SERIALIZATION TEST
    //     SequenceBitMask seq;
    //     SequenceBitMaskPubSubType seqpb;

    //     SerializedPayload_t dynamic_payload(payloadSize);
    //     ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
    //     ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

    //     uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
    //     SerializedPayload_t static_payload(static_payloadSize);
    //     ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
    //     ASSERT_TRUE(static_payload.length == static_payloadSize);
    //     DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
    //     ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
    //     ASSERT_TRUE(data3->equals(data));

    //     ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
    //     ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    // }
    // ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    // ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceAlias)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(base_type_builder != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");
            
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(alias_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceAlias seq;
        SequenceAliasPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceShortArray)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    std::vector<uint32_t> array_length = { 10 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type_builder != nullptr);
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr complex_seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(content_type_builder.get(), length);
        DynamicType_ptr complex_seq_type = complex_seq_type_builder->build();
        ASSERT_TRUE(complex_seq_type_builder != nullptr);
        ASSERT_TRUE(complex_seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(data != nullptr);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Loan Value to modify the first sequence
        DynamicData* seq_data = data->loan_value(newId);
        ASSERT_TRUE(seq_data != nullptr);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId newContentId(0);
        newContentId = seq_data->get_array_index(vPosition);
        ASSERT_TRUE(newContentId != MEMBER_ID_INVALID);

        // Invalid input vectors.
        std::vector<uint32_t> vPosition2 = { 1, 1 };
        ASSERT_FALSE(seq_data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
        std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
        ASSERT_FALSE(seq_data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(seq_data, expected_types, &test_value_1, newContentId);
        check_get_values(seq_data, expected_types, &test_value_2, newContentId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count before and after remove an element.
        ASSERT_TRUE(seq_data->get_item_count() == content_type->get_total_bounds());
        ASSERT_TRUE(seq_data->clear_value(newContentId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == content_type->get_total_bounds());
        ASSERT_TRUE(seq_data->clear_array_data(newContentId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == content_type->get_total_bounds());

        // Check the clear values method
        ASSERT_TRUE(seq_data->set_int16_value(test_value_1, newContentId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == content_type->get_total_bounds());
        ASSERT_TRUE(seq_data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == content_type->get_total_bounds());

        // Try to set a value out of the array.
        ASSERT_FALSE(seq_data->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

        // Return the pointer of the sequence
        ASSERT_TRUE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(content_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(content_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceShortArray seq;
        SequenceShortArrayPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(content_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceSequence)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type_builder != nullptr);
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr complex_seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(content_type_builder.get(), length);
        DynamicType_ptr complex_seq_type = complex_seq_type_builder->build();
        ASSERT_TRUE(complex_seq_type_builder != nullptr);
        ASSERT_TRUE(complex_seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(data != nullptr);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Loan Value to modify the first sequence
        DynamicData* seq_data = data->loan_value(newId);
        ASSERT_TRUE(seq_data != nullptr);

        MemberId newContentId;
        ASSERT_TRUE(seq_data->insert_sequence_data(newContentId) == ReturnCode_t::RETCODE_OK);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(seq_data, expected_types, &test_value_1, newContentId);
        check_get_values(seq_data, expected_types, &test_value_2, newContentId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer of the sequence
        ASSERT_TRUE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(complex_seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceSequence seq;
        SequenceSequencePubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceMap)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr map_type = map_type_builder->build();
        ASSERT_TRUE(map_type_builder != nullptr);
        ASSERT_TRUE(map_type != nullptr);

        DynamicTypeBuilder_ptr complex_seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(map_type_builder.get(), length);
        DynamicType_ptr complex_seq_type = complex_seq_type_builder->build();
        ASSERT_TRUE(complex_seq_type_builder != nullptr);
        ASSERT_TRUE(complex_seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(data != nullptr);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Loan Value to modify the first sequence
        DynamicData* seq_data = data->loan_value(newId);
        ASSERT_TRUE(seq_data != nullptr);

        // Set and get a value.
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;
        
        // Try to write on an empty position
        ASSERT_FALSE(seq_data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(seq_data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(seq_data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(seq_data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(seq_data, expected_types, &test_value_1, valueId);
        check_get_values(seq_data, expected_types, &test_value_2, valueId);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Check items count with removes
        ASSERT_TRUE(seq_data->get_item_count() == 2);
        ASSERT_FALSE(seq_data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == 2);
        ASSERT_TRUE(seq_data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == 1);
        ASSERT_TRUE(seq_data->clear_all_values() == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(seq_data->get_item_count() == 0);

        // Return the pointer of the sequence
        ASSERT_TRUE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(complex_seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceMap seq;
        SequenceMapPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceUnion)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicTypeBuilder_ptr complex_seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(union_type_builder.get(), length);
        DynamicType_ptr complex_seq_type = complex_seq_type_builder->build();
        ASSERT_TRUE(complex_seq_type_builder != nullptr);
        ASSERT_TRUE(complex_seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(data != nullptr);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Loan Value to modify the first sequence
        DynamicData* seq_data = data->loan_value(newId);
        ASSERT_TRUE(seq_data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(seq_data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(seq_data, expected_types, &test_value_1, 0);
        check_get_values(seq_data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(seq_data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Return the pointer of the sequence
        ASSERT_TRUE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(complex_seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceMap seq;
        SequenceMapPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceStructure)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_SequenceBitset)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(bitset_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr bitset_type = bitset_type_builder->build();
        ASSERT_TRUE(bitset_type != nullptr);

        DynamicTypeBuilder_ptr complex_seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(bitset_type_builder.get(), length);
        DynamicType_ptr complex_seq_type = complex_seq_type_builder->build();
        ASSERT_TRUE(complex_seq_type_builder != nullptr);
        ASSERT_TRUE(complex_seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(data != nullptr);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        MemberId newId2;
        ASSERT_TRUE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Loan Value to modify the first sequence
        DynamicData* seq_data = data->loan_value(newId);
        ASSERT_TRUE(seq_data != nullptr);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(seq_data->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(seq_data->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(seq_data->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(seq_data->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer of the sequence
        ASSERT_TRUE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(seq_data) == ReturnCode_t::RETCODE_OK);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(complex_seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        SequenceMap seq;
        SequenceMapPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(complex_seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedSmallSequences)
{
    uint32_t length = 1;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(123, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        // Try to insert more than the limit.
        MemberId newId2;
        ASSERT_FALSE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BoundedSmallSequences seq;
        BoundedSmallSequencesPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedBigSequences)
{
    uint32_t length = 41925;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        ASSERT_TRUE(base_type_builder != nullptr);
        DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        ASSERT_TRUE(seq_type_builder != nullptr);
        DynamicType_ptr seq_type = seq_type_builder->build();
        ASSERT_TRUE(seq_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(data != nullptr);

        // Try to write on an empty position
        ASSERT_FALSE(data->set_int16_value(123, 1) == ReturnCode_t::RETCODE_OK);

        MemberId newId;
        ASSERT_TRUE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        // Try to insert more than the limit.
        for(uint32_t i = 1; i < length; i++)
        {
            MemberId valid_id;
            ASSERT_TRUE(data->insert_sequence_data(valid_id) == ReturnCode_t::RETCODE_OK);
        }
        MemberId newId2;
        ASSERT_FALSE(data->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

        // Set and get a value.
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, newId);
        check_get_values(data, expected_types, &test_value_2, newId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Remove the elements.
        ASSERT_TRUE(data->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // New Insert Methods
        ASSERT_TRUE(data->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(data->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(test_value_1 == test_value_2);
        ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);

        // Check that the sequence is empty.
        ASSERT_FALSE(data->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(seq_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);

        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        BoundedBigSequences seq;
        BoundedBigSequencesPubSubType seqpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

        uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(seq_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}


#pragma endregion

/*********
 * STRINGS
**********/
#pragma region STRINGS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_String)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        StringStruct wstring;
        StringStructPubSubType wstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wstringpb.deserialize(&dynamic_payload, &wstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wstringpb.getSerializedSizeProvider(&wstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wstringpb.serialize(&wstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_WString)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        WStringStruct wwstring;
        WStringStructPubSubType wwstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wwstringpb.deserialize(&dynamic_payload, &wwstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wwstringpb.getSerializedSizeProvider(&wwstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wwstringpb.serialize(&wwstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ShortBoundedString)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1 = "A";
        std::string test_value_2 = "";

        ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        StringStruct wstring;
        StringStructPubSubType wstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wstringpb.deserialize(&dynamic_payload, &wstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wstringpb.getSerializedSizeProvider(&wstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wstringpb.serialize(&wstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ShortBoundedWString)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";

        ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        WStringStruct wwstring;
        WStringStructPubSubType wwstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wwstringpb.deserialize(&dynamic_payload, &wwstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wwstringpb.getSerializedSizeProvider(&wwstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wwstringpb.serialize(&wwstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_LargeBoundedString)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(41925);
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::string test_value_1;
        for (int i = 0; i < 41925; ++i) {
            test_value_1 += "A";
        }

        std::string test_value_2 = "";
        std::string over_length_string;
        for (int i = 0; i < 41926; ++i) {
            over_length_string += "A";
        }

        ASSERT_FALSE(data->set_string_value(over_length_string, MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        StringStruct wstring;
        StringStructPubSubType wstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wstringpb.deserialize(&dynamic_payload, &wstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wstringpb.getSerializedSizeProvider(&wstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wstringpb.serialize(&wstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_LargeBoundedWString)
{
    {
        DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(41925);
        ASSERT_TRUE(created_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(data != nullptr);

        std::wstring test_value_1;
        for (int i = 0; i < 41925; ++i) {
            test_value_1 += L"A";
        }

        std::wstring test_value_2 = L"";
        std::wstring over_length_string;
        for (int i = 0; i < 41926; ++i) {
            over_length_string += L"A";
        }

        ASSERT_FALSE(data->set_wstring_value(over_length_string, MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);

        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(created_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        WStringStruct wwstring;
        WStringStructPubSubType wwstringpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wwstringpb.deserialize(&dynamic_payload, &wwstring));

        uint32_t static_payloadSize = static_cast<uint32_t>(wwstringpb.getSerializedSizeProvider(&wwstring)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wwstringpb.serialize(&wwstring, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion

/************
 * STRUCTURES
************/
#pragma region STRUCTURES


TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_Structures)
{
    StructShort var_StructShort;
    StructUnsignedShort var_StructUnsignedShort;
    StructLong var_StructLong;
    StructUnsignedLong var_StructUnsignedLong;
    StructLongLong var_StructLongLong;
    StructUnsignedLongLong var_StructUnsignedLongLong;
    StructFloat var_StructFloat;
    StructDouble var_StructDouble;
    StructLongDouble var_StructLongDouble;
    StructBoolean var_StructBoolean;
    StructOctet var_StructOctet;
    StructChar8 var_StructChar8;
    StructChar16 var_StructChar16;
    StructString var_StructString;
    StructWString var_StructWString;
    StructEnum var_StructEnum;
    StructBitMask var_StructBitMask;
    StructAlias var_StructAlias;
    StructShortArray var_StructShortArray;
    StructSequence var_StructSequence;
    StructMap var_StructMap;
    StructUnion var_StructUnion;
    StructStructure var_StructStructure;
    StructBitset var_StructBitset;
    StructEmpty var_StructEmpty;
} 

#pragma endregion

/********
 * UNIONS
********/
#pragma region UNIONS

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionShort)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionShort wunion;
        UnionShortPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionUShort)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        uint16_t test_value_1 = 123;
        uint16_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionUShort wunion;
        UnionUShortPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);
        
        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionLong wunion;
        UnionLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionULong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        uint32_t test_value_1 = 123;
        uint32_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionULong wunion;
        UnionULongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionLongLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int64_t test_value_1 = 123;
        int64_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionLongLong wunion;
        UnionLongLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionULongLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        uint64_t test_value_1 = 123;
        uint64_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionULongLong wunion;
        UnionULongLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionFloat)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        float_t test_value_1 = 123.0;
        float_t test_value_2 = 0.0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Float};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionFloat wunion;
        UnionFloatPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDouble)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        double test_value_1 = 123.0;
        double test_value_2 = 0.0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Double};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDouble wunion;
        UnionDoublePubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionLongDouble)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        long double test_value_1 = 123.0;
        long double test_value_2 = 0.0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionLongDouble wunion;
        UnionLongDoublePubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionBoolean)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        bool test_value_1 = true;
        bool test_value_2 = false;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionBoolean wunion;
        UnionBooleanPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionOctet)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        octet test_value_1 = 255;
        octet test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionOctet wunion;
        UnionOctetPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionChar)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        char test_value_1 = 'a';
        char test_value_2 = 'b';

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Char};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionChar wunion;
        UnionCharPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionWChar)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);


        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        wchar_t test_value_1 = L'a';
        wchar_t test_value_2 = L'b';

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionWChar wunion;
        UnionWCharPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionString)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        std::string test_value_1 = "STRING_TEST";
        std::string test_value_2 = "";

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionString wunion;
        UnionStringPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionWString)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        std::wstring test_value_1 = L"STRING_TEST";
        std::wstring test_value_2 = L"";

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionWString wunion;
        UnionWStringPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionBoundedString)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        std::string test_value_1 = "A";
        std::string test_value_2 = "";

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::String};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionBoundedString wunion;
        UnionBoundedStringPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionBoundedWString)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        std::wstring test_value_1 = L"A";
        std::wstring test_value_2 = L"";

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::WString};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionBoundedWString wunion;
        UnionBoundedWStringPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerEnumHelper)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        std::string test_value_1 = "SECOND";
        std::string test_value_2;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionInnerEnumHelper wunion;
        UnionInnerEnumHelperPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerBitMaskHelper)
{
    uint32_t limit = 5;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        // Add members to the bitmask
        ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
        // Try to add a descriptor with the same name
        ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
        // Out of bounds
        ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        uint64_t test_value_1 = 55;// 00110111
        uint64_t test_value_2;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
        expected_types.push_back(ExpectedType::ULongLong);
        check_set_values(data, expected_types, &test_value_1);
        check_get_values(data, expected_types, &test_value_2);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionInnerEnumHelper wunion;
        UnionInnerEnumHelperPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerAliasHelper)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", created_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", created_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", created_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionInnerAliasHelper wunion;
        UnionInnerAliasHelperPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionArray)
{
    std::vector<uint32_t> array_length = { 2 };
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        //DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        //ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type_builder != nullptr);
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", content_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        DynamicData* content_data = data->loan_value(0);
        ASSERT_TRUE(content_data != 0);

        // Get an index in the array.
        std::vector<uint32_t> vPosition = { 1 };
        MemberId newContentId(0);
        newContentId = content_data->get_array_index(vPosition);
        ASSERT_TRUE(newContentId != MEMBER_ID_INVALID);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(content_data, expected_types, &test_value_1, newContentId);
        check_get_values(content_data, expected_types, &test_value_2, newContentId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionArray wunion;
        UnionArrayPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionSequence)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        //DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        //ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type_builder != nullptr);
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", content_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Loan Value
        DynamicData* content_data = data->loan_value(0);
        ASSERT_TRUE(content_data != 0);

        MemberId newContentId;
        ASSERT_TRUE(content_data->insert_sequence_data(newContentId) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(content_data, expected_types, &test_value_1, newContentId);
        check_get_values(content_data, expected_types, &test_value_2, newContentId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer
        ASSERT_TRUE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionArray wunion;
        UnionArrayPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionMap)
{
    uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
    {
        DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr key_type = key_type_builder->build();
        ASSERT_TRUE(key_type_builder != nullptr);
        ASSERT_TRUE(key_type != nullptr);

        DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr value_type = value_type_builder->build();
        ASSERT_TRUE(value_type_builder != nullptr);
        ASSERT_TRUE(value_type != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type_builder != nullptr);
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", content_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Loan Value
        DynamicData* content_data = data->loan_value(0);
        ASSERT_TRUE(content_data != 0);

        MemberId keyId;
        MemberId valueId;
        DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        ASSERT_TRUE(content_data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

        // Try to Add the same key twice.
        ASSERT_FALSE(content_data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        MemberId keyId2;
        MemberId valueId2;
        key_data = DynamicDataFactory::get_instance()->create_data(key_type);
        key_data->set_int32_value(2, MEMBER_ID_INVALID);
        ASSERT_TRUE(content_data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(content_data, expected_types, &test_value_1, valueId);
        check_get_values(content_data, expected_types, &test_value_2, valueId);
        ASSERT_TRUE(test_value_1 == test_value_2);

        // Return the pointer
        ASSERT_TRUE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionMap wunion;
        UnionMapPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerUnionHelper)
{
    {
        DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type1 = base_type_builder1->build();
        ASSERT_TRUE(base_type_builder1!= nullptr);
        ASSERT_TRUE(base_type1 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr base_type3 = base_type_builder3->build();
        ASSERT_TRUE(base_type_builder3 != nullptr);
        ASSERT_TRUE(base_type3 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(content_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(content_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(content_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(content_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(content_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(content_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", content_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        // Set and get a value.
        uint64_t label;
        int16_t test_value_1 = 123;
        int16_t test_value_2 = 0;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Loan Value
        DynamicData* loaned_value1 = data->loan_value(0);
        ASSERT_TRUE(loaned_value1 != 0);
 
        uint64_t inner_label;

        ASSERT_TRUE(loaned_value1->get_union_label(inner_label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(inner_label == 0);

        std::vector<ExpectedType> expected_types = {ExpectedType::Short};
        check_set_values(loaned_value1, expected_types, &test_value_1, 0);
        check_get_values(loaned_value1, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(loaned_value1->get_union_label(inner_label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(inner_label == 0);

        // Return the pointer 
        ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionArray wunion;
        UnionArrayPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerStructureHelper)
{
    //TODO
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionInnerBitsetHelper)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        auto base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
        ASSERT_TRUE(content_type_builder != nullptr);

        // Add members to the struct.
        ASSERT_TRUE(content_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(content_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
        content_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
        content_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
        content_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
        content_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

        DynamicType_ptr content_type = content_type_builder->build();
        ASSERT_TRUE(content_type != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "l", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "l", content_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "X", content_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);

        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        // Loan Value
        DynamicData* content_data = data->loan_value(0);
        ASSERT_TRUE(content_data != 0);

        // Set and get the child values.
        octet test1(234);
        ASSERT_TRUE(content_data->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
        octet test2(0);
        ASSERT_TRUE(content_data->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test1 == test2);
        // 11101010
        // 00000010 (two bits)
        ASSERT_TRUE(test2 == 2);
        uint32_t test3(289582314);
        ASSERT_TRUE(content_data->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
        uint32_t test4(0);
        ASSERT_TRUE(content_data->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(test3 == test4);
        // 00000001010000101010110011101010
        // 00000000000000101010110011101010 (20 bits)
        ASSERT_TRUE(test4 == 175338);

        // Return the pointer
        ASSERT_TRUE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);
        ASSERT_FALSE(data->return_loaned_value(content_data) == ReturnCode_t::RETCODE_OK);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionMap wunion;
        UnionMapPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorShort)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorShort wunion;
        UnionDiscriminatorShortPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorUShort)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorUShort wunion;
        UnionDiscriminatorUShortPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorLong wunion;
        UnionDiscriminatorLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorULong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorULong wunion;
        UnionDiscriminatorULongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorLongLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorLongLong wunion;
        UnionDiscriminatorLongLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorULongLong)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorULongLong wunion;
        UnionDiscriminatorULongLongPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorBoolean)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorBoolean wunion;
        UnionDiscriminatorBooleanPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorOctet)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorOctet wunion;
        UnionDiscriminatorOctetPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorChar)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorChar wunion;
        UnionDiscriminatorCharPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorWChar)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorWChar wunion;
        UnionDiscriminatorWCharPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorEnum)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
        DynamicType_ptr discriminator_type = discriminator_type_builder->build();
        ASSERT_TRUE(discriminator_type_builder != nullptr);
        ASSERT_TRUE(discriminator_type != nullptr);

        // Add three members to the enum.
        ASSERT_TRUE(discriminator_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(discriminator_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(discriminator_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

        // Try to add a descriptor with the same name.
        ASSERT_FALSE(discriminator_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorWChar wunion;
        UnionDiscriminatorWCharPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_UnionDiscriminatorAlias)
{
    {
        DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        DynamicType_ptr base_type = base_type_builder->build();
        ASSERT_TRUE(base_type_builder != nullptr);
        ASSERT_TRUE(base_type != nullptr);

        DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
        DynamicType_ptr base_type2 = base_type_builder2->build();
        ASSERT_TRUE(base_type_builder2 != nullptr);
        ASSERT_TRUE(base_type2 != nullptr);

        DynamicTypeBuilder_ptr content_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
        ASSERT_TRUE(content_type_builder != nullptr);

        std::string name = "InnerAliasHelper";
        DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(content_type_builder.get(), name);
        ASSERT_TRUE(alias_builder != nullptr);
        DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
        ASSERT_TRUE(created_type != nullptr);
        ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");


        DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(alias_builder.get());
        ASSERT_TRUE(union_type_builder != nullptr);

        // Add members to the union.
        ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(union_type_builder->add_member(1, "second", base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
        // Try to add a second "DEFAULT" value to the union
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
        // Try to add a second value to the same case label
        ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

        // Create a data of this union
        DynamicType_ptr union_type = union_type_builder->build();
        ASSERT_TRUE(union_type != nullptr);
        DynamicData* data = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(data != nullptr);

        uint64_t label;
        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int32_t test_value_1 = 123;
        int32_t test_value_2 = 0;

        std::vector<ExpectedType> expected_types = {ExpectedType::Long};
        check_set_values(data, expected_types, &test_value_1, 0);
        check_get_values(data, expected_types, &test_value_2, 0);
        ASSERT_TRUE(test_value_1 == test_value_2);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 0);

        int64_t test_value_3 = 234;
        int64_t test_value_4 = 0;

        expected_types = {ExpectedType::LongLong};
        check_set_values(data, expected_types, &test_value_3, 1);
        check_get_values(data, expected_types, &test_value_4, 1);
        ASSERT_TRUE(test_value_3 == test_value_4);

        ASSERT_TRUE(data->get_union_label(label) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(label == 1);

        // Serialize <-> Deserialize Test
        DynamicPubSubType pubsubType(union_type);
        uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
        SerializedPayload_t payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &payload));
        ASSERT_TRUE(payload.length == payloadSize);
        DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
        ASSERT_TRUE(data2->equals(data));

        // SERIALIZATION TEST
        UnionDiscriminatorOctet wunion;
        UnionDiscriminatorOctetPubSubType wunionpb;

        SerializedPayload_t dynamic_payload(payloadSize);
        ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
        ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

        uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
        SerializedPayload_t static_payload(static_payloadSize);
        ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
        ASSERT_TRUE(static_payload.length == static_payloadSize);
        DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(union_type);
        ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
        ASSERT_TRUE(data3->equals(data));

        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
        ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
    }
    ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
    ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
}

#pragma endregion


int main(
        int argc,
        char** argv)
{
    eprosima::fastdds::dds::Log::SetVerbosity(eprosima::fastdds::dds::Log::Info);

    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
