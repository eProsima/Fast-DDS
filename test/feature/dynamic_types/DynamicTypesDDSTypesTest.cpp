// Copyright 2024 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "DynamicTypesDDSTypesTest.hpp"

#include <gtest/gtest.h>

#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/xtypes/dynamic_types/DynamicDataFactory.hpp>
#include <fastdds/dds/xtypes/dynamic_types/DynamicType.hpp>
#include <fastdds/dds/xtypes/dynamic_types/DynamicTypeBuilder.hpp>
#include <fastdds/dds/xtypes/dynamic_types/DynamicTypeBuilderFactory.hpp>
#include <fastdds/dds/xtypes/dynamic_types/MemberDescriptor.hpp>
#include <fastdds/dds/xtypes/dynamic_types/TypeDescriptor.hpp>
#include <fastdds/dds/xtypes/dynamic_types/Types.hpp>

namespace eprosima {
namespace fastdds {
namespace dds {

DynamicTypesDDSTypesTest::~DynamicTypesDDSTypesTest()
{
    eprosima::fastdds::dds::Log::KillThread();
}

void DynamicTypesDDSTypesTest::TearDown()
{
    DynamicDataFactory::delete_instance();
    DynamicTypeBuilderFactory::delete_instance();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_enum_helper()
{
    TypeDescriptor::_ref_type enum_descriptor {traits<TypeDescriptor>::make_shared()};
    enum_descriptor->kind(TK_ENUM);
    enum_descriptor->name(enum_name);
    DynamicTypeBuilder::_ref_type enum_builder {DynamicTypeBuilderFactory::get_instance()->create_type(enum_descriptor)};

    MemberDescriptor::_ref_type enum_literal_descriptor {traits<MemberDescriptor>::make_shared()};
    enum_literal_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_UINT32));
    enum_literal_descriptor->name(enum_value_1_name);
    enum_builder->add_member(enum_literal_descriptor);
    enum_literal_descriptor = traits<MemberDescriptor>::make_shared();
    enum_literal_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_UINT32));
    enum_literal_descriptor->name(enum_value_2_name);
    enum_builder->add_member(enum_literal_descriptor);
    enum_literal_descriptor = traits<MemberDescriptor>::make_shared();
    enum_literal_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_UINT32));
    enum_literal_descriptor->name(enum_value_3_name);
    enum_builder->add_member(enum_literal_descriptor);

    return enum_builder->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_bitmask_helper()
{
    TypeDescriptor::_ref_type bitmask_descriptor {traits<TypeDescriptor>::make_shared()};
    bitmask_descriptor->kind(TK_BITMASK);
    bitmask_descriptor->name(bitmask_name);
    bitmask_descriptor->element_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitmask_descriptor->bound().push_back(32);
    DynamicTypeBuilder::_ref_type bitmask_builder {DynamicTypeBuilderFactory::get_instance()->create_type(bitmask_descriptor)};

    MemberDescriptor::_ref_type bitfield_descriptor {traits<MemberDescriptor>::make_shared()};
    bitfield_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitfield_descriptor->name(bitmask_flag_0_name);
    bitfield_descriptor->id(0);
    bitmask_builder->add_member(bitfield_descriptor);
    bitfield_descriptor = traits<MemberDescriptor>::make_shared();
    bitfield_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitfield_descriptor->name(bitmask_flag_1_name);
    bitfield_descriptor->id(1);
    bitmask_builder->add_member(bitfield_descriptor);
    bitfield_descriptor = traits<MemberDescriptor>::make_shared();
    bitfield_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitfield_descriptor->name(bitmask_flag_4_name);
    bitfield_descriptor->id(4);
    bitmask_builder->add_member(bitfield_descriptor);
    bitfield_descriptor = traits<MemberDescriptor>::make_shared();
    bitfield_descriptor->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitfield_descriptor->name(bitmask_flag_6_name);
    bitfield_descriptor->id(6);
    bitmask_builder->add_member(bitfield_descriptor);

    return bitmask_builder->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_helper()
{
    TypeDescriptor::_ref_type inner_alias_descriptor {traits<TypeDescriptor>::make_shared()};
    inner_alias_descriptor->kind(TK_ALIAS);
    inner_alias_descriptor->name(alias_name);
    inner_alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32));

    return DynamicTypeBuilderFactory::get_instance()->create_type(inner_alias_descriptor)->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_union_helper()
{
    TypeDescriptor::_ref_type union_descriptor {traits<TypeDescriptor>::make_shared()};
    union_descriptor->kind(TK_UNION);
    union_descriptor->name(union_name);
    union_descriptor->discriminator_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32));
    union_descriptor->is_nested(true);
    DynamicTypeBuilder::_ref_type union_builder {DynamicTypeBuilderFactory::get_instance()->create_type(union_descriptor)};

    MemberDescriptor::_ref_type union_member {traits<MemberDescriptor>::make_shared()};
    union_member->name(union_long_member_name);
    union_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32));
    union_member->label({0});
    union_builder->add_member(union_member);
    union_member = traits<MemberDescriptor>::make_shared();
    union_member->name(union_float_member_name);
    union_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_FLOAT32));
    union_member->label({1});
    union_builder->add_member(union_member);
    union_member = traits<MemberDescriptor>::make_shared();
    union_member->name(union_short_member_name);
    union_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT16));
    union_member->is_default_label(true);
    union_builder->add_member(union_member);

    return union_builder->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_struct_helper()
{
    TypeDescriptor::_ref_type struct_descriptor {traits<TypeDescriptor>::make_shared()};
    struct_descriptor->kind(TK_STRUCTURE);
    struct_descriptor->name(struct_name);
    struct_descriptor->is_nested(true);
    DynamicTypeBuilder::_ref_type struct_builder {DynamicTypeBuilderFactory::get_instance()->create_type(struct_descriptor)};

    MemberDescriptor::_ref_type struct_member {traits<MemberDescriptor>::make_shared()};
    struct_member->name(struct_long_member_name);
    struct_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32));
    struct_builder->add_member(struct_member);
    struct_member = traits<MemberDescriptor>::make_shared();
    struct_member->name(struct_float_member_name);
    struct_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_FLOAT32));
    struct_builder->add_member(struct_member);

    return struct_builder->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_bitset_helper()
{
    TypeDescriptor::_ref_type bitset_descriptor {traits<TypeDescriptor>::make_shared()};
    bitset_descriptor->kind(TK_BITSET);
    bitset_descriptor->name(bitset_name);
    bitset_descriptor->bound({3, 1, 10, 12});
    DynamicTypeBuilder::_ref_type bitset_builder {DynamicTypeBuilderFactory::get_instance()->create_type(bitset_descriptor)};

    MemberDescriptor::_ref_type bitset_member {traits<MemberDescriptor>::make_shared()};
    bitset_member->name(bitfield_a);
    bitset_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_UINT8));
    bitset_member->id(0);
    bitset_builder->add_member(bitset_member);
    bitset_member = traits<MemberDescriptor>::make_shared();
    bitset_member->name(bitfield_b);
    bitset_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_BOOLEAN));
    bitset_member->id(3);
    bitset_builder->add_member(bitset_member);
    bitset_member = traits<MemberDescriptor>::make_shared();
    bitset_member->name(bitfield_c);
    bitset_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_UINT16));
    bitset_member->id(8);
    bitset_builder->add_member(bitset_member);
    bitset_member = traits<MemberDescriptor>::make_shared();
    bitset_member->name(bitfield_d);
    bitset_member->type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT16));
    bitset_member->id(21);
    bitset_builder->add_member(bitset_member);

    return bitset_builder->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_bounded_string_helper()
{
    TypeDescriptor::_ref_type alias_descriptor {traits<TypeDescriptor>::make_shared()};
    alias_descriptor->kind(TK_ALIAS);
    alias_descriptor->name(bounded_string_alias);
    alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->create_string_type(10)->build());

    return DynamicTypeBuilderFactory::get_instance()->create_type(alias_descriptor)->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_bounded_wstring_helper()
{
    TypeDescriptor::_ref_type alias_descriptor {traits<TypeDescriptor>::make_shared()};
    alias_descriptor->kind(TK_ALIAS);
    alias_descriptor->name(bounded_wstring_alias);
    alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->create_wstring_type(10)->build());

    return DynamicTypeBuilderFactory::get_instance()->create_type(alias_descriptor)->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_array_helper()
{
    TypeDescriptor::_ref_type alias_descriptor {traits<TypeDescriptor>::make_shared()};
    alias_descriptor->kind(TK_ALIAS);
    alias_descriptor->name(array_alias);
    alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->create_array_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT16), {2})->build());

    return DynamicTypeBuilderFactory::get_instance()->create_type(alias_descriptor)->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_sequence_helper()
{
    TypeDescriptor::_ref_type alias_descriptor {traits<TypeDescriptor>::make_shared()};
    alias_descriptor->kind(TK_ALIAS);
    alias_descriptor->name(seq_alias);
    alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->create_sequence_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT16), LENGTH_UNLIMITED)->build());

    return DynamicTypeBuilderFactory::get_instance()->create_type(alias_descriptor)->build();
}

DynamicType::_ref_type DynamicTypesDDSTypesTest::create_inner_alias_map_helper()
{
    TypeDescriptor::_ref_type alias_descriptor {traits<TypeDescriptor>::make_shared()};
    alias_descriptor->kind(TK_ALIAS);
    alias_descriptor->name(map_alias);
    alias_descriptor->base_type(DynamicTypeBuilderFactory::get_instance()->create_map_type(DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32), DynamicTypeBuilderFactory::get_instance()->get_primitive_type(TK_INT32), LENGTH_UNLIMITED)->build());

    return DynamicTypeBuilderFactory::get_instance()->create_type(alias_descriptor)->build();
}

// /********
//  * ARRAYS
// *********/
// #pragma region ARRAYS

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayShort)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayShort warray;
//         ArrayShortPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayUShort)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayUShort warray;
//         ArrayUShortPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLong)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayLong warray;
//         ArrayLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayULong)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayULong warray;
//         ArrayULongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLongLong)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayLongLong warray;
//         ArrayLongLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayULongLong)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayULongLong warray;
//         ArrayULongLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayFloat)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         float test_value_1 = 123.0f;
//         float test_value_2 = 0.0f;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayFloat warray;
//         ArrayFloatPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayDouble)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayDouble warray;
//         ArrayDoublePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayLongDouble)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float128_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayLongDouble warray;
//         ArrayLongDoublePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoolean)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_bool_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBoolean warray;
//         ArrayBooleanPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayOctet)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         octet test_value_1 = 255;
//         octet test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_byte_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayOctet warray;
//         ArrayOctetPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayChar)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         char test_value_1 = 'a';
//         char test_value_2 = 'b';

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_char8_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayChar warray;
//         ArrayCharPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayWChar)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_char16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayWChar warray;
//         ArrayWCharPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayString)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayString warray;
//         ArrayStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayWString)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayWString warray;
//         ArrayWStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoundedString)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";

//         ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBoundedString warray;
//         ArrayBoundedStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBoundedWString)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";

//         ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBoundedWString warray;
//         ArrayBoundedWStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayEnum)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Try to set an invalid value.
//         ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_enum_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayEnum warray;
//         ArrayEnumPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBitMask)
// {
//     std::vector<uint32_t> length = { 10 };
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBitMask warray;
//         ArrayBitMaskPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayAlias)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(alias_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayAlias warray;
//         ArrayAliasPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayShortArray)
// {
//     std::vector<uint32_t> length = { 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         ASSERT_TRUE(array_type_builder != nullptr);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicTypeBuilder_ptr parent_array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(array_type_builder.get(), length);
//         ASSERT_TRUE(parent_array_type_builder != nullptr);
//         DynamicType_ptr parent_array_type = parent_array_type_builder->build();
//         ASSERT_TRUE(parent_array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(parent_array_type);

//         MemberId newId;
//         ASSERT_FALSE(data->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         int16_t test_value_1 = 123;
//         int16_t test_value_2(0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == parent_array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(parent_array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(parent_array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayShortArray seq;
//         ArrayShortArrayPubSubType seqpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(seqpb.deserialize(&dynamic_payload, &seq));

//         uint32_t static_payloadSize = static_cast<uint32_t>(seqpb.getSerializedSizeProvider(&seq)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(seqpb.serialize(&seq, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArraySequence)
// {
//     std::vector<uint32_t> length = { 10 };
//     uint32_t seq_length = 10;
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), seq_length);
//         ASSERT_TRUE(seq_type_builder != nullptr);
//         DynamicType_ptr seq_type = seq_type_builder->build();
//         ASSERT_TRUE(seq_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(seq_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArraySequence warray;
//         ArraySequencePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMap)
// {
//     std::vector<uint32_t> length = { 10 };
//     uint32_t map_length = 10;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), map_length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(map_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMap warray;
//         ArrayMapPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayUnion)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(union_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayUnion warray;
//         ArrayUnionPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayStructure)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(value_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayStructure warray;
//         ArrayStructurePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayBitset)
// {
//     std::vector<uint32_t> length = { 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(bitset_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = bitset_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(bitset_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBitset warray;
//         ArrayBitsetPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionShort)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionShort warray;
//         ArrayMultiDimensionShortPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionUShort)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_uint16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionUShort warray;
//         ArrayMultiDimensionUShortPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLong)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionLong warray;
//         ArrayMultiDimensionLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionULong)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_uint32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionULong warray;
//         ArrayMultiDimensionULongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLongLong)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_int64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionLongLong warray;
//         ArrayMultiDimensionLongLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionULongLong)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_uint64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_uint64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionULongLong warray;
//         ArrayMultiDimensionULongLongPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionFloat)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_float32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionFloat warray;
//         ArrayMultiDimensionFloatPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionDouble)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float64_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_float64_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionDouble warray;
//         ArrayMultiDimensionDoublePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionLongDouble)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_float128_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_float128_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionLongDouble warray;
//         ArrayMultiDimensionLongDoublePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoolean)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_bool_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 100000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_bool_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionBoolean warray;
//         ArrayMultiDimensionBooleanPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionOctet)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         octet test_value_1 = 255;
//         octet test_value_2 = 0;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_byte_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 100000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_byte_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionOctet warray;
//         ArrayMultiDimensionOctetPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionChar)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_char8_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_char8_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionChar warray;
//         ArrayMultiDimensionCharPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionWChar)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_char16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_char16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionWChar warray;
//         ArrayMultiDimensionWCharPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionString)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_string_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionString warray;
//         ArrayMultiDimensionStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionWString)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";
        
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionWString warray;
//         ArrayMultiDimensionWStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoundedString)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";

//         ASSERT_FALSE(data->set_string_value("TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);
     
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_string_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_string_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_string_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionBoundedString warray;
//         ArrayMultiDimensionBoundedStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBoundedWString)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";

//         ASSERT_FALSE(data->set_wstring_value(L"TEST_OVER_LENGTH_LIMITS", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);
     
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_wstring_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_wstring_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionBoundedWString warray;
//         ArrayMultiDimensionBoundedWStringPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionEnum)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(base_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(base_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Try to set an invalid value.
//         ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;

//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_enum_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_enum_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionEnum warray;
//         ArrayMultiDimensionEnumPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBitMask)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayBitMask warray;
//         ArrayBitMaskPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionAlias)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(base_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(alias_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Get an index in the multidimensional array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int32_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 10000) == ReturnCode_t::RETCODE_OK);
//         // TO CHECK // ASSERT_FALSE(data->set_int32_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionAlias warray;
//         ArrayMultiDimensionAliasPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionSequence)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     uint32_t seq_length = 10;
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr seq_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), seq_length);
//         DynamicType_ptr seq_type = seq_type_builder->build();
//         ASSERT_TRUE(seq_type_builder != nullptr);
//         ASSERT_TRUE(seq_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(seq_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int32_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int32_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int32_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionSequence warray;
//         ArrayMultiDimensionSequencePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionMap)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     uint32_t map_length = 10;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), map_length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(map_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionMap warray;
//         ArrayMultiDimensionMapPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionUnion)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(union_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionUnion warray;
//         ArrayMultiDimensionUnionPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionStructure)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(value_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionStructure warray;
//         ArrayMultiDimensionStructurePubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ArrayMultiDimensionBitset)
// {
//     std::vector<uint32_t> arrays_lengths = { 10, 10, 10 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(bitset_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = bitset_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(bitset_type_builder.get(), arrays_lengths);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1, 1, 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(testPos);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(testPos);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ArrayMultiDimensionBitset warray;
//         ArrayMultiDimensionBitsetPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedSmallArrays)
// {
//     std::vector<uint32_t> length = { 1 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 0 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 0, 0 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 0, 0, 0, 0 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 2) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         BoundedSmallArrays warray;
//         BoundedSmallArraysPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedBigArrays)
// {
//     std::vector<uint32_t> length = { 41925 };
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr array_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), length);
//         DynamicType_ptr array_type = array_type_builder->build();
//         ASSERT_TRUE(array_type_builder != nullptr);
//         ASSERT_TRUE(array_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(data != nullptr);

//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = data->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(data->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, testPos);
//         check_get_values(data, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(data->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == array_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 41927) == ReturnCode_t::RETCODE_OK);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(array_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         BoundedBigArrays warray;
//         BoundedBigArraysPubSubType warraypb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(warraypb.deserialize(&dynamic_payload, &warray));

//         uint32_t static_payloadSize = static_cast<uint32_t>(warraypb.getSerializedSizeProvider(&warray)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(warraypb.serialize(&warray, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(array_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*********
//  * BITSETS
// **********/
// #pragma region BITSETS

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BitsetStruct)
// {
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr bitset_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(bitset_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(bitset_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(bitset_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         bitset_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         bitset_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = bitset_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);
//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(bitset_type);
//         ASSERT_TRUE(data != nullptr);

//         ASSERT_FALSE(data->set_int32_value(10, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->set_string_value("", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(data->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(data->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(data->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(data->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(bitset_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(bitset_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         BitsetStruct wbitset;
//         BitsetStructPubSubType wbitsetpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));        
//         ASSERT_TRUE(wbitsetpb.deserialize(&dynamic_payload, &wbitset));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wbitsetpb.getSerializedSizeProvider(&wbitset)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wbitsetpb.serialize(&wbitset, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(bitset_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);

//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /**************
//  * DECLARATIONS
// ***************/
// #pragma region DECLARATIONS

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ForwardDeclarationsStruct)
// {
//     {
//         DynamicTypeBuilder_ptr struct_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr struct_base_type1 = struct_base_type_builder1->build();
//         ASSERT_TRUE(struct_base_type_builder1 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr struct_base_type2 = struct_base_type_builder2->build();
//         ASSERT_TRUE(struct_base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_base_type_builder->add_member(0, "field1", struct_base_type1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_base_type_builder->add_member(1, "field2", struct_base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr struct_base_type = struct_base_type_builder->build();
//         ASSERT_TRUE(struct_base_type != nullptr);    
        

//         DynamicTypeBuilder_ptr union_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type = union_base_type_builder->build();
//         ASSERT_TRUE(union_base_type_builder != nullptr);
//         ASSERT_TRUE(union_base_type != nullptr);

//         DynamicTypeBuilder_ptr union_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type2 = union_base_type_builder2->build();
//         ASSERT_TRUE(union_base_type_builder2 != nullptr);
//         ASSERT_TRUE(union_base_type2 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", union_base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(1, "second", union_base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         DynamicTypeBuilder_ptr forward_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(forward_struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(0, "field1", struct_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(1, "field2", union_type) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr forward_struct_base_type = forward_struct_base_type_builder->build();
//         ASSERT_TRUE(forward_struct_base_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(data != nullptr);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(forward_struct_base_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ForwardDeclarationsStruct structures;
//         ForwardDeclarationsStructPubSubType structurespb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(structurespb.deserialize(&dynamic_payload, &structures));

//         uint32_t static_payloadSize = static_cast<uint32_t>(structurespb.getSerializedSizeProvider(&structures)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(structurespb.serialize(&structures, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ForwardDeclarationsRecursiveStruct)
// {
//     {
//         DynamicTypeBuilder_ptr struct_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr struct_base_type1 = struct_base_type_builder1->build();
//         ASSERT_TRUE(struct_base_type_builder1 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr struct_base_type2 = struct_base_type_builder2->build();
//         ASSERT_TRUE(struct_base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_base_type_builder->add_member(0, "field1", struct_base_type1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_base_type_builder->add_member(1, "field2", struct_base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr struct_base_type = struct_base_type_builder->build();
//         ASSERT_TRUE(struct_base_type != nullptr);    
        
//         uint32_t sequence_length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//         DynamicTypeBuilder_ptr sequence_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(struct_base_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_struct_base_type = sequence_struct_base_type_builder->build();
//         ASSERT_TRUE(sequence_struct_base_type_builder != nullptr);
//         ASSERT_TRUE(sequence_struct_base_type != nullptr);
        
//         sequence_length = 10;
//         DynamicTypeBuilder_ptr sequence_struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(struct_base_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_struct_base_type2 = sequence_struct_base_type_builder2->build();
//         ASSERT_TRUE(sequence_struct_base_type_builder2 != nullptr);
//         ASSERT_TRUE(sequence_struct_base_type2 != nullptr);
        
//         DynamicTypeBuilder_ptr union_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type1 = union_base_type_builder1->build();
//         ASSERT_TRUE(union_base_type_builder1!= nullptr);
//         ASSERT_TRUE(union_base_type1 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "default", union_base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", union_base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "second", union_base_type1, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         sequence_length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//         DynamicTypeBuilder_ptr sequence_union_base_typetype_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(union_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_union_base_typetype = sequence_union_base_typetype_builder->build();
//         ASSERT_TRUE(sequence_union_base_typetype_builder != nullptr);
//         ASSERT_TRUE(sequence_union_base_typetype != nullptr);

//         sequence_length = 10;
//         DynamicTypeBuilder_ptr sequence_union_base_typetype_builder2 = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(union_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_union_base_typetype2 = sequence_union_base_typetype_builder2->build();
//         ASSERT_TRUE(sequence_union_base_typetype_builder2 != nullptr);
//         ASSERT_TRUE(sequence_union_base_typetype2 != nullptr);
               
//         DynamicTypeBuilder_ptr forward_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(forward_struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(0, "field1", sequence_struct_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(1, "field2", sequence_struct_base_type2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(2, "field3", sequence_union_base_typetype) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(3, "field4", sequence_union_base_typetype2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr forward_struct_base_type = forward_struct_base_type_builder->build();
//         ASSERT_TRUE(forward_struct_base_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(data != nullptr);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(forward_struct_base_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ForwardDeclarationsRecursiveStruct structures;
//         ForwardDeclarationsRecursiveStructPubSubType structurespb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(structurespb.deserialize(&dynamic_payload, &structures));

//         uint32_t static_payloadSize = static_cast<uint32_t>(structurespb.getSerializedSizeProvider(&structures)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(structurespb.serialize(&structures, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ModuledForwardDeclarationsStruct)
// {
//     {
//         DynamicTypeBuilder_ptr struct_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr struct_base_type1 = struct_base_type_builder1->build();
//         ASSERT_TRUE(struct_base_type_builder1 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr struct_base_type2 = struct_base_type_builder2->build();
//         ASSERT_TRUE(struct_base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_base_type_builder->add_member(0, "field1", struct_base_type1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_base_type_builder->add_member(1, "field2", struct_base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr struct_base_type = struct_base_type_builder->build();
//         ASSERT_TRUE(struct_base_type != nullptr);    
        

//         DynamicTypeBuilder_ptr union_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type = union_base_type_builder->build();
//         ASSERT_TRUE(union_base_type_builder != nullptr);
//         ASSERT_TRUE(union_base_type != nullptr);

//         DynamicTypeBuilder_ptr union_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type2 = union_base_type_builder2->build();
//         ASSERT_TRUE(union_base_type_builder2 != nullptr);
//         ASSERT_TRUE(union_base_type2 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", union_base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(1, "second", union_base_type2, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         DynamicTypeBuilder_ptr forward_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(forward_struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(0, "field1", struct_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(1, "field2", union_type) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr forward_struct_base_type = forward_struct_base_type_builder->build();
//         ASSERT_TRUE(forward_struct_base_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(data != nullptr);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(forward_struct_base_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ModuledForwardDeclarationsStruct structures;
//         ModuledForwardDeclarationsStructPubSubType structurespb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(structurespb.deserialize(&dynamic_payload, &structures));

//         uint32_t static_payloadSize = static_cast<uint32_t>(structurespb.getSerializedSizeProvider(&structures)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(structurespb.serialize(&structures, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_ModuledForwardDeclarationsRecursiveStruct)
// {
//     {
//         DynamicTypeBuilder_ptr struct_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr struct_base_type1 = struct_base_type_builder1->build();
//         ASSERT_TRUE(struct_base_type_builder1 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr struct_base_type2 = struct_base_type_builder2->build();
//         ASSERT_TRUE(struct_base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_base_type_builder->add_member(0, "field1", struct_base_type1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_base_type_builder->add_member(1, "field2", struct_base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr struct_base_type = struct_base_type_builder->build();
//         ASSERT_TRUE(struct_base_type != nullptr);    
        
//         uint32_t sequence_length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//         DynamicTypeBuilder_ptr sequence_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(struct_base_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_struct_base_type = sequence_struct_base_type_builder->build();
//         ASSERT_TRUE(sequence_struct_base_type_builder != nullptr);
//         ASSERT_TRUE(sequence_struct_base_type != nullptr);
        
//         sequence_length = 10;
//         DynamicTypeBuilder_ptr sequence_struct_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(struct_base_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_struct_base_type2 = sequence_struct_base_type_builder2->build();
//         ASSERT_TRUE(sequence_struct_base_type_builder2 != nullptr);
//         ASSERT_TRUE(sequence_struct_base_type2 != nullptr);
        
//         DynamicTypeBuilder_ptr union_base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr union_base_type1 = union_base_type_builder1->build();
//         ASSERT_TRUE(union_base_type_builder1!= nullptr);
//         ASSERT_TRUE(union_base_type1 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr union_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(union_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(union_type_builder->add_member(0, "default", union_base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "first", union_base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(union_type_builder->add_member(0, "second", union_base_type1, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(union_type_builder->add_member(0, "third", union_base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         // Create a data of this union
//         DynamicType_ptr union_type = union_type_builder->build();
//         ASSERT_TRUE(union_type != nullptr);

//         sequence_length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//         DynamicTypeBuilder_ptr sequence_union_base_typetype_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(union_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_union_base_typetype = sequence_union_base_typetype_builder->build();
//         ASSERT_TRUE(sequence_union_base_typetype_builder != nullptr);
//         ASSERT_TRUE(sequence_union_base_typetype != nullptr);

//         sequence_length = 10;
//         DynamicTypeBuilder_ptr sequence_union_base_typetype_builder2 = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(union_type_builder.get(), sequence_length);
//         DynamicType_ptr sequence_union_base_typetype2 = sequence_union_base_typetype_builder2->build();
//         ASSERT_TRUE(sequence_union_base_typetype_builder2 != nullptr);
//         ASSERT_TRUE(sequence_union_base_typetype2 != nullptr);
               
//         DynamicTypeBuilder_ptr forward_struct_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(forward_struct_base_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(0, "field1", sequence_struct_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(1, "field2", sequence_struct_base_type2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(2, "field3", sequence_union_base_typetype) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(forward_struct_base_type_builder->add_member(3, "field4", sequence_union_base_typetype2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr forward_struct_base_type = forward_struct_base_type_builder->build();
//         ASSERT_TRUE(forward_struct_base_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(data != nullptr);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(forward_struct_base_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         ModuledForwardDeclarationsRecursiveStruct structures;
//         ModuledForwardDeclarationsRecursiveStructPubSubType structurespb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(structurespb.deserialize(&dynamic_payload, &structures));

//         uint32_t static_payloadSize = static_cast<uint32_t>(structurespb.getSerializedSizeProvider(&structures)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(structurespb.serialize(&structures, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(forward_struct_base_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /**************
//  * ENUMERATIONS
// ***************/
// #pragma region ENUMERATIONS

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_Enum)
// {
//     {
//         DynamicTypeBuilder_ptr created_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         ASSERT_TRUE(created_builder != nullptr);
        
//         // Add three members to the enum.
//         ASSERT_TRUE(created_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(created_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(created_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(created_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);
        
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(created_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(data != nullptr);

//         // Try to set an invalid value.
//         ASSERT_FALSE(data->set_enum_value("BAD", MEMBER_ID_INVALID) == ReturnCode_t::RETCODE_OK);

//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1);
//         check_get_values(data, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(created_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         EnumStructure wenum;
//         EnumStructurePubSubType wenumpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wenumpb.deserialize(&dynamic_payload, &wenum));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wenumpb.getSerializedSizeProvider(&wenum)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wenumpb.serialize(&wenum, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_Bitmask)
// {
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(base_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(base_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(base_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(base_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(base_type_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId test_member_id;
//         test_member_id = data->get_member_id_by_name("FLAG0");
//         ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
//         test_member_id = data->get_member_id_by_name("FLAG1");
//         ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
//         test_member_id = data->get_member_id_by_name("FLAG4");
//         ASSERT_TRUE(test_member_id != MEMBER_ID_INVALID);
//         test_member_id= data->get_member_id_by_name("FLAG5");
//         ASSERT_FALSE(test_member_id != MEMBER_ID_INVALID);

//         uint64_t test_bitmask_value_1 = 55;// 00110111
//         uint64_t test_bitmask_value_2;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(data, expected_types, &test_bitmask_value_1);
//         check_get_values(data, expected_types, &test_bitmask_value_2);

//         ASSERT_TRUE(test_bitmask_value_1 == test_bitmask_value_2);
//         ASSERT_TRUE(data->get_bool_value("FLAG0"));
//         ASSERT_TRUE(data->get_bool_value("FLAG1"));
//         ASSERT_TRUE(data->get_bool_value("FLAG4"));

//         // Over the limit
//         ASSERT_FALSE(data->set_bool_value(true, limit + 1) == ReturnCode_t::RETCODE_OK);

//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         ASSERT_TRUE(data->get_bool_value(test_value_2, 2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_2 == true);
//         ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_2 == data->get_bool_value("FLAG0"));

//         bool test3 = data->get_bool_value("FLAG0");
//         ASSERT_TRUE(test_value_1 == test3);
//         ASSERT_TRUE(data->set_bool_value(true, "FLAG4") == ReturnCode_t::RETCODE_OK);
//         bool test4 = data->get_bool_value("FLAG4");
//         ASSERT_TRUE(test4 == true);

//         test_value_1 = false;
//         ASSERT_TRUE(data->set_bool_value(test_value_1, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_bool_value(test_value_2, data->get_member_id_by_name("FLAG0")) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(created_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         BitMaskStructure wbitmask;
//         BitMaskStructurePubSubType wbitmaskpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wbitmaskpb.deserialize(&dynamic_payload, &wbitmask));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wbitmaskpb.getSerializedSizeProvider(&wbitmask)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wbitmaskpb.serialize(&wbitmask, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(created_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*************
//  * INHERITANCE
// *************/
// #pragma region INHERITANCE

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperChild)
// {
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         auto base_type = base_type_builder->build();

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         auto base_type2 = base_type_builder2->build();

//         DynamicTypeBuilder_ptr struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_type_builder->add_member(0, "int32", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_type_builder->add_member(1, "float32", base_type2) == ReturnCode_t::RETCODE_OK);

//         auto struct_type = struct_type_builder->build();
//         ASSERT_TRUE(struct_type != nullptr);

//         // Try to create the child struct without parent
//         DynamicTypeBuilder_ptr child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(nullptr);
//         ASSERT_FALSE(child_struct_type_builder != nullptr);

//         DynamicTypeBuilder_ptr child_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         ASSERT_TRUE(child_base_type_builder != nullptr);
//         auto child_base_type = child_base_type_builder->build();

//         DynamicTypeBuilder_ptr child_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         ASSERT_TRUE(child_base_type_builder2 != nullptr);
//         auto child_base_type2 = child_base_type_builder2->build();

//         // Create the child struct.
//         child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(struct_type_builder.get());
//         ASSERT_TRUE(child_struct_type_builder != nullptr);

//         // Add a new member to the child struct.
//         ASSERT_TRUE(child_struct_type_builder->add_member(2, "child_int64", child_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(child_struct_type_builder->add_member(3, "child_uint64", child_base_type2) == ReturnCode_t::RETCODE_OK);

//         // try to add a member to override one of the parent struct.
//         ASSERT_FALSE(child_struct_type_builder->add_member(4, "int32", child_base_type) == ReturnCode_t::RETCODE_OK);

//         auto child_struct_type = child_struct_type_builder->build();
//         ASSERT_TRUE(child_struct_type != nullptr);
//         auto data = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, 0);
//         check_get_values(data, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(data, expected_types2, &test_value_3, 1);
//         check_get_values(data, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);


//         int64_t test_value_5 = 123;
//         int64_t test_value_6 = 0;

//         std::vector<ExpectedType> expected_types3 = {ExpectedType::LongLong};
//         check_set_values(data, expected_types3, &test_value_5, 2);
//         check_get_values(data, expected_types3, &test_value_6, 2);
//         ASSERT_TRUE(test_value_5 == test_value_6);

//         uint64_t test_value_7 = 123;
//         uint64_t test_value_8 = 0;

//         std::vector<ExpectedType> expected_types4 = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types4, &test_value_7, 3);
//         check_get_values(data, expected_types4, &test_value_8, 3);
//         ASSERT_TRUE(test_value_7 == test_value_8);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(child_struct_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         InnerStructureHelperChild wunion;
//         InnerStructureHelperChildPubSubType wunionpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperChildChild)
// {
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         auto base_type = base_type_builder->build();

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         auto base_type2 = base_type_builder2->build();

//         DynamicTypeBuilder_ptr struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_type_builder->add_member(0, "int32", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_type_builder->add_member(1, "float32", base_type2) == ReturnCode_t::RETCODE_OK);

//         auto struct_type = struct_type_builder->build();
//         ASSERT_TRUE(struct_type != nullptr);

//         // Try to create the child struct without parent
//         DynamicTypeBuilder_ptr child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(nullptr);
//         ASSERT_FALSE(child_struct_type_builder != nullptr);

//         DynamicTypeBuilder_ptr child_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         ASSERT_TRUE(child_base_type_builder != nullptr);
//         auto child_base_type = child_base_type_builder->build();

//         DynamicTypeBuilder_ptr child_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         ASSERT_TRUE(child_base_type_builder2 != nullptr);
//         auto child_base_type2 = child_base_type_builder2->build();

//         // Create the child struct.
//         child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(struct_type_builder.get());
//         ASSERT_TRUE(child_struct_type_builder != nullptr);

//         // Add a new member to the child struct.
//         ASSERT_TRUE(child_struct_type_builder->add_member(2, "child_int64", child_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(child_struct_type_builder->add_member(3, "child_uint64", child_base_type2) == ReturnCode_t::RETCODE_OK);

//         // try to add a member to override one of the parent struct.
//         ASSERT_FALSE(child_struct_type_builder->add_member(4, "int32", child_base_type) == ReturnCode_t::RETCODE_OK);

//         auto child_struct_type = child_struct_type_builder->build();
//         ASSERT_TRUE(child_struct_type != nullptr);

//         DynamicTypeBuilder_ptr child_child_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         ASSERT_TRUE(child_child_base_type_builder != nullptr);
//         auto child_child_base_type = child_child_base_type_builder->build();

//         DynamicTypeBuilder_ptr child_child_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         ASSERT_TRUE(child_child_base_type_builder2 != nullptr);
//         auto child_child_base_type2 = child_child_base_type_builder2->build();

//         // Create the child struct.
//         DynamicTypeBuilder_ptr child_child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(child_struct_type_builder.get());
//         ASSERT_TRUE(child_child_struct_type_builder != nullptr);

//         // Add a new member to the child struct.
//         ASSERT_TRUE(child_child_struct_type_builder->add_member(4, "child_child_int64", child_child_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(child_child_struct_type_builder->add_member(5, "child_child_uint64", child_child_base_type2) == ReturnCode_t::RETCODE_OK);

//         // try to add a member to override one of the parent struct.
//         ASSERT_FALSE(child_child_struct_type_builder->add_member(6, "child_int64", child_child_base_type) == ReturnCode_t::RETCODE_OK);

//         auto child_child_struct_type = child_child_struct_type_builder->build();
//         ASSERT_TRUE(child_child_struct_type != nullptr);

//         auto data = DynamicDataFactory::get_instance()->create_data(child_child_struct_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, 0);
//         check_get_values(data, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(data, expected_types2, &test_value_3, 1);
//         check_get_values(data, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);


//         int64_t test_value_5 = 123;
//         int64_t test_value_6 = 0;

//         std::vector<ExpectedType> expected_types3 = {ExpectedType::LongLong};
//         check_set_values(data, expected_types3, &test_value_5, 2);
//         check_get_values(data, expected_types3, &test_value_6, 2);
//         ASSERT_TRUE(test_value_5 == test_value_6);

//         uint64_t test_value_7 = 123;
//         uint64_t test_value_8 = 0;

//         std::vector<ExpectedType> expected_types4 = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types4, &test_value_7, 3);
//         check_get_values(data, expected_types4, &test_value_8, 3);
//         ASSERT_TRUE(test_value_7 == test_value_8);

//         int64_t test_value_9 = 123;
//         int64_t test_value_10 = 0;

//         std::vector<ExpectedType> expected_types5 = {ExpectedType::LongLong};
//         check_set_values(data, expected_types5, &test_value_9, 4);
//         check_get_values(data, expected_types5, &test_value_10, 4);
//         ASSERT_TRUE(test_value_9 == test_value_10);

//         uint64_t test_value_11 = 123;
//         uint64_t test_value_12 = 0;

//         std::vector<ExpectedType> expected_types6 = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types6, &test_value_11, 5);
//         check_get_values(data, expected_types6, &test_value_12, 5);
//         ASSERT_TRUE(test_value_11 == test_value_12);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(child_struct_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         InnerStructureHelperChildChild wunion;
//         InnerStructureHelperChildChildPubSubType wunionpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerStructureHelperEmptyChild)
// {
//     {
//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         auto base_type = base_type_builder->build();

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         auto base_type2 = base_type_builder2->build();

//         DynamicTypeBuilder_ptr struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(struct_type_builder->add_member(0, "int32", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(struct_type_builder->add_member(1, "float32", base_type2) == ReturnCode_t::RETCODE_OK);

//         auto struct_type = struct_type_builder->build();
//         ASSERT_TRUE(struct_type != nullptr);

//         // Try to create the child struct without parent
//         DynamicTypeBuilder_ptr child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(nullptr);
//         ASSERT_FALSE(child_struct_type_builder != nullptr);

//         // Create the child struct.
//         child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(struct_type_builder.get());
//         ASSERT_TRUE(child_struct_type_builder != nullptr);

//         auto child_struct_type = child_struct_type_builder->build();
//         ASSERT_TRUE(child_struct_type != nullptr);
//         auto data = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(data != nullptr);

//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, 0);
//         check_get_values(data, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(data, expected_types2, &test_value_3, 1);
//         check_get_values(data, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(child_struct_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         InnerStructureHelperEmptyChild wunion;
//         InnerStructureHelperEmptyChildPubSubType wunionpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_InnerEmptyStructureHelperChild)
// {
//     {
//         DynamicTypeBuilder_ptr struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(struct_type_builder != nullptr);

//         auto struct_type = struct_type_builder->build();
//         ASSERT_TRUE(struct_type != nullptr);

//         // Try to create the child struct without parent
//         DynamicTypeBuilder_ptr child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(nullptr);
//         ASSERT_FALSE(child_struct_type_builder != nullptr);

//         DynamicTypeBuilder_ptr child_base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         ASSERT_TRUE(child_base_type_builder != nullptr);
//         auto child_base_type = child_base_type_builder->build();

//         DynamicTypeBuilder_ptr child_base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         ASSERT_TRUE(child_base_type_builder2 != nullptr);
//         auto child_base_type2 = child_base_type_builder2->build();

//         // Create the child struct.
//         child_struct_type_builder = DynamicTypeBuilderFactory::get_instance()->create_child_struct_builder(struct_type_builder.get());
//         ASSERT_TRUE(child_struct_type_builder != nullptr);

//         // Add a new member to the child struct.
//         ASSERT_TRUE(child_struct_type_builder->add_member(0, "child_int64", child_base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(child_struct_type_builder->add_member(1, "child_uint64", child_base_type2) == ReturnCode_t::RETCODE_OK);

//         auto child_struct_type = child_struct_type_builder->build();
//         ASSERT_TRUE(child_struct_type != nullptr);
//         auto data = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(data != nullptr);

//         int64_t test_value_5 = 123;
//         int64_t test_value_6 = 0;

//         std::vector<ExpectedType> expected_types3 = {ExpectedType::LongLong};
//         check_set_values(data, expected_types3, &test_value_5, 0);
//         check_get_values(data, expected_types3, &test_value_6, 0);
//         ASSERT_TRUE(test_value_5 == test_value_6);

//         uint64_t test_value_7 = 123;
//         uint64_t test_value_8 = 0;

//         std::vector<ExpectedType> expected_types4 = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types4, &test_value_7, 1);
//         check_get_values(data, expected_types4, &test_value_8, 1);
//         ASSERT_TRUE(test_value_7 == test_value_8);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(child_struct_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);
//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         InnerEmptyStructureHelperChild wunion;
//         InnerEmptyStructureHelperChildPubSubType wunionpb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wunionpb.deserialize(&dynamic_payload, &wunion));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wunionpb.getSerializedSizeProvider(&wunion)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wunionpb.serialize(&wunion, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(child_struct_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /******
//  * MAPS
// ******/
// #pragma region MAPS

// /***********
//  * KEY_SHORT
// ***********/
// #pragma region KEY_SHORT

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);  

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortShort wmap;
//         MapShortShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);
        
//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortUShort wmap;
//         MapShortUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortLong wmap;
//         MapShortLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortULong wmap;
//         MapShortULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortLongLong wmap;
//         MapShortLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortULongLong wmap;
//         MapShortULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortFloat wmap;
//         MapShortFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortDouble wmap;
//         MapShortDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortLongDouble wmap;
//         MapShortLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortBoolean wmap;
//         MapShortBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortOctet wmap;
//         MapShortOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortChar wmap;
//         MapShortCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortWChar wmap;
//         MapShortWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortString wmap;
//         MapShortStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortWString wmap;
//         MapShortWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasBoundedStringHelper wmap;
//         MapShortInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasBoundedStringHelper wmap;
//         MapShortInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerEnumHelper wmap;
//         MapShortInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerEnumHelper wmap;
//         MapShortInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasHelper wmap;
//         MapShortInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasArrayHelper wmap;
//         MapShortInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasSequenceHelper wmap;
//         MapShortInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerAliasMapHelper wmap;
//         MapShortInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerUnionHelper wmap;
//         MapShortInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;

//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerStructureHelper wmap;
//         MapShortInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapShortInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapShortInnerBitsetHelper wmap;
//         MapShortInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /************
//  * KEY_USHORT
// ************/
// #pragma region KEY_USHORT

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortShort wmap;
//         MapUShortShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortUShort wmap;
//         MapUShortUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortLong wmap;
//         MapUShortLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortULong wmap;
//         MapUShortULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortLongLong wmap;
//         MapUShortLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortULongLong wmap;
//         MapUShortULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortFloat wmap;
//         MapUShortFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortDouble wmap;
//         MapUShortDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortLongDouble wmap;
//         MapUShortLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortBoolean wmap;
//         MapUShortBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortOctet wmap;
//         MapUShortOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortChar wmap;
//         MapUShortCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortWChar wmap;
//         MapUShortWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortString wmap;
//         MapUShortStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortWString wmap;
//         MapUShortWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
      
//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasBoundedStringHelper wmap;
//         MapUShortInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasBoundedStringHelper wmap;
//         MapUShortInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerEnumHelper wmap;
//         MapUShortInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerEnumHelper wmap;
//         MapUShortInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasHelper wmap;
//         MapUShortInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasArrayHelper wmap;
//         MapUShortInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasSequenceHelper wmap;
//         MapUShortInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerAliasMapHelper wmap;
//         MapUShortInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerUnionHelper wmap;
//         MapUShortInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerStructureHelper wmap;
//         MapUShortInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapUShortInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint16_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapUShortInnerBitsetHelper wmap;
//         MapUShortInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /**********
//  * KEY_LONG
// **********/
// #pragma region KEY_LONG

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongShort wmap;
//         MapLongShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongUShort wmap;
//         MapLongUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLong wmap;
//         MapLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongULong wmap;
//         MapLongULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongKeyLongLongValue)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongKeyLongLongValue wmap;
//         MapLongKeyLongLongValuePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongULongLong wmap;
//         MapLongULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongFloat wmap;
//         MapLongFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongDouble wmap;
//         MapLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongKeyLongDoubleValue)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongKeyLongDoubleValue wmap;
//         MapLongKeyLongDoubleValuePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongBoolean wmap;
//         MapLongBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongOctet wmap;
//         MapLongOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongChar wmap;
//         MapLongCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongWChar wmap;
//         MapLongWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongString wmap;
//         MapLongStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongWString wmap;
//         MapLongWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasBoundedStringHelper wmap;
//         MapLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasBoundedStringHelper wmap;
//         MapLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerEnumHelper wmap;
//         MapLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerEnumHelper wmap;
//         MapLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasHelper wmap;
//         MapLongInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasArrayHelper wmap;
//         MapLongInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasSequenceHelper wmap;
//         MapLongInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerAliasMapHelper wmap;
//         MapLongInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerUnionHelper wmap;
//         MapLongInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerStructureHelper wmap;
//         MapLongInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongInnerBitsetHelper wmap;
//         MapLongInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /***********
//  * KEY_ULONG
// ***********/
// #pragma region KEY_ULONG

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongShort wmap;
//         MapULongShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongUShort wmap;
//         MapULongUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLong wmap;
//         MapULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongULong wmap;
//         MapULongULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongLong wmap;
//         MapULongLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongULongLong wmap;
//         MapULongULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongFloat wmap;
//         MapULongFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongDouble wmap;
//         MapULongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongValueLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapKeyULongValueLongDouble wmap;
//         MapKeyULongValueLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongBoolean wmap;
//         MapULongBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongOctet wmap;
//         MapULongOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongChar wmap;
//         MapULongCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongWChar wmap;
//         MapULongWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongString wmap;
//         MapULongStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongWString wmap;
//         MapULongWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasBoundedStringHelper wmap;
//         MapULongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasBoundedStringHelper wmap;
//         MapULongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerEnumHelper wmap;
//         MapULongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerEnumHelper wmap;
//         MapULongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasHelper wmap;
//         MapULongInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasArrayHelper wmap;
//         MapULongInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasSequenceHelper wmap;
//         MapULongInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerAliasMapHelper wmap;
//         MapULongInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerUnionHelper wmap;
//         MapULongInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerStructureHelper wmap;
//         MapULongInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongInnerBitsetHelper wmap;
//         MapULongInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /**************
//  * KEY_LONGLONG
// **************/
// #pragma region KEY_LONGLONG

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongShort wmap;
//         MapLongLongShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongUShort wmap;
//         MapLongLongUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongKeyLongValue)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test..
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongKeyLongValue wmap;
//         MapLongLongKeyLongValuePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongULong wmap;
//         MapLongLongULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongLongLong wmap;
//         MapLongLongLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongULongLong wmap;
//         MapLongLongULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongFloat wmap;
//         MapLongLongFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongKeyDoubleValue)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongKeyDoubleValue wmap;
//         MapLongLongKeyDoubleValuePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongLongDouble wmap;
//         MapLongLongLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongBoolean wmap;
//         MapLongLongBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongOctet wmap;
//         MapLongLongOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongChar wmap;
//         MapLongLongCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongWChar wmap;
//         MapLongLongWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongString wmap;
//         MapLongLongStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongWString wmap;
//         MapLongLongWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasBoundedStringHelper wmap;
//         MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasBoundedStringHelper wmap;
//         MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerEnumHelper wmap;
//         MapLongLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerEnumHelper wmap;
//         MapLongLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasHelper wmap;
//         MapLongLongInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasArrayHelper wmap;
//         MapLongLongInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasSequenceHelper wmap;
//         MapLongLongInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasMapHelper wmap;
//         MapLongLongInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerUnionHelper wmap;
//         MapLongLongInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerStructureHelper wmap;
//         MapLongLongInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapLongLongInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerBitsetHelper wmap;
//         MapLongLongInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /***************
//  * KEY_ULONGLONG
// ***************/
// #pragma region KEY_ULONGLONG

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongShort wmap;
//         MapULongLongShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongUShort wmap;
//         MapLongLongUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongValueLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapKeyULongValueLongLong wmap;
//         MapKeyULongValueLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongULong wmap;
//         MapLongLongULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongLongLong wmap;
//         MapLongLongLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongULongLong wmap;
//         MapLongLongULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongFloat wmap;
//         MapLongLongFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapKeyULongLongValueDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapKeyULongLongValueDouble wmap;
//         MapKeyULongLongValueDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongLongDouble wmap;
//         MapLongLongLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongBoolean wmap;
//         MapLongLongBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongOctet wmap;
//         MapLongLongOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongChar wmap;
//         MapLongLongCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongWChar wmap;
//         MapLongLongWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongString wmap;
//         MapLongLongStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongWString wmap;
//         MapLongLongWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasBoundedStringHelper wmap;
//         MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerAliasBoundedStringHelper wmap;
//         MapLongLongInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLongInnerEnumHelper wmap;
//         MapLongLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerEnumHelper wmap;
//         MapULongLongInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerAliasHelper wmap;
//         MapULongLongInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerAliasArrayHelper wmap;
//         MapULongLongInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerAliasSequenceHelper wmap;
//         MapULongLongInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerAliasMapHelper wmap;
//         MapULongLongInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerUnionHelper wmap;
//         MapULongLongInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerStructureHelper wmap;
//         MapULongLongInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapULongLongInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_uint64_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapULongLongInnerBitsetHelper wmap;
//         MapULongLongInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /************
//  * KEY_STRING
// ************/
// #pragma region KEY_STRING

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringShort wmap;
//         MapStringShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringUShort wmap;
//         MapStringUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLong wmap;
//         MapStringLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringULong wmap;
//         MapStringULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLongLong wmap;
//         MapStringLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringULongLong wmap;
//         MapStringULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringFloat wmap;
//         MapStringFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringDouble wmap;
//         MapStringDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLongDouble wmap;
//         MapStringLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringBoolean wmap;
//         MapStringBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringOctet wmap;
//         MapStringOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringChar wmap;
//         MapStringCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringWChar wmap;
//         MapStringWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringString wmap;
//         MapStringStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringWString wmap;
//         MapStringWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasBoundedStringHelper wmap;
//         MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasBoundedStringHelper wmap;
//         MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerEnumHelper wmap;
//         MapStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerEnumHelper wmap;
//         MapStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasHelper wmap;
//         MapStringInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasArrayHelper wmap;
//         MapStringInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasSequenceHelper wmap;
//         MapStringInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasMapHelper wmap;
//         MapStringInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerUnionHelper wmap;
//         MapStringInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerStructureHelper wmap;
//         MapStringInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapStringInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerBitsetHelper wmap;
//         MapStringInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*************
//  * KEY_WSTRING
// *************/
// #pragma region KEY_WSTRING

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringShort wmap;
//         MapWStringShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringUShort wmap;
//         MapWStringUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLong wmap;
//         MapWStringLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringULong wmap;
//         MapWStringULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLongLong wmap;
//         MapWStringLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringULongLong wmap;
//         MapWStringULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringFloat wmap;
//         MapWStringFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringDouble wmap;
//         MapWStringDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLongDouble wmap;
//         MapWStringLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringBoolean wmap;
//         MapWStringBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringOctet wmap;
//         MapWStringOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringChar wmap;
//         MapWStringCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringWChar wmap;
//         MapWStringWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringString wmap;
//         MapWStringStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringWString wmap;
//         MapWStringWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasBoundedStringHelper wmap;
//         MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasBoundedStringHelper wmap;
//         MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerEnumHelper wmap;
//         MapWStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerEnumHelper wmap;
//         MapWStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasHelper wmap;
//         MapWStringInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasArrayHelper wmap;
//         MapWStringInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasSequenceHelper wmap;
//         MapWStringInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasMapHelper wmap;
//         MapWStringInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerUnionHelper wmap;
//         MapWStringInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerStructureHelper wmap;
//         MapWStringInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapWStringInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerBitsetHelper wmap;
//         MapWStringInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*******************
//  * KEY_BOUNDEDSTRING
// *******************/
// #pragma region KEY_BOUNDEDSTRING

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringShort wmap;
//         MapStringShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringUShort wmap;
//         MapStringUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLong wmap;
//         MapStringLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringULong wmap;
//         MapStringULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLongLong wmap;
//         MapStringLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringULongLong wmap;
//         MapStringULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringFloat wmap;
//         MapStringFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringDouble wmap;
//         MapStringDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringLongDouble wmap;
//         MapStringLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringBoolean wmap;
//         MapStringBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringOctet wmap;
//         MapStringOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringChar wmap;
//         MapStringCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringWChar wmap;
//         MapStringWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringString wmap;
//         MapStringStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringWString wmap;
//         MapStringWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasBoundedStringHelper wmap;
//         MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerAliasBoundedStringHelper wmap;
//         MapStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapStringInnerEnumHelper wmap;
//         MapStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerBitMaskHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerBitMaskHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerAliasHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerAliasArrayHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerAliasSequenceHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerAliasMapHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerUnionHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerStructureHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedStringHelperInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_string_value("2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedStringHelperInnerBitsetHelper wmap;
//         MapInnerAliasBoundedStringHelperInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*******************
//  * KEY_BOUNDEDWSTRING
// *******************/
// #pragma region KEY_BOUNDEDWSTRING

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringShort wmap;
//         MapWStringShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperUShort)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint16_t test_value_1 = 123;
//         uint16_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::UShort};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringUShort wmap;
//         MapWStringUShortPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLong wmap;
//         MapWStringLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperULong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint32_t test_value_1 = 123;
//         uint32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringULong wmap;
//         MapWStringULongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int64_t test_value_1 = 123;
//         int64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLongLong wmap;
//         MapWStringLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperULongLong)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_uint64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 123;
//         uint64_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_uint64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::ULongLong};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringULongLong wmap;
//         MapWStringULongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperFloat)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         float_t test_value_1 = 123.0f;
//         float_t test_value_2 = 0.0f;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Float};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringFloat wmap;
//         MapWStringFloatPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float64_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         double test_value_1 = 123.0;
//         double test_value_2 = 0.0;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float64_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Double};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringDouble wmap;
//         MapWStringDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperLongDouble)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_float128_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         long double test_value_1 = 123.0;
//         long double test_value_2 = 0.0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_float128_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::LongDouble};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringLongDouble wmap;
//         MapWStringLongDoublePubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperBoolean)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bool_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         bool test_value_1 = true;
//         bool test_value_2 = false;

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_bool_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Boolean};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringBoolean wmap;
//         MapWStringBooleanPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperOctet)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         octet test_value_1 = 255;
//         octet test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_byte_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Octet};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringOctet wmap;
//         MapWStringOctetPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char8_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         char test_value_1 = 'a';
//         char test_value_2 = 'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char8_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Char};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringChar wmap;
//         MapWStringCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperWChar)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_char16_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         wchar_t test_value_1 = L'a';
//         wchar_t test_value_2 = L'b';
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_char16_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WChar};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringWChar wmap;
//         MapWStringWCharPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "STRING_TEST";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringString wmap;
//         MapWStringStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperWString)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"STRING_TEST";
//         std::wstring test_value_2 = L"";

//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringWString wmap;
//         MapWStringWStringPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasBoundedStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_string_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "A";
//         std::string test_value_2 = "";
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_string_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::String};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasBoundedStringHelper wmap;
//         MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasBoundedWStringHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::wstring test_value_1 = L"A";
//         std::wstring test_value_2 = L"";
                
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_wstring_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::WString};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerAliasBoundedStringHelper wmap;
//         MapWStringInnerAliasBoundedStringHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerEnumHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(10);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_enum_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add three members to the enum.
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "DEFAULT") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FIRST") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(2, "SECOND") == ReturnCode_t::RETCODE_OK);

//         // Try to add a descriptor with the same name.
//         ASSERT_FALSE(value_type_builder->add_empty_member(4, "DEFAULT") == ReturnCode_t::RETCODE_OK);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         std::string test_value_1 = "SECOND";
//         std::string test_value_2;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_enum_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Enum};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapWStringInnerEnumHelper wmap;
//         MapWStringInnerEnumHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerBitMaskHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     uint32_t limit = 5;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitmask_builder(limit);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         // Add members to the bitmask
//         ASSERT_TRUE(value_type_builder->add_empty_member(0, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(1, "FLAG1") == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_empty_member(4, "FLAG4") == ReturnCode_t::RETCODE_OK);
        
//         // Try to add a descriptor with the same name
//         ASSERT_FALSE(value_type_builder->add_empty_member(1, "FLAG0") == ReturnCode_t::RETCODE_OK);
//         // Out of bounds
//         ASSERT_FALSE(value_type_builder->add_empty_member(5, "FLAG5") == ReturnCode_t::RETCODE_OK); 

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t test_value_1 = 55;// 00110111
//         uint64_t test_value_2;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Bitmask};
//         expected_types.push_back(ExpectedType::ULongLong);
//         check_set_values(loaned_value1, expected_types, &test_value_1);
//         check_get_values(loaned_value1, expected_types, &test_value_2);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerBitMaskHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerBitMaskHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         std::string name = "InnerAliasHelper";
//         DynamicTypeBuilder_ptr alias_builder = DynamicTypeBuilderFactory::get_instance()->create_alias_builder(value_type_builder.get(), name);
//         ASSERT_TRUE(alias_builder != nullptr);
//         DynamicType_ptr created_type = DynamicTypeBuilderFactory::get_instance()->create_type(alias_builder.get());
//         ASSERT_TRUE(created_type != nullptr);
//         ASSERT_TRUE(created_type->get_name() == "InnerAliasHelper");

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), alias_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);
//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerAliasHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerAliasHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     std::vector<uint32_t> array_length = { 10 };
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_array_builder(base_type_builder.get(), array_length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Get an index in the array.
//         std::vector<uint32_t> vPosition = { 1 };
//         MemberId testPos(0);
//         testPos = loaned_value1->get_array_index(vPosition);
//         ASSERT_TRUE(testPos != MEMBER_ID_INVALID);

//         // Invalid input vectors.
//         std::vector<uint32_t> vPosition2 = { 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition2) != MEMBER_ID_INVALID);
//         std::vector<uint32_t> vPosition3 = { 1, 1, 1, 1 };
//         ASSERT_FALSE(loaned_value1->get_array_index(vPosition3) != MEMBER_ID_INVALID);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, testPos);
//         check_get_values(loaned_value1, expected_types, &test_value_2, testPos);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count before and after remove an element.
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_value(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_array_data(testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Check the clear values method
//         ASSERT_TRUE(loaned_value1->set_int16_value(test_value_1, testPos) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == value_type->get_total_bounds());

//         // Try to set a value out of the array.
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 100) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerAliasArrayHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerAliasArrayHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_sequence_builder(base_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int16_value(test_value_1, 1) == ReturnCode_t::RETCODE_OK);

//         MemberId newId;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         MemberId newId2;
//         ASSERT_TRUE(loaned_value1->insert_sequence_data(newId2) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, newId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, newId);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Remove the elements.
//         ASSERT_TRUE(loaned_value1->remove_sequence_data(newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // New Insert Methods
//         ASSERT_TRUE(loaned_value1->insert_int16_value(test_value_1, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_int16_value(test_value_2, newId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(test_value_1 == test_value_2);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);

//         // Check that the sequence is empty.
//         ASSERT_FALSE(loaned_value1->get_int16_value(test_value_2, 0) == ReturnCode_t::RETCODE_OK);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerAliasSequenceHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerAliasMapHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_key_type = inner_key_type_builder->build();
//         ASSERT_TRUE(inner_key_type_builder != nullptr);
//         ASSERT_TRUE(inner_key_type != nullptr);

//         DynamicTypeBuilder_ptr inner_value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr inner_value_type = inner_value_type_builder->build();
//         ASSERT_TRUE(inner_value_type_builder != nullptr);
//         ASSERT_TRUE(inner_value_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(inner_key_type_builder.get(), inner_value_type_builder.get(), length);
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Try to write on an empty position
//         ASSERT_FALSE(loaned_value1->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId;
//         MemberId inner_valueId;
//         DynamicData* inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(loaned_value1->insert_map_data(inner_key_data, inner_keyId, inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId inner_keyId2;
//         MemberId inner_valueId2;
//         inner_key_data = DynamicDataFactory::get_instance()->create_data(inner_key_type);
//         inner_key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_TRUE(loaned_value1->insert_map_data(inner_key_data, inner_keyId2, inner_valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(inner_key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, inner_valueId);
//         check_get_values(loaned_value1, expected_types, &test_value_2, inner_valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_FALSE(loaned_value1->remove_map_data(inner_valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 2);
//         ASSERT_TRUE(loaned_value1->remove_map_data(inner_keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 1);
//         ASSERT_TRUE(loaned_value1->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(loaned_value1->get_item_count() == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerAliasMapHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerAliasMapHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerUnionHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder1 = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type1 = base_type_builder1->build();
//         ASSERT_TRUE(base_type_builder1!= nullptr);
//         ASSERT_TRUE(base_type1 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder3 = DynamicTypeBuilderFactory::get_instance()->create_int16_builder();
//         DynamicType_ptr base_type3 = base_type_builder3->build();
//         ASSERT_TRUE(base_type_builder3 != nullptr);
//         ASSERT_TRUE(base_type3 != nullptr);

//         DynamicTypeBuilder_ptr discriminator_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr discriminator_type = discriminator_type_builder->build();
//         ASSERT_TRUE(discriminator_type_builder != nullptr);
//         ASSERT_TRUE(discriminator_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_union_builder(discriminator_type_builder.get());
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the union.
//         ASSERT_TRUE(value_type_builder->add_member(0, "default", base_type3, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "first", base_type1, "", { 1}, false) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(0, "second", base_type2, "", { 2 }, false) == ReturnCode_t::RETCODE_OK);

//         // Try to add a second "DEFAULT" value to the union
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 0 }, true) == ReturnCode_t::RETCODE_OK);
//         // Try to add a second value to the same case label
//         ASSERT_FALSE(value_type_builder->add_member(0, "third", base_type1, "", { 1 }, false) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         uint64_t label;
//         int16_t test_value_1 = 123;
//         int16_t test_value_2 = 0;
        
//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Short};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);

//         ASSERT_TRUE(loaned_value1->get_union_label(label) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(label == 0);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerUnionHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerUnionHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerStructureHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_float32_builder();
//         DynamicType_ptr base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_struct_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "field1", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "field2", base_type2) == ReturnCode_t::RETCODE_OK);

//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(loaned_value1, expected_types, &test_value_1, 0);
//         check_get_values(loaned_value1, expected_types, &test_value_2, 0);
//         ASSERT_TRUE(test_value_1 == test_value_2);
        
//         float test_value_3 = 123.0f;
//         float test_value_4 = 0.0f;
//         std::vector<ExpectedType> expected_types2 = {ExpectedType::Float};
//         check_set_values(loaned_value1, expected_types2, &test_value_3, 1);
//         check_get_values(loaned_value1, expected_types2, &test_value_4, 1);
//         ASSERT_TRUE(test_value_3 == test_value_4);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerStructureHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerStructureHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_MapInnerAliasBoundedWStringHelperInnerBitsetHelper)
// {
//     uint32_t length = eprosima::fastrtps::types::BOUND_UNLIMITED;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_wstring_builder(1);
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder = DynamicTypeBuilderFactory::get_instance()->create_byte_builder();
//         DynamicType_ptr base_type = base_type_builder->build();
//         ASSERT_TRUE(base_type_builder != nullptr);
//         ASSERT_TRUE(base_type != nullptr);

//         DynamicTypeBuilder_ptr base_type_builder2 = DynamicTypeBuilderFactory::get_instance()->create_uint32_builder();
//         auto base_type2 = base_type_builder2->build();
//         ASSERT_TRUE(base_type_builder2 != nullptr);
//         ASSERT_TRUE(base_type2 != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_bitset_builder();
//         ASSERT_TRUE(value_type_builder != nullptr);

//         // Add members to the struct.
//         ASSERT_TRUE(value_type_builder->add_member(0, "a", base_type) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(value_type_builder->add_member(1, "b", base_type2) == ReturnCode_t::RETCODE_OK);
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_BIT_BOUND_ID, "value", "2");
//         value_type_builder->apply_annotation_to_member(0, ANNOTATION_POSITION_ID, "value", "0");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_BIT_BOUND_ID, "value", "20");
//         value_type_builder->apply_annotation_to_member(1, ANNOTATION_POSITION_ID, "value", "10"); 

//         DynamicType_ptr bitset_type = value_type_builder->build();
//         ASSERT_TRUE(bitset_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_wstring_value(L"2", MEMBER_ID_INVALID);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Loan Complex values.
//         DynamicData* loaned_value1 = data->loan_value(valueId);
//         ASSERT_TRUE(loaned_value1 != nullptr);
//         DynamicData* loaned_value2 = data->loan_value(valueId);
//         ASSERT_FALSE(loaned_value2 != nullptr);

//         // Set and get the child values.
//         octet test1(234);
//         ASSERT_TRUE(loaned_value1->set_byte_value(test1, 0) == ReturnCode_t::RETCODE_OK);
//         octet test2(0);
//         ASSERT_TRUE(loaned_value1->get_byte_value(test2, 0) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test1 == test2);
//         // 11101010
//         // 00000010 (two bits)
//         ASSERT_TRUE(test2 == 2);
//         uint32_t test3(289582314);
//         ASSERT_TRUE(loaned_value1->set_uint32_value(test3, 1) == ReturnCode_t::RETCODE_OK);
//         uint32_t test4(0);
//         ASSERT_TRUE(loaned_value1->get_uint32_value(test4, 1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(test3 == test4);
//         // 00000001010000101010110011101010
//         // 00000000000000101010110011101010 (20 bits)
//         ASSERT_TRUE(test4 == 175338);

//         // Return the pointer 
//         ASSERT_TRUE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value1) == ReturnCode_t::RETCODE_OK);
//         ASSERT_FALSE(data->return_loaned_value(loaned_value2) == ReturnCode_t::RETCODE_OK);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 2);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapInnerAliasBoundedWStringHelperInnerBitsetHelper wmap;
//         MapInnerAliasBoundedWStringHelperInnerBitsetHelperPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// /*******************
//  * BOUNDED_MAPS
// *******************/
// #pragma region BOUNDED_MAPS

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedSmallMap)
// {
//     uint32_t length = 1;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId2;
//         MemberId valueId2;
//         key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         key_data->set_int32_value(2, MEMBER_ID_INVALID);
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 1);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLong wmap;
//         MapLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// TEST_F(DynamicTypesDDSTypesTest, DDSTypesTest_BoundedLargeMap)
// {
//     uint32_t length = 41925; //TO LONG FOR TIMEOUT?
//     length = 10;
//     {
//         DynamicTypeBuilder_ptr key_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr key_type = key_type_builder->build();
//         ASSERT_TRUE(key_type_builder != nullptr);
//         ASSERT_TRUE(key_type != nullptr);

//         DynamicTypeBuilder_ptr value_type_builder = DynamicTypeBuilderFactory::get_instance()->create_int32_builder();
//         DynamicType_ptr value_type = value_type_builder->build();
//         ASSERT_TRUE(value_type_builder != nullptr);
//         ASSERT_TRUE(value_type != nullptr);

//         DynamicTypeBuilder_ptr map_type_builder = DynamicTypeBuilderFactory::get_instance()->create_map_builder(key_type_builder.get(), value_type_builder.get(), length);
//         DynamicType_ptr map_type = map_type_builder->build();
//         ASSERT_TRUE(map_type_builder != nullptr);
//         ASSERT_TRUE(map_type != nullptr);

//         DynamicData* data = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(data != nullptr);

//         // Set and get a value.
//         int32_t test_value_1 = 123;
//         int32_t test_value_2 = 0;
        
//         // Try to write on an empty position
//         ASSERT_FALSE(data->set_int32_value(test_value_1, 0) == ReturnCode_t::RETCODE_OK);

//         MemberId keyId;
//         MemberId valueId;
//         DynamicData* key_data = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_TRUE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);

//         // Try to Add the same key twice.
//         ASSERT_FALSE(data->insert_map_data(key_data, keyId, valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data) == ReturnCode_t::RETCODE_OK);

//         // Try to Add one more than the limit
//         for(uint32_t i = 1; i < length; i++)
//         {
//             ASSERT_TRUE(data->get_item_count() == i);
//             MemberId keyId2;
//             MemberId valueId2;
//             DynamicData* key_data2 = DynamicDataFactory::get_instance()->create_data(key_type);
//             key_data2->set_int32_value(i, MEMBER_ID_INVALID);
//             ASSERT_TRUE(data->insert_map_data(key_data2, keyId2, valueId2) == ReturnCode_t::RETCODE_OK);
//             ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data2) == ReturnCode_t::RETCODE_OK);

//             ASSERT_TRUE(data->get_item_count() == i+1);
//         }
//         MemberId keyId3;
//         MemberId valueId3;
//         DynamicData* key_data3 = DynamicDataFactory::get_instance()->create_data(key_type);
//         ASSERT_FALSE(data->insert_map_data(key_data3, keyId3, valueId3) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(key_data3) == ReturnCode_t::RETCODE_OK);

//         std::vector<ExpectedType> expected_types = {ExpectedType::Long};
//         check_set_values(data, expected_types, &test_value_1, valueId);
//         check_get_values(data, expected_types, &test_value_2, valueId);

//         ASSERT_TRUE(test_value_1 == test_value_2);

//         // Check items count with removes
//         ASSERT_TRUE(data->get_item_count() == length);
//         ASSERT_FALSE(data->remove_map_data(valueId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == length);
//         ASSERT_TRUE(data->remove_map_data(keyId) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == length -1);
//         ASSERT_TRUE(data->clear_all_values() == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(data->get_item_count() == 0);

//         // Serialize <-> Deserialize Test
//         DynamicPubSubType pubsubType(map_type);
//         uint32_t payloadSize = static_cast<uint32_t>(pubsubType.getSerializedSizeProvider(data)());
//         SerializedPayload_t payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &payload));
//         ASSERT_TRUE(payload.length == payloadSize);

//         DynamicData* data2 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&payload, data2));
//         ASSERT_TRUE(data2->equals(data));

//         // SERIALIZATION TEST
//         MapLongLong wmap;
//         MapLongLongPubSubType wmappb;

//         SerializedPayload_t dynamic_payload(payloadSize);
//         ASSERT_TRUE(pubsubType.serialize(data, &dynamic_payload));
//         ASSERT_TRUE(wmappb.deserialize(&dynamic_payload, &wmap));

//         uint32_t static_payloadSize = static_cast<uint32_t>(wmappb.getSerializedSizeProvider(&wmap)());
//         SerializedPayload_t static_payload(static_payloadSize);
//         ASSERT_TRUE(wmappb.serialize(&wmap, &static_payload));
//         ASSERT_TRUE(static_payload.length == static_payloadSize);
//         DynamicData* data3 = DynamicDataFactory::get_instance()->create_data(map_type);
//         ASSERT_TRUE(pubsubType.deserialize(&static_payload, data3));
//         ASSERT_TRUE(data3->equals(data));

//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data2) == ReturnCode_t::RETCODE_OK);
//         ASSERT_TRUE(DynamicDataFactory::get_instance()->delete_data(data3) == ReturnCode_t::RETCODE_OK);
//     }
//     ASSERT_TRUE(DynamicTypeBuilderFactory::get_instance()->is_empty());
//     ASSERT_TRUE(DynamicDataFactory::get_instance()->is_empty());
// }

// #pragma endregion

// #pragma endregion

} // dds
} // fastdds
} // eprosima

int main(
        int argc,
        char** argv)
{
    eprosima::fastdds::dds::Log::SetVerbosity(eprosima::fastdds::dds::Log::Info);

    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
