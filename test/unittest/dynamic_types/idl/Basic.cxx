// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file Basic.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "Basic.h"

#if FASTCDR_VERSION_MAJOR > 1

#include "BasicTypeObject.h"

#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>




EnumStruct::EnumStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

EnumStruct::~EnumStruct()
{
}

EnumStruct::EnumStruct(
        const EnumStruct& x)
{
    m_my_enum = x.m_my_enum;
}

EnumStruct::EnumStruct(
        EnumStruct&& x) noexcept
{
    m_my_enum = x.m_my_enum;
}

EnumStruct& EnumStruct::operator =(
        const EnumStruct& x)
{

    m_my_enum = x.m_my_enum;
    return *this;
}

EnumStruct& EnumStruct::operator =(
        EnumStruct&& x) noexcept
{

    m_my_enum = x.m_my_enum;
    return *this;
}

bool EnumStruct::operator ==(
        const EnumStruct& x) const
{
    return (m_my_enum == x.m_my_enum);
}

bool EnumStruct::operator !=(
        const EnumStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_enum
 * @param _my_enum New value for member my_enum
 */
void EnumStruct::my_enum(
        MyEnum _my_enum)
{
    m_my_enum = _my_enum;
}

/*!
 * @brief This function returns the value of member my_enum
 * @return Value of member my_enum
 */
MyEnum EnumStruct::my_enum() const
{
    return m_my_enum;
}

/*!
 * @brief This function returns a reference to member my_enum
 * @return Reference to member my_enum
 */
MyEnum& EnumStruct::my_enum()
{
    return m_my_enum;
}




AliasStruct::AliasStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

AliasStruct::~AliasStruct()
{
}

AliasStruct::AliasStruct(
        const AliasStruct& x)
{
    m_my_alias = x.m_my_alias;
}

AliasStruct::AliasStruct(
        AliasStruct&& x) noexcept
{
    m_my_alias = x.m_my_alias;
}

AliasStruct& AliasStruct::operator =(
        const AliasStruct& x)
{

    m_my_alias = x.m_my_alias;
    return *this;
}

AliasStruct& AliasStruct::operator =(
        AliasStruct&& x) noexcept
{

    m_my_alias = x.m_my_alias;
    return *this;
}

bool AliasStruct::operator ==(
        const AliasStruct& x) const
{
    return (m_my_alias == x.m_my_alias);
}

bool AliasStruct::operator !=(
        const AliasStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_alias
 * @param _my_alias New value for member my_alias
 */
void AliasStruct::my_alias(
        MyAliasEnum _my_alias)
{
    m_my_alias = _my_alias;
}

/*!
 * @brief This function returns the value of member my_alias
 * @return Value of member my_alias
 */
MyAliasEnum AliasStruct::my_alias() const
{
    return m_my_alias;
}

/*!
 * @brief This function returns a reference to member my_alias
 * @return Reference to member my_alias
 */
MyAliasEnum& AliasStruct::my_alias()
{
    return m_my_alias;
}




AliasAliasStruct::AliasAliasStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

AliasAliasStruct::~AliasAliasStruct()
{
}

AliasAliasStruct::AliasAliasStruct(
        const AliasAliasStruct& x)
{
    m_my_alias_alias = x.m_my_alias_alias;
}

AliasAliasStruct::AliasAliasStruct(
        AliasAliasStruct&& x) noexcept
{
    m_my_alias_alias = x.m_my_alias_alias;
}

AliasAliasStruct& AliasAliasStruct::operator =(
        const AliasAliasStruct& x)
{

    m_my_alias_alias = x.m_my_alias_alias;
    return *this;
}

AliasAliasStruct& AliasAliasStruct::operator =(
        AliasAliasStruct&& x) noexcept
{

    m_my_alias_alias = x.m_my_alias_alias;
    return *this;
}

bool AliasAliasStruct::operator ==(
        const AliasAliasStruct& x) const
{
    return (m_my_alias_alias == x.m_my_alias_alias);
}

bool AliasAliasStruct::operator !=(
        const AliasAliasStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_alias_alias
 * @param _my_alias_alias New value for member my_alias_alias
 */
void AliasAliasStruct::my_alias_alias(
        MyAliasAliasEnum _my_alias_alias)
{
    m_my_alias_alias = _my_alias_alias;
}

/*!
 * @brief This function returns the value of member my_alias_alias
 * @return Value of member my_alias_alias
 */
MyAliasAliasEnum AliasAliasStruct::my_alias_alias() const
{
    return m_my_alias_alias;
}

/*!
 * @brief This function returns a reference to member my_alias_alias
 * @return Reference to member my_alias_alias
 */
MyAliasAliasEnum& AliasAliasStruct::my_alias_alias()
{
    return m_my_alias_alias;
}




BoolStruct::BoolStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

BoolStruct::~BoolStruct()
{
}

BoolStruct::BoolStruct(
        const BoolStruct& x)
{
    m_my_bool = x.m_my_bool;
}

BoolStruct::BoolStruct(
        BoolStruct&& x) noexcept
{
    m_my_bool = x.m_my_bool;
}

BoolStruct& BoolStruct::operator =(
        const BoolStruct& x)
{

    m_my_bool = x.m_my_bool;
    return *this;
}

BoolStruct& BoolStruct::operator =(
        BoolStruct&& x) noexcept
{

    m_my_bool = x.m_my_bool;
    return *this;
}

bool BoolStruct::operator ==(
        const BoolStruct& x) const
{
    return (m_my_bool == x.m_my_bool);
}

bool BoolStruct::operator !=(
        const BoolStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_bool
 * @param _my_bool New value for member my_bool
 */
void BoolStruct::my_bool(
        bool _my_bool)
{
    m_my_bool = _my_bool;
}

/*!
 * @brief This function returns the value of member my_bool
 * @return Value of member my_bool
 */
bool BoolStruct::my_bool() const
{
    return m_my_bool;
}

/*!
 * @brief This function returns a reference to member my_bool
 * @return Reference to member my_bool
 */
bool& BoolStruct::my_bool()
{
    return m_my_bool;
}




OctetStruct::OctetStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

OctetStruct::~OctetStruct()
{
}

OctetStruct::OctetStruct(
        const OctetStruct& x)
{
    m_my_octet = x.m_my_octet;
}

OctetStruct::OctetStruct(
        OctetStruct&& x) noexcept
{
    m_my_octet = x.m_my_octet;
}

OctetStruct& OctetStruct::operator =(
        const OctetStruct& x)
{

    m_my_octet = x.m_my_octet;
    return *this;
}

OctetStruct& OctetStruct::operator =(
        OctetStruct&& x) noexcept
{

    m_my_octet = x.m_my_octet;
    return *this;
}

bool OctetStruct::operator ==(
        const OctetStruct& x) const
{
    return (m_my_octet == x.m_my_octet);
}

bool OctetStruct::operator !=(
        const OctetStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_octet
 * @param _my_octet New value for member my_octet
 */
void OctetStruct::my_octet(
        uint8_t _my_octet)
{
    m_my_octet = _my_octet;
}

/*!
 * @brief This function returns the value of member my_octet
 * @return Value of member my_octet
 */
uint8_t OctetStruct::my_octet() const
{
    return m_my_octet;
}

/*!
 * @brief This function returns a reference to member my_octet
 * @return Reference to member my_octet
 */
uint8_t& OctetStruct::my_octet()
{
    return m_my_octet;
}




ShortStruct::ShortStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

ShortStruct::~ShortStruct()
{
}

ShortStruct::ShortStruct(
        const ShortStruct& x)
{
    m_my_int16 = x.m_my_int16;
}

ShortStruct::ShortStruct(
        ShortStruct&& x) noexcept
{
    m_my_int16 = x.m_my_int16;
}

ShortStruct& ShortStruct::operator =(
        const ShortStruct& x)
{

    m_my_int16 = x.m_my_int16;
    return *this;
}

ShortStruct& ShortStruct::operator =(
        ShortStruct&& x) noexcept
{

    m_my_int16 = x.m_my_int16;
    return *this;
}

bool ShortStruct::operator ==(
        const ShortStruct& x) const
{
    return (m_my_int16 == x.m_my_int16);
}

bool ShortStruct::operator !=(
        const ShortStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_int16
 * @param _my_int16 New value for member my_int16
 */
void ShortStruct::my_int16(
        int16_t _my_int16)
{
    m_my_int16 = _my_int16;
}

/*!
 * @brief This function returns the value of member my_int16
 * @return Value of member my_int16
 */
int16_t ShortStruct::my_int16() const
{
    return m_my_int16;
}

/*!
 * @brief This function returns a reference to member my_int16
 * @return Reference to member my_int16
 */
int16_t& ShortStruct::my_int16()
{
    return m_my_int16;
}




LongStruct::LongStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

LongStruct::~LongStruct()
{
}

LongStruct::LongStruct(
        const LongStruct& x)
{
    m_my_int32 = x.m_my_int32;
}

LongStruct::LongStruct(
        LongStruct&& x) noexcept
{
    m_my_int32 = x.m_my_int32;
}

LongStruct& LongStruct::operator =(
        const LongStruct& x)
{

    m_my_int32 = x.m_my_int32;
    return *this;
}

LongStruct& LongStruct::operator =(
        LongStruct&& x) noexcept
{

    m_my_int32 = x.m_my_int32;
    return *this;
}

bool LongStruct::operator ==(
        const LongStruct& x) const
{
    return (m_my_int32 == x.m_my_int32);
}

bool LongStruct::operator !=(
        const LongStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_int32
 * @param _my_int32 New value for member my_int32
 */
void LongStruct::my_int32(
        int32_t _my_int32)
{
    m_my_int32 = _my_int32;
}

/*!
 * @brief This function returns the value of member my_int32
 * @return Value of member my_int32
 */
int32_t LongStruct::my_int32() const
{
    return m_my_int32;
}

/*!
 * @brief This function returns a reference to member my_int32
 * @return Reference to member my_int32
 */
int32_t& LongStruct::my_int32()
{
    return m_my_int32;
}




LongLongStruct::LongLongStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

LongLongStruct::~LongLongStruct()
{
}

LongLongStruct::LongLongStruct(
        const LongLongStruct& x)
{
    m_my_int64 = x.m_my_int64;
}

LongLongStruct::LongLongStruct(
        LongLongStruct&& x) noexcept
{
    m_my_int64 = x.m_my_int64;
}

LongLongStruct& LongLongStruct::operator =(
        const LongLongStruct& x)
{

    m_my_int64 = x.m_my_int64;
    return *this;
}

LongLongStruct& LongLongStruct::operator =(
        LongLongStruct&& x) noexcept
{

    m_my_int64 = x.m_my_int64;
    return *this;
}

bool LongLongStruct::operator ==(
        const LongLongStruct& x) const
{
    return (m_my_int64 == x.m_my_int64);
}

bool LongLongStruct::operator !=(
        const LongLongStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_int64
 * @param _my_int64 New value for member my_int64
 */
void LongLongStruct::my_int64(
        int64_t _my_int64)
{
    m_my_int64 = _my_int64;
}

/*!
 * @brief This function returns the value of member my_int64
 * @return Value of member my_int64
 */
int64_t LongLongStruct::my_int64() const
{
    return m_my_int64;
}

/*!
 * @brief This function returns a reference to member my_int64
 * @return Reference to member my_int64
 */
int64_t& LongLongStruct::my_int64()
{
    return m_my_int64;
}




UShortStruct::UShortStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

UShortStruct::~UShortStruct()
{
}

UShortStruct::UShortStruct(
        const UShortStruct& x)
{
    m_my_uint16 = x.m_my_uint16;
}

UShortStruct::UShortStruct(
        UShortStruct&& x) noexcept
{
    m_my_uint16 = x.m_my_uint16;
}

UShortStruct& UShortStruct::operator =(
        const UShortStruct& x)
{

    m_my_uint16 = x.m_my_uint16;
    return *this;
}

UShortStruct& UShortStruct::operator =(
        UShortStruct&& x) noexcept
{

    m_my_uint16 = x.m_my_uint16;
    return *this;
}

bool UShortStruct::operator ==(
        const UShortStruct& x) const
{
    return (m_my_uint16 == x.m_my_uint16);
}

bool UShortStruct::operator !=(
        const UShortStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_uint16
 * @param _my_uint16 New value for member my_uint16
 */
void UShortStruct::my_uint16(
        uint16_t _my_uint16)
{
    m_my_uint16 = _my_uint16;
}

/*!
 * @brief This function returns the value of member my_uint16
 * @return Value of member my_uint16
 */
uint16_t UShortStruct::my_uint16() const
{
    return m_my_uint16;
}

/*!
 * @brief This function returns a reference to member my_uint16
 * @return Reference to member my_uint16
 */
uint16_t& UShortStruct::my_uint16()
{
    return m_my_uint16;
}




ULongStruct::ULongStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

ULongStruct::~ULongStruct()
{
}

ULongStruct::ULongStruct(
        const ULongStruct& x)
{
    m_my_uint32 = x.m_my_uint32;
}

ULongStruct::ULongStruct(
        ULongStruct&& x) noexcept
{
    m_my_uint32 = x.m_my_uint32;
}

ULongStruct& ULongStruct::operator =(
        const ULongStruct& x)
{

    m_my_uint32 = x.m_my_uint32;
    return *this;
}

ULongStruct& ULongStruct::operator =(
        ULongStruct&& x) noexcept
{

    m_my_uint32 = x.m_my_uint32;
    return *this;
}

bool ULongStruct::operator ==(
        const ULongStruct& x) const
{
    return (m_my_uint32 == x.m_my_uint32);
}

bool ULongStruct::operator !=(
        const ULongStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_uint32
 * @param _my_uint32 New value for member my_uint32
 */
void ULongStruct::my_uint32(
        uint32_t _my_uint32)
{
    m_my_uint32 = _my_uint32;
}

/*!
 * @brief This function returns the value of member my_uint32
 * @return Value of member my_uint32
 */
uint32_t ULongStruct::my_uint32() const
{
    return m_my_uint32;
}

/*!
 * @brief This function returns a reference to member my_uint32
 * @return Reference to member my_uint32
 */
uint32_t& ULongStruct::my_uint32()
{
    return m_my_uint32;
}




ULongLongStruct::ULongLongStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

ULongLongStruct::~ULongLongStruct()
{
}

ULongLongStruct::ULongLongStruct(
        const ULongLongStruct& x)
{
    m_my_uint64 = x.m_my_uint64;
}

ULongLongStruct::ULongLongStruct(
        ULongLongStruct&& x) noexcept
{
    m_my_uint64 = x.m_my_uint64;
}

ULongLongStruct& ULongLongStruct::operator =(
        const ULongLongStruct& x)
{

    m_my_uint64 = x.m_my_uint64;
    return *this;
}

ULongLongStruct& ULongLongStruct::operator =(
        ULongLongStruct&& x) noexcept
{

    m_my_uint64 = x.m_my_uint64;
    return *this;
}

bool ULongLongStruct::operator ==(
        const ULongLongStruct& x) const
{
    return (m_my_uint64 == x.m_my_uint64);
}

bool ULongLongStruct::operator !=(
        const ULongLongStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_uint64
 * @param _my_uint64 New value for member my_uint64
 */
void ULongLongStruct::my_uint64(
        uint64_t _my_uint64)
{
    m_my_uint64 = _my_uint64;
}

/*!
 * @brief This function returns the value of member my_uint64
 * @return Value of member my_uint64
 */
uint64_t ULongLongStruct::my_uint64() const
{
    return m_my_uint64;
}

/*!
 * @brief This function returns a reference to member my_uint64
 * @return Reference to member my_uint64
 */
uint64_t& ULongLongStruct::my_uint64()
{
    return m_my_uint64;
}




FloatStruct::FloatStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

FloatStruct::~FloatStruct()
{
}

FloatStruct::FloatStruct(
        const FloatStruct& x)
{
    m_my_float32 = x.m_my_float32;
}

FloatStruct::FloatStruct(
        FloatStruct&& x) noexcept
{
    m_my_float32 = x.m_my_float32;
}

FloatStruct& FloatStruct::operator =(
        const FloatStruct& x)
{

    m_my_float32 = x.m_my_float32;
    return *this;
}

FloatStruct& FloatStruct::operator =(
        FloatStruct&& x) noexcept
{

    m_my_float32 = x.m_my_float32;
    return *this;
}

bool FloatStruct::operator ==(
        const FloatStruct& x) const
{
    return (m_my_float32 == x.m_my_float32);
}

bool FloatStruct::operator !=(
        const FloatStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_float32
 * @param _my_float32 New value for member my_float32
 */
void FloatStruct::my_float32(
        float _my_float32)
{
    m_my_float32 = _my_float32;
}

/*!
 * @brief This function returns the value of member my_float32
 * @return Value of member my_float32
 */
float FloatStruct::my_float32() const
{
    return m_my_float32;
}

/*!
 * @brief This function returns a reference to member my_float32
 * @return Reference to member my_float32
 */
float& FloatStruct::my_float32()
{
    return m_my_float32;
}




DoubleStruct::DoubleStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

DoubleStruct::~DoubleStruct()
{
}

DoubleStruct::DoubleStruct(
        const DoubleStruct& x)
{
    m_my_float64 = x.m_my_float64;
}

DoubleStruct::DoubleStruct(
        DoubleStruct&& x) noexcept
{
    m_my_float64 = x.m_my_float64;
}

DoubleStruct& DoubleStruct::operator =(
        const DoubleStruct& x)
{

    m_my_float64 = x.m_my_float64;
    return *this;
}

DoubleStruct& DoubleStruct::operator =(
        DoubleStruct&& x) noexcept
{

    m_my_float64 = x.m_my_float64;
    return *this;
}

bool DoubleStruct::operator ==(
        const DoubleStruct& x) const
{
    return (m_my_float64 == x.m_my_float64);
}

bool DoubleStruct::operator !=(
        const DoubleStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_float64
 * @param _my_float64 New value for member my_float64
 */
void DoubleStruct::my_float64(
        double _my_float64)
{
    m_my_float64 = _my_float64;
}

/*!
 * @brief This function returns the value of member my_float64
 * @return Value of member my_float64
 */
double DoubleStruct::my_float64() const
{
    return m_my_float64;
}

/*!
 * @brief This function returns a reference to member my_float64
 * @return Reference to member my_float64
 */
double& DoubleStruct::my_float64()
{
    return m_my_float64;
}




LongDoubleStruct::LongDoubleStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

LongDoubleStruct::~LongDoubleStruct()
{
}

LongDoubleStruct::LongDoubleStruct(
        const LongDoubleStruct& x)
{
    m_my_float128 = x.m_my_float128;
}

LongDoubleStruct::LongDoubleStruct(
        LongDoubleStruct&& x) noexcept
{
    m_my_float128 = x.m_my_float128;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        const LongDoubleStruct& x)
{

    m_my_float128 = x.m_my_float128;
    return *this;
}

LongDoubleStruct& LongDoubleStruct::operator =(
        LongDoubleStruct&& x) noexcept
{

    m_my_float128 = x.m_my_float128;
    return *this;
}

bool LongDoubleStruct::operator ==(
        const LongDoubleStruct& x) const
{
    return (m_my_float128 == x.m_my_float128);
}

bool LongDoubleStruct::operator !=(
        const LongDoubleStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_float128
 * @param _my_float128 New value for member my_float128
 */
void LongDoubleStruct::my_float128(
        long double _my_float128)
{
    m_my_float128 = _my_float128;
}

/*!
 * @brief This function returns the value of member my_float128
 * @return Value of member my_float128
 */
long double LongDoubleStruct::my_float128() const
{
    return m_my_float128;
}

/*!
 * @brief This function returns a reference to member my_float128
 * @return Reference to member my_float128
 */
long double& LongDoubleStruct::my_float128()
{
    return m_my_float128;
}




CharStruct::CharStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

CharStruct::~CharStruct()
{
}

CharStruct::CharStruct(
        const CharStruct& x)
{
    m_my_char = x.m_my_char;
}

CharStruct::CharStruct(
        CharStruct&& x) noexcept
{
    m_my_char = x.m_my_char;
}

CharStruct& CharStruct::operator =(
        const CharStruct& x)
{

    m_my_char = x.m_my_char;
    return *this;
}

CharStruct& CharStruct::operator =(
        CharStruct&& x) noexcept
{

    m_my_char = x.m_my_char;
    return *this;
}

bool CharStruct::operator ==(
        const CharStruct& x) const
{
    return (m_my_char == x.m_my_char);
}

bool CharStruct::operator !=(
        const CharStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_char
 * @param _my_char New value for member my_char
 */
void CharStruct::my_char(
        char _my_char)
{
    m_my_char = _my_char;
}

/*!
 * @brief This function returns the value of member my_char
 * @return Value of member my_char
 */
char CharStruct::my_char() const
{
    return m_my_char;
}

/*!
 * @brief This function returns a reference to member my_char
 * @return Reference to member my_char
 */
char& CharStruct::my_char()
{
    return m_my_char;
}




WCharStruct::WCharStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

WCharStruct::~WCharStruct()
{
}

WCharStruct::WCharStruct(
        const WCharStruct& x)
{
    m_my_wchar = x.m_my_wchar;
}

WCharStruct::WCharStruct(
        WCharStruct&& x) noexcept
{
    m_my_wchar = x.m_my_wchar;
}

WCharStruct& WCharStruct::operator =(
        const WCharStruct& x)
{

    m_my_wchar = x.m_my_wchar;
    return *this;
}

WCharStruct& WCharStruct::operator =(
        WCharStruct&& x) noexcept
{

    m_my_wchar = x.m_my_wchar;
    return *this;
}

bool WCharStruct::operator ==(
        const WCharStruct& x) const
{
    return (m_my_wchar == x.m_my_wchar);
}

bool WCharStruct::operator !=(
        const WCharStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member my_wchar
 * @param _my_wchar New value for member my_wchar
 */
void WCharStruct::my_wchar(
        wchar_t _my_wchar)
{
    m_my_wchar = _my_wchar;
}

/*!
 * @brief This function returns the value of member my_wchar
 * @return Value of member my_wchar
 */
wchar_t WCharStruct::my_wchar() const
{
    return m_my_wchar;
}

/*!
 * @brief This function returns a reference to member my_wchar
 * @return Reference to member my_wchar
 */
wchar_t& WCharStruct::my_wchar()
{
    return m_my_wchar;
}




StringStruct::StringStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

StringStruct::~StringStruct()
{
}

StringStruct::StringStruct(
        const StringStruct& x)
{
    m_my_string = x.m_my_string;
}

StringStruct::StringStruct(
        StringStruct&& x) noexcept
{
    m_my_string = std::move(x.m_my_string);
}

StringStruct& StringStruct::operator =(
        const StringStruct& x)
{

    m_my_string = x.m_my_string;
    return *this;
}

StringStruct& StringStruct::operator =(
        StringStruct&& x) noexcept
{

    m_my_string = std::move(x.m_my_string);
    return *this;
}

bool StringStruct::operator ==(
        const StringStruct& x) const
{
    return (m_my_string == x.m_my_string);
}

bool StringStruct::operator !=(
        const StringStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void StringStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void StringStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& StringStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& StringStruct::my_string()
{
    return m_my_string;
}




WStringStruct::WStringStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

WStringStruct::~WStringStruct()
{
}

WStringStruct::WStringStruct(
        const WStringStruct& x)
{
    m_my_wstring = x.m_my_wstring;
}

WStringStruct::WStringStruct(
        WStringStruct&& x) noexcept
{
    m_my_wstring = std::move(x.m_my_wstring);
}

WStringStruct& WStringStruct::operator =(
        const WStringStruct& x)
{

    m_my_wstring = x.m_my_wstring;
    return *this;
}

WStringStruct& WStringStruct::operator =(
        WStringStruct&& x) noexcept
{

    m_my_wstring = std::move(x.m_my_wstring);
    return *this;
}

bool WStringStruct::operator ==(
        const WStringStruct& x) const
{
    return (m_my_wstring == x.m_my_wstring);
}

bool WStringStruct::operator !=(
        const WStringStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_wstring
 * @param _my_wstring New value to be copied in member my_wstring
 */
void WStringStruct::my_wstring(
        const std::wstring& _my_wstring)
{
    m_my_wstring = _my_wstring;
}

/*!
 * @brief This function moves the value in member my_wstring
 * @param _my_wstring New value to be moved in member my_wstring
 */
void WStringStruct::my_wstring(
        std::wstring&& _my_wstring)
{
    m_my_wstring = std::move(_my_wstring);
}

/*!
 * @brief This function returns a constant reference to member my_wstring
 * @return Constant reference to member my_wstring
 */
const std::wstring& WStringStruct::my_wstring() const
{
    return m_my_wstring;
}

/*!
 * @brief This function returns a reference to member my_wstring
 * @return Reference to member my_wstring
 */
std::wstring& WStringStruct::my_wstring()
{
    return m_my_wstring;
}




LargeStringStruct::LargeStringStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

LargeStringStruct::~LargeStringStruct()
{
}

LargeStringStruct::LargeStringStruct(
        const LargeStringStruct& x)
{
    m_my_large_string = x.m_my_large_string;
}

LargeStringStruct::LargeStringStruct(
        LargeStringStruct&& x) noexcept
{
    m_my_large_string = std::move(x.m_my_large_string);
}

LargeStringStruct& LargeStringStruct::operator =(
        const LargeStringStruct& x)
{

    m_my_large_string = x.m_my_large_string;
    return *this;
}

LargeStringStruct& LargeStringStruct::operator =(
        LargeStringStruct&& x) noexcept
{

    m_my_large_string = std::move(x.m_my_large_string);
    return *this;
}

bool LargeStringStruct::operator ==(
        const LargeStringStruct& x) const
{
    return (m_my_large_string == x.m_my_large_string);
}

bool LargeStringStruct::operator !=(
        const LargeStringStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_large_string
 * @param _my_large_string New value to be copied in member my_large_string
 */
void LargeStringStruct::my_large_string(
        const eprosima::fastcdr::fixed_string<41925>& _my_large_string)
{
    m_my_large_string = _my_large_string;
}

/*!
 * @brief This function moves the value in member my_large_string
 * @param _my_large_string New value to be moved in member my_large_string
 */
void LargeStringStruct::my_large_string(
        eprosima::fastcdr::fixed_string<41925>&& _my_large_string)
{
    m_my_large_string = std::move(_my_large_string);
}

/*!
 * @brief This function returns a constant reference to member my_large_string
 * @return Constant reference to member my_large_string
 */
const eprosima::fastcdr::fixed_string<41925>& LargeStringStruct::my_large_string() const
{
    return m_my_large_string;
}

/*!
 * @brief This function returns a reference to member my_large_string
 * @return Reference to member my_large_string
 */
eprosima::fastcdr::fixed_string<41925>& LargeStringStruct::my_large_string()
{
    return m_my_large_string;
}




LargeWStringStruct::LargeWStringStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

LargeWStringStruct::~LargeWStringStruct()
{
}

LargeWStringStruct::LargeWStringStruct(
        const LargeWStringStruct& x)
{
    m_my_large_wstring = x.m_my_large_wstring;
}

LargeWStringStruct::LargeWStringStruct(
        LargeWStringStruct&& x) noexcept
{
    m_my_large_wstring = std::move(x.m_my_large_wstring);
}

LargeWStringStruct& LargeWStringStruct::operator =(
        const LargeWStringStruct& x)
{

    m_my_large_wstring = x.m_my_large_wstring;
    return *this;
}

LargeWStringStruct& LargeWStringStruct::operator =(
        LargeWStringStruct&& x) noexcept
{

    m_my_large_wstring = std::move(x.m_my_large_wstring);
    return *this;
}

bool LargeWStringStruct::operator ==(
        const LargeWStringStruct& x) const
{
    return (m_my_large_wstring == x.m_my_large_wstring);
}

bool LargeWStringStruct::operator !=(
        const LargeWStringStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_large_wstring
 * @param _my_large_wstring New value to be copied in member my_large_wstring
 */
void LargeWStringStruct::my_large_wstring(
        const std::wstring& _my_large_wstring)
{
    m_my_large_wstring = _my_large_wstring;
}

/*!
 * @brief This function moves the value in member my_large_wstring
 * @param _my_large_wstring New value to be moved in member my_large_wstring
 */
void LargeWStringStruct::my_large_wstring(
        std::wstring&& _my_large_wstring)
{
    m_my_large_wstring = std::move(_my_large_wstring);
}

/*!
 * @brief This function returns a constant reference to member my_large_wstring
 * @return Constant reference to member my_large_wstring
 */
const std::wstring& LargeWStringStruct::my_large_wstring() const
{
    return m_my_large_wstring;
}

/*!
 * @brief This function returns a reference to member my_large_wstring
 * @return Reference to member my_large_wstring
 */
std::wstring& LargeWStringStruct::my_large_wstring()
{
    return m_my_large_wstring;
}




ArraytStruct::ArraytStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

ArraytStruct::~ArraytStruct()
{
}

ArraytStruct::ArraytStruct(
        const ArraytStruct& x)
{
    m_my_array = x.m_my_array;
}

ArraytStruct::ArraytStruct(
        ArraytStruct&& x) noexcept
{
    m_my_array = std::move(x.m_my_array);
}

ArraytStruct& ArraytStruct::operator =(
        const ArraytStruct& x)
{

    m_my_array = x.m_my_array;
    return *this;
}

ArraytStruct& ArraytStruct::operator =(
        ArraytStruct&& x) noexcept
{

    m_my_array = std::move(x.m_my_array);
    return *this;
}

bool ArraytStruct::operator ==(
        const ArraytStruct& x) const
{
    return (m_my_array == x.m_my_array);
}

bool ArraytStruct::operator !=(
        const ArraytStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_array
 * @param _my_array New value to be copied in member my_array
 */
void ArraytStruct::my_array(
        const std::array<std::array<std::array<int32_t, 2>, 2>, 2>& _my_array)
{
    m_my_array = _my_array;
}

/*!
 * @brief This function moves the value in member my_array
 * @param _my_array New value to be moved in member my_array
 */
void ArraytStruct::my_array(
        std::array<std::array<std::array<int32_t, 2>, 2>, 2>&& _my_array)
{
    m_my_array = std::move(_my_array);
}

/*!
 * @brief This function returns a constant reference to member my_array
 * @return Constant reference to member my_array
 */
const std::array<std::array<std::array<int32_t, 2>, 2>, 2>& ArraytStruct::my_array() const
{
    return m_my_array;
}

/*!
 * @brief This function returns a reference to member my_array
 * @return Reference to member my_array
 */
std::array<std::array<std::array<int32_t, 2>, 2>, 2>& ArraytStruct::my_array()
{
    return m_my_array;
}





ArrayArrayStruct::ArrayArrayStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

ArrayArrayStruct::~ArrayArrayStruct()
{
}

ArrayArrayStruct::ArrayArrayStruct(
        const ArrayArrayStruct& x)
{
    m_my_array_array = x.m_my_array_array;
}

ArrayArrayStruct::ArrayArrayStruct(
        ArrayArrayStruct&& x) noexcept
{
    m_my_array_array = std::move(x.m_my_array_array);
}

ArrayArrayStruct& ArrayArrayStruct::operator =(
        const ArrayArrayStruct& x)
{

    m_my_array_array = x.m_my_array_array;
    return *this;
}

ArrayArrayStruct& ArrayArrayStruct::operator =(
        ArrayArrayStruct&& x) noexcept
{

    m_my_array_array = std::move(x.m_my_array_array);
    return *this;
}

bool ArrayArrayStruct::operator ==(
        const ArrayArrayStruct& x) const
{
    return (m_my_array_array == x.m_my_array_array);
}

bool ArrayArrayStruct::operator !=(
        const ArrayArrayStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_array_array
 * @param _my_array_array New value to be copied in member my_array_array
 */
void ArrayArrayStruct::my_array_array(
        const std::array<std::array<MyArray, 2>, 2>& _my_array_array)
{
    m_my_array_array = _my_array_array;
}

/*!
 * @brief This function moves the value in member my_array_array
 * @param _my_array_array New value to be moved in member my_array_array
 */
void ArrayArrayStruct::my_array_array(
        std::array<std::array<MyArray, 2>, 2>&& _my_array_array)
{
    m_my_array_array = std::move(_my_array_array);
}

/*!
 * @brief This function returns a constant reference to member my_array_array
 * @return Constant reference to member my_array_array
 */
const std::array<std::array<MyArray, 2>, 2>& ArrayArrayStruct::my_array_array() const
{
    return m_my_array_array;
}

/*!
 * @brief This function returns a reference to member my_array_array
 * @return Reference to member my_array_array
 */
std::array<std::array<MyArray, 2>, 2>& ArrayArrayStruct::my_array_array()
{
    return m_my_array_array;
}






SequenceStruct::SequenceStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

SequenceStruct::~SequenceStruct()
{
}

SequenceStruct::SequenceStruct(
        const SequenceStruct& x)
{
    m_my_sequence = x.m_my_sequence;
}

SequenceStruct::SequenceStruct(
        SequenceStruct&& x) noexcept
{
    m_my_sequence = std::move(x.m_my_sequence);
}

SequenceStruct& SequenceStruct::operator =(
        const SequenceStruct& x)
{

    m_my_sequence = x.m_my_sequence;
    return *this;
}

SequenceStruct& SequenceStruct::operator =(
        SequenceStruct&& x) noexcept
{

    m_my_sequence = std::move(x.m_my_sequence);
    return *this;
}

bool SequenceStruct::operator ==(
        const SequenceStruct& x) const
{
    return (m_my_sequence == x.m_my_sequence);
}

bool SequenceStruct::operator !=(
        const SequenceStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_sequence
 * @param _my_sequence New value to be copied in member my_sequence
 */
void SequenceStruct::my_sequence(
        const std::vector<int32_t>& _my_sequence)
{
    m_my_sequence = _my_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence
 * @param _my_sequence New value to be moved in member my_sequence
 */
void SequenceStruct::my_sequence(
        std::vector<int32_t>&& _my_sequence)
{
    m_my_sequence = std::move(_my_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence
 * @return Constant reference to member my_sequence
 */
const std::vector<int32_t>& SequenceStruct::my_sequence() const
{
    return m_my_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence
 * @return Reference to member my_sequence
 */
std::vector<int32_t>& SequenceStruct::my_sequence()
{
    return m_my_sequence;
}








SequenceSequenceStruct::SequenceSequenceStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

SequenceSequenceStruct::~SequenceSequenceStruct()
{
}

SequenceSequenceStruct::SequenceSequenceStruct(
        const SequenceSequenceStruct& x)
{
    m_my_sequence_sequence = x.m_my_sequence_sequence;
}

SequenceSequenceStruct::SequenceSequenceStruct(
        SequenceSequenceStruct&& x) noexcept
{
    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);
}

SequenceSequenceStruct& SequenceSequenceStruct::operator =(
        const SequenceSequenceStruct& x)
{

    m_my_sequence_sequence = x.m_my_sequence_sequence;
    return *this;
}

SequenceSequenceStruct& SequenceSequenceStruct::operator =(
        SequenceSequenceStruct&& x) noexcept
{

    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);
    return *this;
}

bool SequenceSequenceStruct::operator ==(
        const SequenceSequenceStruct& x) const
{
    return (m_my_sequence_sequence == x.m_my_sequence_sequence);
}

bool SequenceSequenceStruct::operator !=(
        const SequenceSequenceStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be copied in member my_sequence_sequence
 */
void SequenceSequenceStruct::my_sequence_sequence(
        const std::vector<std::vector<int32_t>>& _my_sequence_sequence)
{
    m_my_sequence_sequence = _my_sequence_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be moved in member my_sequence_sequence
 */
void SequenceSequenceStruct::my_sequence_sequence(
        std::vector<std::vector<int32_t>>&& _my_sequence_sequence)
{
    m_my_sequence_sequence = std::move(_my_sequence_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence_sequence
 * @return Constant reference to member my_sequence_sequence
 */
const std::vector<std::vector<int32_t>>& SequenceSequenceStruct::my_sequence_sequence() const
{
    return m_my_sequence_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence_sequence
 * @return Reference to member my_sequence_sequence
 */
std::vector<std::vector<int32_t>>& SequenceSequenceStruct::my_sequence_sequence()
{
    return m_my_sequence_sequence;
}






MapStruct::MapStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

MapStruct::~MapStruct()
{
}

MapStruct::MapStruct(
        const MapStruct& x)
{
    m_my_map = x.m_my_map;
}

MapStruct::MapStruct(
        MapStruct&& x) noexcept
{
    m_my_map = std::move(x.m_my_map);
}

MapStruct& MapStruct::operator =(
        const MapStruct& x)
{

    m_my_map = x.m_my_map;
    return *this;
}

MapStruct& MapStruct::operator =(
        MapStruct&& x) noexcept
{

    m_my_map = std::move(x.m_my_map);
    return *this;
}

bool MapStruct::operator ==(
        const MapStruct& x) const
{
    return (m_my_map == x.m_my_map);
}

bool MapStruct::operator !=(
        const MapStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_map
 * @param _my_map New value to be copied in member my_map
 */
void MapStruct::my_map(
        const std::map<int32_t, int32_t>& _my_map)
{
    m_my_map = _my_map;
}

/*!
 * @brief This function moves the value in member my_map
 * @param _my_map New value to be moved in member my_map
 */
void MapStruct::my_map(
        std::map<int32_t, int32_t>&& _my_map)
{
    m_my_map = std::move(_my_map);
}

/*!
 * @brief This function returns a constant reference to member my_map
 * @return Constant reference to member my_map
 */
const std::map<int32_t, int32_t>& MapStruct::my_map() const
{
    return m_my_map;
}

/*!
 * @brief This function returns a reference to member my_map
 * @return Reference to member my_map
 */
std::map<int32_t, int32_t>& MapStruct::my_map()
{
    return m_my_map;
}








MapMapStruct::MapMapStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

MapMapStruct::~MapMapStruct()
{
}

MapMapStruct::MapMapStruct(
        const MapMapStruct& x)
{
    m_my_map_map = x.m_my_map_map;
}

MapMapStruct::MapMapStruct(
        MapMapStruct&& x) noexcept
{
    m_my_map_map = std::move(x.m_my_map_map);
}

MapMapStruct& MapMapStruct::operator =(
        const MapMapStruct& x)
{

    m_my_map_map = x.m_my_map_map;
    return *this;
}

MapMapStruct& MapMapStruct::operator =(
        MapMapStruct&& x) noexcept
{

    m_my_map_map = std::move(x.m_my_map_map);
    return *this;
}

bool MapMapStruct::operator ==(
        const MapMapStruct& x) const
{
    return (m_my_map_map == x.m_my_map_map);
}

bool MapMapStruct::operator !=(
        const MapMapStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_map_map
 * @param _my_map_map New value to be copied in member my_map_map
 */
void MapMapStruct::my_map_map(
        const std::map<int32_t, std::map<int32_t, int32_t>>& _my_map_map)
{
    m_my_map_map = _my_map_map;
}

/*!
 * @brief This function moves the value in member my_map_map
 * @param _my_map_map New value to be moved in member my_map_map
 */
void MapMapStruct::my_map_map(
        std::map<int32_t, std::map<int32_t, int32_t>>&& _my_map_map)
{
    m_my_map_map = std::move(_my_map_map);
}

/*!
 * @brief This function returns a constant reference to member my_map_map
 * @return Constant reference to member my_map_map
 */
const std::map<int32_t, std::map<int32_t, int32_t>>& MapMapStruct::my_map_map() const
{
    return m_my_map_map;
}

/*!
 * @brief This function returns a reference to member my_map_map
 * @return Reference to member my_map_map
 */
std::map<int32_t, std::map<int32_t, int32_t>>& MapMapStruct::my_map_map()
{
    return m_my_map_map;
}


MyBitset::MyBitset(){
    // Just to register all known types
    registerBasicTypes();
}

MyBitset::~MyBitset()
{
}

MyBitset::MyBitset(
        const MyBitset& x){
    m_bitset = x.m_bitset;
}

MyBitset::MyBitset(
        MyBitset&& x) noexcept {
    m_bitset = x.m_bitset;
}

MyBitset& MyBitset::operator =(
        const MyBitset& x)
{

    m_bitset = x.m_bitset;

    return *this;
}

MyBitset& MyBitset::operator =(
        MyBitset&& x) noexcept
{

    m_bitset = x.m_bitset;

    return *this;
}

bool MyBitset::operator ==(
        const MyBitset& x) const
{

    return m_bitset == x.m_bitset;
}

bool MyBitset::operator !=(
        const MyBitset& x) const
{
    return !(*this == x);
}


void MyBitset::a(
        char _a)
{
    int base = 0;
    int size = 2;
    for (int i = base; i < base + size; ++i)
    {
        m_bitset.set(i, !!(_a & 0x01));
        _a = _a >> 1;
    }

}

char MyBitset::a() const
{
    int base = 0;
    int size = 2;
    std::bitset<2> aux;
    for (int i = 0; i < size; ++i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<char>(aux.to_ullong());

}



void MyBitset::b(
        uint32_t _b)
{
    int base = 10;
    int size = 20;
    for (int i = base; i < base + size; ++i)
    {
        m_bitset.set(i, !!(_b & 0x01));
        _b = _b >> 1;
    }

}

uint32_t MyBitset::b() const
{
    int base = 10;
    int size = 20;
    std::bitset<20> aux;
    for (int i = 0; i < size; ++i)
    {
        aux.set(i, m_bitset.test(i + base));
    }
    return static_cast<uint32_t>(aux.to_ullong());

}


std::bitset<30> MyBitset::bitset() const
{
    std::string str_value;

    str_value = m_bitset.to_string() + str_value;

    return std::bitset<30>(str_value);
}

void MyBitset::bitset(
        const std::bitset<30>& bitset)
{
    std::string str_value {bitset.to_string()};
    size_t base_diff {0};
    size_t last_post {std::string::npos};

    base_diff += 30;
    m_bitset = std::bitset<30>(str_value.substr(str_value.length() - base_diff, last_post));
}



BitsetStruct::BitsetStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

BitsetStruct::~BitsetStruct()
{
}

BitsetStruct::BitsetStruct(
        const BitsetStruct& x)
{
    m_a = x.m_a;
}

BitsetStruct::BitsetStruct(
        BitsetStruct&& x) noexcept
{
    m_a = std::move(x.m_a);
}

BitsetStruct& BitsetStruct::operator =(
        const BitsetStruct& x)
{

    m_a = x.m_a;
    return *this;
}

BitsetStruct& BitsetStruct::operator =(
        BitsetStruct&& x) noexcept
{

    m_a = std::move(x.m_a);
    return *this;
}

bool BitsetStruct::operator ==(
        const BitsetStruct& x) const
{
    return (m_a == x.m_a);
}

bool BitsetStruct::operator !=(
        const BitsetStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member a
 * @param _a New value to be copied in member a
 */
void BitsetStruct::a(
        const MyBitset& _a)
{
    m_a = _a;
}

/*!
 * @brief This function moves the value in member a
 * @param _a New value to be moved in member a
 */
void BitsetStruct::a(
        MyBitset&& _a)
{
    m_a = std::move(_a);
}

/*!
 * @brief This function returns a constant reference to member a
 * @return Constant reference to member a
 */
const MyBitset& BitsetStruct::a() const
{
    return m_a;
}

/*!
 * @brief This function returns a reference to member a
 * @return Reference to member a
 */
MyBitset& BitsetStruct::a()
{
    return m_a;
}




StructStruct::StructStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

StructStruct::~StructStruct()
{
}

StructStruct::StructStruct(
        const StructStruct& x)
{
    m_a = x.m_a;
    m_b = x.m_b;
}

StructStruct::StructStruct(
        StructStruct&& x) noexcept
{
    m_a = x.m_a;
    m_b = x.m_b;
}

StructStruct& StructStruct::operator =(
        const StructStruct& x)
{

    m_a = x.m_a;
    m_b = x.m_b;
    return *this;
}

StructStruct& StructStruct::operator =(
        StructStruct&& x) noexcept
{

    m_a = x.m_a;
    m_b = x.m_b;
    return *this;
}

bool StructStruct::operator ==(
        const StructStruct& x) const
{
    return (m_a == x.m_a &&
           m_b == x.m_b);
}

bool StructStruct::operator !=(
        const StructStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member a
 * @param _a New value for member a
 */
void StructStruct::a(
        int32_t _a)
{
    m_a = _a;
}

/*!
 * @brief This function returns the value of member a
 * @return Value of member a
 */
int32_t StructStruct::a() const
{
    return m_a;
}

/*!
 * @brief This function returns a reference to member a
 * @return Reference to member a
 */
int32_t& StructStruct::a()
{
    return m_a;
}


/*!
 * @brief This function sets a value in member b
 * @param _b New value for member b
 */
void StructStruct::b(
        int64_t _b)
{
    m_b = _b;
}

/*!
 * @brief This function returns the value of member b
 * @return Value of member b
 */
int64_t StructStruct::b() const
{
    return m_b;
}

/*!
 * @brief This function returns a reference to member b
 * @return Reference to member b
 */
int64_t& StructStruct::b()
{
    return m_b;
}




StructStructStruct::StructStructStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

StructStructStruct::~StructStructStruct()
{
}

StructStructStruct::StructStructStruct(
        const StructStructStruct& x)
{
    m_child_struct = x.m_child_struct;
    m_child_int64 = x.m_child_int64;
}

StructStructStruct::StructStructStruct(
        StructStructStruct&& x) noexcept
{
    m_child_struct = std::move(x.m_child_struct);
    m_child_int64 = x.m_child_int64;
}

StructStructStruct& StructStructStruct::operator =(
        const StructStructStruct& x)
{

    m_child_struct = x.m_child_struct;
    m_child_int64 = x.m_child_int64;
    return *this;
}

StructStructStruct& StructStructStruct::operator =(
        StructStructStruct&& x) noexcept
{

    m_child_struct = std::move(x.m_child_struct);
    m_child_int64 = x.m_child_int64;
    return *this;
}

bool StructStructStruct::operator ==(
        const StructStructStruct& x) const
{
    return (m_child_struct == x.m_child_struct &&
           m_child_int64 == x.m_child_int64);
}

bool StructStructStruct::operator !=(
        const StructStructStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member child_struct
 * @param _child_struct New value to be copied in member child_struct
 */
void StructStructStruct::child_struct(
        const StructStruct& _child_struct)
{
    m_child_struct = _child_struct;
}

/*!
 * @brief This function moves the value in member child_struct
 * @param _child_struct New value to be moved in member child_struct
 */
void StructStructStruct::child_struct(
        StructStruct&& _child_struct)
{
    m_child_struct = std::move(_child_struct);
}

/*!
 * @brief This function returns a constant reference to member child_struct
 * @return Constant reference to member child_struct
 */
const StructStruct& StructStructStruct::child_struct() const
{
    return m_child_struct;
}

/*!
 * @brief This function returns a reference to member child_struct
 * @return Reference to member child_struct
 */
StructStruct& StructStructStruct::child_struct()
{
    return m_child_struct;
}


/*!
 * @brief This function sets a value in member child_int64
 * @param _child_int64 New value for member child_int64
 */
void StructStructStruct::child_int64(
        int64_t _child_int64)
{
    m_child_int64 = _child_int64;
}

/*!
 * @brief This function returns the value of member child_int64
 * @return Value of member child_int64
 */
int64_t StructStructStruct::child_int64() const
{
    return m_child_int64;
}

/*!
 * @brief This function returns a reference to member child_int64
 * @return Reference to member child_int64
 */
int64_t& StructStructStruct::child_int64()
{
    return m_child_int64;
}




SimpleUnion::SimpleUnion()
{
    m__d = A;
}

SimpleUnion::~SimpleUnion()
{
}

SimpleUnion::SimpleUnion(
        const SimpleUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }
}

SimpleUnion::SimpleUnion(
        SimpleUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }
}

SimpleUnion& SimpleUnion::operator =(
        const SimpleUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }

    return *this;
}

SimpleUnion& SimpleUnion::operator =(
        SimpleUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }

    return *this;
}

bool SimpleUnion::operator ==(
        const SimpleUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch (m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;


        case B:
            return (m_second == x.m_second);
            break;

        default:
            break;
    }
    return false;
}

bool SimpleUnion::operator !=(
        const SimpleUnion& x) const
{
    return !(*this == x);
}

void SimpleUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch (m__d)
    {
        case A:
            switch (__d)
            {
                case A:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case B:
            switch (__d)
            {
                case B:
                    b = true;
                    break;
                default:
                    break;
            }
            break;

        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t SimpleUnion::_d() const
{
    return m__d;
}

int32_t& SimpleUnion::_d()
{
    return m__d;
}

void SimpleUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = A;

}

int32_t SimpleUnion::first() const
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& SimpleUnion::first()
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}


void SimpleUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = B;

}

int64_t SimpleUnion::second() const
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& SimpleUnion::second()
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}




UnionUnion::UnionUnion()
{
    m__d = A;
}

UnionUnion::~UnionUnion()
{
}

UnionUnion::UnionUnion(
        const UnionUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }
}

UnionUnion::UnionUnion(
        UnionUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = std::move(x.m_second);

            break;

        default:
            break;
    }
}

UnionUnion& UnionUnion::operator =(
        const UnionUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }

    return *this;
}

UnionUnion& UnionUnion::operator =(
        UnionUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = std::move(x.m_second);

            break;

        default:
            break;
    }

    return *this;
}

bool UnionUnion::operator ==(
        const UnionUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch (m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;


        case B:
            return (m_second == x.m_second);
            break;

        default:
            break;
    }
    return false;
}

bool UnionUnion::operator !=(
        const UnionUnion& x) const
{
    return !(*this == x);
}

void UnionUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch (m__d)
    {
        case A:
            switch (__d)
            {
                case A:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case B:
            switch (__d)
            {
                case B:
                    b = true;
                    break;
                default:
                    break;
            }
            break;

        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t UnionUnion::_d() const
{
    return m__d;
}

int32_t& UnionUnion::_d()
{
    return m__d;
}

void UnionUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = A;

}

int32_t UnionUnion::first() const
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& UnionUnion::first()
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}


void UnionUnion::second(
        const SimpleUnion& _second)
{
    m_second = _second;
    m__d = B;

}

void UnionUnion::second(
        SimpleUnion&& _second)
{
    m_second = std::move(_second);
    m__d = B;

}

const SimpleUnion& UnionUnion::second() const
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

SimpleUnion& UnionUnion::second()
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}




WCharUnion::WCharUnion()
{
    m__d = A;
}

WCharUnion::~WCharUnion()
{
}

WCharUnion::WCharUnion(
        const WCharUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }
}

WCharUnion::WCharUnion(
        WCharUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }
}

WCharUnion& WCharUnion::operator =(
        const WCharUnion& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }

    return *this;
}

WCharUnion& WCharUnion::operator =(
        WCharUnion&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case A:
            m_first = x.m_first;
            break;


        case B:
            m_second = x.m_second;
            break;

        default:
            break;
    }

    return *this;
}

bool WCharUnion::operator ==(
        const WCharUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch (m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;


        case B:
            return (m_second == x.m_second);
            break;

        default:
            break;
    }
    return false;
}

bool WCharUnion::operator !=(
        const WCharUnion& x) const
{
    return !(*this == x);
}

void WCharUnion::_d(
        wchar_t __d)
{
    bool b = false;

    switch (m__d)
    {
        case A:
            switch (__d)
            {
                case A:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case B:
            switch (__d)
            {
                case B:
                    b = true;
                    break;
                default:
                    break;
            }
            break;

        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

wchar_t WCharUnion::_d() const
{
    return m__d;
}

wchar_t& WCharUnion::_d()
{
    return m__d;
}

void WCharUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = A;

}

int32_t WCharUnion::first() const
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}

int32_t& WCharUnion::first()
{
    bool b = false;

    switch (m__d)
    {
        case A:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_first;
}


void WCharUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = B;

}

int64_t WCharUnion::second() const
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}

int64_t& WCharUnion::second()
{
    bool b = false;

    switch (m__d)
    {
        case B:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_second;
}




SimpleUnionStruct::SimpleUnionStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

SimpleUnionStruct::~SimpleUnionStruct()
{
}

SimpleUnionStruct::SimpleUnionStruct(
        const SimpleUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

SimpleUnionStruct::SimpleUnionStruct(
        SimpleUnionStruct&& x) noexcept
{
    m_my_union = std::move(x.m_my_union);
}

SimpleUnionStruct& SimpleUnionStruct::operator =(
        const SimpleUnionStruct& x)
{

    m_my_union = x.m_my_union;
    return *this;
}

SimpleUnionStruct& SimpleUnionStruct::operator =(
        SimpleUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);
    return *this;
}

bool SimpleUnionStruct::operator ==(
        const SimpleUnionStruct& x) const
{
    return (m_my_union == x.m_my_union);
}

bool SimpleUnionStruct::operator !=(
        const SimpleUnionStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimpleUnionStruct::my_union(
        const SimpleUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimpleUnionStruct::my_union(
        SimpleUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleUnion& SimpleUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleUnion& SimpleUnionStruct::my_union()
{
    return m_my_union;
}




UnionUnionUnionStruct::UnionUnionUnionStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

UnionUnionUnionStruct::~UnionUnionUnionStruct()
{
}

UnionUnionUnionStruct::UnionUnionUnionStruct(
        const UnionUnionUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

UnionUnionUnionStruct::UnionUnionUnionStruct(
        UnionUnionUnionStruct&& x) noexcept
{
    m_my_union = std::move(x.m_my_union);
}

UnionUnionUnionStruct& UnionUnionUnionStruct::operator =(
        const UnionUnionUnionStruct& x)
{

    m_my_union = x.m_my_union;
    return *this;
}

UnionUnionUnionStruct& UnionUnionUnionStruct::operator =(
        UnionUnionUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);
    return *this;
}

bool UnionUnionUnionStruct::operator ==(
        const UnionUnionUnionStruct& x) const
{
    return (m_my_union == x.m_my_union);
}

bool UnionUnionUnionStruct::operator !=(
        const UnionUnionUnionStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void UnionUnionUnionStruct::my_union(
        const UnionUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void UnionUnionUnionStruct::my_union(
        UnionUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const UnionUnion& UnionUnionUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
UnionUnion& UnionUnionUnionStruct::my_union()
{
    return m_my_union;
}




WCharUnionStruct::WCharUnionStruct()
{
    // Just to register all known types
    registerBasicTypes();
}

WCharUnionStruct::~WCharUnionStruct()
{
}

WCharUnionStruct::WCharUnionStruct(
        const WCharUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

WCharUnionStruct::WCharUnionStruct(
        WCharUnionStruct&& x) noexcept
{
    m_my_union = std::move(x.m_my_union);
}

WCharUnionStruct& WCharUnionStruct::operator =(
        const WCharUnionStruct& x)
{

    m_my_union = x.m_my_union;
    return *this;
}

WCharUnionStruct& WCharUnionStruct::operator =(
        WCharUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);
    return *this;
}

bool WCharUnionStruct::operator ==(
        const WCharUnionStruct& x) const
{
    return (m_my_union == x.m_my_union);
}

bool WCharUnionStruct::operator !=(
        const WCharUnionStruct& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void WCharUnionStruct::my_union(
        const WCharUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void WCharUnionStruct::my_union(
        WCharUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const WCharUnion& WCharUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
WCharUnion& WCharUnionStruct::my_union()
{
    return m_my_union;
}


// Include auxiliary functions like for serializing/deserializing.
#include "BasicCdrAux.ipp"

#endif // FASTCDR_VERSION_MAJOR > 1
