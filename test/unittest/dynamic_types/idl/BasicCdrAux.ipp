// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file BasicCdrAux.ipp
 * This source file contains some declarations of CDR related functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifndef _FAST_DDS_GENERATED_BASICCDRAUX_IPP_
#define _FAST_DDS_GENERATED_BASICCDRAUX_IPP_

#include "BasicCdrAux.hpp"

#include <fastcdr/Cdr.h>
#if FASTCDR_VERSION_MAJOR > 1
#include <fastcdr/CdrSizeCalculator.hpp>
#endif // FASTCDR_VERSION_MAJOR > 1



#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {







template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const EnumStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_enum(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const EnumStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << (uint32_t)data.my_enum()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_enum()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        EnumStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                {
                    uint32_t enum_value = 0;
                    cdr >> enum_value;
                    data.my_enum() = (MyEnum)enum_value;
                }
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_enum();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const EnumStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const AliasStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_alias(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const AliasStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << (uint32_t)data.my_alias()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_alias()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        AliasStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                {
                    uint32_t enum_value = 0;
                    cdr >> enum_value;
                    data.my_alias() = (MyAliasEnum)enum_value;
                }
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_alias();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const AliasStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const AliasAliasStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_alias_alias(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const AliasAliasStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << (uint32_t)data.my_alias_alias()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_alias_alias()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        AliasAliasStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                {
                    uint32_t enum_value = 0;
                    cdr >> enum_value;
                    data.my_alias_alias() = (MyAliasAliasEnum)enum_value;
                }
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_alias_alias();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const AliasAliasStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BoolStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_bool(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const BoolStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_bool()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_bool()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        BoolStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_bool();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_bool();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const BoolStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const OctetStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_octet(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const OctetStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_octet()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_octet()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        OctetStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_octet();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_octet();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const OctetStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ShortStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_int16(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const ShortStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_int16()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_int16()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        ShortStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_int16();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_int16();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const ShortStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LongStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_int32(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const LongStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_int32()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_int32()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        LongStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_int32();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_int32();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const LongStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LongLongStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_int64(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const LongLongStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_int64()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_int64()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        LongLongStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_int64();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_int64();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const LongLongStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const UShortStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_uint16(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const UShortStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_uint16()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_uint16()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        UShortStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_uint16();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_uint16();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const UShortStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ULongStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_uint32(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const ULongStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_uint32()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_uint32()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        ULongStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_uint32();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_uint32();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const ULongStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ULongLongStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_uint64(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const ULongLongStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_uint64()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_uint64()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        ULongLongStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_uint64();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_uint64();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const ULongLongStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const FloatStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_float32(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const FloatStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_float32()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_float32()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        FloatStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_float32();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_float32();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const FloatStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const DoubleStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_float64(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const DoubleStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_float64()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_float64()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        DoubleStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_float64();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_float64();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const DoubleStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LongDoubleStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_float128(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const LongDoubleStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_float128()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_float128()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        LongDoubleStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_float128();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_float128();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const LongDoubleStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const CharStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_char(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const CharStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_char()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_char()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        CharStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_char();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_char();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const CharStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const WCharStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_wchar(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const WCharStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_wchar()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_wchar()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        WCharStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_wchar();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_wchar();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const WCharStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StringStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.my_string().size() + 1;



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StringStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_string()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_string()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StringStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_string();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StringStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const WStringStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.my_wstring().size()) * 4; // 32 bits



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const WStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_wstring()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_wstring()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        WStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_wstring();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const WStringStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LargeStringStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.my_large_string().size() + 1;



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_large_string(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const LargeStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_large_string()
                .c_str()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_large_string()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        LargeStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                {
                    std::string aux;
                    cdr >> aux;
                    data.my_large_string() = aux.c_str();
                }
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_large_string();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const LargeStringStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LargeWStringStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.my_large_wstring().size()) * 4; // 32 bits



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_large_wstring(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const LargeWStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_large_wstring()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_large_wstring()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        LargeWStringStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_large_wstring();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_large_wstring();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const LargeWStringStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArraytStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += ((2 * 2 * 2) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);





    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_array(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const ArraytStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_array();

#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_array()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        ArraytStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_array();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_array();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const ArraytStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}






template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArrayArrayStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};


            for(size_t a = 0; a < data.my_array_array().size(); ++a)
            {

                for(size_t b = 0; b < data.my_array_array().at(a).size(); ++b)
                {
                        current_alignment += ((2 * 2) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



                }

            }




    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_array_array(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const ArrayArrayStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_array_array();

#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_array_array()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        ArrayArrayStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                        cdr >> data.my_array_array();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_array_array();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const ArrayArrayStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}






template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            if (data.my_sequence().size() > 0)
            {
                current_alignment += (data.my_sequence().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            }





    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_sequence(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const SequenceStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_sequence()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_sequence()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        SequenceStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                    cdr >> data.my_sequence();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_sequence();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const SequenceStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}








template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceSequenceStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            for(size_t a = 0; a < data.my_sequence_sequence().size(); ++a)
            {
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                if (data.my_sequence_sequence().at(a).size() > 0)
                {
                    current_alignment += (data.my_sequence_sequence().at(a).size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                }


            }




    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_sequence_sequence(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const SequenceSequenceStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_sequence_sequence()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_sequence_sequence()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        SequenceSequenceStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                    cdr >> data.my_sequence_sequence();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_sequence_sequence();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const SequenceSequenceStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}






template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            for(auto a : data.my_map())
            {
                (void)a;

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            }



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_map(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_map()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_map()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_map();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_map();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}








template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapMapStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            for(auto a : data.my_map_map())
            {
                (void)a;

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    for(auto b : a.second)
                    {
                        (void)b;

                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    }

            }



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_map_map(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MapMapStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_map_map()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_map_map()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        MapMapStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_map_map();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_map_map();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const MapMapStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MyBitset& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1
    static_cast<void>(calculator);
    static_cast<void>(current_alignment);
    return 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
#else
    return calculator.calculate_serialized_size(data.bitset(), current_alignment);
#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const MyBitset& data)
{
    scdr <<
#if FASTCDR_VERSION_MAJOR == 1
    (uint32_t)
#endif // FASTCDR_VERSION_MAJOR == 1
    data.bitset()
#if FASTCDR_VERSION_MAJOR == 1
    .to_ulong()
#endif // FASTCDR_VERSION_MAJOR == 1
    ;
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& dcdr,
        MyBitset& data)
{
#if FASTCDR_VERSION_MAJOR == 1
    uint32_t bitset;
    dcdr >> bitset;
    data.bitset(bitset);
#else
    std::bitset<30> bitset;
    dcdr >> bitset;
    data.bitset(bitset);
#endif // FASTCDR_VERSION_MAJOR == 1
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BitsetStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.a(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const BitsetStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.a()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.a()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        BitsetStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.a();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.a();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const BitsetStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.b(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.a()
            ;


            scdr << data.b()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.a()
        << eprosima::fastcdr::MemberId(1) << data.b()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.a();
                cdr >> data.b();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.a();
                                            break;

                                        case 1:
                                                dcdr >> data.b();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StructStructStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            calculate_serialized_size(calculator, data.child_struct(), current_alignment);


            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.child_struct(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.child_int64(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const StructStructStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.child_struct()
            ;


            scdr << data.child_int64()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.child_struct()
        << eprosima::fastcdr::MemberId(1) << data.child_int64()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        StructStructStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.child_struct();
                cdr >> data.child_int64();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.child_struct();
                                            break;

                                        case 1:
                                                dcdr >> data.child_int64();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const StructStructStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnion& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    switch(data._d())
    {
        case A:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;


        case B:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;

        default:
        break;
    }

    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
        case A:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                                data.first(), current_alignment);
                    break;

        case B:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.second(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const SimpleUnion& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
    scdr << data._d();

    switch (data._d())
    {
                case A:
                    scdr << data.first()
                        ;
                    break;

                case B:
                    scdr << data.second()
                        ;
                    break;

        default:
            break;
    }
#else
    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case A:
                    scdr << eprosima::fastcdr::MemberId(0) << data.first();
                    break;

                case B:
                    scdr << eprosima::fastcdr::MemberId(1) << data.second();
                    break;

        default:
            break;
    }
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        SimpleUnion& data)
{
#if FASTCDR_VERSION_MAJOR == 1

    cdr >> data._d();

    switch (data._d())
    {
                        case A:
                            cdr >> data.first();
                        break;

                        case B:
                            cdr >> data.second();
                        break;

    }
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> data._d();
                        break;
                    default:
                        switch (data._d())
                        {
                                                        case A:
                                                            dcdr >> data.first();
                                                            break;

                                                        case B:
                                                            dcdr >> data.second();
                                                            break;

                            default:
                                break;
                        }
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const UnionUnion& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    switch(data._d())
    {
        case A:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;


        case B:
        calculate_serialized_size(calculator, data.second(), current_alignment);

        break;

        default:
        break;
    }

    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
        case A:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                                data.first(), current_alignment);
                    break;

        case B:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.second(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const UnionUnion& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
    scdr << data._d();

    switch (data._d())
    {
                case A:
                    scdr << data.first()
                        ;
                    break;

                case B:
                    scdr << data.second()
                        ;
                    break;

        default:
            break;
    }
#else
    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case A:
                    scdr << eprosima::fastcdr::MemberId(0) << data.first();
                    break;

                case B:
                    scdr << eprosima::fastcdr::MemberId(1) << data.second();
                    break;

        default:
            break;
    }
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        UnionUnion& data)
{
#if FASTCDR_VERSION_MAJOR == 1

    cdr >> data._d();

    switch (data._d())
    {
                        case A:
                            cdr >> data.first();
                        break;

                        case B:
                            cdr >> data.second();
                        break;

    }
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> data._d();
                        break;
                    default:
                        switch (data._d())
                        {
                                                        case A:
                                                            dcdr >> data.first();
                                                            break;

                                                        case B:
                                                            dcdr >> data.second();
                                                            break;

                            default:
                                break;
                        }
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const WCharUnion& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    switch(data._d())
    {
        case A:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;


        case B:
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        break;

        default:
        break;
    }

    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
        case A:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                                data.first(), current_alignment);
                    break;

        case B:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.second(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const WCharUnion& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
    scdr << data._d();

    switch (data._d())
    {
                case A:
                    scdr << data.first()
                        ;
                    break;

                case B:
                    scdr << data.second()
                        ;
                    break;

        default:
            break;
    }
#else
    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case A:
                    scdr << eprosima::fastcdr::MemberId(0) << data.first();
                    break;

                case B:
                    scdr << eprosima::fastcdr::MemberId(1) << data.second();
                    break;

        default:
            break;
    }
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        WCharUnion& data)
{
#if FASTCDR_VERSION_MAJOR == 1

    cdr >> data._d();

    switch (data._d())
    {
                        case A:
                            cdr >> data.first();
                        break;

                        case B:
                            cdr >> data.second();
                        break;

    }
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> data._d();
                        break;
                    default:
                        switch (data._d())
                        {
                                                        case A:
                                                            dcdr >> data.first();
                                                            break;

                                                        case B:
                                                            dcdr >> data.second();
                                                            break;

                            default:
                                break;
                        }
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnionStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            calculate_serialized_size(calculator, data.my_union(), current_alignment);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_union(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const SimpleUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_union()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_union()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        SimpleUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_union();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_union();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const SimpleUnionStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const UnionUnionUnionStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            calculate_serialized_size(calculator, data.my_union(), current_alignment);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_union(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const UnionUnionUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_union()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_union()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        UnionUnionUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_union();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_union();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const UnionUnionUnionStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const WCharUnionStruct& data,
        size_t& current_alignment)
{
    static_cast<void>(data);

#if FASTCDR_VERSION_MAJOR == 1

    static_cast<void>(calculator);
    static_cast<void>(current_alignment);

    size_t initial_alignment {current_alignment};

            calculate_serialized_size(calculator, data.my_union(), current_alignment);



    return current_alignment - initial_alignment;

#else

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.my_union(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;

#endif // FASTCDR_VERSION_MAJOR == 1
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const WCharUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR > 1
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);
#endif // FASTCDR_VERSION_MAJOR > 1

#if FASTCDR_VERSION_MAJOR == 1
            scdr << data.my_union()
            ;


#else
    scdr
        << eprosima::fastcdr::MemberId(0) << data.my_union()
;
#endif // FASTCDR_VERSION_MAJOR == 1

#if FASTCDR_VERSION_MAJOR > 1
    scdr.end_serialize_type(current_state);
#endif // FASTCDR_VERSION_MAJOR > 1
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        WCharUnionStruct& data)
{
#if FASTCDR_VERSION_MAJOR == 1
                cdr >> data.my_union();
;
#else
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.my_union();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
#endif // FASTCDR_VERSION_MAJOR == 1
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const WCharUnionStruct& data)
{
    static_cast<void>(scdr);
    static_cast<void>(data);
}



} // namespace fastcdr
} // namespace eprosima

#endif // _FAST_DDS_GENERATED_BASICCDRAUX_IPP_

