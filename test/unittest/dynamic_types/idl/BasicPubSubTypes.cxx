// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file BasicPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "BasicPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;




EnumStructPubSubType::EnumStructPubSubType()
{
    setName("EnumStruct");
    m_typeSize = (uint32_t)EnumStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = EnumStruct::isKeyDefined();
    size_t keyLength = EnumStruct::getKeyMaxCdrSerializedSize()>16 ? EnumStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

EnumStructPubSubType::~EnumStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool EnumStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    EnumStruct *p_type = (EnumStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool EnumStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    EnumStruct* p_type = (EnumStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> EnumStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<EnumStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* EnumStructPubSubType::createData()
{
    return (void*)new EnumStruct();
}

void EnumStructPubSubType::deleteData(void* data)
{
    delete((EnumStruct*)data);
}

bool EnumStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    EnumStruct* p_type = (EnumStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,EnumStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(EnumStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

AliasStructPubSubType::AliasStructPubSubType()
{
    setName("AliasStruct");
    m_typeSize = (uint32_t)AliasStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = AliasStruct::isKeyDefined();
    size_t keyLength = AliasStruct::getKeyMaxCdrSerializedSize()>16 ? AliasStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

AliasStructPubSubType::~AliasStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool AliasStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    AliasStruct *p_type = (AliasStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool AliasStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    AliasStruct* p_type = (AliasStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> AliasStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<AliasStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* AliasStructPubSubType::createData()
{
    return (void*)new AliasStruct();
}

void AliasStructPubSubType::deleteData(void* data)
{
    delete((AliasStruct*)data);
}

bool AliasStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    AliasStruct* p_type = (AliasStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,AliasStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(AliasStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

AliasAliasStructPubSubType::AliasAliasStructPubSubType()
{
    setName("AliasAliasStruct");
    m_typeSize = (uint32_t)AliasAliasStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = AliasAliasStruct::isKeyDefined();
    size_t keyLength = AliasAliasStruct::getKeyMaxCdrSerializedSize()>16 ? AliasAliasStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

AliasAliasStructPubSubType::~AliasAliasStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool AliasAliasStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    AliasAliasStruct *p_type = (AliasAliasStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool AliasAliasStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    AliasAliasStruct* p_type = (AliasAliasStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> AliasAliasStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<AliasAliasStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* AliasAliasStructPubSubType::createData()
{
    return (void*)new AliasAliasStruct();
}

void AliasAliasStructPubSubType::deleteData(void* data)
{
    delete((AliasAliasStruct*)data);
}

bool AliasAliasStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    AliasAliasStruct* p_type = (AliasAliasStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,AliasAliasStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(AliasAliasStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

BoolStructPubSubType::BoolStructPubSubType()
{
    setName("BoolStruct");
    m_typeSize = (uint32_t)BoolStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = BoolStruct::isKeyDefined();
    size_t keyLength = BoolStruct::getKeyMaxCdrSerializedSize()>16 ? BoolStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

BoolStructPubSubType::~BoolStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool BoolStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    BoolStruct *p_type = (BoolStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool BoolStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    BoolStruct* p_type = (BoolStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> BoolStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<BoolStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* BoolStructPubSubType::createData()
{
    return (void*)new BoolStruct();
}

void BoolStructPubSubType::deleteData(void* data)
{
    delete((BoolStruct*)data);
}

bool BoolStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    BoolStruct* p_type = (BoolStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,BoolStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(BoolStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

OctetStructPubSubType::OctetStructPubSubType()
{
    setName("OctetStruct");
    m_typeSize = (uint32_t)OctetStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = OctetStruct::isKeyDefined();
    size_t keyLength = OctetStruct::getKeyMaxCdrSerializedSize()>16 ? OctetStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

OctetStructPubSubType::~OctetStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool OctetStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    OctetStruct *p_type = (OctetStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool OctetStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    OctetStruct* p_type = (OctetStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> OctetStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<OctetStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* OctetStructPubSubType::createData()
{
    return (void*)new OctetStruct();
}

void OctetStructPubSubType::deleteData(void* data)
{
    delete((OctetStruct*)data);
}

bool OctetStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    OctetStruct* p_type = (OctetStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,OctetStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(OctetStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

ShortStructPubSubType::ShortStructPubSubType()
{
    setName("ShortStruct");
    m_typeSize = (uint32_t)ShortStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = ShortStruct::isKeyDefined();
    size_t keyLength = ShortStruct::getKeyMaxCdrSerializedSize()>16 ? ShortStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

ShortStructPubSubType::~ShortStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool ShortStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    ShortStruct *p_type = (ShortStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool ShortStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    ShortStruct* p_type = (ShortStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> ShortStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<ShortStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* ShortStructPubSubType::createData()
{
    return (void*)new ShortStruct();
}

void ShortStructPubSubType::deleteData(void* data)
{
    delete((ShortStruct*)data);
}

bool ShortStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    ShortStruct* p_type = (ShortStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ShortStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(ShortStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

LongStructPubSubType::LongStructPubSubType()
{
    setName("LongStruct");
    m_typeSize = (uint32_t)LongStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = LongStruct::isKeyDefined();
    size_t keyLength = LongStruct::getKeyMaxCdrSerializedSize()>16 ? LongStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

LongStructPubSubType::~LongStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool LongStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    LongStruct *p_type = (LongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool LongStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    LongStruct* p_type = (LongStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> LongStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<LongStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* LongStructPubSubType::createData()
{
    return (void*)new LongStruct();
}

void LongStructPubSubType::deleteData(void* data)
{
    delete((LongStruct*)data);
}

bool LongStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    LongStruct* p_type = (LongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LongStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(LongStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

LongLongStructPubSubType::LongLongStructPubSubType()
{
    setName("LongLongStruct");
    m_typeSize = (uint32_t)LongLongStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = LongLongStruct::isKeyDefined();
    size_t keyLength = LongLongStruct::getKeyMaxCdrSerializedSize()>16 ? LongLongStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

LongLongStructPubSubType::~LongLongStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool LongLongStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    LongLongStruct *p_type = (LongLongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool LongLongStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    LongLongStruct* p_type = (LongLongStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> LongLongStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<LongLongStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* LongLongStructPubSubType::createData()
{
    return (void*)new LongLongStruct();
}

void LongLongStructPubSubType::deleteData(void* data)
{
    delete((LongLongStruct*)data);
}

bool LongLongStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    LongLongStruct* p_type = (LongLongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LongLongStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(LongLongStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

UShortStructPubSubType::UShortStructPubSubType()
{
    setName("UShortStruct");
    m_typeSize = (uint32_t)UShortStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = UShortStruct::isKeyDefined();
    size_t keyLength = UShortStruct::getKeyMaxCdrSerializedSize()>16 ? UShortStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

UShortStructPubSubType::~UShortStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool UShortStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    UShortStruct *p_type = (UShortStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool UShortStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    UShortStruct* p_type = (UShortStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> UShortStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<UShortStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* UShortStructPubSubType::createData()
{
    return (void*)new UShortStruct();
}

void UShortStructPubSubType::deleteData(void* data)
{
    delete((UShortStruct*)data);
}

bool UShortStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    UShortStruct* p_type = (UShortStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,UShortStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(UShortStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

ULongStructPubSubType::ULongStructPubSubType()
{
    setName("ULongStruct");
    m_typeSize = (uint32_t)ULongStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = ULongStruct::isKeyDefined();
    size_t keyLength = ULongStruct::getKeyMaxCdrSerializedSize()>16 ? ULongStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

ULongStructPubSubType::~ULongStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool ULongStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    ULongStruct *p_type = (ULongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool ULongStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    ULongStruct* p_type = (ULongStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> ULongStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<ULongStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* ULongStructPubSubType::createData()
{
    return (void*)new ULongStruct();
}

void ULongStructPubSubType::deleteData(void* data)
{
    delete((ULongStruct*)data);
}

bool ULongStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    ULongStruct* p_type = (ULongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ULongStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(ULongStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

ULongLongStructPubSubType::ULongLongStructPubSubType()
{
    setName("ULongLongStruct");
    m_typeSize = (uint32_t)ULongLongStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = ULongLongStruct::isKeyDefined();
    size_t keyLength = ULongLongStruct::getKeyMaxCdrSerializedSize()>16 ? ULongLongStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

ULongLongStructPubSubType::~ULongLongStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool ULongLongStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    ULongLongStruct *p_type = (ULongLongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool ULongLongStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    ULongLongStruct* p_type = (ULongLongStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> ULongLongStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<ULongLongStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* ULongLongStructPubSubType::createData()
{
    return (void*)new ULongLongStruct();
}

void ULongLongStructPubSubType::deleteData(void* data)
{
    delete((ULongLongStruct*)data);
}

bool ULongLongStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    ULongLongStruct* p_type = (ULongLongStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ULongLongStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(ULongLongStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

FloatStructPubSubType::FloatStructPubSubType()
{
    setName("FloatStruct");
    m_typeSize = (uint32_t)FloatStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = FloatStruct::isKeyDefined();
    size_t keyLength = FloatStruct::getKeyMaxCdrSerializedSize()>16 ? FloatStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

FloatStructPubSubType::~FloatStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool FloatStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    FloatStruct *p_type = (FloatStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool FloatStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    FloatStruct* p_type = (FloatStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> FloatStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<FloatStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* FloatStructPubSubType::createData()
{
    return (void*)new FloatStruct();
}

void FloatStructPubSubType::deleteData(void* data)
{
    delete((FloatStruct*)data);
}

bool FloatStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    FloatStruct* p_type = (FloatStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FloatStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(FloatStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

DoubleStructPubSubType::DoubleStructPubSubType()
{
    setName("DoubleStruct");
    m_typeSize = (uint32_t)DoubleStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = DoubleStruct::isKeyDefined();
    size_t keyLength = DoubleStruct::getKeyMaxCdrSerializedSize()>16 ? DoubleStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

DoubleStructPubSubType::~DoubleStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool DoubleStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    DoubleStruct *p_type = (DoubleStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool DoubleStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    DoubleStruct* p_type = (DoubleStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> DoubleStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<DoubleStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* DoubleStructPubSubType::createData()
{
    return (void*)new DoubleStruct();
}

void DoubleStructPubSubType::deleteData(void* data)
{
    delete((DoubleStruct*)data);
}

bool DoubleStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    DoubleStruct* p_type = (DoubleStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,DoubleStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(DoubleStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

LongDoubleStructPubSubType::LongDoubleStructPubSubType()
{
    setName("LongDoubleStruct");
    m_typeSize = (uint32_t)LongDoubleStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = LongDoubleStruct::isKeyDefined();
    size_t keyLength = LongDoubleStruct::getKeyMaxCdrSerializedSize()>16 ? LongDoubleStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

LongDoubleStructPubSubType::~LongDoubleStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool LongDoubleStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    LongDoubleStruct *p_type = (LongDoubleStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool LongDoubleStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    LongDoubleStruct* p_type = (LongDoubleStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> LongDoubleStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<LongDoubleStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* LongDoubleStructPubSubType::createData()
{
    return (void*)new LongDoubleStruct();
}

void LongDoubleStructPubSubType::deleteData(void* data)
{
    delete((LongDoubleStruct*)data);
}

bool LongDoubleStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    LongDoubleStruct* p_type = (LongDoubleStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LongDoubleStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(LongDoubleStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

CharStructPubSubType::CharStructPubSubType()
{
    setName("CharStruct");
    m_typeSize = (uint32_t)CharStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = CharStruct::isKeyDefined();
    size_t keyLength = CharStruct::getKeyMaxCdrSerializedSize()>16 ? CharStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

CharStructPubSubType::~CharStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool CharStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    CharStruct *p_type = (CharStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool CharStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    CharStruct* p_type = (CharStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> CharStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<CharStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* CharStructPubSubType::createData()
{
    return (void*)new CharStruct();
}

void CharStructPubSubType::deleteData(void* data)
{
    delete((CharStruct*)data);
}

bool CharStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    CharStruct* p_type = (CharStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,CharStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(CharStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

WCharStructPubSubType::WCharStructPubSubType()
{
    setName("WCharStruct");
    m_typeSize = (uint32_t)WCharStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = WCharStruct::isKeyDefined();
    size_t keyLength = WCharStruct::getKeyMaxCdrSerializedSize()>16 ? WCharStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

WCharStructPubSubType::~WCharStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool WCharStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    WCharStruct *p_type = (WCharStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool WCharStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    WCharStruct* p_type = (WCharStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> WCharStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<WCharStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* WCharStructPubSubType::createData()
{
    return (void*)new WCharStruct();
}

void WCharStructPubSubType::deleteData(void* data)
{
    delete((WCharStruct*)data);
}

bool WCharStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    WCharStruct* p_type = (WCharStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,WCharStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(WCharStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

StringStructPubSubType::StringStructPubSubType()
{
    setName("StringStruct");
    m_typeSize = (uint32_t)StringStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = StringStruct::isKeyDefined();
    size_t keyLength = StringStruct::getKeyMaxCdrSerializedSize()>16 ? StringStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

StringStructPubSubType::~StringStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool StringStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    StringStruct *p_type = (StringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool StringStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    StringStruct* p_type = (StringStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> StringStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<StringStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* StringStructPubSubType::createData()
{
    return (void*)new StringStruct();
}

void StringStructPubSubType::deleteData(void* data)
{
    delete((StringStruct*)data);
}

bool StringStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    StringStruct* p_type = (StringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,StringStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(StringStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

WStringStructPubSubType::WStringStructPubSubType()
{
    setName("WStringStruct");
    m_typeSize = (uint32_t)WStringStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = WStringStruct::isKeyDefined();
    size_t keyLength = WStringStruct::getKeyMaxCdrSerializedSize()>16 ? WStringStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

WStringStructPubSubType::~WStringStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool WStringStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    WStringStruct *p_type = (WStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool WStringStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    WStringStruct* p_type = (WStringStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> WStringStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<WStringStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* WStringStructPubSubType::createData()
{
    return (void*)new WStringStruct();
}

void WStringStructPubSubType::deleteData(void* data)
{
    delete((WStringStruct*)data);
}

bool WStringStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    WStringStruct* p_type = (WStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,WStringStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(WStringStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

LargeStringStructPubSubType::LargeStringStructPubSubType()
{
    setName("LargeStringStruct");
    m_typeSize = (uint32_t)LargeStringStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = LargeStringStruct::isKeyDefined();
    size_t keyLength = LargeStringStruct::getKeyMaxCdrSerializedSize()>16 ? LargeStringStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

LargeStringStructPubSubType::~LargeStringStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool LargeStringStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    LargeStringStruct *p_type = (LargeStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool LargeStringStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    LargeStringStruct* p_type = (LargeStringStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> LargeStringStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<LargeStringStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* LargeStringStructPubSubType::createData()
{
    return (void*)new LargeStringStruct();
}

void LargeStringStructPubSubType::deleteData(void* data)
{
    delete((LargeStringStruct*)data);
}

bool LargeStringStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    LargeStringStruct* p_type = (LargeStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LargeStringStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(LargeStringStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

LargeWStringStructPubSubType::LargeWStringStructPubSubType()
{
    setName("LargeWStringStruct");
    m_typeSize = (uint32_t)LargeWStringStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = LargeWStringStruct::isKeyDefined();
    size_t keyLength = LargeWStringStruct::getKeyMaxCdrSerializedSize()>16 ? LargeWStringStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

LargeWStringStructPubSubType::~LargeWStringStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool LargeWStringStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    LargeWStringStruct *p_type = (LargeWStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool LargeWStringStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    LargeWStringStruct* p_type = (LargeWStringStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> LargeWStringStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<LargeWStringStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* LargeWStringStructPubSubType::createData()
{
    return (void*)new LargeWStringStruct();
}

void LargeWStringStructPubSubType::deleteData(void* data)
{
    delete((LargeWStringStruct*)data);
}

bool LargeWStringStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    LargeWStringStruct* p_type = (LargeWStringStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,LargeWStringStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(LargeWStringStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

ArraytStructPubSubType::ArraytStructPubSubType()
{
    setName("ArraytStruct");
    m_typeSize = (uint32_t)ArraytStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = ArraytStruct::isKeyDefined();
    size_t keyLength = ArraytStruct::getKeyMaxCdrSerializedSize()>16 ? ArraytStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

ArraytStructPubSubType::~ArraytStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool ArraytStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    ArraytStruct *p_type = (ArraytStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool ArraytStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    ArraytStruct* p_type = (ArraytStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> ArraytStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<ArraytStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* ArraytStructPubSubType::createData()
{
    return (void*)new ArraytStruct();
}

void ArraytStructPubSubType::deleteData(void* data)
{
    delete((ArraytStruct*)data);
}

bool ArraytStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    ArraytStruct* p_type = (ArraytStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ArraytStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(ArraytStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}


ArrayArrayStructPubSubType::ArrayArrayStructPubSubType()
{
    setName("ArrayArrayStruct");
    m_typeSize = (uint32_t)ArrayArrayStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = ArrayArrayStruct::isKeyDefined();
    size_t keyLength = ArrayArrayStruct::getKeyMaxCdrSerializedSize()>16 ? ArrayArrayStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

ArrayArrayStructPubSubType::~ArrayArrayStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool ArrayArrayStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    ArrayArrayStruct *p_type = (ArrayArrayStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool ArrayArrayStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    ArrayArrayStruct* p_type = (ArrayArrayStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> ArrayArrayStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<ArrayArrayStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* ArrayArrayStructPubSubType::createData()
{
    return (void*)new ArrayArrayStruct();
}

void ArrayArrayStructPubSubType::deleteData(void* data)
{
    delete((ArrayArrayStruct*)data);
}

bool ArrayArrayStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    ArrayArrayStruct* p_type = (ArrayArrayStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ArrayArrayStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(ArrayArrayStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

SequenceStructPubSubType::SequenceStructPubSubType()
{
    setName("SequenceStruct");
    m_typeSize = (uint32_t)SequenceStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = SequenceStruct::isKeyDefined();
    size_t keyLength = SequenceStruct::getKeyMaxCdrSerializedSize()>16 ? SequenceStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

SequenceStructPubSubType::~SequenceStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool SequenceStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    SequenceStruct *p_type = (SequenceStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool SequenceStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    SequenceStruct* p_type = (SequenceStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> SequenceStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<SequenceStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* SequenceStructPubSubType::createData()
{
    return (void*)new SequenceStruct();
}

void SequenceStructPubSubType::deleteData(void* data)
{
    delete((SequenceStruct*)data);
}

bool SequenceStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    SequenceStruct* p_type = (SequenceStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,SequenceStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(SequenceStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

SequenceSequenceStructPubSubType::SequenceSequenceStructPubSubType()
{
    setName("SequenceSequenceStruct");
    m_typeSize = (uint32_t)SequenceSequenceStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = SequenceSequenceStruct::isKeyDefined();
    size_t keyLength = SequenceSequenceStruct::getKeyMaxCdrSerializedSize()>16 ? SequenceSequenceStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

SequenceSequenceStructPubSubType::~SequenceSequenceStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool SequenceSequenceStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    SequenceSequenceStruct *p_type = (SequenceSequenceStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool SequenceSequenceStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    SequenceSequenceStruct* p_type = (SequenceSequenceStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> SequenceSequenceStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<SequenceSequenceStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* SequenceSequenceStructPubSubType::createData()
{
    return (void*)new SequenceSequenceStruct();
}

void SequenceSequenceStructPubSubType::deleteData(void* data)
{
    delete((SequenceSequenceStruct*)data);
}

bool SequenceSequenceStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    SequenceSequenceStruct* p_type = (SequenceSequenceStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,SequenceSequenceStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(SequenceSequenceStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

MapStructPubSubType::MapStructPubSubType()
{
    setName("MapStruct");
    m_typeSize = (uint32_t)MapStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = MapStruct::isKeyDefined();
    size_t keyLength = MapStruct::getKeyMaxCdrSerializedSize()>16 ? MapStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

MapStructPubSubType::~MapStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool MapStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    MapStruct *p_type = (MapStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool MapStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    MapStruct* p_type = (MapStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> MapStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<MapStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* MapStructPubSubType::createData()
{
    return (void*)new MapStruct();
}

void MapStructPubSubType::deleteData(void* data)
{
    delete((MapStruct*)data);
}

bool MapStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    MapStruct* p_type = (MapStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,MapStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(MapStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

MapMapStructPubSubType::MapMapStructPubSubType()
{
    setName("MapMapStruct");
    m_typeSize = (uint32_t)MapMapStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = MapMapStruct::isKeyDefined();
    size_t keyLength = MapMapStruct::getKeyMaxCdrSerializedSize()>16 ? MapMapStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

MapMapStructPubSubType::~MapMapStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool MapMapStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    MapMapStruct *p_type = (MapMapStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool MapMapStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    MapMapStruct* p_type = (MapMapStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> MapMapStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<MapMapStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* MapMapStructPubSubType::createData()
{
    return (void*)new MapMapStruct();
}

void MapMapStructPubSubType::deleteData(void* data)
{
    delete((MapMapStruct*)data);
}

bool MapMapStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    MapMapStruct* p_type = (MapMapStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,MapMapStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(MapMapStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

StructStructPubSubType::StructStructPubSubType()
{
    setName("StructStruct");
    m_typeSize = (uint32_t)StructStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = StructStruct::isKeyDefined();
    size_t keyLength = StructStruct::getKeyMaxCdrSerializedSize()>16 ? StructStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

StructStructPubSubType::~StructStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool StructStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    StructStruct *p_type = (StructStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool StructStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    StructStruct* p_type = (StructStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> StructStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<StructStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* StructStructPubSubType::createData()
{
    return (void*)new StructStruct();
}

void StructStructPubSubType::deleteData(void* data)
{
    delete((StructStruct*)data);
}

bool StructStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    StructStruct* p_type = (StructStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,StructStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(StructStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

StructStructStructPubSubType::StructStructStructPubSubType()
{
    setName("StructStructStruct");
    m_typeSize = (uint32_t)StructStructStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = StructStructStruct::isKeyDefined();
    size_t keyLength = StructStructStruct::getKeyMaxCdrSerializedSize()>16 ? StructStructStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

StructStructStructPubSubType::~StructStructStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool StructStructStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    StructStructStruct *p_type = (StructStructStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool StructStructStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    StructStructStruct* p_type = (StructStructStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> StructStructStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<StructStructStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* StructStructStructPubSubType::createData()
{
    return (void*)new StructStructStruct();
}

void StructStructStructPubSubType::deleteData(void* data)
{
    delete((StructStructStruct*)data);
}

bool StructStructStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    StructStructStruct* p_type = (StructStructStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,StructStructStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(StructStructStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}




SimpleUnionStructPubSubType::SimpleUnionStructPubSubType()
{
    setName("SimpleUnionStruct");
    m_typeSize = (uint32_t)SimpleUnionStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = SimpleUnionStruct::isKeyDefined();
    size_t keyLength = SimpleUnionStruct::getKeyMaxCdrSerializedSize()>16 ? SimpleUnionStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

SimpleUnionStructPubSubType::~SimpleUnionStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool SimpleUnionStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    SimpleUnionStruct *p_type = (SimpleUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool SimpleUnionStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    SimpleUnionStruct* p_type = (SimpleUnionStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> SimpleUnionStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<SimpleUnionStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* SimpleUnionStructPubSubType::createData()
{
    return (void*)new SimpleUnionStruct();
}

void SimpleUnionStructPubSubType::deleteData(void* data)
{
    delete((SimpleUnionStruct*)data);
}

bool SimpleUnionStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    SimpleUnionStruct* p_type = (SimpleUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,SimpleUnionStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(SimpleUnionStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

UnionUnionUnionStructPubSubType::UnionUnionUnionStructPubSubType()
{
    setName("UnionUnionUnionStruct");
    m_typeSize = (uint32_t)UnionUnionUnionStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = UnionUnionUnionStruct::isKeyDefined();
    size_t keyLength = UnionUnionUnionStruct::getKeyMaxCdrSerializedSize()>16 ? UnionUnionUnionStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

UnionUnionUnionStructPubSubType::~UnionUnionUnionStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool UnionUnionUnionStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    UnionUnionUnionStruct *p_type = (UnionUnionUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool UnionUnionUnionStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    UnionUnionUnionStruct* p_type = (UnionUnionUnionStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> UnionUnionUnionStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<UnionUnionUnionStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* UnionUnionUnionStructPubSubType::createData()
{
    return (void*)new UnionUnionUnionStruct();
}

void UnionUnionUnionStructPubSubType::deleteData(void* data)
{
    delete((UnionUnionUnionStruct*)data);
}

bool UnionUnionUnionStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    UnionUnionUnionStruct* p_type = (UnionUnionUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,UnionUnionUnionStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(UnionUnionUnionStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

WCharUnionStructPubSubType::WCharUnionStructPubSubType()
{
    setName("WCharUnionStruct");
    m_typeSize = (uint32_t)WCharUnionStruct::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = WCharUnionStruct::isKeyDefined();
    size_t keyLength = WCharUnionStruct::getKeyMaxCdrSerializedSize()>16 ? WCharUnionStruct::getKeyMaxCdrSerializedSize() : 16;
    m_keyBuffer = (unsigned char*)malloc(keyLength);
    memset(m_keyBuffer, 0, keyLength);
}

WCharUnionStructPubSubType::~WCharUnionStructPubSubType()
{
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool WCharUnionStructPubSubType::serialize(void *data, SerializedPayload_t *payload)
{
    WCharUnionStruct *p_type = (WCharUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool WCharUnionStructPubSubType::deserialize(SerializedPayload_t* payload, void* data)
{
    WCharUnionStruct* p_type = (WCharUnionStruct*) data;     //Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> WCharUnionStructPubSubType::getSerializedSizeProvider(void* data)
{
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<WCharUnionStruct*>(data)) + 4 /*encapsulation*/;
    };
}

void* WCharUnionStructPubSubType::createData()
{
    return (void*)new WCharUnionStruct();
}

void WCharUnionStructPubSubType::deleteData(void* data)
{
    delete((WCharUnionStruct*)data);
}

bool WCharUnionStructPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    WCharUnionStruct* p_type = (WCharUnionStruct*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,WCharUnionStruct::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
    p_type->serializeKey(ser);
    if(WCharUnionStruct::getKeyMaxCdrSerializedSize()>16)    {
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)        {
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

