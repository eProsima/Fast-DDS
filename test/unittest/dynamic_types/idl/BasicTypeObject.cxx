// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file BasicTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "Basic.h"
#include "BasicTypeObject.h"
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

BasicTypeFactory::BasicTypeFactory()
{
    registerTypes();
}

BasicTypeFactory::~BasicTypeFactory()
{
}

void BasicTypeFactory::registerTypes()
{
    TypeObjectFactory *factory = TypeObjectFactory::GetInstance();
    factory->AddTypeObject("MyEnum", GetMyEnumIdentifier(true), GetMyEnumObject(true));
    factory->AddTypeObject("MyEnum", GetMyEnumIdentifier(false), GetMyEnumObject(false));
    factory->AddTypeObject("MyAliasEnum", GetMyAliasEnumIdentifier(true), GetMyAliasEnumObject(true));
    factory->AddTypeObject("MyAliasEnum", GetMyAliasEnumIdentifier(false), GetMyAliasEnumObject(false));
    factory->AddTypeObject("MyAliasAliasEnum", GetMyAliasAliasEnumIdentifier(true), GetMyAliasAliasEnumObject(true));
    factory->AddTypeObject("MyAliasAliasEnum", GetMyAliasAliasEnumIdentifier(false), GetMyAliasAliasEnumObject(false));
    factory->AddTypeObject("EnumStruct", GetEnumStructIdentifier(true), GetEnumStructObject(true));
    factory->AddTypeObject("EnumStruct", GetEnumStructIdentifier(false), GetEnumStructObject(false));
    factory->AddTypeObject("AliasStruct", GetAliasStructIdentifier(true), GetAliasStructObject(true));
    factory->AddTypeObject("AliasStruct", GetAliasStructIdentifier(false), GetAliasStructObject(false));
    factory->AddTypeObject("AliasAliasStruct", GetAliasAliasStructIdentifier(true), GetAliasAliasStructObject(true));
    factory->AddTypeObject("AliasAliasStruct", GetAliasAliasStructIdentifier(false), GetAliasAliasStructObject(false));
    factory->AddTypeObject("BoolStruct", GetBoolStructIdentifier(true), GetBoolStructObject(true));
    factory->AddTypeObject("BoolStruct", GetBoolStructIdentifier(false), GetBoolStructObject(false));
    factory->AddTypeObject("OctetStruct", GetOctetStructIdentifier(true), GetOctetStructObject(true));
    factory->AddTypeObject("OctetStruct", GetOctetStructIdentifier(false), GetOctetStructObject(false));
    factory->AddTypeObject("ShortStruct", GetShortStructIdentifier(true), GetShortStructObject(true));
    factory->AddTypeObject("ShortStruct", GetShortStructIdentifier(false), GetShortStructObject(false));
    factory->AddTypeObject("LongStruct", GetLongStructIdentifier(true), GetLongStructObject(true));
    factory->AddTypeObject("LongStruct", GetLongStructIdentifier(false), GetLongStructObject(false));
    factory->AddTypeObject("LongLongStruct", GetLongLongStructIdentifier(true), GetLongLongStructObject(true));
    factory->AddTypeObject("LongLongStruct", GetLongLongStructIdentifier(false), GetLongLongStructObject(false));
    factory->AddTypeObject("UShortStruct", GetUShortStructIdentifier(true), GetUShortStructObject(true));
    factory->AddTypeObject("UShortStruct", GetUShortStructIdentifier(false), GetUShortStructObject(false));
    factory->AddTypeObject("ULongStruct", GetULongStructIdentifier(true), GetULongStructObject(true));
    factory->AddTypeObject("ULongStruct", GetULongStructIdentifier(false), GetULongStructObject(false));
    factory->AddTypeObject("ULongLongStruct", GetULongLongStructIdentifier(true), GetULongLongStructObject(true));
    factory->AddTypeObject("ULongLongStruct", GetULongLongStructIdentifier(false), GetULongLongStructObject(false));
    factory->AddTypeObject("FloatStruct", GetFloatStructIdentifier(true), GetFloatStructObject(true));
    factory->AddTypeObject("FloatStruct", GetFloatStructIdentifier(false), GetFloatStructObject(false));
    factory->AddTypeObject("DoubleStruct", GetDoubleStructIdentifier(true), GetDoubleStructObject(true));
    factory->AddTypeObject("DoubleStruct", GetDoubleStructIdentifier(false), GetDoubleStructObject(false));
    factory->AddTypeObject("LongDoubleStruct", GetLongDoubleStructIdentifier(true), GetLongDoubleStructObject(true));
    factory->AddTypeObject("LongDoubleStruct", GetLongDoubleStructIdentifier(false), GetLongDoubleStructObject(false));
    factory->AddTypeObject("CharStruct", GetCharStructIdentifier(true), GetCharStructObject(true));
    factory->AddTypeObject("CharStruct", GetCharStructIdentifier(false), GetCharStructObject(false));
    factory->AddTypeObject("WCharStruct", GetWCharStructIdentifier(true), GetWCharStructObject(true));
    factory->AddTypeObject("WCharStruct", GetWCharStructIdentifier(false), GetWCharStructObject(false));
    factory->AddTypeObject("StringStruct", GetStringStructIdentifier(true), GetStringStructObject(true));
    factory->AddTypeObject("StringStruct", GetStringStructIdentifier(false), GetStringStructObject(false));
    factory->AddTypeObject("WStringStruct", GetWStringStructIdentifier(true), GetWStringStructObject(true));
    factory->AddTypeObject("WStringStruct", GetWStringStructIdentifier(false), GetWStringStructObject(false));
    factory->AddTypeObject("LargeStringStruct", GetLargeStringStructIdentifier(true), GetLargeStringStructObject(true));
    factory->AddTypeObject("LargeStringStruct", GetLargeStringStructIdentifier(false), GetLargeStringStructObject(false));
    factory->AddTypeObject("LargeWStringStruct", GetLargeWStringStructIdentifier(true), GetLargeWStringStructObject(true));
    factory->AddTypeObject("LargeWStringStruct", GetLargeWStringStructIdentifier(false), GetLargeWStringStructObject(false));
    factory->AddTypeObject("ArraytStruct", GetArraytStructIdentifier(true), GetArraytStructObject(true));
    factory->AddTypeObject("ArraytStruct", GetArraytStructIdentifier(false), GetArraytStructObject(false));
    factory->AddTypeObject("MyArray", GetMyArrayIdentifier(true), GetMyArrayObject(true));
    factory->AddTypeObject("MyArray", GetMyArrayIdentifier(false), GetMyArrayObject(false));
    factory->AddTypeObject("ArrayArrayStruct", GetArrayArrayStructIdentifier(true), GetArrayArrayStructObject(true));
    factory->AddTypeObject("ArrayArrayStruct", GetArrayArrayStructIdentifier(false), GetArrayArrayStructObject(false));
    factory->AddTypeObject("SequenceStruct", GetSequenceStructIdentifier(true), GetSequenceStructObject(true));
    factory->AddTypeObject("SequenceStruct", GetSequenceStructIdentifier(false), GetSequenceStructObject(false));
    factory->AddTypeObject("SequenceSequenceStruct", GetSequenceSequenceStructIdentifier(true), GetSequenceSequenceStructObject(true));
    factory->AddTypeObject("SequenceSequenceStruct", GetSequenceSequenceStructIdentifier(false), GetSequenceSequenceStructObject(false));
    factory->AddTypeObject("MapStruct", GetMapStructIdentifier(true), GetMapStructObject(true));
    factory->AddTypeObject("MapStruct", GetMapStructIdentifier(false), GetMapStructObject(false));
    factory->AddTypeObject("MapMapStruct", GetMapMapStructIdentifier(true), GetMapMapStructObject(true));
    factory->AddTypeObject("MapMapStruct", GetMapMapStructIdentifier(false), GetMapMapStructObject(false));
    factory->AddTypeObject("StructStruct", GetStructStructIdentifier(true), GetStructStructObject(true));
    factory->AddTypeObject("StructStruct", GetStructStructIdentifier(false), GetStructStructObject(false));
    factory->AddTypeObject("StructStructStruct", GetStructStructStructIdentifier(true), GetStructStructStructObject(true));
    factory->AddTypeObject("StructStructStruct", GetStructStructStructIdentifier(false), GetStructStructStructObject(false));
    factory->AddTypeObject("SimpleUnion", GetSimpleUnionIdentifier(true), GetSimpleUnionObject(true));
    factory->AddTypeObject("SimpleUnion", GetSimpleUnionIdentifier(false), GetSimpleUnionObject(false));
    factory->AddTypeObject("UnionUnion", GetUnionUnionIdentifier(true), GetUnionUnionObject(true));
    factory->AddTypeObject("UnionUnion", GetUnionUnionIdentifier(false), GetUnionUnionObject(false));
    factory->AddTypeObject("WCharUnion", GetWCharUnionIdentifier(true), GetWCharUnionObject(true));
    factory->AddTypeObject("WCharUnion", GetWCharUnionIdentifier(false), GetWCharUnionObject(false));
    factory->AddTypeObject("SimpleUnionStruct", GetSimpleUnionStructIdentifier(true), GetSimpleUnionStructObject(true));
    factory->AddTypeObject("SimpleUnionStruct", GetSimpleUnionStructIdentifier(false), GetSimpleUnionStructObject(false));
    factory->AddTypeObject("UnionUnionUnionStruct", GetUnionUnionUnionStructIdentifier(true), GetUnionUnionUnionStructObject(true));
    factory->AddTypeObject("UnionUnionUnionStruct", GetUnionUnionUnionStructIdentifier(false), GetUnionUnionUnionStructObject(false));
    factory->AddTypeObject("WCharUnionStruct", GetWCharUnionStructIdentifier(true), GetWCharUnionStructObject(true));
    factory->AddTypeObject("WCharUnionStruct", GetWCharUnionStructIdentifier(false), GetWCharUnionStructObject(false));
}

const TypeIdentifier* BasicTypeFactory::GetTypeIdentifier(const std::string &type_name, bool complete)
{
    // Try general factory
    const TypeIdentifier *type_id = (complete)
            ? TypeObjectFactory::GetInstance()->GetTypeIdentifierTryingComplete(type_name)
            : TypeObjectFactory::GetInstance()->GetTypeIdentifier(type_name, false);
    if (type_id == nullptr) // For basic types, it's ok to accept non-complete
    {
        // Try users types.
        if (type_name == "MyEnum") return GetMyEnumIdentifier(complete);
        if (type_name == "MyAliasEnum") return GetMyAliasEnumIdentifier(complete);
        if (type_name == "MyAliasAliasEnum") return GetMyAliasAliasEnumIdentifier(complete);
        if (type_name == "EnumStruct") return GetEnumStructIdentifier(complete);
        if (type_name == "AliasStruct") return GetAliasStructIdentifier(complete);
        if (type_name == "AliasAliasStruct") return GetAliasAliasStructIdentifier(complete);
        if (type_name == "BoolStruct") return GetBoolStructIdentifier(complete);
        if (type_name == "OctetStruct") return GetOctetStructIdentifier(complete);
        if (type_name == "ShortStruct") return GetShortStructIdentifier(complete);
        if (type_name == "LongStruct") return GetLongStructIdentifier(complete);
        if (type_name == "LongLongStruct") return GetLongLongStructIdentifier(complete);
        if (type_name == "UShortStruct") return GetUShortStructIdentifier(complete);
        if (type_name == "ULongStruct") return GetULongStructIdentifier(complete);
        if (type_name == "ULongLongStruct") return GetULongLongStructIdentifier(complete);
        if (type_name == "FloatStruct") return GetFloatStructIdentifier(complete);
        if (type_name == "DoubleStruct") return GetDoubleStructIdentifier(complete);
        if (type_name == "LongDoubleStruct") return GetLongDoubleStructIdentifier(complete);
        if (type_name == "CharStruct") return GetCharStructIdentifier(complete);
        if (type_name == "WCharStruct") return GetWCharStructIdentifier(complete);
        if (type_name == "StringStruct") return GetStringStructIdentifier(complete);
        if (type_name == "WStringStruct") return GetWStringStructIdentifier(complete);
        if (type_name == "LargeStringStruct") return GetLargeStringStructIdentifier(complete);
        if (type_name == "LargeWStringStruct") return GetLargeWStringStructIdentifier(complete);
        if (type_name == "ArraytStruct") return GetArraytStructIdentifier(complete);
        if (type_name == "MyArray") return GetMyArrayIdentifier(complete);
        if (type_name == "ArrayArrayStruct") return GetArrayArrayStructIdentifier(complete);
        if (type_name == "SequenceStruct") return GetSequenceStructIdentifier(complete);
        if (type_name == "SequenceSequenceStruct") return GetSequenceSequenceStructIdentifier(complete);
        if (type_name == "MapStruct") return GetMapStructIdentifier(complete);
        if (type_name == "MapMapStruct") return GetMapMapStructIdentifier(complete);
        if (type_name == "StructStruct") return GetStructStructIdentifier(complete);
        if (type_name == "StructStructStruct") return GetStructStructStructIdentifier(complete);
        if (type_name == "SimpleUnion") return GetSimpleUnionIdentifier(complete);
        if (type_name == "UnionUnion") return GetUnionUnionIdentifier(complete);
        if (type_name == "WCharUnion") return GetWCharUnionIdentifier(complete);
        if (type_name == "SimpleUnionStruct") return GetSimpleUnionStructIdentifier(complete);
        if (type_name == "UnionUnionUnionStruct") return GetUnionUnionUnionStructIdentifier(complete);
        if (type_name == "WCharUnionStruct") return GetWCharUnionStructIdentifier(complete);
    }
    else
    {
        return type_id;
    }
    return nullptr;
}

const TypeObject* BasicTypeFactory::GetTypeObject(const std::string &type_name, bool complete)
{
    // Try general factory
    const TypeObject *type_id = TypeObjectFactory::GetInstance()->GetTypeObject(type_name, complete);
    if (type_id == nullptr || (complete && type_id->_d() == EK_MINIMAL))
    {
        // Try users types.
        if (type_name == "MyEnum")
        {
            GetMyEnumIdentifier(complete);
            return GetTypeObject("MyEnum", complete);
        }
        if (type_name == "MyAliasEnum")
        {
            GetMyAliasEnumIdentifier(complete);
            return GetTypeObject("MyAliasEnum", complete);
        }
        if (type_name == "MyAliasAliasEnum")
        {
            GetMyAliasAliasEnumIdentifier(complete);
            return GetTypeObject("MyAliasAliasEnum", complete);
        }
        if (type_name == "EnumStruct")
        {
            GetEnumStructIdentifier(complete);
            return GetTypeObject("EnumStruct", complete);
        }
        if (type_name == "AliasStruct")
        {
            GetAliasStructIdentifier(complete);
            return GetTypeObject("AliasStruct", complete);
        }
        if (type_name == "AliasAliasStruct")
        {
            GetAliasAliasStructIdentifier(complete);
            return GetTypeObject("AliasAliasStruct", complete);
        }
        if (type_name == "BoolStruct")
        {
            GetBoolStructIdentifier(complete);
            return GetTypeObject("BoolStruct", complete);
        }
        if (type_name == "OctetStruct")
        {
            GetOctetStructIdentifier(complete);
            return GetTypeObject("OctetStruct", complete);
        }
        if (type_name == "ShortStruct")
        {
            GetShortStructIdentifier(complete);
            return GetTypeObject("ShortStruct", complete);
        }
        if (type_name == "LongStruct")
        {
            GetLongStructIdentifier(complete);
            return GetTypeObject("LongStruct", complete);
        }
        if (type_name == "LongLongStruct")
        {
            GetLongLongStructIdentifier(complete);
            return GetTypeObject("LongLongStruct", complete);
        }
        if (type_name == "UShortStruct")
        {
            GetUShortStructIdentifier(complete);
            return GetTypeObject("UShortStruct", complete);
        }
        if (type_name == "ULongStruct")
        {
            GetULongStructIdentifier(complete);
            return GetTypeObject("ULongStruct", complete);
        }
        if (type_name == "ULongLongStruct")
        {
            GetULongLongStructIdentifier(complete);
            return GetTypeObject("ULongLongStruct", complete);
        }
        if (type_name == "FloatStruct")
        {
            GetFloatStructIdentifier(complete);
            return GetTypeObject("FloatStruct", complete);
        }
        if (type_name == "DoubleStruct")
        {
            GetDoubleStructIdentifier(complete);
            return GetTypeObject("DoubleStruct", complete);
        }
        if (type_name == "LongDoubleStruct")
        {
            GetLongDoubleStructIdentifier(complete);
            return GetTypeObject("LongDoubleStruct", complete);
        }
        if (type_name == "CharStruct")
        {
            GetCharStructIdentifier(complete);
            return GetTypeObject("CharStruct", complete);
        }
        if (type_name == "WCharStruct")
        {
            GetWCharStructIdentifier(complete);
            return GetTypeObject("WCharStruct", complete);
        }
        if (type_name == "StringStruct")
        {
            GetStringStructIdentifier(complete);
            return GetTypeObject("StringStruct", complete);
        }
        if (type_name == "WStringStruct")
        {
            GetWStringStructIdentifier(complete);
            return GetTypeObject("WStringStruct", complete);
        }
        if (type_name == "LargeStringStruct")
        {
            GetLargeStringStructIdentifier(complete);
            return GetTypeObject("LargeStringStruct", complete);
        }
        if (type_name == "LargeWStringStruct")
        {
            GetLargeWStringStructIdentifier(complete);
            return GetTypeObject("LargeWStringStruct", complete);
        }
        if (type_name == "ArraytStruct")
        {
            GetArraytStructIdentifier(complete);
            return GetTypeObject("ArraytStruct", complete);
        }
        if (type_name == "MyArray")
        {
            GetMyArrayIdentifier(complete);
            return GetTypeObject("MyArray", complete);
        }
        if (type_name == "ArrayArrayStruct")
        {
            GetArrayArrayStructIdentifier(complete);
            return GetTypeObject("ArrayArrayStruct", complete);
        }
        if (type_name == "SequenceStruct")
        {
            GetSequenceStructIdentifier(complete);
            return GetTypeObject("SequenceStruct", complete);
        }
        if (type_name == "SequenceSequenceStruct")
        {
            GetSequenceSequenceStructIdentifier(complete);
            return GetTypeObject("SequenceSequenceStruct", complete);
        }
        if (type_name == "MapStruct")
        {
            GetMapStructIdentifier(complete);
            return GetTypeObject("MapStruct", complete);
        }
        if (type_name == "MapMapStruct")
        {
            GetMapMapStructIdentifier(complete);
            return GetTypeObject("MapMapStruct", complete);
        }
        if (type_name == "StructStruct")
        {
            GetStructStructIdentifier(complete);
            return GetTypeObject("StructStruct", complete);
        }
        if (type_name == "StructStructStruct")
        {
            GetStructStructStructIdentifier(complete);
            return GetTypeObject("StructStructStruct", complete);
        }
        if (type_name == "SimpleUnion")
        {
            GetSimpleUnionIdentifier(complete);
            return GetTypeObject("SimpleUnion", complete);
        }
        if (type_name == "UnionUnion")
        {
            GetUnionUnionIdentifier(complete);
            return GetTypeObject("UnionUnion", complete);
        }
        if (type_name == "WCharUnion")
        {
            GetWCharUnionIdentifier(complete);
            return GetTypeObject("WCharUnion", complete);
        }
        if (type_name == "SimpleUnionStruct")
        {
            GetSimpleUnionStructIdentifier(complete);
            return GetTypeObject("SimpleUnionStruct", complete);
        }
        if (type_name == "UnionUnionUnionStruct")
        {
            GetUnionUnionUnionStructIdentifier(complete);
            return GetTypeObject("UnionUnionUnionStruct", complete);
        }
        if (type_name == "WCharUnionStruct")
        {
            GetWCharUnionStructIdentifier(complete);
            return GetTypeObject("WCharUnionStruct", complete);
        }
    }

    return type_id;
}

const TypeIdentifier* BasicTypeFactory::GetMyEnumIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyEnumObject(complete); // Generated inside
    return GetTypeIdentifier("MyEnum", complete);
}

const TypeObject* BasicTypeFactory::GetMyEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyEnumObject();
    }
    // else
    return GetMinimalMyEnumObject();
}

const TypeObject* BasicTypeFactory::GetMinimalMyEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);
    // Unused
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_A;
    mel_A.common().flags().TRY_CONSTRUCT1(false);
    mel_A.common().flags().TRY_CONSTRUCT2(false);
    mel_A.common().flags().IS_EXTERNAL(false);
    mel_A.common().flags().IS_OPTIONAL(false);
    mel_A.common().flags().IS_MUST_UNDERSTAND(false);
    mel_A.common().flags().IS_KEY(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().value(value++);
    MD5 A_hash("A");
    for(int i = 0; i < 4; ++i)
    {
        mel_A.detail().name_hash()[i] = A_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_A);

    MinimalEnumeratedLiteral mel_B;
    mel_B.common().flags().TRY_CONSTRUCT1(false);
    mel_B.common().flags().TRY_CONSTRUCT2(false);
    mel_B.common().flags().IS_EXTERNAL(false);
    mel_B.common().flags().IS_OPTIONAL(false);
    mel_B.common().flags().IS_MUST_UNDERSTAND(false);
    mel_B.common().flags().IS_KEY(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().value(value++);
    MD5 B_hash("B");
    for(int i = 0; i < 4; ++i)
    {
        mel_B.detail().name_hash()[i] = B_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_B);

    MinimalEnumeratedLiteral mel_C;
    mel_C.common().flags().TRY_CONSTRUCT1(false);
    mel_C.common().flags().TRY_CONSTRUCT2(false);
    mel_C.common().flags().IS_EXTERNAL(false);
    mel_C.common().flags().IS_OPTIONAL(false);
    mel_C.common().flags().IS_MUST_UNDERSTAND(false);
    mel_C.common().flags().IS_KEY(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().value(value++);
    MD5 C_hash("C");
    for(int i = 0; i < 4; ++i)
    {
        mel_C.detail().name_hash()[i] = C_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_C);


    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalEnumeratedType::getCdrSerializedSize(type_object->minimal().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyEnum", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMyEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    //type_object->complete().enumerated_type().header().detail().ann_builtin()...
    //type_object->complete().enumerated_type().header().detail().ann_custom()...
    type_object->complete().enumerated_type().header().detail().type_name("MyEnum");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_A;
    cel_A.common().flags().TRY_CONSTRUCT1(false);
    cel_A.common().flags().TRY_CONSTRUCT2(false);
    cel_A.common().flags().IS_EXTERNAL(false);
    cel_A.common().flags().IS_OPTIONAL(false);
    cel_A.common().flags().IS_MUST_UNDERSTAND(false);
    cel_A.common().flags().IS_KEY(false);
    cel_A.common().flags().IS_DEFAULT(false);
    cel_A.common().flags().IS_DEFAULT(false);
    cel_A.common().value(value++);
    cel_A.detail().name("A");
    //cel_A.detail().ann_builtin()...
    //cel_A.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_A);

    CompleteEnumeratedLiteral cel_B;
    cel_B.common().flags().TRY_CONSTRUCT1(false);
    cel_B.common().flags().TRY_CONSTRUCT2(false);
    cel_B.common().flags().IS_EXTERNAL(false);
    cel_B.common().flags().IS_OPTIONAL(false);
    cel_B.common().flags().IS_MUST_UNDERSTAND(false);
    cel_B.common().flags().IS_KEY(false);
    cel_B.common().flags().IS_DEFAULT(false);
    cel_B.common().flags().IS_DEFAULT(false);
    cel_B.common().value(value++);
    cel_B.detail().name("B");
    //cel_B.detail().ann_builtin()...
    //cel_B.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_B);

    CompleteEnumeratedLiteral cel_C;
    cel_C.common().flags().TRY_CONSTRUCT1(false);
    cel_C.common().flags().TRY_CONSTRUCT2(false);
    cel_C.common().flags().IS_EXTERNAL(false);
    cel_C.common().flags().IS_OPTIONAL(false);
    cel_C.common().flags().IS_MUST_UNDERSTAND(false);
    cel_C.common().flags().IS_KEY(false);
    cel_C.common().flags().IS_DEFAULT(false);
    cel_C.common().flags().IS_DEFAULT(false);
    cel_C.common().value(value++);
    cel_C.detail().name("C");
    //cel_C.detail().ann_builtin()...
    //cel_C.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_C);


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteEnumeratedType::getCdrSerializedSize(type_object->complete().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyEnum", true);
}

const TypeIdentifier* BasicTypeFactory::GetMyAliasEnumIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyAliasEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyAliasEnumObject(complete); // Generated inside
    return GetTypeIdentifier("MyAliasEnum", complete);
}

const TypeObject* BasicTypeFactory::GetMyAliasEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyAliasEnumObject();
    }
    else
    {
        return GetMinimalMyAliasEnumObject();
    }
}

const TypeObject* BasicTypeFactory::GetMinimalMyAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyEnum", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyAliasEnum", "MyEnum");

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMyAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyAliasEnum");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyEnum", true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyAliasEnum", "MyEnum");

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum", true);
}

const TypeIdentifier* BasicTypeFactory::GetMyAliasAliasEnumIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyAliasAliasEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyAliasAliasEnumObject(complete); // Generated inside
    return GetTypeIdentifier("MyAliasAliasEnum", complete);
}

const TypeObject* BasicTypeFactory::GetMyAliasAliasEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasAliasEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyAliasAliasEnumObject();
    }
    else
    {
        return GetMinimalMyAliasAliasEnumObject();
    }
}

const TypeObject* BasicTypeFactory::GetMinimalMyAliasAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasAliasEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyAliasAliasEnum", "MyAliasEnum");

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasAliasEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyAliasAliasEnum", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMyAliasAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasAliasEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyAliasAliasEnum");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum", true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyAliasAliasEnum", "MyAliasEnum");

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasAliasEnum", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyAliasAliasEnum", true);
}

const TypeIdentifier* BasicTypeFactory::GetEnumStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("EnumStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetEnumStructObject(complete); // Generated inside
    return GetTypeIdentifier("EnumStruct", complete);
}

const TypeObject* BasicTypeFactory::GetEnumStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("EnumStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteEnumStructObject();
    }
    //else
    return GetMinimalEnumStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalEnumStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("EnumStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_enum;
    mst_my_enum.common().member_id(memberId++);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_enum.common().member_flags().IS_KEY(false);
    mst_my_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_enum.common().member_type_id(*GetMyEnumIdentifier(false));
    MD5 my_enum_hash("my_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_enum.detail().name_hash()[i] = my_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_enum);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("EnumStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("EnumStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteEnumStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("EnumStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_enum;
    cst_my_enum.common().member_id(memberId++);
    cst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_enum.common().member_flags().IS_EXTERNAL(false);
    cst_my_enum.common().member_flags().IS_OPTIONAL(false);
    cst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_enum.common().member_flags().IS_KEY(false);
    cst_my_enum.common().member_flags().IS_DEFAULT(false);
    cst_my_enum.common().member_type_id(*GetMyEnumIdentifier(true));
    cst_my_enum.detail().name("my_enum");
    //cst_my_enum.detail().ann_builtin()...
    //cst_my_enum.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_enum);


    // Header
    type_object->complete().struct_type().header().detail().type_name("EnumStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("EnumStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("EnumStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetAliasStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("AliasStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAliasStructObject(complete); // Generated inside
    return GetTypeIdentifier("AliasStruct", complete);
}

const TypeObject* BasicTypeFactory::GetAliasStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAliasStructObject();
    }
    //else
    return GetMinimalAliasStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_alias;
    mst_my_alias.common().member_id(memberId++);
    mst_my_alias.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_alias.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_alias.common().member_flags().IS_EXTERNAL(false);
    mst_my_alias.common().member_flags().IS_OPTIONAL(false);
    mst_my_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_alias.common().member_flags().IS_KEY(false);
    mst_my_alias.common().member_flags().IS_DEFAULT(false);
    mst_my_alias.common().member_type_id(*GetMyAliasEnumIdentifier(false));
    MD5 my_alias_hash("my_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_alias.detail().name_hash()[i] = my_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("AliasStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("AliasStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_alias;
    cst_my_alias.common().member_id(memberId++);
    cst_my_alias.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_alias.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_alias.common().member_flags().IS_EXTERNAL(false);
    cst_my_alias.common().member_flags().IS_OPTIONAL(false);
    cst_my_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_alias.common().member_flags().IS_KEY(false);
    cst_my_alias.common().member_flags().IS_DEFAULT(false);
    cst_my_alias.common().member_type_id(*GetMyAliasEnumIdentifier(true));
    cst_my_alias.detail().name("my_alias");
    //cst_my_alias.detail().ann_builtin()...
    //cst_my_alias.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AliasStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("AliasStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("AliasStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetAliasAliasStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("AliasAliasStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAliasAliasStructObject(complete); // Generated inside
    return GetTypeIdentifier("AliasAliasStruct", complete);
}

const TypeObject* BasicTypeFactory::GetAliasAliasStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasAliasStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAliasAliasStructObject();
    }
    //else
    return GetMinimalAliasAliasStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalAliasAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasAliasStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_alias_alias;
    mst_my_alias_alias.common().member_id(memberId++);
    mst_my_alias_alias.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_alias_alias.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_alias_alias.common().member_flags().IS_EXTERNAL(false);
    mst_my_alias_alias.common().member_flags().IS_OPTIONAL(false);
    mst_my_alias_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_alias_alias.common().member_flags().IS_KEY(false);
    mst_my_alias_alias.common().member_flags().IS_DEFAULT(false);
    mst_my_alias_alias.common().member_type_id(*GetMyAliasAliasEnumIdentifier(false));
    MD5 my_alias_alias_hash("my_alias_alias");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_alias_alias.detail().name_hash()[i] = my_alias_alias_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_alias_alias);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("AliasAliasStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("AliasAliasStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteAliasAliasStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("AliasAliasStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_alias_alias;
    cst_my_alias_alias.common().member_id(memberId++);
    cst_my_alias_alias.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_alias_alias.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_alias_alias.common().member_flags().IS_EXTERNAL(false);
    cst_my_alias_alias.common().member_flags().IS_OPTIONAL(false);
    cst_my_alias_alias.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_alias_alias.common().member_flags().IS_KEY(false);
    cst_my_alias_alias.common().member_flags().IS_DEFAULT(false);
    cst_my_alias_alias.common().member_type_id(*GetMyAliasAliasEnumIdentifier(true));
    cst_my_alias_alias.detail().name("my_alias_alias");
    //cst_my_alias_alias.detail().ann_builtin()...
    //cst_my_alias_alias.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_alias_alias);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AliasAliasStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("AliasAliasStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("AliasAliasStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetBoolStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("BoolStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBoolStructObject(complete); // Generated inside
    return GetTypeIdentifier("BoolStruct", complete);
}

const TypeObject* BasicTypeFactory::GetBoolStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BoolStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBoolStructObject();
    }
    //else
    return GetMinimalBoolStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalBoolStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BoolStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_bool;
    mst_my_bool.common().member_id(memberId++);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_bool.common().member_flags().IS_EXTERNAL(false);
    mst_my_bool.common().member_flags().IS_OPTIONAL(false);
    mst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_bool.common().member_flags().IS_KEY(false);
    mst_my_bool.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "bool";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_bool.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_bool_hash("my_bool");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_bool.detail().name_hash()[i] = my_bool_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_bool);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("BoolStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("BoolStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteBoolStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BoolStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_bool;
    cst_my_bool.common().member_id(memberId++);
    cst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_bool.common().member_flags().IS_EXTERNAL(false);
    cst_my_bool.common().member_flags().IS_OPTIONAL(false);
    cst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_bool.common().member_flags().IS_KEY(false);
    cst_my_bool.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "bool";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_bool.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_bool.detail().name("my_bool");
    //cst_my_bool.detail().ann_builtin()...
    //cst_my_bool.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_bool);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BoolStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("BoolStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("BoolStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetOctetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("OctetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetOctetStructObject(complete); // Generated inside
    return GetTypeIdentifier("OctetStruct", complete);
}

const TypeObject* BasicTypeFactory::GetOctetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("OctetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteOctetStructObject();
    }
    //else
    return GetMinimalOctetStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("OctetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("OctetStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("OctetStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("OctetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_octet;
    cst_my_octet.common().member_id(memberId++);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_octet.common().member_flags().IS_KEY(false);
    cst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_octet.detail().name("my_octet");
    //cst_my_octet.detail().ann_builtin()...
    //cst_my_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("OctetStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("OctetStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("OctetStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetShortStructObject(complete); // Generated inside
    return GetTypeIdentifier("ShortStruct", complete);
}

const TypeObject* BasicTypeFactory::GetShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteShortStructObject();
    }
    //else
    return GetMinimalShortStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_int16;
    mst_my_int16.common().member_id(memberId++);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int16.common().member_flags().IS_EXTERNAL(false);
    mst_my_int16.common().member_flags().IS_OPTIONAL(false);
    mst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int16.common().member_flags().IS_KEY(false);
    mst_my_int16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int16_hash("my_int16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int16.detail().name_hash()[i] = my_int16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ShortStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ShortStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_int16;
    cst_my_int16.common().member_id(memberId++);
    cst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int16.common().member_flags().IS_EXTERNAL(false);
    cst_my_int16.common().member_flags().IS_OPTIONAL(false);
    cst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int16.common().member_flags().IS_KEY(false);
    cst_my_int16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int16.detail().name("my_int16");
    //cst_my_int16.detail().ann_builtin()...
    //cst_my_int16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ShortStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ShortStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ShortStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("LongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongStructObject(complete); // Generated inside
    return GetTypeIdentifier("LongStruct", complete);
}

const TypeObject* BasicTypeFactory::GetLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongStructObject();
    }
    //else
    return GetMinimalLongStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_int32;
    mst_my_int32.common().member_id(memberId++);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int32.common().member_flags().IS_EXTERNAL(false);
    mst_my_int32.common().member_flags().IS_OPTIONAL(false);
    mst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int32.common().member_flags().IS_KEY(false);
    mst_my_int32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int32_hash("my_int32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int32.detail().name_hash()[i] = my_int32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int32);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_int32;
    cst_my_int32.common().member_id(memberId++);
    cst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int32.common().member_flags().IS_EXTERNAL(false);
    cst_my_int32.common().member_flags().IS_OPTIONAL(false);
    cst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int32.common().member_flags().IS_KEY(false);
    cst_my_int32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int32.detail().name("my_int32");
    //cst_my_int32.detail().ann_builtin()...
    //cst_my_int32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int32);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("LongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongLongStructObject(complete); // Generated inside
    return GetTypeIdentifier("LongLongStruct", complete);
}

const TypeObject* BasicTypeFactory::GetLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongLongStructObject();
    }
    //else
    return GetMinimalLongLongStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_int64;
    mst_my_int64.common().member_id(memberId++);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int64.common().member_flags().IS_EXTERNAL(false);
    mst_my_int64.common().member_flags().IS_OPTIONAL(false);
    mst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int64.common().member_flags().IS_KEY(false);
    mst_my_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int64_hash("my_int64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int64.detail().name_hash()[i] = my_int64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int64);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongLongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongLongStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_int64;
    cst_my_int64.common().member_id(memberId++);
    cst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int64.common().member_flags().IS_EXTERNAL(false);
    cst_my_int64.common().member_flags().IS_OPTIONAL(false);
    cst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int64.common().member_flags().IS_KEY(false);
    cst_my_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int64.detail().name("my_int64");
    //cst_my_int64.detail().ann_builtin()...
    //cst_my_int64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int64);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongLongStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongLongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongLongStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetUShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("UShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUShortStructObject(complete); // Generated inside
    return GetTypeIdentifier("UShortStruct", complete);
}

const TypeObject* BasicTypeFactory::GetUShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUShortStructObject();
    }
    //else
    return GetMinimalUShortStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_uint16;
    mst_my_uint16.common().member_id(memberId++);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint16.common().member_flags().IS_KEY(false);
    mst_my_uint16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint16_hash("my_uint16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint16.detail().name_hash()[i] = my_uint16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UShortStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("UShortStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_uint16;
    cst_my_uint16.common().member_id(memberId++);
    cst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint16.common().member_flags().IS_KEY(false);
    cst_my_uint16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint16.detail().name("my_uint16");
    //cst_my_uint16.detail().ann_builtin()...
    //cst_my_uint16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UShortStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UShortStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("UShortStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetULongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ULongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetULongStructObject(complete); // Generated inside
    return GetTypeIdentifier("ULongStruct", complete);
}

const TypeObject* BasicTypeFactory::GetULongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteULongStructObject();
    }
    //else
    return GetMinimalULongStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_uint32;
    mst_my_uint32.common().member_id(memberId++);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint32.common().member_flags().IS_KEY(false);
    mst_my_uint32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint32_hash("my_uint32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint32.detail().name_hash()[i] = my_uint32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint32);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ULongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ULongStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_uint32;
    cst_my_uint32.common().member_id(memberId++);
    cst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint32.common().member_flags().IS_KEY(false);
    cst_my_uint32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint32.detail().name("my_uint32");
    //cst_my_uint32.detail().ann_builtin()...
    //cst_my_uint32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint32);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ULongStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ULongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ULongStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetULongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ULongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetULongLongStructObject(complete); // Generated inside
    return GetTypeIdentifier("ULongLongStruct", complete);
}

const TypeObject* BasicTypeFactory::GetULongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteULongLongStructObject();
    }
    //else
    return GetMinimalULongLongStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_uint64;
    mst_my_uint64.common().member_id(memberId++);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint64.common().member_flags().IS_KEY(false);
    mst_my_uint64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint64_hash("my_uint64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint64.detail().name_hash()[i] = my_uint64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint64);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ULongLongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ULongLongStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ULongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_uint64;
    cst_my_uint64.common().member_id(memberId++);
    cst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint64.common().member_flags().IS_KEY(false);
    cst_my_uint64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint64.detail().name("my_uint64");
    //cst_my_uint64.detail().ann_builtin()...
    //cst_my_uint64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint64);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ULongLongStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ULongLongStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ULongLongStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetFloatStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("FloatStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetFloatStructObject(complete); // Generated inside
    return GetTypeIdentifier("FloatStruct", complete);
}

const TypeObject* BasicTypeFactory::GetFloatStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("FloatStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteFloatStructObject();
    }
    //else
    return GetMinimalFloatStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("FloatStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_float32;
    mst_my_float32.common().member_id(memberId++);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float32.common().member_flags().IS_EXTERNAL(false);
    mst_my_float32.common().member_flags().IS_OPTIONAL(false);
    mst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float32.common().member_flags().IS_KEY(false);
    mst_my_float32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "float";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float32_hash("my_float32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float32.detail().name_hash()[i] = my_float32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float32);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("FloatStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("FloatStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("FloatStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_float32;
    cst_my_float32.common().member_id(memberId++);
    cst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float32.common().member_flags().IS_EXTERNAL(false);
    cst_my_float32.common().member_flags().IS_OPTIONAL(false);
    cst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float32.common().member_flags().IS_KEY(false);
    cst_my_float32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "float";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float32.detail().name("my_float32");
    //cst_my_float32.detail().ann_builtin()...
    //cst_my_float32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float32);


    // Header
    type_object->complete().struct_type().header().detail().type_name("FloatStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("FloatStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("FloatStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("DoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetDoubleStructObject(complete); // Generated inside
    return GetTypeIdentifier("DoubleStruct", complete);
}

const TypeObject* BasicTypeFactory::GetDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("DoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteDoubleStructObject();
    }
    //else
    return GetMinimalDoubleStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("DoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_float64;
    mst_my_float64.common().member_id(memberId++);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float64.common().member_flags().IS_EXTERNAL(false);
    mst_my_float64.common().member_flags().IS_OPTIONAL(false);
    mst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float64.common().member_flags().IS_KEY(false);
    mst_my_float64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float64_hash("my_float64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float64.detail().name_hash()[i] = my_float64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float64);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("DoubleStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("DoubleStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("DoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_float64;
    cst_my_float64.common().member_id(memberId++);
    cst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float64.common().member_flags().IS_EXTERNAL(false);
    cst_my_float64.common().member_flags().IS_OPTIONAL(false);
    cst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float64.common().member_flags().IS_KEY(false);
    cst_my_float64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float64.detail().name("my_float64");
    //cst_my_float64.detail().ann_builtin()...
    //cst_my_float64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float64);


    // Header
    type_object->complete().struct_type().header().detail().type_name("DoubleStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("DoubleStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("DoubleStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetLongDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("LongDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLongDoubleStructObject(complete); // Generated inside
    return GetTypeIdentifier("LongDoubleStruct", complete);
}

const TypeObject* BasicTypeFactory::GetLongDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLongDoubleStructObject();
    }
    //else
    return GetMinimalLongDoubleStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_float128;
    mst_my_float128.common().member_id(memberId++);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float128.common().member_flags().IS_EXTERNAL(false);
    mst_my_float128.common().member_flags().IS_OPTIONAL(false);
    mst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float128.common().member_flags().IS_KEY(false);
    mst_my_float128.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "long double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float128.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float128_hash("my_float128");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float128.detail().name_hash()[i] = my_float128_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float128);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongDoubleStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LongDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_float128;
    cst_my_float128.common().member_id(memberId++);
    cst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float128.common().member_flags().IS_EXTERNAL(false);
    cst_my_float128.common().member_flags().IS_OPTIONAL(false);
    cst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float128.common().member_flags().IS_KEY(false);
    cst_my_float128.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "long double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float128.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float128.detail().name("my_float128");
    //cst_my_float128.detail().ann_builtin()...
    //cst_my_float128.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float128);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LongDoubleStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LongDoubleStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LongDoubleStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("CharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCharStructObject(complete); // Generated inside
    return GetTypeIdentifier("CharStruct", complete);
}

const TypeObject* BasicTypeFactory::GetCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCharStructObject();
    }
    //else
    return GetMinimalCharStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_char;
    mst_my_char.common().member_id(memberId++);
    mst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_char.common().member_flags().IS_EXTERNAL(false);
    mst_my_char.common().member_flags().IS_OPTIONAL(false);
    mst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_char.common().member_flags().IS_KEY(false);
    mst_my_char.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "char";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_char.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_char_hash("my_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_char.detail().name_hash()[i] = my_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_char);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("CharStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("CharStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_char;
    cst_my_char.common().member_id(memberId++);
    cst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_char.common().member_flags().IS_EXTERNAL(false);
    cst_my_char.common().member_flags().IS_OPTIONAL(false);
    cst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_char.common().member_flags().IS_KEY(false);
    cst_my_char.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "char";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_char.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_char.detail().name("my_char");
    //cst_my_char.detail().ann_builtin()...
    //cst_my_char.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_char);


    // Header
    type_object->complete().struct_type().header().detail().type_name("CharStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("CharStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("CharStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetWCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("WCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWCharStructObject(complete); // Generated inside
    return GetTypeIdentifier("WCharStruct", complete);
}

const TypeObject* BasicTypeFactory::GetWCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWCharStructObject();
    }
    //else
    return GetMinimalWCharStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_wchar;
    mst_my_wchar.common().member_id(memberId++);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    mst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wchar.common().member_flags().IS_KEY(false);
    mst_my_wchar.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "wchar_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_wchar.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_wchar_hash("my_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wchar.detail().name_hash()[i] = my_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wchar);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WCharStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_wchar;
    cst_my_wchar.common().member_id(memberId++);
    cst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    cst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_wchar.common().member_flags().IS_KEY(false);
    cst_my_wchar.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "wchar_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_wchar.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_wchar.detail().name("my_wchar");
    //cst_my_wchar.detail().ann_builtin()...
    //cst_my_wchar.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_wchar);


    // Header
    type_object->complete().struct_type().header().detail().type_name("WCharStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WCharStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("StringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStringStructObject(complete); // Generated inside
    return GetTypeIdentifier("StringStruct", complete);
}

const TypeObject* BasicTypeFactory::GetStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStringStructObject();
    }
    //else
    return GetMinimalStringStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_string;
    mst_my_string.common().member_id(memberId++);
    mst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_string.common().member_flags().IS_KEY(false);
    mst_my_string.common().member_flags().IS_DEFAULT(false);
    mst_my_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    MD5 my_string_hash("my_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_string.detail().name_hash()[i] = my_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StringStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_string;
    cst_my_string.common().member_id(memberId++);
    cst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_string.common().member_flags().IS_EXTERNAL(false);
    cst_my_string.common().member_flags().IS_OPTIONAL(false);
    cst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_string.common().member_flags().IS_KEY(false);
    cst_my_string.common().member_flags().IS_DEFAULT(false);
    cst_my_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    cst_my_string.detail().name("my_string");
    //cst_my_string.detail().ann_builtin()...
    //cst_my_string.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StringStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StringStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetWStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("WStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWStringStructObject(complete); // Generated inside
    return GetTypeIdentifier("WStringStruct", complete);
}

const TypeObject* BasicTypeFactory::GetWStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWStringStructObject();
    }
    //else
    return GetMinimalWStringStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_wstring;
    mst_my_wstring.common().member_id(memberId++);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    mst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wstring.common().member_flags().IS_KEY(false);
    mst_my_wstring.common().member_flags().IS_DEFAULT(false);
    mst_my_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, true));


    MD5 my_wstring_hash("my_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wstring.detail().name_hash()[i] = my_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WStringStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_wstring;
    cst_my_wstring.common().member_id(memberId++);
    cst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    cst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_wstring.common().member_flags().IS_KEY(false);
    cst_my_wstring.common().member_flags().IS_DEFAULT(false);
    cst_my_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, true));


    cst_my_wstring.detail().name("my_wstring");
    //cst_my_wstring.detail().ann_builtin()...
    //cst_my_wstring.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("WStringStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WStringStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetLargeStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("LargeStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLargeStringStructObject(complete); // Generated inside
    return GetTypeIdentifier("LargeStringStruct", complete);
}

const TypeObject* BasicTypeFactory::GetLargeStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLargeStringStructObject();
    }
    //else
    return GetMinimalLargeStringStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalLargeStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_large_string;
    mst_my_large_string.common().member_id(memberId++);
    mst_my_large_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string.common().member_flags().IS_KEY(false);
    mst_my_large_string.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(41925, false));


    MD5 my_large_string_hash("my_large_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string.detail().name_hash()[i] = my_large_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LargeStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LargeStringStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteLargeStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_large_string;
    cst_my_large_string.common().member_id(memberId++);
    cst_my_large_string.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_large_string.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_large_string.common().member_flags().IS_EXTERNAL(false);
    cst_my_large_string.common().member_flags().IS_OPTIONAL(false);
    cst_my_large_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_large_string.common().member_flags().IS_KEY(false);
    cst_my_large_string.common().member_flags().IS_DEFAULT(false);
    cst_my_large_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(41925, false));


    cst_my_large_string.detail().name("my_large_string");
    //cst_my_large_string.detail().ann_builtin()...
    //cst_my_large_string.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_large_string);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LargeStringStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LargeStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LargeStringStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetLargeWStringStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("LargeWStringStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLargeWStringStructObject(complete); // Generated inside
    return GetTypeIdentifier("LargeWStringStruct", complete);
}

const TypeObject* BasicTypeFactory::GetLargeWStringStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeWStringStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLargeWStringStructObject();
    }
    //else
    return GetMinimalLargeWStringStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalLargeWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeWStringStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_large_wstring;
    mst_my_large_wstring.common().member_id(memberId++);
    mst_my_large_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_wstring.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_wstring.common().member_flags().IS_KEY(false);
    mst_my_large_wstring.common().member_flags().IS_DEFAULT(false);
    mst_my_large_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(41925, true));


    MD5 my_large_wstring_hash("my_large_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_wstring.detail().name_hash()[i] = my_large_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LargeWStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LargeWStringStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteLargeWStringStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("LargeWStringStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_large_wstring;
    cst_my_large_wstring.common().member_id(memberId++);
    cst_my_large_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_large_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_large_wstring.common().member_flags().IS_EXTERNAL(false);
    cst_my_large_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_my_large_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_large_wstring.common().member_flags().IS_KEY(false);
    cst_my_large_wstring.common().member_flags().IS_DEFAULT(false);
    cst_my_large_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(41925, true));


    cst_my_large_wstring.detail().name("my_large_wstring");
    //cst_my_large_wstring.detail().ann_builtin()...
    //cst_my_large_wstring.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_large_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LargeWStringStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("LargeWStringStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("LargeWStringStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetArraytStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ArraytStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArraytStructObject(complete); // Generated inside
    return GetTypeIdentifier("ArraytStruct", complete);
}

const TypeObject* BasicTypeFactory::GetArraytStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArraytStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArraytStructObject();
    }
    //else
    return GetMinimalArraytStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalArraytStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArraytStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_array;
    mst_my_array.common().member_id(memberId++);
    mst_my_array.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array.common().member_flags().IS_EXTERNAL(false);
    mst_my_array.common().member_flags().IS_OPTIONAL(false);
    mst_my_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array.common().member_flags().IS_KEY(false);
    mst_my_array.common().member_flags().IS_DEFAULT(false);
    mst_my_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("int32_t", {2, 2, 2}, false));


    MD5 my_array_hash("my_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array.detail().name_hash()[i] = my_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ArraytStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ArraytStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteArraytStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArraytStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_array;
    cst_my_array.common().member_id(memberId++);
    cst_my_array.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array.common().member_flags().IS_EXTERNAL(false);
    cst_my_array.common().member_flags().IS_OPTIONAL(false);
    cst_my_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array.common().member_flags().IS_KEY(false);
    cst_my_array.common().member_flags().IS_DEFAULT(false);
    cst_my_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("int32_t", {2, 2, 2}, true));


    cst_my_array.detail().name("my_array");
    //cst_my_array.detail().ann_builtin()...
    //cst_my_array.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArraytStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ArraytStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ArraytStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetMyArrayIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyArray", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyArrayObject(complete); // Generated inside
    return GetTypeIdentifier("MyArray", complete);
}

const TypeObject* BasicTypeFactory::GetMyArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyArrayObject();
    }
    else
    {
        return GetMinimalMyArrayObject();
    }
}

const TypeObject* BasicTypeFactory::GetMinimalMyArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("int32_t", {2, 2}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalAliasType::getCdrSerializedSize(type_object->minimal().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyArray", TypeNamesGenerator::getArrayTypeName("int32_t", {2, 2}));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyArray", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyArray", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMyArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyArray");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("int32_t", {2, 2}), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteAliasType::getCdrSerializedSize(type_object->complete().alias_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    // Don't add our TypeIdentifier but our alias
    TypeObjectFactory::GetInstance()->AddAlias("MyArray", TypeNamesGenerator::getArrayTypeName("int32_t", {2, 2}));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyArray", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MyArray", true);
}

const TypeIdentifier* BasicTypeFactory::GetArrayArrayStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ArrayArrayStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetArrayArrayStructObject(complete); // Generated inside
    return GetTypeIdentifier("ArrayArrayStruct", complete);
}

const TypeObject* BasicTypeFactory::GetArrayArrayStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArrayArrayStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteArrayArrayStructObject();
    }
    //else
    return GetMinimalArrayArrayStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalArrayArrayStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArrayArrayStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_array_array;
    mst_my_array_array.common().member_id(memberId++);
    mst_my_array_array.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_array.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_array.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_array.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_array.common().member_flags().IS_KEY(false);
    mst_my_array_array.common().member_flags().IS_DEFAULT(false);
    mst_my_array_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyArray", {2, 2}, false));


    MD5 my_array_array_hash("my_array_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_array.detail().name_hash()[i] = my_array_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ArrayArrayStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ArrayArrayStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteArrayArrayStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ArrayArrayStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_array_array;
    cst_my_array_array.common().member_id(memberId++);
    cst_my_array_array.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array_array.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array_array.common().member_flags().IS_EXTERNAL(false);
    cst_my_array_array.common().member_flags().IS_OPTIONAL(false);
    cst_my_array_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array_array.common().member_flags().IS_KEY(false);
    cst_my_array_array.common().member_flags().IS_DEFAULT(false);
    cst_my_array_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyArray", {2, 2}, true));


    cst_my_array_array.detail().name("my_array_array");
    //cst_my_array_array.detail().ann_builtin()...
    //cst_my_array_array.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ArrayArrayStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ArrayArrayStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ArrayArrayStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetSequenceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("SequenceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceStructObject(complete); // Generated inside
    return GetTypeIdentifier("SequenceStruct", complete);
}

const TypeObject* BasicTypeFactory::GetSequenceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceStructObject();
    }
    //else
    return GetMinimalSequenceStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_sequence;
    mst_my_sequence.common().member_id(memberId++);
    mst_my_sequence.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence.common().member_flags().IS_KEY(false);
    mst_my_sequence.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("int32_t", 2, false));


    MD5 my_sequence_hash("my_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence.detail().name_hash()[i] = my_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SequenceStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SequenceStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_sequence;
    cst_my_sequence.common().member_id(memberId++);
    cst_my_sequence.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_sequence.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_sequence.common().member_flags().IS_EXTERNAL(false);
    cst_my_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_my_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_sequence.common().member_flags().IS_KEY(false);
    cst_my_sequence.common().member_flags().IS_DEFAULT(false);
    cst_my_sequence.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("int32_t", 2, true));


    cst_my_sequence.detail().name("my_sequence");
    //cst_my_sequence.detail().ann_builtin()...
    //cst_my_sequence.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SequenceStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SequenceStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetSequenceSequenceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("SequenceSequenceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSequenceSequenceStructObject(complete); // Generated inside
    return GetTypeIdentifier("SequenceSequenceStruct", complete);
}

const TypeObject* BasicTypeFactory::GetSequenceSequenceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceSequenceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSequenceSequenceStructObject();
    }
    //else
    return GetMinimalSequenceSequenceStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalSequenceSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceSequenceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_sequence_sequence;
    mst_my_sequence_sequence.common().member_id(memberId++);
    mst_my_sequence_sequence.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_sequence.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_sequence.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_sequence.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_sequence.common().member_flags().IS_KEY(false);
    mst_my_sequence_sequence.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_sequence.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier(TypeNamesGenerator::getSequenceTypeName("int32_t", 2), 3, false));


    MD5 my_sequence_sequence_hash("my_sequence_sequence");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_sequence.detail().name_hash()[i] = my_sequence_sequence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_sequence);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SequenceSequenceStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SequenceSequenceStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteSequenceSequenceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SequenceSequenceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_sequence_sequence;
    cst_my_sequence_sequence.common().member_id(memberId++);
    cst_my_sequence_sequence.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_sequence_sequence.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_sequence_sequence.common().member_flags().IS_EXTERNAL(false);
    cst_my_sequence_sequence.common().member_flags().IS_OPTIONAL(false);
    cst_my_sequence_sequence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_sequence_sequence.common().member_flags().IS_KEY(false);
    cst_my_sequence_sequence.common().member_flags().IS_DEFAULT(false);
    cst_my_sequence_sequence.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier(TypeNamesGenerator::getSequenceTypeName("int32_t", 2), 3, true));


    cst_my_sequence_sequence.detail().name("my_sequence_sequence");
    //cst_my_sequence_sequence.detail().ann_builtin()...
    //cst_my_sequence_sequence.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_sequence_sequence);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SequenceSequenceStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SequenceSequenceStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SequenceSequenceStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetMapStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MapStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapStructObject(complete); // Generated inside
    return GetTypeIdentifier("MapStruct", complete);
}

const TypeObject* BasicTypeFactory::GetMapStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapStructObject();
    }
    //else
    return GetMinimalMapStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_map;
    mst_my_map.common().member_id(memberId++);
    mst_my_map.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map.common().member_flags().IS_EXTERNAL(false);
    mst_my_map.common().member_flags().IS_OPTIONAL(false);
    mst_my_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map.common().member_flags().IS_KEY(false);
    mst_my_map.common().member_flags().IS_DEFAULT(false);
    mst_my_map.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "int32_t", 2, false));


    MD5 my_map_hash("my_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map.detail().name_hash()[i] = my_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MapStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MapStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_map;
    cst_my_map.common().member_id(memberId++);
    cst_my_map.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map.common().member_flags().IS_EXTERNAL(false);
    cst_my_map.common().member_flags().IS_OPTIONAL(false);
    cst_my_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map.common().member_flags().IS_KEY(false);
    cst_my_map.common().member_flags().IS_DEFAULT(false);
    cst_my_map.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "int32_t", 2, true));


    cst_my_map.detail().name("my_map");
    //cst_my_map.detail().ann_builtin()...
    //cst_my_map.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MapStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MapStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetMapMapStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MapMapStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMapMapStructObject(complete); // Generated inside
    return GetTypeIdentifier("MapMapStruct", complete);
}

const TypeObject* BasicTypeFactory::GetMapMapStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapMapStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMapMapStructObject();
    }
    //else
    return GetMinimalMapMapStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalMapMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapMapStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_map_map;
    mst_my_map_map.common().member_id(memberId++);
    mst_my_map_map.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_map.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_map.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_map.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_map.common().member_flags().IS_KEY(false);
    mst_my_map_map.common().member_flags().IS_DEFAULT(false);
    mst_my_map_map.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getMapTypeName("int32_t", "int32_t", 2), 2, false));


    MD5 my_map_map_hash("my_map_map");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_map.detail().name_hash()[i] = my_map_map_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_map);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MapMapStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MapMapStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteMapMapStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MapMapStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_map_map;
    cst_my_map_map.common().member_id(memberId++);
    cst_my_map_map.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_map.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_map.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_map.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_map.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_map.common().member_flags().IS_KEY(false);
    cst_my_map_map.common().member_flags().IS_DEFAULT(false);
    cst_my_map_map.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getMapTypeName("int32_t", "int32_t", 2), 2, true));


    cst_my_map_map.detail().name("my_map_map");
    //cst_my_map_map.detail().ann_builtin()...
    //cst_my_map_map.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_map);


    // Header
    type_object->complete().struct_type().header().detail().type_name("MapMapStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MapMapStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("MapMapStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetStructStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("StructStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructStructObject(complete); // Generated inside
    return GetTypeIdentifier("StructStruct", complete);
}

const TypeObject* BasicTypeFactory::GetStructStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructStructObject();
    }
    //else
    return GetMinimalStructStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_a;
    mst_a.common().member_id(memberId++);
    mst_a.common().member_flags().TRY_CONSTRUCT1(false);
    mst_a.common().member_flags().TRY_CONSTRUCT2(false);
    mst_a.common().member_flags().IS_EXTERNAL(false);
    mst_a.common().member_flags().IS_OPTIONAL(false);
    mst_a.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_a.common().member_flags().IS_KEY(false);
    mst_a.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_a.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 a_hash("a");
    for(int i = 0; i < 4; ++i)
    {
        mst_a.detail().name_hash()[i] = a_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_a);

    MinimalStructMember mst_b;
    mst_b.common().member_id(memberId++);
    mst_b.common().member_flags().TRY_CONSTRUCT1(false);
    mst_b.common().member_flags().TRY_CONSTRUCT2(false);
    mst_b.common().member_flags().IS_EXTERNAL(false);
    mst_b.common().member_flags().IS_OPTIONAL(false);
    mst_b.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_b.common().member_flags().IS_KEY(false);
    mst_b.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_b.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 b_hash("b");
    for(int i = 0; i < 4; ++i)
    {
        mst_b.detail().name_hash()[i] = b_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_b);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StructStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StructStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_a;
    cst_a.common().member_id(memberId++);
    cst_a.common().member_flags().TRY_CONSTRUCT1(false);
    cst_a.common().member_flags().TRY_CONSTRUCT2(false);
    cst_a.common().member_flags().IS_EXTERNAL(false);
    cst_a.common().member_flags().IS_OPTIONAL(false);
    cst_a.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_a.common().member_flags().IS_KEY(false);
    cst_a.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_a.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_a.detail().name("a");
    //cst_a.detail().ann_builtin()...
    //cst_a.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_a);

    CompleteStructMember cst_b;
    cst_b.common().member_id(memberId++);
    cst_b.common().member_flags().TRY_CONSTRUCT1(false);
    cst_b.common().member_flags().TRY_CONSTRUCT2(false);
    cst_b.common().member_flags().IS_EXTERNAL(false);
    cst_b.common().member_flags().IS_OPTIONAL(false);
    cst_b.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_b.common().member_flags().IS_KEY(false);
    cst_b.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_b.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_b.detail().name("b");
    //cst_b.detail().ann_builtin()...
    //cst_b.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_b);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StructStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StructStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetStructStructStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("StructStructStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetStructStructStructObject(complete); // Generated inside
    return GetTypeIdentifier("StructStructStruct", complete);
}

const TypeObject* BasicTypeFactory::GetStructStructStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStructStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteStructStructStructObject();
    }
    //else
    return GetMinimalStructStructStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalStructStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStructStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_child_struct;
    mst_child_struct.common().member_id(memberId++);
    mst_child_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_child_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_child_struct.common().member_flags().IS_EXTERNAL(false);
    mst_child_struct.common().member_flags().IS_OPTIONAL(false);
    mst_child_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_child_struct.common().member_flags().IS_KEY(false);
    mst_child_struct.common().member_flags().IS_DEFAULT(false);
    mst_child_struct.common().member_type_id(*GetStructStructIdentifier(false));
    MD5 child_struct_hash("child_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_child_struct.detail().name_hash()[i] = child_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_child_struct);

    MinimalStructMember mst_child_int64;
    mst_child_int64.common().member_id(memberId++);
    mst_child_int64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_child_int64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_child_int64.common().member_flags().IS_EXTERNAL(false);
    mst_child_int64.common().member_flags().IS_OPTIONAL(false);
    mst_child_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_child_int64.common().member_flags().IS_KEY(false);
    mst_child_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_child_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 child_int64_hash("child_int64");
    for(int i = 0; i < 4; ++i)
    {
        mst_child_int64.detail().name_hash()[i] = child_int64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_child_int64);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StructStructStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StructStructStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteStructStructStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("StructStructStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_child_struct;
    cst_child_struct.common().member_id(memberId++);
    cst_child_struct.common().member_flags().TRY_CONSTRUCT1(false);
    cst_child_struct.common().member_flags().TRY_CONSTRUCT2(false);
    cst_child_struct.common().member_flags().IS_EXTERNAL(false);
    cst_child_struct.common().member_flags().IS_OPTIONAL(false);
    cst_child_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_child_struct.common().member_flags().IS_KEY(false);
    cst_child_struct.common().member_flags().IS_DEFAULT(false);
    cst_child_struct.common().member_type_id(*GetStructStructIdentifier(true));
    cst_child_struct.detail().name("child_struct");
    //cst_child_struct.detail().ann_builtin()...
    //cst_child_struct.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_child_struct);

    CompleteStructMember cst_child_int64;
    cst_child_int64.common().member_id(memberId++);
    cst_child_int64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_child_int64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_child_int64.common().member_flags().IS_EXTERNAL(false);
    cst_child_int64.common().member_flags().IS_OPTIONAL(false);
    cst_child_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_child_int64.common().member_flags().IS_KEY(false);
    cst_child_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_child_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_child_int64.detail().name("child_int64");
    //cst_child_int64.detail().ann_builtin()...
    //cst_child_int64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_child_int64);


    // Header
    type_object->complete().struct_type().header().detail().type_name("StructStructStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("StructStructStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("StructStructStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetSimpleUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("SimpleUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSimpleUnionObject(complete);
    return GetTypeIdentifier("SimpleUnion", complete);
}

const TypeObject* BasicTypeFactory::GetSimpleUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSimpleUnionObject();
    }
    // else
    return GetMinimalSimpleUnionObject();
}

const TypeObject* BasicTypeFactory::GetMinimalSimpleUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetTypeIdentifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false);
    mst_first.common().member_flags().TRY_CONSTRUCT2(false);
    mst_first.common().member_flags().IS_EXTERNAL(false);
    mst_first.common().member_flags().IS_OPTIONAL(false);
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_first.common().member_flags().IS_KEY(false);
    mst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_first.common().label_seq().emplace_back(A);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false);
    mst_second.common().member_flags().TRY_CONSTRUCT2(false);
    mst_second.common().member_flags().IS_EXTERNAL(false);
    mst_second.common().member_flags().IS_OPTIONAL(false);
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_second.common().member_flags().IS_KEY(false);
    mst_second.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_second.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_second.common().label_seq().emplace_back(B);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SimpleUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("SimpleUnion", false);
}

const TypeObject* BasicTypeFactory::GetCompleteSimpleUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false);

    //type_object->complete().union_type().discriminator().ann_builtin()...
    //type_object->complete().union_type().discriminator().ann_custom()...
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->complete().union_type().discriminator().common().type_id(*GetTypeIdentifier("int32_t", false));

    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false);
    cst_first.common().member_flags().TRY_CONSTRUCT2(false);
    cst_first.common().member_flags().IS_EXTERNAL(false);
    cst_first.common().member_flags().IS_OPTIONAL(false);
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_first.common().member_flags().IS_KEY(false);
    cst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_first.common().label_seq().emplace_back(A);

    cst_first.detail().name("first");
    //cst_first.detail().ann_builtin()...
    //cst_first.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false);
    cst_second.common().member_flags().TRY_CONSTRUCT2(false);
    cst_second.common().member_flags().IS_EXTERNAL(false);
    cst_second.common().member_flags().IS_OPTIONAL(false);
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_second.common().member_flags().IS_KEY(false);
    cst_second.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_second.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_second.common().label_seq().emplace_back(B);

    cst_second.detail().name("second");
    //cst_second.detail().ann_builtin()...
    //cst_second.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    //type_object->complete().union_type().header().detail().ann_builtin()..
    //type_object->complete().union_type().header().detail().ann_builtin()..
    type_object->complete().union_type().header().detail().type_name("SimpleUnion");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SimpleUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("SimpleUnion", true);
}

const TypeIdentifier* BasicTypeFactory::GetUnionUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("UnionUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionUnionObject(complete);
    return GetTypeIdentifier("UnionUnion", complete);
}

const TypeObject* BasicTypeFactory::GetUnionUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionUnionObject();
    }
    // else
    return GetMinimalUnionUnionObject();
}

const TypeObject* BasicTypeFactory::GetMinimalUnionUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetTypeIdentifier("int32_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false);
    mst_first.common().member_flags().TRY_CONSTRUCT2(false);
    mst_first.common().member_flags().IS_EXTERNAL(false);
    mst_first.common().member_flags().IS_OPTIONAL(false);
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_first.common().member_flags().IS_KEY(false);
    mst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_first.common().label_seq().emplace_back(A);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false);
    mst_second.common().member_flags().TRY_CONSTRUCT2(false);
    mst_second.common().member_flags().IS_EXTERNAL(false);
    mst_second.common().member_flags().IS_OPTIONAL(false);
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_second.common().member_flags().IS_KEY(false);
    mst_second.common().member_flags().IS_DEFAULT(false);
    mst_second.common().type_id(*GetSimpleUnionIdentifier(false));
    mst_second.common().label_seq().emplace_back(B);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UnionUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("UnionUnion", false);
}

const TypeObject* BasicTypeFactory::GetCompleteUnionUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false);

    //type_object->complete().union_type().discriminator().ann_builtin()...
    //type_object->complete().union_type().discriminator().ann_custom()...
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->complete().union_type().discriminator().common().type_id(*GetTypeIdentifier("int32_t", false));

    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false);
    cst_first.common().member_flags().TRY_CONSTRUCT2(false);
    cst_first.common().member_flags().IS_EXTERNAL(false);
    cst_first.common().member_flags().IS_OPTIONAL(false);
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_first.common().member_flags().IS_KEY(false);
    cst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_first.common().label_seq().emplace_back(A);

    cst_first.detail().name("first");
    //cst_first.detail().ann_builtin()...
    //cst_first.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false);
    cst_second.common().member_flags().TRY_CONSTRUCT2(false);
    cst_second.common().member_flags().IS_EXTERNAL(false);
    cst_second.common().member_flags().IS_OPTIONAL(false);
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_second.common().member_flags().IS_KEY(false);
    cst_second.common().member_flags().IS_DEFAULT(false);
    cst_second.common().type_id(*GetSimpleUnionIdentifier(true));
    cst_second.common().label_seq().emplace_back(B);

    cst_second.detail().name("second");
    //cst_second.detail().ann_builtin()...
    //cst_second.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    //type_object->complete().union_type().header().detail().ann_builtin()..
    //type_object->complete().union_type().header().detail().ann_builtin()..
    type_object->complete().union_type().header().detail().type_name("UnionUnion");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UnionUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("UnionUnion", true);
}

const TypeIdentifier* BasicTypeFactory::GetWCharUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("WCharUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWCharUnionObject(complete);
    return GetTypeIdentifier("WCharUnion", complete);
}

const TypeObject* BasicTypeFactory::GetWCharUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWCharUnionObject();
    }
    // else
    return GetMinimalWCharUnionObject();
}

const TypeObject* BasicTypeFactory::GetMinimalWCharUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetTypeIdentifier("wchar_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_first;
    mst_first.common().member_id(memberId++);
    mst_first.common().member_flags().TRY_CONSTRUCT1(false);
    mst_first.common().member_flags().TRY_CONSTRUCT2(false);
    mst_first.common().member_flags().IS_EXTERNAL(false);
    mst_first.common().member_flags().IS_OPTIONAL(false);
    mst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_first.common().member_flags().IS_KEY(false);
    mst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_first.common().label_seq().emplace_back(A);
    MD5 first_hash("first");
    for(int i = 0; i < 4; ++i)
    {
        mst_first.detail().name_hash()[i] = first_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_first);

    MinimalUnionMember mst_second;
    mst_second.common().member_id(memberId++);
    mst_second.common().member_flags().TRY_CONSTRUCT1(false);
    mst_second.common().member_flags().TRY_CONSTRUCT2(false);
    mst_second.common().member_flags().IS_EXTERNAL(false);
    mst_second.common().member_flags().IS_OPTIONAL(false);
    mst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_second.common().member_flags().IS_KEY(false);
    mst_second.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_second.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_second.common().label_seq().emplace_back(B);
    MD5 second_hash("second");
    for(int i = 0; i < 4; ++i)
    {
        mst_second.detail().name_hash()[i] = second_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_second);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("WCharUnion", false);
}

const TypeObject* BasicTypeFactory::GetCompleteWCharUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false);

    //type_object->complete().union_type().discriminator().ann_builtin()...
    //type_object->complete().union_type().discriminator().ann_custom()...
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->complete().union_type().discriminator().common().type_id(*GetTypeIdentifier("wchar_t", false));

    MemberId memberId = 0;
    CompleteUnionMember cst_first;
    cst_first.common().member_id(memberId++);
    cst_first.common().member_flags().TRY_CONSTRUCT1(false);
    cst_first.common().member_flags().TRY_CONSTRUCT2(false);
    cst_first.common().member_flags().IS_EXTERNAL(false);
    cst_first.common().member_flags().IS_OPTIONAL(false);
    cst_first.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_first.common().member_flags().IS_KEY(false);
    cst_first.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_first.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_first.common().label_seq().emplace_back(A);

    cst_first.detail().name("first");
    //cst_first.detail().ann_builtin()...
    //cst_first.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_first);

    CompleteUnionMember cst_second;
    cst_second.common().member_id(memberId++);
    cst_second.common().member_flags().TRY_CONSTRUCT1(false);
    cst_second.common().member_flags().TRY_CONSTRUCT2(false);
    cst_second.common().member_flags().IS_EXTERNAL(false);
    cst_second.common().member_flags().IS_OPTIONAL(false);
    cst_second.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_second.common().member_flags().IS_KEY(false);
    cst_second.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_second.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_second.common().label_seq().emplace_back(B);

    cst_second.detail().name("second");
    //cst_second.detail().ann_builtin()...
    //cst_second.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_second);


    // Header
    //type_object->complete().union_type().header().detail().ann_builtin()..
    //type_object->complete().union_type().header().detail().ann_builtin()..
    type_object->complete().union_type().header().detail().type_name("WCharUnion");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("WCharUnion", true);
}

const TypeIdentifier* BasicTypeFactory::GetSimpleUnionStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("SimpleUnionStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetSimpleUnionStructObject(complete); // Generated inside
    return GetTypeIdentifier("SimpleUnionStruct", complete);
}

const TypeObject* BasicTypeFactory::GetSimpleUnionStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnionStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteSimpleUnionStructObject();
    }
    //else
    return GetMinimalSimpleUnionStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalSimpleUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnionStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*GetSimpleUnionIdentifier(false));
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SimpleUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SimpleUnionStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteSimpleUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("SimpleUnionStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_union;
    cst_my_union.common().member_id(memberId++);
    cst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_union.common().member_flags().IS_EXTERNAL(false);
    cst_my_union.common().member_flags().IS_OPTIONAL(false);
    cst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_union.common().member_flags().IS_KEY(false);
    cst_my_union.common().member_flags().IS_DEFAULT(false);
    cst_my_union.common().member_type_id(*GetSimpleUnionIdentifier(true));
    cst_my_union.detail().name("my_union");
    //cst_my_union.detail().ann_builtin()...
    //cst_my_union.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("SimpleUnionStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("SimpleUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("SimpleUnionStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetUnionUnionUnionStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("UnionUnionUnionStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetUnionUnionUnionStructObject(complete); // Generated inside
    return GetTypeIdentifier("UnionUnionUnionStruct", complete);
}

const TypeObject* BasicTypeFactory::GetUnionUnionUnionStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnionUnionStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteUnionUnionUnionStructObject();
    }
    //else
    return GetMinimalUnionUnionUnionStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalUnionUnionUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnionUnionStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*GetUnionUnionIdentifier(false));
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UnionUnionUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("UnionUnionUnionStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteUnionUnionUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("UnionUnionUnionStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_union;
    cst_my_union.common().member_id(memberId++);
    cst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_union.common().member_flags().IS_EXTERNAL(false);
    cst_my_union.common().member_flags().IS_OPTIONAL(false);
    cst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_union.common().member_flags().IS_KEY(false);
    cst_my_union.common().member_flags().IS_DEFAULT(false);
    cst_my_union.common().member_type_id(*GetUnionUnionIdentifier(true));
    cst_my_union.detail().name("my_union");
    //cst_my_union.detail().ann_builtin()...
    //cst_my_union.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("UnionUnionUnionStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("UnionUnionUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("UnionUnionUnionStruct", true);
}

const TypeIdentifier* BasicTypeFactory::GetWCharUnionStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("WCharUnionStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetWCharUnionStructObject(complete); // Generated inside
    return GetTypeIdentifier("WCharUnionStruct", complete);
}

const TypeObject* BasicTypeFactory::GetWCharUnionStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnionStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteWCharUnionStructObject();
    }
    //else
    return GetMinimalWCharUnionStructObject();
}

const TypeObject* BasicTypeFactory::GetMinimalWCharUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnionStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*GetWCharUnionIdentifier(false));
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WCharUnionStruct", false);
}

const TypeObject* BasicTypeFactory::GetCompleteWCharUnionStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("WCharUnionStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_union;
    cst_my_union.common().member_id(memberId++);
    cst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_union.common().member_flags().IS_EXTERNAL(false);
    cst_my_union.common().member_flags().IS_OPTIONAL(false);
    cst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_union.common().member_flags().IS_KEY(false);
    cst_my_union.common().member_flags().IS_DEFAULT(false);
    cst_my_union.common().member_type_id(*GetWCharUnionIdentifier(true));
    cst_my_union.detail().name("my_union");
    //cst_my_union.detail().ann_builtin()...
    //cst_my_union.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_union);


    // Header
    type_object->complete().struct_type().header().detail().type_name("WCharUnionStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("WCharUnionStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("WCharUnionStruct", true);
}
