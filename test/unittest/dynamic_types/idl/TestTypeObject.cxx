// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file TestTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "Test.h"
#include "TestTypeObject.h"
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

TestTypeFactory::TestTypeFactory()
{
    registerTypes();
}

TestTypeFactory::~TestTypeFactory()
{
}

void TestTypeFactory::registerTypes()
{
    TypeObjectFactory *factory = TypeObjectFactory::GetInstance();
    factory->AddTypeObject("MyEnum", GetMyEnumIdentifier(false), GetMyEnumObject(false));
    factory->AddTypeObject("MyEnum", GetMyEnumIdentifier(true), GetMyEnumObject(true));
    factory->AddTypeObject("MyAliasEnum", GetMyAliasEnumIdentifier(false), GetMyAliasEnumObject(false));
    factory->AddTypeObject("MyAliasEnum", GetMyAliasEnumIdentifier(true), GetMyAliasEnumObject(true));
    factory->AddTypeObject("MyAliasEnum2", GetMyAliasEnum2Identifier(false), GetMyAliasEnum2Object(false));
    factory->AddTypeObject("MyAliasEnum2", GetMyAliasEnum2Identifier(true), GetMyAliasEnum2Object(true));
    factory->AddTypeObject("MyAliasEnum3", GetMyAliasEnum3Identifier(false), GetMyAliasEnum3Object(false));
    factory->AddTypeObject("MyAliasEnum3", GetMyAliasEnum3Identifier(true), GetMyAliasEnum3Object(true));
    factory->AddTypeObject("BasicStruct", GetBasicStructIdentifier(false), GetBasicStructObject(false));
    factory->AddTypeObject("BasicStruct", GetBasicStructIdentifier(true), GetBasicStructObject(true));
    factory->AddTypeObject("MyOctetArray500", GetMyOctetArray500Identifier(false), GetMyOctetArray500Object(false));
    factory->AddTypeObject("MyOctetArray500", GetMyOctetArray500Identifier(true), GetMyOctetArray500Object(true));
    factory->AddTypeObject("BSAlias5", GetBSAlias5Identifier(false), GetBSAlias5Object(false));
    factory->AddTypeObject("BSAlias5", GetBSAlias5Identifier(true), GetBSAlias5Object(true));
    factory->AddTypeObject("MA3", GetMA3Identifier(false), GetMA3Object(false));
    factory->AddTypeObject("MA3", GetMA3Identifier(true), GetMA3Object(true));
    factory->AddTypeObject("MyMiniArray", GetMyMiniArrayIdentifier(false), GetMyMiniArrayObject(false));
    factory->AddTypeObject("MyMiniArray", GetMyMiniArrayIdentifier(true), GetMyMiniArrayObject(true));
    factory->AddTypeObject("MySequenceLong", GetMySequenceLongIdentifier(false), GetMySequenceLongObject(false));
    factory->AddTypeObject("MySequenceLong", GetMySequenceLongIdentifier(true), GetMySequenceLongObject(true));
    factory->AddTypeObject("ComplexStruct", GetComplexStructIdentifier(false), GetComplexStructObject(false));
    factory->AddTypeObject("ComplexStruct", GetComplexStructIdentifier(true), GetComplexStructObject(true));
    factory->AddTypeObject("MyUnion", GetMyUnionIdentifier(false), GetMyUnionObject(false));
    factory->AddTypeObject("MyUnion", GetMyUnionIdentifier(true), GetMyUnionObject(true));
    factory->AddTypeObject("MyUnion2", GetMyUnion2Identifier(false), GetMyUnion2Object(false));
    factory->AddTypeObject("MyUnion2", GetMyUnion2Identifier(true), GetMyUnion2Object(true));
    factory->AddTypeObject("CompleteStruct", GetCompleteStructIdentifier(false), GetCompleteStructObject(false));
    factory->AddTypeObject("CompleteStruct", GetCompleteStructIdentifier(true), GetCompleteStructObject(true));
}

const TypeIdentifier* TestTypeFactory::GetTypeIdentifier(const std::string &type_name, bool complete)
{
    // Try general factory
    const TypeIdentifier *type_id = TypeObjectFactory::GetInstance()->GetTypeIdentifier(type_name, complete);
    if (type_id == nullptr) // For basic types, it's ok to accept non-complete
    {
        if (m_Aliases.find(type_name) != m_Aliases.end())
        {
            return GetTypeIdentifier(m_Aliases.at(type_name), complete);
        }

        // Try users types.
        if (type_name == "MyEnum") return GetMyEnumIdentifier(complete);
        if (type_name == "MyAliasEnum") return GetMyAliasEnumIdentifier(complete);
        if (type_name == "MyAliasEnum2") return GetMyAliasEnum2Identifier(complete);
        if (type_name == "MyAliasEnum3") return GetMyAliasEnum3Identifier(complete);
        if (type_name == "BasicStruct") return GetBasicStructIdentifier(complete);
        if (type_name == "MyOctetArray500") return GetMyOctetArray500Identifier(complete);
        if (type_name == "BSAlias5") return GetBSAlias5Identifier(complete);
        if (type_name == "MA3") return GetMA3Identifier(complete);
        if (type_name == "MyMiniArray") return GetMyMiniArrayIdentifier(complete);
        if (type_name == "MySequenceLong") return GetMySequenceLongIdentifier(complete);
        if (type_name == "ComplexStruct") return GetComplexStructIdentifier(complete);
        if (type_name == "MyUnion") return GetMyUnionIdentifier(complete);
        if (type_name == "MyUnion2") return GetMyUnion2Identifier(complete);
        if (type_name == "CompleteStruct") return GetCompleteStructIdentifier(complete);
    }
    else
    {
        return type_id;
    }
}

const TypeObject* TestTypeFactory::GetTypeObject(const std::string &type_name, bool complete)
{
    // Try general factory
    const TypeObject *type_id = TypeObjectFactory::GetInstance()->GetTypeObject(type_name, complete);
    if (type_id == nullptr || (complete && type_id->_d() == EK_MINIMAL))
    {
        if (m_Aliases.find(type_name) != m_Aliases.end())
        {
            return GetTypeObject(m_Aliases.at(type_name), complete);
        }

        // Try users types.
        if (type_name == "MyEnum")
        {
            GetMyEnumIdentifier(complete);
            return GetTypeObject("MyEnum", complete);
        }
        if (type_name == "MyAliasEnum")
        {
            GetMyAliasEnumIdentifier(complete);
            return GetTypeObject("MyAliasEnum", complete);
        }
        if (type_name == "MyAliasEnum2")
        {
            GetMyAliasEnum2Identifier(complete);
            return GetTypeObject("MyAliasEnum2", complete);
        }
        if (type_name == "MyAliasEnum3")
        {
            GetMyAliasEnum3Identifier(complete);
            return GetTypeObject("MyAliasEnum3", complete);
        }
        if (type_name == "BasicStruct")
        {
            GetBasicStructIdentifier(complete);
            return GetTypeObject("BasicStruct", complete);
        }
        if (type_name == "MyOctetArray500")
        {
            GetMyOctetArray500Identifier(complete);
            return GetTypeObject("MyOctetArray500", complete);
        }
        if (type_name == "BSAlias5")
        {
            GetBSAlias5Identifier(complete);
            return GetTypeObject("BSAlias5", complete);
        }
        if (type_name == "MA3")
        {
            GetMA3Identifier(complete);
            return GetTypeObject("MA3", complete);
        }
        if (type_name == "MyMiniArray")
        {
            GetMyMiniArrayIdentifier(complete);
            return GetTypeObject("MyMiniArray", complete);
        }
        if (type_name == "MySequenceLong")
        {
            GetMySequenceLongIdentifier(complete);
            return GetTypeObject("MySequenceLong", complete);
        }
        if (type_name == "ComplexStruct")
        {
            GetComplexStructIdentifier(complete);
            return GetTypeObject("ComplexStruct", complete);
        }
        if (type_name == "MyUnion")
        {
            GetMyUnionIdentifier(complete);
            return GetTypeObject("MyUnion", complete);
        }
        if (type_name == "MyUnion2")
        {
            GetMyUnion2Identifier(complete);
            return GetTypeObject("MyUnion2", complete);
        }
        if (type_name == "CompleteStruct")
        {
            GetCompleteStructIdentifier(complete);
            return GetTypeObject("CompleteStruct", complete);
        }
    }

    return type_id;
}

const TypeIdentifier* TestTypeFactory::GetMyEnumIdentifier(bool complete)
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyEnum", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyEnumObject(complete); // Generated inside
    return GetTypeIdentifier("MyEnum", complete);
}

const TypeObject* TestTypeFactory::GetMyEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyEnumObject();
    }
    else
    {
        return GetMinimalMyEnumObject();
    }
    return GetTypeObject("MyEnum", complete);
}

const TypeObject* TestTypeFactory::GetMinimalMyEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);
    // Unused
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_A;
    mel_A.common().flags().TRY_CONSTRUCT1(false);
    mel_A.common().flags().TRY_CONSTRUCT2(false);
    mel_A.common().flags().IS_EXTERNAL(false);
    mel_A.common().flags().IS_OPTIONAL(false);
    mel_A.common().flags().IS_MUST_UNDERSTAND(false);
    mel_A.common().flags().IS_KEY(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().value(value++);
    MD5 A_hash("A");
    for(int i = 0; i < 4; ++i)
    {
        mel_A.detail().name_hash()[i] = A_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_A);

    MinimalEnumeratedLiteral mel_B;
    mel_B.common().flags().TRY_CONSTRUCT1(false);
    mel_B.common().flags().TRY_CONSTRUCT2(false);
    mel_B.common().flags().IS_EXTERNAL(false);
    mel_B.common().flags().IS_OPTIONAL(false);
    mel_B.common().flags().IS_MUST_UNDERSTAND(false);
    mel_B.common().flags().IS_KEY(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().value(value++);
    MD5 B_hash("B");
    for(int i = 0; i < 4; ++i)
    {
        mel_B.detail().name_hash()[i] = B_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_B);

    MinimalEnumeratedLiteral mel_C;
    mel_C.common().flags().TRY_CONSTRUCT1(false);
    mel_C.common().flags().TRY_CONSTRUCT2(false);
    mel_C.common().flags().IS_EXTERNAL(false);
    mel_C.common().flags().IS_OPTIONAL(false);
    mel_C.common().flags().IS_MUST_UNDERSTAND(false);
    mel_C.common().flags().IS_KEY(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().value(value++);
    MD5 C_hash("C");
    for(int i = 0; i < 4; ++i)
    {
        mel_C.detail().name_hash()[i] = C_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_C);


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalEnumeratedType::getCdrSerializedSize(type_object->minimal().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyEnum", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyEnum", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ENUM);

    type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
    type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
    type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
    type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
    type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
    //type_object->complete().enumerated_type().header().detail().ann_builtin()...
    //type_object->complete().enumerated_type().header().detail().ann_custom()...
    type_object->complete().enumerated_type().header().detail().type_name("MyEnum");

    uint32_t value = 0;
    CompleteEnumeratedLiteral cel_A;
    cel_A.common().flags().TRY_CONSTRUCT1(false);
    cel_A.common().flags().TRY_CONSTRUCT2(false);
    cel_A.common().flags().IS_EXTERNAL(false);
    cel_A.common().flags().IS_OPTIONAL(false);
    cel_A.common().flags().IS_MUST_UNDERSTAND(false);
    cel_A.common().flags().IS_KEY(false);
    cel_A.common().flags().IS_DEFAULT(false);
    cel_A.common().flags().IS_DEFAULT(false);
    cel_A.common().value(value++);
    cel_A.detail().name("A");
    //cel_A.detail().ann_builtin()...
    //cel_A.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_A);

    CompleteEnumeratedLiteral cel_B;
    cel_B.common().flags().TRY_CONSTRUCT1(false);
    cel_B.common().flags().TRY_CONSTRUCT2(false);
    cel_B.common().flags().IS_EXTERNAL(false);
    cel_B.common().flags().IS_OPTIONAL(false);
    cel_B.common().flags().IS_MUST_UNDERSTAND(false);
    cel_B.common().flags().IS_KEY(false);
    cel_B.common().flags().IS_DEFAULT(false);
    cel_B.common().flags().IS_DEFAULT(false);
    cel_B.common().value(value++);
    cel_B.detail().name("B");
    //cel_B.detail().ann_builtin()...
    //cel_B.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_B);

    CompleteEnumeratedLiteral cel_C;
    cel_C.common().flags().TRY_CONSTRUCT1(false);
    cel_C.common().flags().TRY_CONSTRUCT2(false);
    cel_C.common().flags().IS_EXTERNAL(false);
    cel_C.common().flags().IS_OPTIONAL(false);
    cel_C.common().flags().IS_MUST_UNDERSTAND(false);
    cel_C.common().flags().IS_KEY(false);
    cel_C.common().flags().IS_DEFAULT(false);
    cel_C.common().flags().IS_DEFAULT(false);
    cel_C.common().value(value++);
    cel_C.detail().name("C");
    //cel_C.detail().ann_builtin()...
    //cel_C.detail().ann_custom()...
    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_C);


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteEnumeratedType::getCdrSerializedSize(type_object->complete().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyEnum", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyEnum", true);
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnumIdentifier(bool complete)
{
    if (complete)
    {
        return GetMyEnumIdentifier(true);
    }
    else
    {
        return GetMyEnumIdentifier(false);
    }
}

const TypeObject* TestTypeFactory::GetMyAliasEnumObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyAliasEnumObject();
    }
    else
    {
        return GetMinimalMyAliasEnumObject();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMyAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyEnum", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum", "MyEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyAliasEnum");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyEnum", true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum", "MyEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum", false);
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnum2Identifier(bool complete)
{
    if (complete)
    {
        return GetMyAliasEnumIdentifier(true);
    }
    else
    {
        return GetMyAliasEnumIdentifier(false);
    }
}

const TypeObject* TestTypeFactory::GetMyAliasEnum2Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum2", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyAliasEnum2Object();
    }
    else
    {
        return GetMinimalMyAliasEnum2Object();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMyAliasEnum2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum2", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum2", "MyAliasEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum2", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum2", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyAliasEnum2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum2", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyAliasEnum2");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum", true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum2", "MyAliasEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum2", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum2", false);
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnum3Identifier(bool complete)
{
    if (complete)
    {
        return GetMyAliasEnum2Identifier(true);
    }
    else
    {
        return GetMyAliasEnum2Identifier(false);
    }
}

const TypeObject* TestTypeFactory::GetMyAliasEnum3Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum3", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyAliasEnum3Object();
    }
    else
    {
        return GetMinimalMyAliasEnum3Object();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMyAliasEnum3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum3", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum2", false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum3", "MyAliasEnum2"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum3", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyAliasEnum3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum3", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyAliasEnum3");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum2", true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum3", "MyAliasEnum2"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum3", false);
}

const TypeIdentifier* TestTypeFactory::GetBasicStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("BasicStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBasicStructObject(complete); // Generated inside
    return GetTypeIdentifier("BasicStruct", complete);
}

const TypeObject* TestTypeFactory::GetBasicStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BasicStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBasicStructObject();
    }
    else
    {
        return GetMinimalBasicStructObject();
    }
    return GetTypeObject("BasicStruct", complete);
}

const TypeObject* TestTypeFactory::GetMinimalBasicStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BasicStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_bool;
    mst_my_bool.common().member_id(memberId++);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_bool.common().member_flags().IS_EXTERNAL(false);
    mst_my_bool.common().member_flags().IS_OPTIONAL(false);
    mst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_bool.common().member_flags().IS_KEY(false);
    mst_my_bool.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "bool";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_bool.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_bool_hash("my_bool");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_bool.detail().name_hash()[i] = my_bool_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_bool);

    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_int16;
    mst_my_int16.common().member_id(memberId++);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int16.common().member_flags().IS_EXTERNAL(false);
    mst_my_int16.common().member_flags().IS_OPTIONAL(false);
    mst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int16.common().member_flags().IS_KEY(false);
    mst_my_int16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int16_hash("my_int16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int16.detail().name_hash()[i] = my_int16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int16);

    MinimalStructMember mst_my_int32;
    mst_my_int32.common().member_id(memberId++);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int32.common().member_flags().IS_EXTERNAL(false);
    mst_my_int32.common().member_flags().IS_OPTIONAL(false);
    mst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int32.common().member_flags().IS_KEY(false);
    mst_my_int32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int32_hash("my_int32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int32.detail().name_hash()[i] = my_int32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int32);

    MinimalStructMember mst_my_int64;
    mst_my_int64.common().member_id(memberId++);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int64.common().member_flags().IS_EXTERNAL(false);
    mst_my_int64.common().member_flags().IS_OPTIONAL(false);
    mst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int64.common().member_flags().IS_KEY(false);
    mst_my_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_int64_hash("my_int64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int64.detail().name_hash()[i] = my_int64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int64);

    MinimalStructMember mst_my_uint16;
    mst_my_uint16.common().member_id(memberId++);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint16.common().member_flags().IS_KEY(false);
    mst_my_uint16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint16_hash("my_uint16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint16.detail().name_hash()[i] = my_uint16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint16);

    MinimalStructMember mst_my_uint32;
    mst_my_uint32.common().member_id(memberId++);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint32.common().member_flags().IS_KEY(false);
    mst_my_uint32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint32_hash("my_uint32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint32.detail().name_hash()[i] = my_uint32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint32);

    MinimalStructMember mst_my_uint64;
    mst_my_uint64.common().member_id(memberId++);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint64.common().member_flags().IS_KEY(false);
    mst_my_uint64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_uint64_hash("my_uint64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint64.detail().name_hash()[i] = my_uint64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint64);

    MinimalStructMember mst_my_float32;
    mst_my_float32.common().member_id(memberId++);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float32.common().member_flags().IS_EXTERNAL(false);
    mst_my_float32.common().member_flags().IS_OPTIONAL(false);
    mst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float32.common().member_flags().IS_KEY(false);
    mst_my_float32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "float";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float32_hash("my_float32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float32.detail().name_hash()[i] = my_float32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float32);

    MinimalStructMember mst_my_float64;
    mst_my_float64.common().member_id(memberId++);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float64.common().member_flags().IS_EXTERNAL(false);
    mst_my_float64.common().member_flags().IS_OPTIONAL(false);
    mst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float64.common().member_flags().IS_KEY(false);
    mst_my_float64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float64_hash("my_float64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float64.detail().name_hash()[i] = my_float64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float64);

    MinimalStructMember mst_my_float128;
    mst_my_float128.common().member_id(memberId++);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float128.common().member_flags().IS_EXTERNAL(false);
    mst_my_float128.common().member_flags().IS_OPTIONAL(false);
    mst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float128.common().member_flags().IS_KEY(false);
    mst_my_float128.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "long double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float128.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_float128_hash("my_float128");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float128.detail().name_hash()[i] = my_float128_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float128);

    MinimalStructMember mst_my_char;
    mst_my_char.common().member_id(memberId++);
    mst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_char.common().member_flags().IS_EXTERNAL(false);
    mst_my_char.common().member_flags().IS_OPTIONAL(false);
    mst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_char.common().member_flags().IS_KEY(false);
    mst_my_char.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "char";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_char.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_char_hash("my_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_char.detail().name_hash()[i] = my_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_char);

    MinimalStructMember mst_my_wchar;
    mst_my_wchar.common().member_id(memberId++);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    mst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wchar.common().member_flags().IS_KEY(false);
    mst_my_wchar.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "wchar_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_wchar.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_wchar_hash("my_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wchar.detail().name_hash()[i] = my_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wchar);

    MinimalStructMember mst_my_string;
    mst_my_string.common().member_id(memberId++);
    mst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_string.common().member_flags().IS_KEY(false);
    mst_my_string.common().member_flags().IS_DEFAULT(false);
    mst_my_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    MD5 my_string_hash("my_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_string.detail().name_hash()[i] = my_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_string);

    MinimalStructMember mst_my_wstring;
    mst_my_wstring.common().member_id(memberId++);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    mst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wstring.common().member_flags().IS_KEY(false);
    mst_my_wstring.common().member_flags().IS_DEFAULT(false);
    mst_my_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, true));


    MD5 my_wstring_hash("my_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wstring.detail().name_hash()[i] = my_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wstring);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("BasicStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("BasicStruct", false);
}

const TypeObject* TestTypeFactory::GetCompleteBasicStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BasicStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_bool;
    cst_my_bool.common().member_id(memberId++);
    cst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_bool.common().member_flags().IS_EXTERNAL(false);
    cst_my_bool.common().member_flags().IS_OPTIONAL(false);
    cst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_bool.common().member_flags().IS_KEY(false);
    cst_my_bool.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "bool";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_bool.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_bool.detail().name("my_bool");
    //cst_my_bool.detail().ann_builtin()...
    //cst_my_bool.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_bool);

    CompleteStructMember cst_my_octet;
    cst_my_octet.common().member_id(memberId++);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_octet.common().member_flags().IS_KEY(false);
    cst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_octet.detail().name("my_octet");
    //cst_my_octet.detail().ann_builtin()...
    //cst_my_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_octet);

    CompleteStructMember cst_my_int16;
    cst_my_int16.common().member_id(memberId++);
    cst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int16.common().member_flags().IS_EXTERNAL(false);
    cst_my_int16.common().member_flags().IS_OPTIONAL(false);
    cst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int16.common().member_flags().IS_KEY(false);
    cst_my_int16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int16.detail().name("my_int16");
    //cst_my_int16.detail().ann_builtin()...
    //cst_my_int16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int16);

    CompleteStructMember cst_my_int32;
    cst_my_int32.common().member_id(memberId++);
    cst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int32.common().member_flags().IS_EXTERNAL(false);
    cst_my_int32.common().member_flags().IS_OPTIONAL(false);
    cst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int32.common().member_flags().IS_KEY(false);
    cst_my_int32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int32.detail().name("my_int32");
    //cst_my_int32.detail().ann_builtin()...
    //cst_my_int32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int32);

    CompleteStructMember cst_my_int64;
    cst_my_int64.common().member_id(memberId++);
    cst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_int64.common().member_flags().IS_EXTERNAL(false);
    cst_my_int64.common().member_flags().IS_OPTIONAL(false);
    cst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_int64.common().member_flags().IS_KEY(false);
    cst_my_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_int64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_int64.detail().name("my_int64");
    //cst_my_int64.detail().ann_builtin()...
    //cst_my_int64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_int64);

    CompleteStructMember cst_my_uint16;
    cst_my_uint16.common().member_id(memberId++);
    cst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint16.common().member_flags().IS_KEY(false);
    cst_my_uint16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint16.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint16.detail().name("my_uint16");
    //cst_my_uint16.detail().ann_builtin()...
    //cst_my_uint16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint16);

    CompleteStructMember cst_my_uint32;
    cst_my_uint32.common().member_id(memberId++);
    cst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint32.common().member_flags().IS_KEY(false);
    cst_my_uint32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint32.detail().name("my_uint32");
    //cst_my_uint32.detail().ann_builtin()...
    //cst_my_uint32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint32);

    CompleteStructMember cst_my_uint64;
    cst_my_uint64.common().member_id(memberId++);
    cst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    cst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    cst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_uint64.common().member_flags().IS_KEY(false);
    cst_my_uint64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_uint64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_uint64.detail().name("my_uint64");
    //cst_my_uint64.detail().ann_builtin()...
    //cst_my_uint64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_uint64);

    CompleteStructMember cst_my_float32;
    cst_my_float32.common().member_id(memberId++);
    cst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float32.common().member_flags().IS_EXTERNAL(false);
    cst_my_float32.common().member_flags().IS_OPTIONAL(false);
    cst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float32.common().member_flags().IS_KEY(false);
    cst_my_float32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "float";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float32.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float32.detail().name("my_float32");
    //cst_my_float32.detail().ann_builtin()...
    //cst_my_float32.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float32);

    CompleteStructMember cst_my_float64;
    cst_my_float64.common().member_id(memberId++);
    cst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float64.common().member_flags().IS_EXTERNAL(false);
    cst_my_float64.common().member_flags().IS_OPTIONAL(false);
    cst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float64.common().member_flags().IS_KEY(false);
    cst_my_float64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float64.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float64.detail().name("my_float64");
    //cst_my_float64.detail().ann_builtin()...
    //cst_my_float64.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float64);

    CompleteStructMember cst_my_float128;
    cst_my_float128.common().member_id(memberId++);
    cst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_float128.common().member_flags().IS_EXTERNAL(false);
    cst_my_float128.common().member_flags().IS_OPTIONAL(false);
    cst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_float128.common().member_flags().IS_KEY(false);
    cst_my_float128.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "long double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_float128.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_float128.detail().name("my_float128");
    //cst_my_float128.detail().ann_builtin()...
    //cst_my_float128.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_float128);

    CompleteStructMember cst_my_char;
    cst_my_char.common().member_id(memberId++);
    cst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_char.common().member_flags().IS_EXTERNAL(false);
    cst_my_char.common().member_flags().IS_OPTIONAL(false);
    cst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_char.common().member_flags().IS_KEY(false);
    cst_my_char.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "char";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_char.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_char.detail().name("my_char");
    //cst_my_char.detail().ann_builtin()...
    //cst_my_char.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_char);

    CompleteStructMember cst_my_wchar;
    cst_my_wchar.common().member_id(memberId++);
    cst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    cst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    cst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_wchar.common().member_flags().IS_KEY(false);
    cst_my_wchar.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "wchar_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_wchar.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_wchar.detail().name("my_wchar");
    //cst_my_wchar.detail().ann_builtin()...
    //cst_my_wchar.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_wchar);

    CompleteStructMember cst_my_string;
    cst_my_string.common().member_id(memberId++);
    cst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_string.common().member_flags().IS_EXTERNAL(false);
    cst_my_string.common().member_flags().IS_OPTIONAL(false);
    cst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_string.common().member_flags().IS_KEY(false);
    cst_my_string.common().member_flags().IS_DEFAULT(false);
    cst_my_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    cst_my_string.detail().name("my_string");
    //cst_my_string.detail().ann_builtin()...
    //cst_my_string.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_string);

    CompleteStructMember cst_my_wstring;
    cst_my_wstring.common().member_id(memberId++);
    cst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    cst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    cst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_wstring.common().member_flags().IS_KEY(false);
    cst_my_wstring.common().member_flags().IS_DEFAULT(false);
    cst_my_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, true));


    cst_my_wstring.detail().name("my_wstring");
    //cst_my_wstring.detail().ann_builtin()...
    //cst_my_wstring.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_wstring);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BasicStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("BasicStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("BasicStruct", true);
}

const TypeIdentifier* TestTypeFactory::GetMyOctetArray500Identifier(bool complete)
{
    if (complete)
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("uint8_t", {500}, true);
    }
    else
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("uint8_t", {500}, false);
    }
}

const TypeObject* TestTypeFactory::GetMyOctetArray500Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyOctetArray500", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyOctetArray500Object();
    }
    else
    {
        return GetMinimalMyOctetArray500Object();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMyOctetArray500Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyOctetArray500", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("uint8_t", {500}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyOctetArray500", TypeNamesGenerator::getArrayTypeName("uint8_t", {500})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyOctetArray500", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyOctetArray500", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyOctetArray500Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyOctetArray500", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyOctetArray500");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("uint8_t", {500}), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyOctetArray500", TypeNamesGenerator::getArrayTypeName("uint8_t", {500})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyOctetArray500", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyOctetArray500", false);
}

const TypeIdentifier* TestTypeFactory::GetBSAlias5Identifier(bool complete)
{
    if (complete)
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5}, true);
    }
    else
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5}, false);
    }
}

const TypeObject* TestTypeFactory::GetBSAlias5Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BSAlias5", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBSAlias5Object();
    }
    else
    {
        return GetMinimalBSAlias5Object();
    }
}

const TypeObject* TestTypeFactory::GetMinimalBSAlias5Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BSAlias5", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("BasicStruct", {5}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("BSAlias5", TypeNamesGenerator::getArrayTypeName("BasicStruct", {5})));

    TypeObjectFactory::GetInstance()->AddTypeObject("BSAlias5", relatedType, type_object);
    delete type_object;
    return GetTypeObject("BSAlias5", false);
}

const TypeObject* TestTypeFactory::GetCompleteBSAlias5Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BSAlias5", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("BSAlias5");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("BasicStruct", {5}), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("BSAlias5", TypeNamesGenerator::getArrayTypeName("BasicStruct", {5})));

    TypeObjectFactory::GetInstance()->AddTypeObject("BSAlias5", relatedType, type_object);
    delete type_object;
    return GetTypeObject("BSAlias5", false);
}

const TypeIdentifier* TestTypeFactory::GetMA3Identifier(bool complete)
{
    if (complete)
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyAliasEnum3", {42}, true);
    }
    else
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyAliasEnum3", {42}, false);
    }
}

const TypeObject* TestTypeFactory::GetMA3Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MA3", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMA3Object();
    }
    else
    {
        return GetMinimalMA3Object();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMA3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MA3", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("MyAliasEnum3", {42}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MA3", TypeNamesGenerator::getArrayTypeName("MyAliasEnum3", {42})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MA3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MA3", false);
}

const TypeObject* TestTypeFactory::GetCompleteMA3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MA3", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MA3");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("MyAliasEnum3", {42}), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MA3", TypeNamesGenerator::getArrayTypeName("MyAliasEnum3", {42})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MA3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MA3", false);
}

const TypeIdentifier* TestTypeFactory::GetMyMiniArrayIdentifier(bool complete)
{
    if (complete)
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("int32_t", {2}, true);
    }
    else
    {
        return TypeObjectFactory::GetInstance()->GetArrayIdentifier("int32_t", {2}, false);
    }
}

const TypeObject* TestTypeFactory::GetMyMiniArrayObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyMiniArray", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyMiniArrayObject();
    }
    else
    {
        return GetMinimalMyMiniArrayObject();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMyMiniArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyMiniArray", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("int32_t", {2}), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyMiniArray", TypeNamesGenerator::getArrayTypeName("int32_t", {2})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyMiniArray", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyMiniArray", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyMiniArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyMiniArray", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MyMiniArray");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getArrayTypeName("int32_t", {2}), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyMiniArray", TypeNamesGenerator::getArrayTypeName("int32_t", {2})));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyMiniArray", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyMiniArray", false);
}

const TypeIdentifier* TestTypeFactory::GetMySequenceLongIdentifier(bool complete)
{
    if (complete)
    {
        return TypeObjectFactory::GetInstance()->GetSequenceIdentifier("int32_t", 100, true);
    }
    else
    {
        return TypeObjectFactory::GetInstance()->GetSequenceIdentifier("int32_t", 100, false);
    }
}

const TypeObject* TestTypeFactory::GetMySequenceLongObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MySequenceLong", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMySequenceLongObject();
    }
    else
    {
        return GetMinimalMySequenceLongObject();
    }
}

const TypeObject* TestTypeFactory::GetMinimalMySequenceLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MySequenceLong", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getSequenceTypeName("int32_t", 100), false);


    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MySequenceLong", TypeNamesGenerator::getSequenceTypeName("int32_t", 100)));

    TypeObjectFactory::GetInstance()->AddTypeObject("MySequenceLong", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MySequenceLong", false);
}

const TypeObject* TestTypeFactory::GetCompleteMySequenceLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MySequenceLong", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_ALIAS);
    type_object->complete().alias_type().alias_flags().IS_FINAL(false);
    type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->complete().alias_type().alias_flags().IS_NESTED(false);
    type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
    type_object->complete().alias_type().header().detail().type_name("MySequenceLong");

    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

    //type_object->complete().alias_type().body().common().ann_builtin()
    //type_object->complete().alias_type().body().common().ann_custom()

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier(TypeNamesGenerator::getSequenceTypeName("int32_t", 100), true);


    if (relatedType != nullptr)
    {
        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        delete type_object;
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MySequenceLong", TypeNamesGenerator::getSequenceTypeName("int32_t", 100)));

    TypeObjectFactory::GetInstance()->AddTypeObject("MySequenceLong", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MySequenceLong", false);
}

const TypeIdentifier* TestTypeFactory::GetComplexStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ComplexStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetComplexStructObject(complete); // Generated inside
    return GetTypeIdentifier("ComplexStruct", complete);
}

const TypeObject* TestTypeFactory::GetComplexStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ComplexStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteComplexStructObject();
    }
    else
    {
        return GetMinimalComplexStructObject();
    }
    return GetTypeObject("ComplexStruct", complete);
}

const TypeObject* TestTypeFactory::GetMinimalComplexStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ComplexStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_basic_struct;
    mst_my_basic_struct.common().member_id(memberId++);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_basic_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_basic_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_basic_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_basic_struct.common().member_flags().IS_KEY(false);
    mst_my_basic_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_basic_struct.common().member_type_id(*GetBasicStructIdentifier(false));
    MD5 my_basic_struct_hash("my_basic_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_basic_struct.detail().name_hash()[i] = my_basic_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_basic_struct);

    MinimalStructMember mst_my_alias_enum;
    mst_my_alias_enum.common().member_id(memberId++);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_alias_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_alias_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_alias_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_alias_enum.common().member_flags().IS_KEY(false);
    mst_my_alias_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_alias_enum.common().member_type_id(*GetMyAliasEnumIdentifier(false));
    MD5 my_alias_enum_hash("my_alias_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_alias_enum.detail().name_hash()[i] = my_alias_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_alias_enum);

    MinimalStructMember mst_my_enum;
    mst_my_enum.common().member_id(memberId++);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_enum.common().member_flags().IS_KEY(false);
    mst_my_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_enum.common().member_type_id(*GetMyEnumIdentifier(false));
    MD5 my_enum_hash("my_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_enum.detail().name_hash()[i] = my_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_enum);

    MinimalStructMember mst_my_sequence_octet;
    mst_my_sequence_octet.common().member_id(memberId++);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_octet.common().member_flags().IS_KEY(false);
    mst_my_sequence_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("uint8_t", 55, false));


    MD5 my_sequence_octet_hash("my_sequence_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_octet.detail().name_hash()[i] = my_sequence_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_octet);

    MinimalStructMember mst_my_sequence_struct;
    mst_my_sequence_struct.common().member_id(memberId++);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_struct.common().member_flags().IS_KEY(false);
    mst_my_sequence_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("BasicStruct", 100, false));


    MD5 my_sequence_struct_hash("my_sequence_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_struct.detail().name_hash()[i] = my_sequence_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_struct);

    MinimalStructMember mst_my_array_octet;
    mst_my_array_octet.common().member_id(memberId++);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_octet.common().member_flags().IS_KEY(false);
    mst_my_array_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_array_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("char", {500, 5, 4}, false));


    MD5 my_array_octet_hash("my_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_octet.detail().name_hash()[i] = my_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_octet);

    MinimalStructMember mst_my_octet_array_500;
    mst_my_octet_array_500.common().member_id(memberId++);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_octet_array_500.common().member_type_id(*GetMyOctetArray500Identifier(false));
    MD5 my_octet_array_500_hash("my_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet_array_500.detail().name_hash()[i] = my_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet_array_500);

    MinimalStructMember mst_my_array_struct;
    mst_my_array_struct.common().member_id(memberId++);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_struct.common().member_flags().IS_KEY(false);
    mst_my_array_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_array_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5}, false));


    MD5 my_array_struct_hash("my_array_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_struct.detail().name_hash()[i] = my_array_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_struct);

    MinimalStructMember mst_my_map_octet_short;
    mst_my_map_octet_short.common().member_id(memberId++);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_octet_short.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_octet_short.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_octet_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_octet_short.common().member_flags().IS_KEY(false);
    mst_my_map_octet_short.common().member_flags().IS_DEFAULT(false);
    mst_my_map_octet_short.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("uint8_t", "int16_t", 100, false));


    MD5 my_map_octet_short_hash("my_map_octet_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_octet_short.detail().name_hash()[i] = my_map_octet_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_octet_short);

    MinimalStructMember mst_my_map_long_struct;
    mst_my_map_long_struct.common().member_id(memberId++);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_struct.common().member_flags().IS_KEY(false);
    mst_my_map_long_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "BasicStruct", 100, false));


    MD5 my_map_long_struct_hash("my_map_long_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_struct.detail().name_hash()[i] = my_map_long_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_struct);

    MinimalStructMember mst_my_map_long_seq_octet;
    mst_my_map_long_seq_octet.common().member_id(memberId++);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_KEY(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_seq_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getSequenceTypeName(TypeNamesGenerator::getSequenceTypeName("uint8_t", 100), 100), 100, false));


    MD5 my_map_long_seq_octet_hash("my_map_long_seq_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_seq_octet.detail().name_hash()[i] = my_map_long_seq_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_seq_octet);

    MinimalStructMember mst_my_map_long_octet_array_500;
    mst_my_map_long_octet_array_500.common().member_id(memberId++);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_octet_array_500.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "MyOctetArray500", 100, false));


    MD5 my_map_long_octet_array_500_hash("my_map_long_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_octet_array_500.detail().name_hash()[i] = my_map_long_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_octet_array_500);

    MinimalStructMember mst_my_map_long_lol_type;
    mst_my_map_long_lol_type.common().member_id(memberId++);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_lol_type.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_lol_type.common().member_flags().IS_KEY(false);
    mst_my_map_long_lol_type.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_lol_type.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getMapTypeName("uint8_t", "BSAlias5", 100), 100, false));


    MD5 my_map_long_lol_type_hash("my_map_long_lol_type");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_lol_type.detail().name_hash()[i] = my_map_long_lol_type_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_lol_type);

    MinimalStructMember mst_my_small_string_8;
    mst_my_small_string_8.common().member_id(memberId++);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_8.common().member_flags().IS_KEY(false);
    mst_my_small_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(128, false));


    MD5 my_small_string_8_hash("my_small_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_8.detail().name_hash()[i] = my_small_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_8);

    MinimalStructMember mst_my_small_string_16;
    mst_my_small_string_16.common().member_id(memberId++);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_16.common().member_flags().IS_KEY(false);
    mst_my_small_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(64, true));


    MD5 my_small_string_16_hash("my_small_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_16.detail().name_hash()[i] = my_small_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_16);

    MinimalStructMember mst_my_large_string_8;
    mst_my_large_string_8.common().member_id(memberId++);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_8.common().member_flags().IS_KEY(false);
    mst_my_large_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(500, false));


    MD5 my_large_string_8_hash("my_large_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_8.detail().name_hash()[i] = my_large_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_8);

    MinimalStructMember mst_my_large_string_16;
    mst_my_large_string_16.common().member_id(memberId++);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_16.common().member_flags().IS_KEY(false);
    mst_my_large_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(1024, true));


    MD5 my_large_string_16_hash("my_large_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_16.detail().name_hash()[i] = my_large_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_16);

    MinimalStructMember mst_my_array_string;
    mst_my_array_string.common().member_id(memberId++);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_string.common().member_flags().IS_KEY(false);
    mst_my_array_string.common().member_flags().IS_DEFAULT(false);
    mst_my_array_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier(TypeNamesGenerator::getStringTypeName(75, false), {5, 5}, false));


    MD5 my_array_string_hash("my_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_string.detail().name_hash()[i] = my_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_string);

    MinimalStructMember mst_multi_alias_array_42;
    mst_multi_alias_array_42.common().member_id(memberId++);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT1(false);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT2(false);
    mst_multi_alias_array_42.common().member_flags().IS_EXTERNAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_OPTIONAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_multi_alias_array_42.common().member_flags().IS_KEY(false);
    mst_multi_alias_array_42.common().member_flags().IS_DEFAULT(false);
    mst_multi_alias_array_42.common().member_type_id(*GetMA3Identifier(false));
    MD5 multi_alias_array_42_hash("multi_alias_array_42");
    for(int i = 0; i < 4; ++i)
    {
        mst_multi_alias_array_42.detail().name_hash()[i] = multi_alias_array_42_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_multi_alias_array_42);

    MinimalStructMember mst_my_array_arrays;
    mst_my_array_arrays.common().member_id(memberId++);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_arrays.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_arrays.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_arrays.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_arrays.common().member_flags().IS_KEY(false);
    mst_my_array_arrays.common().member_flags().IS_DEFAULT(false);
    mst_my_array_arrays.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyMiniArray", {5}, false));


    MD5 my_array_arrays_hash("my_array_arrays");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_arrays.detail().name_hash()[i] = my_array_arrays_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_arrays);

    MinimalStructMember mst_my_sequences_array;
    mst_my_sequences_array.common().member_id(memberId++);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequences_array.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequences_array.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequences_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequences_array.common().member_flags().IS_KEY(false);
    mst_my_sequences_array.common().member_flags().IS_DEFAULT(false);
    mst_my_sequences_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MySequenceLong", {23}, false));


    MD5 my_sequences_array_hash("my_sequences_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequences_array.detail().name_hash()[i] = my_sequences_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequences_array);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ComplexStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ComplexStruct", false);
}

const TypeObject* TestTypeFactory::GetCompleteComplexStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ComplexStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_octet;
    cst_my_octet.common().member_id(memberId++);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_octet.common().member_flags().IS_KEY(false);
    cst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_my_octet.detail().name("my_octet");
    //cst_my_octet.detail().ann_builtin()...
    //cst_my_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_octet);

    CompleteStructMember cst_my_basic_struct;
    cst_my_basic_struct.common().member_id(memberId++);
    cst_my_basic_struct.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_basic_struct.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_basic_struct.common().member_flags().IS_EXTERNAL(false);
    cst_my_basic_struct.common().member_flags().IS_OPTIONAL(false);
    cst_my_basic_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_basic_struct.common().member_flags().IS_KEY(false);
    cst_my_basic_struct.common().member_flags().IS_DEFAULT(false);
    cst_my_basic_struct.common().member_type_id(*GetBasicStructIdentifier(true));
    cst_my_basic_struct.detail().name("my_basic_struct");
    //cst_my_basic_struct.detail().ann_builtin()...
    //cst_my_basic_struct.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_basic_struct);

    CompleteStructMember cst_my_alias_enum;
    cst_my_alias_enum.common().member_id(memberId++);
    cst_my_alias_enum.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_alias_enum.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_alias_enum.common().member_flags().IS_EXTERNAL(false);
    cst_my_alias_enum.common().member_flags().IS_OPTIONAL(false);
    cst_my_alias_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_alias_enum.common().member_flags().IS_KEY(false);
    cst_my_alias_enum.common().member_flags().IS_DEFAULT(false);
    cst_my_alias_enum.common().member_type_id(*GetMyAliasEnumIdentifier(true));
    cst_my_alias_enum.detail().name("my_alias_enum");
    //cst_my_alias_enum.detail().ann_builtin()...
    //cst_my_alias_enum.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_alias_enum);

    CompleteStructMember cst_my_enum;
    cst_my_enum.common().member_id(memberId++);
    cst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_enum.common().member_flags().IS_EXTERNAL(false);
    cst_my_enum.common().member_flags().IS_OPTIONAL(false);
    cst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_enum.common().member_flags().IS_KEY(false);
    cst_my_enum.common().member_flags().IS_DEFAULT(false);
    cst_my_enum.common().member_type_id(*GetMyEnumIdentifier(true));
    cst_my_enum.detail().name("my_enum");
    //cst_my_enum.detail().ann_builtin()...
    //cst_my_enum.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_enum);

    CompleteStructMember cst_my_sequence_octet;
    cst_my_sequence_octet.common().member_id(memberId++);
    cst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_sequence_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_sequence_octet.common().member_flags().IS_KEY(false);
    cst_my_sequence_octet.common().member_flags().IS_DEFAULT(false);
    cst_my_sequence_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("uint8_t", 55, false));


    cst_my_sequence_octet.detail().name("my_sequence_octet");
    //cst_my_sequence_octet.detail().ann_builtin()...
    //cst_my_sequence_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_sequence_octet);

    CompleteStructMember cst_my_sequence_struct;
    cst_my_sequence_struct.common().member_id(memberId++);
    cst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_sequence_struct.common().member_flags().IS_EXTERNAL(false);
    cst_my_sequence_struct.common().member_flags().IS_OPTIONAL(false);
    cst_my_sequence_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_sequence_struct.common().member_flags().IS_KEY(false);
    cst_my_sequence_struct.common().member_flags().IS_DEFAULT(false);
    cst_my_sequence_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("BasicStruct", 100, false));


    cst_my_sequence_struct.detail().name("my_sequence_struct");
    //cst_my_sequence_struct.detail().ann_builtin()...
    //cst_my_sequence_struct.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_sequence_struct);

    CompleteStructMember cst_my_array_octet;
    cst_my_array_octet.common().member_id(memberId++);
    cst_my_array_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_array_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array_octet.common().member_flags().IS_KEY(false);
    cst_my_array_octet.common().member_flags().IS_DEFAULT(false);
    cst_my_array_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("char", {500, 5, 4}, false));


    cst_my_array_octet.detail().name("my_array_octet");
    //cst_my_array_octet.detail().ann_builtin()...
    //cst_my_array_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array_octet);

    CompleteStructMember cst_my_octet_array_500;
    cst_my_octet_array_500.common().member_id(memberId++);
    cst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    cst_my_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    cst_my_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_octet_array_500.common().member_flags().IS_KEY(false);
    cst_my_octet_array_500.common().member_flags().IS_DEFAULT(false);
    cst_my_octet_array_500.common().member_type_id(*GetMyOctetArray500Identifier(true));
    cst_my_octet_array_500.detail().name("my_octet_array_500");
    //cst_my_octet_array_500.detail().ann_builtin()...
    //cst_my_octet_array_500.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_octet_array_500);

    CompleteStructMember cst_my_array_struct;
    cst_my_array_struct.common().member_id(memberId++);
    cst_my_array_struct.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array_struct.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array_struct.common().member_flags().IS_EXTERNAL(false);
    cst_my_array_struct.common().member_flags().IS_OPTIONAL(false);
    cst_my_array_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array_struct.common().member_flags().IS_KEY(false);
    cst_my_array_struct.common().member_flags().IS_DEFAULT(false);
    cst_my_array_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5}, false));


    cst_my_array_struct.detail().name("my_array_struct");
    //cst_my_array_struct.detail().ann_builtin()...
    //cst_my_array_struct.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array_struct);

    CompleteStructMember cst_my_map_octet_short;
    cst_my_map_octet_short.common().member_id(memberId++);
    cst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_octet_short.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_octet_short.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_octet_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_octet_short.common().member_flags().IS_KEY(false);
    cst_my_map_octet_short.common().member_flags().IS_DEFAULT(false);
    cst_my_map_octet_short.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("uint8_t", "int16_t", 100, false));


    cst_my_map_octet_short.detail().name("my_map_octet_short");
    //cst_my_map_octet_short.detail().ann_builtin()...
    //cst_my_map_octet_short.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_octet_short);

    CompleteStructMember cst_my_map_long_struct;
    cst_my_map_long_struct.common().member_id(memberId++);
    cst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_long_struct.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_long_struct.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_long_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_long_struct.common().member_flags().IS_KEY(false);
    cst_my_map_long_struct.common().member_flags().IS_DEFAULT(false);
    cst_my_map_long_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "BasicStruct", 100, false));


    cst_my_map_long_struct.detail().name("my_map_long_struct");
    //cst_my_map_long_struct.detail().ann_builtin()...
    //cst_my_map_long_struct.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_long_struct);

    CompleteStructMember cst_my_map_long_seq_octet;
    cst_my_map_long_seq_octet.common().member_id(memberId++);
    cst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_long_seq_octet.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_long_seq_octet.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_long_seq_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_long_seq_octet.common().member_flags().IS_KEY(false);
    cst_my_map_long_seq_octet.common().member_flags().IS_DEFAULT(false);
    cst_my_map_long_seq_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getSequenceTypeName(TypeNamesGenerator::getSequenceTypeName("uint8_t", 100), 100), 100, false));


    cst_my_map_long_seq_octet.detail().name("my_map_long_seq_octet");
    //cst_my_map_long_seq_octet.detail().ann_builtin()...
    //cst_my_map_long_seq_octet.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_long_seq_octet);

    CompleteStructMember cst_my_map_long_octet_array_500;
    cst_my_map_long_octet_array_500.common().member_id(memberId++);
    cst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_long_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_long_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_long_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_long_octet_array_500.common().member_flags().IS_KEY(false);
    cst_my_map_long_octet_array_500.common().member_flags().IS_DEFAULT(false);
    cst_my_map_long_octet_array_500.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "MyOctetArray500", 100, false));


    cst_my_map_long_octet_array_500.detail().name("my_map_long_octet_array_500");
    //cst_my_map_long_octet_array_500.detail().ann_builtin()...
    //cst_my_map_long_octet_array_500.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_long_octet_array_500);

    CompleteStructMember cst_my_map_long_lol_type;
    cst_my_map_long_lol_type.common().member_id(memberId++);
    cst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_map_long_lol_type.common().member_flags().IS_EXTERNAL(false);
    cst_my_map_long_lol_type.common().member_flags().IS_OPTIONAL(false);
    cst_my_map_long_lol_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_map_long_lol_type.common().member_flags().IS_KEY(false);
    cst_my_map_long_lol_type.common().member_flags().IS_DEFAULT(false);
    cst_my_map_long_lol_type.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getMapTypeName("uint8_t", "BSAlias5", 100), 100, false));


    cst_my_map_long_lol_type.detail().name("my_map_long_lol_type");
    //cst_my_map_long_lol_type.detail().ann_builtin()...
    //cst_my_map_long_lol_type.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_map_long_lol_type);

    CompleteStructMember cst_my_small_string_8;
    cst_my_small_string_8.common().member_id(memberId++);
    cst_my_small_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_small_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_small_string_8.common().member_flags().IS_EXTERNAL(false);
    cst_my_small_string_8.common().member_flags().IS_OPTIONAL(false);
    cst_my_small_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_small_string_8.common().member_flags().IS_KEY(false);
    cst_my_small_string_8.common().member_flags().IS_DEFAULT(false);
    cst_my_small_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(128, false));


    cst_my_small_string_8.detail().name("my_small_string_8");
    //cst_my_small_string_8.detail().ann_builtin()...
    //cst_my_small_string_8.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_small_string_8);

    CompleteStructMember cst_my_small_string_16;
    cst_my_small_string_16.common().member_id(memberId++);
    cst_my_small_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_small_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_small_string_16.common().member_flags().IS_EXTERNAL(false);
    cst_my_small_string_16.common().member_flags().IS_OPTIONAL(false);
    cst_my_small_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_small_string_16.common().member_flags().IS_KEY(false);
    cst_my_small_string_16.common().member_flags().IS_DEFAULT(false);
    cst_my_small_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(64, true));


    cst_my_small_string_16.detail().name("my_small_string_16");
    //cst_my_small_string_16.detail().ann_builtin()...
    //cst_my_small_string_16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_small_string_16);

    CompleteStructMember cst_my_large_string_8;
    cst_my_large_string_8.common().member_id(memberId++);
    cst_my_large_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_large_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_large_string_8.common().member_flags().IS_EXTERNAL(false);
    cst_my_large_string_8.common().member_flags().IS_OPTIONAL(false);
    cst_my_large_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_large_string_8.common().member_flags().IS_KEY(false);
    cst_my_large_string_8.common().member_flags().IS_DEFAULT(false);
    cst_my_large_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(500, false));


    cst_my_large_string_8.detail().name("my_large_string_8");
    //cst_my_large_string_8.detail().ann_builtin()...
    //cst_my_large_string_8.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_large_string_8);

    CompleteStructMember cst_my_large_string_16;
    cst_my_large_string_16.common().member_id(memberId++);
    cst_my_large_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_large_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_large_string_16.common().member_flags().IS_EXTERNAL(false);
    cst_my_large_string_16.common().member_flags().IS_OPTIONAL(false);
    cst_my_large_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_large_string_16.common().member_flags().IS_KEY(false);
    cst_my_large_string_16.common().member_flags().IS_DEFAULT(false);
    cst_my_large_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(1024, true));


    cst_my_large_string_16.detail().name("my_large_string_16");
    //cst_my_large_string_16.detail().ann_builtin()...
    //cst_my_large_string_16.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_large_string_16);

    CompleteStructMember cst_my_array_string;
    cst_my_array_string.common().member_id(memberId++);
    cst_my_array_string.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array_string.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array_string.common().member_flags().IS_EXTERNAL(false);
    cst_my_array_string.common().member_flags().IS_OPTIONAL(false);
    cst_my_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array_string.common().member_flags().IS_KEY(false);
    cst_my_array_string.common().member_flags().IS_DEFAULT(false);
    cst_my_array_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier(TypeNamesGenerator::getStringTypeName(75, false), {5, 5}, false));


    cst_my_array_string.detail().name("my_array_string");
    //cst_my_array_string.detail().ann_builtin()...
    //cst_my_array_string.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array_string);

    CompleteStructMember cst_multi_alias_array_42;
    cst_multi_alias_array_42.common().member_id(memberId++);
    cst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT1(false);
    cst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT2(false);
    cst_multi_alias_array_42.common().member_flags().IS_EXTERNAL(false);
    cst_multi_alias_array_42.common().member_flags().IS_OPTIONAL(false);
    cst_multi_alias_array_42.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_multi_alias_array_42.common().member_flags().IS_KEY(false);
    cst_multi_alias_array_42.common().member_flags().IS_DEFAULT(false);
    cst_multi_alias_array_42.common().member_type_id(*GetMA3Identifier(true));
    cst_multi_alias_array_42.detail().name("multi_alias_array_42");
    //cst_multi_alias_array_42.detail().ann_builtin()...
    //cst_multi_alias_array_42.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_multi_alias_array_42);

    CompleteStructMember cst_my_array_arrays;
    cst_my_array_arrays.common().member_id(memberId++);
    cst_my_array_arrays.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_array_arrays.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_array_arrays.common().member_flags().IS_EXTERNAL(false);
    cst_my_array_arrays.common().member_flags().IS_OPTIONAL(false);
    cst_my_array_arrays.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_array_arrays.common().member_flags().IS_KEY(false);
    cst_my_array_arrays.common().member_flags().IS_DEFAULT(false);
    cst_my_array_arrays.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyMiniArray", {5}, false));


    cst_my_array_arrays.detail().name("my_array_arrays");
    //cst_my_array_arrays.detail().ann_builtin()...
    //cst_my_array_arrays.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_array_arrays);

    CompleteStructMember cst_my_sequences_array;
    cst_my_sequences_array.common().member_id(memberId++);
    cst_my_sequences_array.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_sequences_array.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_sequences_array.common().member_flags().IS_EXTERNAL(false);
    cst_my_sequences_array.common().member_flags().IS_OPTIONAL(false);
    cst_my_sequences_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_sequences_array.common().member_flags().IS_KEY(false);
    cst_my_sequences_array.common().member_flags().IS_DEFAULT(false);
    cst_my_sequences_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MySequenceLong", {23}, false));


    cst_my_sequences_array.detail().name("my_sequences_array");
    //cst_my_sequences_array.detail().ann_builtin()...
    //cst_my_sequences_array.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_sequences_array);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ComplexStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ComplexStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("ComplexStruct", true);
}

const TypeIdentifier* TestTypeFactory::GetMyUnionIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MyUnion", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyUnionObject(complete);
    return GetTypeIdentifier("MyUnion", complete);
}

const TypeObject* TestTypeFactory::GetMyUnionObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyUnionObject();
    }
    else
    {
        return GetMinimalMyUnionObject();
    }
    return GetTypeObject("MyUnion", complete);
}

const TypeObject* TestTypeFactory::GetMinimalMyUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetMyEnumIdentifier(false));

    MemberId memberId = 0;
    MinimalUnionMember mst_basic;
    mst_basic.common().member_id(memberId++);
    mst_basic.common().member_flags().TRY_CONSTRUCT1(false);
    mst_basic.common().member_flags().TRY_CONSTRUCT2(false);
    mst_basic.common().member_flags().IS_EXTERNAL(false);
    mst_basic.common().member_flags().IS_OPTIONAL(false);
    mst_basic.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_basic.common().member_flags().IS_KEY(false);
    mst_basic.common().member_flags().IS_DEFAULT(false);
    mst_basic.common().type_id(*GetBasicStructIdentifier(false));
    mst_basic.common().label_seq().emplace_back(::A);
    MD5 basic_hash("basic");
    for(int i = 0; i < 4; ++i)
    {
        mst_basic.detail().name_hash()[i] = basic_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_basic);

    MinimalUnionMember mst_complex;
    mst_complex.common().member_id(memberId++);
    mst_complex.common().member_flags().TRY_CONSTRUCT1(false);
    mst_complex.common().member_flags().TRY_CONSTRUCT2(false);
    mst_complex.common().member_flags().IS_EXTERNAL(false);
    mst_complex.common().member_flags().IS_OPTIONAL(false);
    mst_complex.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_complex.common().member_flags().IS_KEY(false);
    mst_complex.common().member_flags().IS_DEFAULT(false);
    mst_complex.common().type_id(*GetComplexStructIdentifier(false));
    mst_complex.common().label_seq().emplace_back(::B);
    mst_complex.common().label_seq().emplace_back(::C);
    MD5 complex_hash("complex");
    for(int i = 0; i < 4; ++i)
    {
        mst_complex.detail().name_hash()[i] = complex_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_complex);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false);

    //type_object->complete().union_type().discriminator().ann_builtin()...
    //type_object->complete().union_type().discriminator().ann_custom()...
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->complete().union_type().discriminator().common().type_id(*GetMyEnumIdentifier(true));

    MemberId memberId = 0;
    CompleteUnionMember cst_basic;
    cst_basic.common().member_id(memberId++);
    cst_basic.common().member_flags().TRY_CONSTRUCT1(false);
    cst_basic.common().member_flags().TRY_CONSTRUCT2(false);
    cst_basic.common().member_flags().IS_EXTERNAL(false);
    cst_basic.common().member_flags().IS_OPTIONAL(false);
    cst_basic.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_basic.common().member_flags().IS_KEY(false);
    cst_basic.common().member_flags().IS_DEFAULT(false);
    cst_basic.common().type_id(*GetBasicStructIdentifier(true));
    cst_basic.common().label_seq().emplace_back(::A);

    cst_basic.detail().name("basic");
    //cst_basic.detail().ann_builtin()...
    //cst_basic.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_basic);

    CompleteUnionMember cst_complex;
    cst_complex.common().member_id(memberId++);
    cst_complex.common().member_flags().TRY_CONSTRUCT1(false);
    cst_complex.common().member_flags().TRY_CONSTRUCT2(false);
    cst_complex.common().member_flags().IS_EXTERNAL(false);
    cst_complex.common().member_flags().IS_OPTIONAL(false);
    cst_complex.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_complex.common().member_flags().IS_KEY(false);
    cst_complex.common().member_flags().IS_DEFAULT(false);
    cst_complex.common().type_id(*GetComplexStructIdentifier(true));
    cst_complex.common().label_seq().emplace_back(::B);
    cst_complex.common().label_seq().emplace_back(::C);

    cst_complex.detail().name("complex");
    //cst_complex.detail().ann_builtin()...
    //cst_complex.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_complex);


    // Header
    //type_object->complete().union_type().header().detail().ann_builtin()..
    //type_object->complete().union_type().header().detail().ann_builtin()..
    type_object->complete().union_type().header().detail().type_name("MyUnion");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion", true);
}

const TypeIdentifier* TestTypeFactory::GetMyUnion2Identifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MyUnion2", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetMyUnion2Object(complete);
    return GetTypeIdentifier("MyUnion2", complete);
}

const TypeObject* TestTypeFactory::GetMyUnion2Object(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion2", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteMyUnion2Object();
    }
    else
    {
        return GetMinimalMyUnion2Object();
    }
    return GetTypeObject("MyUnion2", complete);
}

const TypeObject* TestTypeFactory::GetMinimalMyUnion2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion2", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetTypeIdentifier("uint8_t", false));

    MemberId memberId = 0;
    MinimalUnionMember mst_uno;
    mst_uno.common().member_id(memberId++);
    mst_uno.common().member_flags().TRY_CONSTRUCT1(false);
    mst_uno.common().member_flags().TRY_CONSTRUCT2(false);
    mst_uno.common().member_flags().IS_EXTERNAL(false);
    mst_uno.common().member_flags().IS_OPTIONAL(false);
    mst_uno.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_uno.common().member_flags().IS_KEY(false);
    mst_uno.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_uno.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_uno.common().label_seq().emplace_back(A);
    MD5 uno_hash("uno");
    for(int i = 0; i < 4; ++i)
    {
        mst_uno.detail().name_hash()[i] = uno_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_uno);

    MinimalUnionMember mst_imString;
    mst_imString.common().member_id(memberId++);
    mst_imString.common().member_flags().TRY_CONSTRUCT1(false);
    mst_imString.common().member_flags().TRY_CONSTRUCT2(false);
    mst_imString.common().member_flags().IS_EXTERNAL(false);
    mst_imString.common().member_flags().IS_OPTIONAL(false);
    mst_imString.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_imString.common().member_flags().IS_KEY(false);
    mst_imString.common().member_flags().IS_DEFAULT(false);
    mst_imString.common().type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    mst_imString.common().label_seq().emplace_back(B);
    MD5 imString_hash("imString");
    for(int i = 0; i < 4; ++i)
    {
        mst_imString.detail().name_hash()[i] = imString_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_imString);

    MinimalUnionMember mst_tres;
    mst_tres.common().member_id(memberId++);
    mst_tres.common().member_flags().TRY_CONSTRUCT1(false);
    mst_tres.common().member_flags().TRY_CONSTRUCT2(false);
    mst_tres.common().member_flags().IS_EXTERNAL(false);
    mst_tres.common().member_flags().IS_OPTIONAL(false);
    mst_tres.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_tres.common().member_flags().IS_KEY(false);
    mst_tres.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_tres.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    mst_tres.common().label_seq().emplace_back(C);
    MD5 tres_hash("tres");
    for(int i = 0; i < 4; ++i)
    {
        mst_tres.detail().name_hash()[i] = tres_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_tres);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion2", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion2", false);
}

const TypeObject* TestTypeFactory::GetCompleteMyUnion2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion2", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_UNION);

    type_object->complete().union_type().union_flags().IS_FINAL(false);
    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
    type_object->complete().union_type().union_flags().IS_NESTED(false);
    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false);

    //type_object->complete().union_type().discriminator().ann_builtin()...
    //type_object->complete().union_type().discriminator().ann_custom()...
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->complete().union_type().discriminator().common().type_id(*GetTypeIdentifier("uint8_t", false));

    MemberId memberId = 0;
    CompleteUnionMember cst_uno;
    cst_uno.common().member_id(memberId++);
    cst_uno.common().member_flags().TRY_CONSTRUCT1(false);
    cst_uno.common().member_flags().TRY_CONSTRUCT2(false);
    cst_uno.common().member_flags().IS_EXTERNAL(false);
    cst_uno.common().member_flags().IS_OPTIONAL(false);
    cst_uno.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_uno.common().member_flags().IS_KEY(false);
    cst_uno.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_uno.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_uno.common().label_seq().emplace_back(A);

    cst_uno.detail().name("uno");
    //cst_uno.detail().ann_builtin()...
    //cst_uno.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_uno);

    CompleteUnionMember cst_imString;
    cst_imString.common().member_id(memberId++);
    cst_imString.common().member_flags().TRY_CONSTRUCT1(false);
    cst_imString.common().member_flags().TRY_CONSTRUCT2(false);
    cst_imString.common().member_flags().IS_EXTERNAL(false);
    cst_imString.common().member_flags().IS_OPTIONAL(false);
    cst_imString.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_imString.common().member_flags().IS_KEY(false);
    cst_imString.common().member_flags().IS_DEFAULT(false);
    cst_imString.common().type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    cst_imString.common().label_seq().emplace_back(B);

    cst_imString.detail().name("imString");
    //cst_imString.detail().ann_builtin()...
    //cst_imString.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_imString);

    CompleteUnionMember cst_tres;
    cst_tres.common().member_id(memberId++);
    cst_tres.common().member_flags().TRY_CONSTRUCT1(false);
    cst_tres.common().member_flags().TRY_CONSTRUCT2(false);
    cst_tres.common().member_flags().IS_EXTERNAL(false);
    cst_tres.common().member_flags().IS_OPTIONAL(false);
    cst_tres.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_tres.common().member_flags().IS_KEY(false);
    cst_tres.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        cst_tres.common().type_id(*GetTypeIdentifier(cppType, false));
    }

    cst_tres.common().label_seq().emplace_back(C);

    cst_tres.detail().name("tres");
    //cst_tres.detail().ann_builtin()...
    //cst_tres.detail().ann_custom()...

    type_object->complete().union_type().member_seq().emplace_back(cst_tres);


    // Header
    //type_object->complete().union_type().header().detail().ann_builtin()..
    //type_object->complete().union_type().header().detail().ann_builtin()..
    type_object->complete().union_type().header().detail().type_name("MyUnion2");


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteUnionType::getCdrSerializedSize(type_object->complete().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion2", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion2", true);
}

const TypeIdentifier* TestTypeFactory::GetCompleteStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("CompleteStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetCompleteStructObject(complete); // Generated inside
    return GetTypeIdentifier("CompleteStruct", complete);
}

const TypeObject* TestTypeFactory::GetCompleteStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CompleteStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteCompleteStructObject();
    }
    else
    {
        return GetMinimalCompleteStructObject();
    }
    return GetTypeObject("CompleteStruct", complete);
}

const TypeObject* TestTypeFactory::GetMinimalCompleteStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CompleteStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*GetMyUnionIdentifier(false));
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);

    MinimalStructMember mst_my_union_2;
    mst_my_union_2.common().member_id(memberId++);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union_2.common().member_flags().IS_EXTERNAL(false);
    mst_my_union_2.common().member_flags().IS_OPTIONAL(false);
    mst_my_union_2.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union_2.common().member_flags().IS_KEY(false);
    mst_my_union_2.common().member_flags().IS_DEFAULT(false);
    mst_my_union_2.common().member_type_id(*GetMyUnion2Identifier(false));
    MD5 my_union_2_hash("my_union_2");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union_2.detail().name_hash()[i] = my_union_2_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union_2);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("CompleteStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("CompleteStruct", false);
}

const TypeObject* TestTypeFactory::GetCompleteCompleteStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CompleteStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    CompleteStructMember cst_my_union;
    cst_my_union.common().member_id(memberId++);
    cst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_union.common().member_flags().IS_EXTERNAL(false);
    cst_my_union.common().member_flags().IS_OPTIONAL(false);
    cst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_union.common().member_flags().IS_KEY(false);
    cst_my_union.common().member_flags().IS_DEFAULT(false);
    cst_my_union.common().member_type_id(*GetMyUnionIdentifier(true));
    cst_my_union.detail().name("my_union");
    //cst_my_union.detail().ann_builtin()...
    //cst_my_union.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_union);

    CompleteStructMember cst_my_union_2;
    cst_my_union_2.common().member_id(memberId++);
    cst_my_union_2.common().member_flags().TRY_CONSTRUCT1(false);
    cst_my_union_2.common().member_flags().TRY_CONSTRUCT2(false);
    cst_my_union_2.common().member_flags().IS_EXTERNAL(false);
    cst_my_union_2.common().member_flags().IS_OPTIONAL(false);
    cst_my_union_2.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_my_union_2.common().member_flags().IS_KEY(false);
    cst_my_union_2.common().member_flags().IS_DEFAULT(false);
    cst_my_union_2.common().member_type_id(*GetMyUnion2Identifier(true));
    cst_my_union_2.detail().name("my_union_2");
    //cst_my_union_2.detail().ann_builtin()...
    //cst_my_union_2.detail().ann_custom()...
    type_object->complete().struct_type().member_seq().emplace_back(cst_my_union_2);


    // Header
    type_object->complete().struct_type().header().detail().type_name("CompleteStruct");
    //type_object->complete().struct_type().header().detail().ann_builtin()...
    //type_object->complete().struct_type().header().detail().ann_custom()...
    // TODO inheritance
    //type_object->complete().struct_type().header().base_type()._d(EK_COMPLETE);
    //type_object->complete().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("CompleteStruct", &identifier, type_object);
    delete type_object;
    return GetTypeObject("CompleteStruct", true);
}
