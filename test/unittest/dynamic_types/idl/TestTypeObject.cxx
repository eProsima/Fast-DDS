// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file TestTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "Test.h"
#include "TestTypeObject.h"
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

TestTypeFactory::TestTypeFactory()
{
    registerTypes();
}

TestTypeFactory::~TestTypeFactory()
{
}

void TestTypeFactory::registerTypes()
{
    TypeObjectFactory *factory = TypeObjectFactory::GetInstance();
    factory->AddTypeObject("MyEnum", GetMyEnumIdentifier(), GetMyEnumObject());
    factory->AddTypeObject("MyAliasEnum", GetMyAliasEnumIdentifier(), GetMyAliasEnumObject());
    factory->AddTypeObject("MyAliasEnum2", GetMyAliasEnum2Identifier(), GetMyAliasEnum2Object());
    factory->AddTypeObject("MyAliasEnum3", GetMyAliasEnum3Identifier(), GetMyAliasEnum3Object());
    factory->AddTypeObject("BasicStruct", GetBasicStructIdentifier(), GetBasicStructObject());
    factory->AddTypeObject("MyOctetArray500", GetMyOctetArray500Identifier(), GetMyOctetArray500Object());
    factory->AddTypeObject("BSAlias5", GetBSAlias5Identifier(), GetBSAlias5Object());
    factory->AddTypeObject("MA3", GetMA3Identifier(), GetMA3Object());
    factory->AddTypeObject("MyMiniArray", GetMyMiniArrayIdentifier(), GetMyMiniArrayObject());
    factory->AddTypeObject("MySequenceLong", GetMySequenceLongIdentifier(), GetMySequenceLongObject());
    factory->AddTypeObject("ComplexStruct", GetComplexStructIdentifier(), GetComplexStructObject());
    factory->AddTypeObject("MyUnion", GetMyUnionIdentifier(), GetMyUnionObject());
    factory->AddTypeObject("MyUnion2", GetMyUnion2Identifier(), GetMyUnion2Object());
    factory->AddTypeObject("CompleteStruct", GetCompleteStructIdentifier(), GetCompleteStructObject());
}

const TypeIdentifier* TestTypeFactory::GetTypeIdentifier(const std::string &type_name)
{
    // Try general factory
    const TypeIdentifier *type_id = TypeObjectFactory::GetInstance()->GetTypeIdentifier(type_name);
    if (type_id == nullptr)
    {
        if (m_Aliases.find(type_name) != m_Aliases.end())
        {
            return GetTypeIdentifier(m_Aliases.at(type_name));
        }

        // Try users types.
        if (type_name == "MyEnum") return GetMyEnumIdentifier();
        if (type_name == "MyAliasEnum") return GetMyAliasEnumIdentifier();
        if (type_name == "MyAliasEnum2") return GetMyAliasEnum2Identifier();
        if (type_name == "MyAliasEnum3") return GetMyAliasEnum3Identifier();
        if (type_name == "BasicStruct") return GetBasicStructIdentifier();
        if (type_name == "MyOctetArray500") return GetMyOctetArray500Identifier();
        if (type_name == "BSAlias5") return GetBSAlias5Identifier();
        if (type_name == "MA3") return GetMA3Identifier();
        if (type_name == "MyMiniArray") return GetMyMiniArrayIdentifier();
        if (type_name == "MySequenceLong") return GetMySequenceLongIdentifier();
        if (type_name == "ComplexStruct") return GetComplexStructIdentifier();
        if (type_name == "MyUnion") return GetMyUnionIdentifier();
        if (type_name == "MyUnion2") return GetMyUnion2Identifier();
        if (type_name == "CompleteStruct") return GetCompleteStructIdentifier();
    }
    else
    {
        return type_id;
    }

    return nullptr;
}

const TypeObject* TestTypeFactory::GetTypeObject(const std::string &type_name)
{
    // Try general factory
    const TypeObject *type_id = TypeObjectFactory::GetInstance()->GetTypeObject(type_name);
    if (type_id == nullptr)
    {
        if (m_Aliases.find(type_name) != m_Aliases.end())
        {
            return GetTypeObject(m_Aliases.at(type_name));
        }

        // Try users types.
        if (type_name == "MyEnum")
        {
            GetMyEnumIdentifier();
            return GetTypeObject("MyEnum");
        }
        if (type_name == "MyAliasEnum")
        {
            GetMyAliasEnumIdentifier();
            return GetTypeObject("MyAliasEnum");
        }
        if (type_name == "MyAliasEnum2")
        {
            GetMyAliasEnum2Identifier();
            return GetTypeObject("MyAliasEnum2");
        }
        if (type_name == "MyAliasEnum3")
        {
            GetMyAliasEnum3Identifier();
            return GetTypeObject("MyAliasEnum3");
        }
        if (type_name == "BasicStruct")
        {
            GetBasicStructIdentifier();
            return GetTypeObject("BasicStruct");
        }
        if (type_name == "MyOctetArray500")
        {
            GetMyOctetArray500Identifier();
            return GetTypeObject("MyOctetArray500");
        }
        if (type_name == "BSAlias5")
        {
            GetBSAlias5Identifier();
            return GetTypeObject("BSAlias5");
        }
        if (type_name == "MA3")
        {
            GetMA3Identifier();
            return GetTypeObject("MA3");
        }
        if (type_name == "MyMiniArray")
        {
            GetMyMiniArrayIdentifier();
            return GetTypeObject("MyMiniArray");
        }
        if (type_name == "MySequenceLong")
        {
            GetMySequenceLongIdentifier();
            return GetTypeObject("MySequenceLong");
        }
        if (type_name == "ComplexStruct")
        {
            GetComplexStructIdentifier();
            return GetTypeObject("ComplexStruct");
        }
        if (type_name == "MyUnion")
        {
            GetMyUnionIdentifier();
            return GetTypeObject("MyUnion");
        }
        if (type_name == "MyUnion2")
        {
            GetMyUnion2Identifier();
            return GetTypeObject("MyUnion2");
        }
        if (type_name == "CompleteStruct")
        {
            GetCompleteStructIdentifier();
            return GetTypeObject("CompleteStruct");
        }
    }

    return type_id;
}

const TypeIdentifier* TestTypeFactory::GetMyEnumIdentifier()
{
    const TypeIdentifier* c_identifier = GetTypeIdentifier("MyEnum");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    GetMyEnumObject(); // Generated inside
    return GetTypeIdentifier("MyEnum");
}

const TypeObject* TestTypeFactory::GetMyEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyEnum");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);
    // Unused
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_A;
    mel_A.common().flags().TRY_CONSTRUCT1(false);
    mel_A.common().flags().TRY_CONSTRUCT2(false);
    mel_A.common().flags().IS_EXTERNAL(false);
    mel_A.common().flags().IS_OPTIONAL(false);
    mel_A.common().flags().IS_MUST_UNDERSTAND(false);
    mel_A.common().flags().IS_KEY(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().value(value++);
    MD5 A_hash("A");
    for(int i = 0; i < 4; ++i)
    {
        mel_A.detail().name_hash()[i] = A_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_A);

    MinimalEnumeratedLiteral mel_B;
    mel_B.common().flags().TRY_CONSTRUCT1(false);
    mel_B.common().flags().TRY_CONSTRUCT2(false);
    mel_B.common().flags().IS_EXTERNAL(false);
    mel_B.common().flags().IS_OPTIONAL(false);
    mel_B.common().flags().IS_MUST_UNDERSTAND(false);
    mel_B.common().flags().IS_KEY(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().value(value++);
    MD5 B_hash("B");
    for(int i = 0; i < 4; ++i)
    {
        mel_B.detail().name_hash()[i] = B_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_B);

    MinimalEnumeratedLiteral mel_C;
    mel_C.common().flags().TRY_CONSTRUCT1(false);
    mel_C.common().flags().TRY_CONSTRUCT2(false);
    mel_C.common().flags().IS_EXTERNAL(false);
    mel_C.common().flags().IS_OPTIONAL(false);
    mel_C.common().flags().IS_MUST_UNDERSTAND(false);
    mel_C.common().flags().IS_KEY(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().value(value++);
    MD5 C_hash("C");
    for(int i = 0; i < 4; ++i)
    {
        mel_C.detail().name_hash()[i] = C_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_C);


    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalEnumeratedType::getCdrSerializedSize(type_object->minimal().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyEnum", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyEnum");
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnumIdentifier()
{
    return GetMyEnumIdentifier();
}

const TypeObject* TestTypeFactory::GetMyAliasEnumObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyEnum");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum", "MyEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum");
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnum2Identifier()
{
    return GetMyAliasEnumIdentifier();
}

const TypeObject* TestTypeFactory::GetMyAliasEnum2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum2");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum2", "MyAliasEnum"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum2", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum2");
}

const TypeIdentifier* TestTypeFactory::GetMyAliasEnum3Identifier()
{
    return GetMyAliasEnum2Identifier();
}

const TypeObject* TestTypeFactory::GetMyAliasEnum3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyAliasEnum3");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("MyAliasEnum2");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum3", "MyAliasEnum2"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyAliasEnum3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyAliasEnum3");
}

const TypeIdentifier* TestTypeFactory::GetBasicStructIdentifier()
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("BasicStruct");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    const TypeObject* c_type_object = GetTypeObject("BasicStruct");
    if (c_type_object != nullptr)
    {
        return &(c_type_object->minimal().struct_type().header().base_type());
    }
    else
    {
        const TypeObject* type_object = GetBasicStructObject();
        // Just for other methods
        return &(type_object->minimal().struct_type().header().base_type());
    }
}

const TypeObject* TestTypeFactory::GetBasicStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BasicStruct");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_bool;
    mst_my_bool.common().member_id(memberId++);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_bool.common().member_flags().IS_EXTERNAL(false);
    mst_my_bool.common().member_flags().IS_OPTIONAL(false);
    mst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_bool.common().member_flags().IS_KEY(false);
    mst_my_bool.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "bool";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_bool.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_bool_hash("my_bool");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_bool.detail().name_hash()[i] = my_bool_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_bool);

    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_int16;
    mst_my_int16.common().member_id(memberId++);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int16.common().member_flags().IS_EXTERNAL(false);
    mst_my_int16.common().member_flags().IS_OPTIONAL(false);
    mst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int16.common().member_flags().IS_KEY(false);
    mst_my_int16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int16.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_int16_hash("my_int16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int16.detail().name_hash()[i] = my_int16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int16);

    MinimalStructMember mst_my_int32;
    mst_my_int32.common().member_id(memberId++);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int32.common().member_flags().IS_EXTERNAL(false);
    mst_my_int32.common().member_flags().IS_OPTIONAL(false);
    mst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int32.common().member_flags().IS_KEY(false);
    mst_my_int32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int32.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_int32_hash("my_int32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int32.detail().name_hash()[i] = my_int32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int32);

    MinimalStructMember mst_my_int64;
    mst_my_int64.common().member_id(memberId++);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int64.common().member_flags().IS_EXTERNAL(false);
    mst_my_int64.common().member_flags().IS_OPTIONAL(false);
    mst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int64.common().member_flags().IS_KEY(false);
    mst_my_int64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_int64.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_int64_hash("my_int64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int64.detail().name_hash()[i] = my_int64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int64);

    MinimalStructMember mst_my_uint16;
    mst_my_uint16.common().member_id(memberId++);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint16.common().member_flags().IS_KEY(false);
    mst_my_uint16.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint16_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint16.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_uint16_hash("my_uint16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint16.detail().name_hash()[i] = my_uint16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint16);

    MinimalStructMember mst_my_uint32;
    mst_my_uint32.common().member_id(memberId++);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint32.common().member_flags().IS_KEY(false);
    mst_my_uint32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint32.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_uint32_hash("my_uint32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint32.detail().name_hash()[i] = my_uint32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint32);

    MinimalStructMember mst_my_uint64;
    mst_my_uint64.common().member_id(memberId++);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint64.common().member_flags().IS_KEY(false);
    mst_my_uint64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint64_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_uint64.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_uint64_hash("my_uint64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint64.detail().name_hash()[i] = my_uint64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint64);

    MinimalStructMember mst_my_float32;
    mst_my_float32.common().member_id(memberId++);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float32.common().member_flags().IS_EXTERNAL(false);
    mst_my_float32.common().member_flags().IS_OPTIONAL(false);
    mst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float32.common().member_flags().IS_KEY(false);
    mst_my_float32.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "float";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float32.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_float32_hash("my_float32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float32.detail().name_hash()[i] = my_float32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float32);

    MinimalStructMember mst_my_float64;
    mst_my_float64.common().member_id(memberId++);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float64.common().member_flags().IS_EXTERNAL(false);
    mst_my_float64.common().member_flags().IS_OPTIONAL(false);
    mst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float64.common().member_flags().IS_KEY(false);
    mst_my_float64.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float64.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_float64_hash("my_float64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float64.detail().name_hash()[i] = my_float64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float64);

    MinimalStructMember mst_my_float128;
    mst_my_float128.common().member_id(memberId++);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float128.common().member_flags().IS_EXTERNAL(false);
    mst_my_float128.common().member_flags().IS_OPTIONAL(false);
    mst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float128.common().member_flags().IS_KEY(false);
    mst_my_float128.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "long double";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_float128.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_float128_hash("my_float128");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float128.detail().name_hash()[i] = my_float128_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float128);

    MinimalStructMember mst_my_char;
    mst_my_char.common().member_id(memberId++);
    mst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_char.common().member_flags().IS_EXTERNAL(false);
    mst_my_char.common().member_flags().IS_OPTIONAL(false);
    mst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_char.common().member_flags().IS_KEY(false);
    mst_my_char.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "char";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_char.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_char_hash("my_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_char.detail().name_hash()[i] = my_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_char);

    MinimalStructMember mst_my_wchar;
    mst_my_wchar.common().member_id(memberId++);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    mst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wchar.common().member_flags().IS_KEY(false);
    mst_my_wchar.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "wchar_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_wchar.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_wchar_hash("my_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wchar.detail().name_hash()[i] = my_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wchar);

    MinimalStructMember mst_my_string;
    mst_my_string.common().member_id(memberId++);
    mst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_string.common().member_flags().IS_KEY(false);
    mst_my_string.common().member_flags().IS_DEFAULT(false);
    mst_my_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    MD5 my_string_hash("my_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_string.detail().name_hash()[i] = my_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_string);

    MinimalStructMember mst_my_wstring;
    mst_my_wstring.common().member_id(memberId++);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    mst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wstring.common().member_flags().IS_KEY(false);
    mst_my_wstring.common().member_flags().IS_DEFAULT(false);
    mst_my_wstring.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, true));


    MD5 my_wstring_hash("my_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wstring.detail().name_hash()[i] = my_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wstring);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos sólo con miembros... ¿también con flags?
    // Como no soportamos de momento tipos recursivos, esto debería bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("BasicStruct", &(type_object->minimal().struct_type().header().base_type()), type_object);
    delete type_object;
    return GetTypeObject("BasicStruct");
}

const TypeIdentifier* TestTypeFactory::GetMyOctetArray500Identifier()
{
    return TypeObjectFactory::GetInstance()->GetArrayIdentifier("uint8_t", {500});
}

const TypeObject* TestTypeFactory::GetMyOctetArray500Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyOctetArray500");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("std::array<uint8_t, 500>");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyOctetArray500", "std::array<uint8_t, 500>"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyOctetArray500", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyOctetArray500");
}

const TypeIdentifier* TestTypeFactory::GetBSAlias5Identifier()
{
    return TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5});
}

const TypeObject* TestTypeFactory::GetBSAlias5Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("BSAlias5");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("std::array<BasicStruct, 5>");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("BSAlias5", "std::array<BasicStruct, 5>"));

    TypeObjectFactory::GetInstance()->AddTypeObject("BSAlias5", relatedType, type_object);
    delete type_object;
    return GetTypeObject("BSAlias5");
}

const TypeIdentifier* TestTypeFactory::GetMA3Identifier()
{
    return TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyAliasEnum3", {42});
}

const TypeObject* TestTypeFactory::GetMA3Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MA3");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("std::array<MyAliasEnum3, 42>");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MA3", "std::array<MyAliasEnum3, 42>"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MA3", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MA3");
}

const TypeIdentifier* TestTypeFactory::GetMyMiniArrayIdentifier()
{
    return TypeObjectFactory::GetInstance()->GetArrayIdentifier("int32_t", {2});
}

const TypeObject* TestTypeFactory::GetMyMiniArrayObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyMiniArray");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("std::array<int32_t, 2>");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyMiniArray", "std::array<int32_t, 2>"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MyMiniArray", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MyMiniArray");
}

const TypeIdentifier* TestTypeFactory::GetMySequenceLongIdentifier()
{
    return TypeObjectFactory::GetInstance()->GetSequenceIdentifier("int32_t", 100);
}

const TypeObject* TestTypeFactory::GetMySequenceLongObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MySequenceLong");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    const TypeIdentifier *relatedType = GetTypeIdentifier("std::vector<int32_t>");
    if (relatedType != nullptr)
    {
        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
    }
    else
    {
        // Cannot determine base type
        return nullptr;
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MySequenceLong", "std::vector<int32_t>"));

    TypeObjectFactory::GetInstance()->AddTypeObject("MySequenceLong", relatedType, type_object);
    delete type_object;
    return GetTypeObject("MySequenceLong");
}

const TypeIdentifier* TestTypeFactory::GetComplexStructIdentifier()
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("ComplexStruct");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    const TypeObject* c_type_object = GetTypeObject("ComplexStruct");
    if (c_type_object != nullptr)
    {
        return &(c_type_object->minimal().struct_type().header().base_type());
    }
    else
    {
        const TypeObject* type_object = GetComplexStructObject();
        // Just for other methods
        return &(type_object->minimal().struct_type().header().base_type());
    }
}

const TypeObject* TestTypeFactory::GetComplexStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("ComplexStruct");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "uint8_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_my_octet.common().member_type_id(*GetTypeIdentifier(cppType));
    }

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_basic_struct;
    mst_my_basic_struct.common().member_id(memberId++);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_basic_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_basic_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_basic_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_basic_struct.common().member_flags().IS_KEY(false);
    mst_my_basic_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_basic_struct.common().member_type_id(*GetBasicStructIdentifier());
    MD5 my_basic_struct_hash("my_basic_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_basic_struct.detail().name_hash()[i] = my_basic_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_basic_struct);

    MinimalStructMember mst_my_alias_enum;
    mst_my_alias_enum.common().member_id(memberId++);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_alias_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_alias_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_alias_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_alias_enum.common().member_flags().IS_KEY(false);
    mst_my_alias_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_alias_enum.common().member_type_id(*GetMyAliasEnumIdentifier());
    MD5 my_alias_enum_hash("my_alias_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_alias_enum.detail().name_hash()[i] = my_alias_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_alias_enum);

    MinimalStructMember mst_my_enum;
    mst_my_enum.common().member_id(memberId++);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_enum.common().member_flags().IS_KEY(false);
    mst_my_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_enum.common().member_type_id(*GetMyEnumIdentifier());
    MD5 my_enum_hash("my_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_enum.detail().name_hash()[i] = my_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_enum);

    MinimalStructMember mst_my_sequence_octet;
    mst_my_sequence_octet.common().member_id(memberId++);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_octet.common().member_flags().IS_KEY(false);
    mst_my_sequence_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("uint8_t", 55));


    MD5 my_sequence_octet_hash("my_sequence_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_octet.detail().name_hash()[i] = my_sequence_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_octet);

    MinimalStructMember mst_my_sequence_struct;
    mst_my_sequence_struct.common().member_id(memberId++);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_struct.common().member_flags().IS_KEY(false);
    mst_my_sequence_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetSequenceIdentifier("BasicStruct", 100));


    MD5 my_sequence_struct_hash("my_sequence_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_struct.detail().name_hash()[i] = my_sequence_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_struct);

    MinimalStructMember mst_my_array_octet;
    mst_my_array_octet.common().member_id(memberId++);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_octet.common().member_flags().IS_KEY(false);
    mst_my_array_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_array_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("char", {500, 5, 4}));


    MD5 my_array_octet_hash("my_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_octet.detail().name_hash()[i] = my_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_octet);

    MinimalStructMember mst_my_octet_array_500;
    mst_my_octet_array_500.common().member_id(memberId++);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_octet_array_500.common().member_type_id(*GetMyOctetArray500Identifier());
    MD5 my_octet_array_500_hash("my_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet_array_500.detail().name_hash()[i] = my_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet_array_500);

    MinimalStructMember mst_my_array_struct;
    mst_my_array_struct.common().member_id(memberId++);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_struct.common().member_flags().IS_KEY(false);
    mst_my_array_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_array_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("BasicStruct", {5}));


    MD5 my_array_struct_hash("my_array_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_struct.detail().name_hash()[i] = my_array_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_struct);

    MinimalStructMember mst_my_map_octet_short;
    mst_my_map_octet_short.common().member_id(memberId++);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_octet_short.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_octet_short.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_octet_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_octet_short.common().member_flags().IS_KEY(false);
    mst_my_map_octet_short.common().member_flags().IS_DEFAULT(false);
    mst_my_map_octet_short.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("uint8_t", "int16_t", 100));


    MD5 my_map_octet_short_hash("my_map_octet_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_octet_short.detail().name_hash()[i] = my_map_octet_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_octet_short);

    MinimalStructMember mst_my_map_long_struct;
    mst_my_map_long_struct.common().member_id(memberId++);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_struct.common().member_flags().IS_KEY(false);
    mst_my_map_long_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_struct.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "BasicStruct", 100));


    MD5 my_map_long_struct_hash("my_map_long_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_struct.detail().name_hash()[i] = my_map_long_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_struct);

    MinimalStructMember mst_my_map_long_seq_octet;
    mst_my_map_long_seq_octet.common().member_id(memberId++);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_KEY(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_seq_octet.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getSequenceTypeName(TypeNamesGenerator::getSequenceTypeName("uint8_t", 100), 100), 100));


    MD5 my_map_long_seq_octet_hash("my_map_long_seq_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_seq_octet.detail().name_hash()[i] = my_map_long_seq_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_seq_octet);

    MinimalStructMember mst_my_map_long_octet_array_500;
    mst_my_map_long_octet_array_500.common().member_id(memberId++);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_octet_array_500.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", "MyOctetArray500", 100));


    MD5 my_map_long_octet_array_500_hash("my_map_long_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_octet_array_500.detail().name_hash()[i] = my_map_long_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_octet_array_500);

    MinimalStructMember mst_my_map_long_lol_type;
    mst_my_map_long_lol_type.common().member_id(memberId++);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_lol_type.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_lol_type.common().member_flags().IS_KEY(false);
    mst_my_map_long_lol_type.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_lol_type.common().member_type_id(*TypeObjectFactory::GetInstance()->GetMapIdentifier("int32_t", TypeNamesGenerator::getMapTypeName("uint8_t", "BSAlias5", 100), 100));


    MD5 my_map_long_lol_type_hash("my_map_long_lol_type");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_lol_type.detail().name_hash()[i] = my_map_long_lol_type_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_lol_type);

    MinimalStructMember mst_my_small_string_8;
    mst_my_small_string_8.common().member_id(memberId++);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_8.common().member_flags().IS_KEY(false);
    mst_my_small_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(128, false));


    MD5 my_small_string_8_hash("my_small_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_8.detail().name_hash()[i] = my_small_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_8);

    MinimalStructMember mst_my_small_string_16;
    mst_my_small_string_16.common().member_id(memberId++);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_16.common().member_flags().IS_KEY(false);
    mst_my_small_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(64, true));


    MD5 my_small_string_16_hash("my_small_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_16.detail().name_hash()[i] = my_small_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_16);

    MinimalStructMember mst_my_large_string_8;
    mst_my_large_string_8.common().member_id(memberId++);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_8.common().member_flags().IS_KEY(false);
    mst_my_large_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_8.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(500, false));


    MD5 my_large_string_8_hash("my_large_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_8.detail().name_hash()[i] = my_large_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_8);

    MinimalStructMember mst_my_large_string_16;
    mst_my_large_string_16.common().member_id(memberId++);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_16.common().member_flags().IS_KEY(false);
    mst_my_large_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_16.common().member_type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(1024, true));


    MD5 my_large_string_16_hash("my_large_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_16.detail().name_hash()[i] = my_large_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_16);

    MinimalStructMember mst_my_array_string;
    mst_my_array_string.common().member_id(memberId++);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_string.common().member_flags().IS_KEY(false);
    mst_my_array_string.common().member_flags().IS_DEFAULT(false);
    mst_my_array_string.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier(TypeNamesGenerator::getStringTypeName(75, false), {5, 5}));


    MD5 my_array_string_hash("my_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_string.detail().name_hash()[i] = my_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_string);

    MinimalStructMember mst_multi_alias_array_42;
    mst_multi_alias_array_42.common().member_id(memberId++);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT1(false);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT2(false);
    mst_multi_alias_array_42.common().member_flags().IS_EXTERNAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_OPTIONAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_multi_alias_array_42.common().member_flags().IS_KEY(false);
    mst_multi_alias_array_42.common().member_flags().IS_DEFAULT(false);
    mst_multi_alias_array_42.common().member_type_id(*GetMA3Identifier());
    MD5 multi_alias_array_42_hash("multi_alias_array_42");
    for(int i = 0; i < 4; ++i)
    {
        mst_multi_alias_array_42.detail().name_hash()[i] = multi_alias_array_42_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_multi_alias_array_42);

    MinimalStructMember mst_my_array_arrays;
    mst_my_array_arrays.common().member_id(memberId++);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_arrays.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_arrays.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_arrays.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_arrays.common().member_flags().IS_KEY(false);
    mst_my_array_arrays.common().member_flags().IS_DEFAULT(false);
    mst_my_array_arrays.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MyMiniArray", {5}));


    MD5 my_array_arrays_hash("my_array_arrays");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_arrays.detail().name_hash()[i] = my_array_arrays_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_arrays);

    MinimalStructMember mst_my_sequences_array;
    mst_my_sequences_array.common().member_id(memberId++);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequences_array.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequences_array.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequences_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequences_array.common().member_flags().IS_KEY(false);
    mst_my_sequences_array.common().member_flags().IS_DEFAULT(false);
    mst_my_sequences_array.common().member_type_id(*TypeObjectFactory::GetInstance()->GetArrayIdentifier("MySequenceLong", {23}));


    MD5 my_sequences_array_hash("my_sequences_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequences_array.detail().name_hash()[i] = my_sequences_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequences_array);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos sólo con miembros... ¿también con flags?
    // Como no soportamos de momento tipos recursivos, esto debería bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("ComplexStruct", &(type_object->minimal().struct_type().header().base_type()), type_object);
    delete type_object;
    return GetTypeObject("ComplexStruct");
}

const TypeIdentifier* TestTypeFactory::GetMyUnionIdentifier()
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MyUnion");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    GetMyUnionObject();
    return GetTypeIdentifier("MyUnion");
}

const TypeObject* TestTypeFactory::GetMyUnionObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetMyEnumIdentifier());

    MemberId memberId = 0;
    MinimalUnionMember mst_basic;
    mst_basic.common().member_id(memberId++);
    mst_basic.common().member_flags().TRY_CONSTRUCT1(false);
    mst_basic.common().member_flags().TRY_CONSTRUCT2(false);
    mst_basic.common().member_flags().IS_EXTERNAL(false);
    mst_basic.common().member_flags().IS_OPTIONAL(false);
    mst_basic.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_basic.common().member_flags().IS_KEY(false);
    mst_basic.common().member_flags().IS_DEFAULT(false);
    mst_basic.common().type_id(*GetBasicStructIdentifier());
    mst_basic.common().label_seq().emplace_back(::A);
    MD5 basic_hash("basic");
    for(int i = 0; i < 4; ++i)
    {
        mst_basic.detail().name_hash()[i] = basic_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_basic);

    MinimalUnionMember mst_complex;
    mst_complex.common().member_id(memberId++);
    mst_complex.common().member_flags().TRY_CONSTRUCT1(false);
    mst_complex.common().member_flags().TRY_CONSTRUCT2(false);
    mst_complex.common().member_flags().IS_EXTERNAL(false);
    mst_complex.common().member_flags().IS_OPTIONAL(false);
    mst_complex.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_complex.common().member_flags().IS_KEY(false);
    mst_complex.common().member_flags().IS_DEFAULT(false);
    mst_complex.common().type_id(*GetComplexStructIdentifier());
    mst_complex.common().label_seq().emplace_back(::B);
    mst_complex.common().label_seq().emplace_back(::C);
    MD5 complex_hash("complex");
    for(int i = 0; i < 4; ++i)
    {
        mst_complex.detail().name_hash()[i] = complex_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_complex);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion");
}

const TypeIdentifier* TestTypeFactory::GetMyUnion2Identifier()
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("MyUnion2");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    GetMyUnion2Object();
    return GetTypeIdentifier("MyUnion2");
}

const TypeObject* TestTypeFactory::GetMyUnion2Object()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("MyUnion2");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*GetTypeIdentifier("uint8_t"));

    MemberId memberId = 0;
    MinimalUnionMember mst_uno;
    mst_uno.common().member_id(memberId++);
    mst_uno.common().member_flags().TRY_CONSTRUCT1(false);
    mst_uno.common().member_flags().TRY_CONSTRUCT2(false);
    mst_uno.common().member_flags().IS_EXTERNAL(false);
    mst_uno.common().member_flags().IS_OPTIONAL(false);
    mst_uno.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_uno.common().member_flags().IS_KEY(false);
    mst_uno.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_uno.common().type_id(*GetTypeIdentifier(cppType));
    }

    mst_uno.common().label_seq().emplace_back(A);
    MD5 uno_hash("uno");
    for(int i = 0; i < 4; ++i)
    {
        mst_uno.detail().name_hash()[i] = uno_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_uno);

    MinimalUnionMember mst_imString;
    mst_imString.common().member_id(memberId++);
    mst_imString.common().member_flags().TRY_CONSTRUCT1(false);
    mst_imString.common().member_flags().TRY_CONSTRUCT2(false);
    mst_imString.common().member_flags().IS_EXTERNAL(false);
    mst_imString.common().member_flags().IS_OPTIONAL(false);
    mst_imString.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_imString.common().member_flags().IS_KEY(false);
    mst_imString.common().member_flags().IS_DEFAULT(false);
    mst_imString.common().type_id(*TypeObjectFactory::GetInstance()->GetStringIdentifier(255, false));


    mst_imString.common().label_seq().emplace_back(B);
    MD5 imString_hash("imString");
    for(int i = 0; i < 4; ++i)
    {
        mst_imString.detail().name_hash()[i] = imString_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_imString);

    MinimalUnionMember mst_tres;
    mst_tres.common().member_id(memberId++);
    mst_tres.common().member_flags().TRY_CONSTRUCT1(false);
    mst_tres.common().member_flags().TRY_CONSTRUCT2(false);
    mst_tres.common().member_flags().IS_EXTERNAL(false);
    mst_tres.common().member_flags().IS_OPTIONAL(false);
    mst_tres.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_tres.common().member_flags().IS_KEY(false);
    mst_tres.common().member_flags().IS_DEFAULT(false);
    {
        std::string cppType = "int32_t";
        if (cppType == "long double")
        {
            cppType = "longdouble";
        }
        mst_tres.common().type_id(*GetTypeIdentifier(cppType));
    }

    mst_tres.common().label_seq().emplace_back(C);
    MD5 tres_hash("tres");
    for(int i = 0; i < 4; ++i)
    {
        mst_tres.detail().name_hash()[i] = tres_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_tres);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("MyUnion2", identifier, type_object);
    delete type_object;
    delete identifier;
    return GetTypeObject("MyUnion2");
}

const TypeIdentifier* TestTypeFactory::GetCompleteStructIdentifier()
{
    const TypeIdentifier * c_identifier = GetTypeIdentifier("CompleteStruct");
    if (c_identifier != nullptr)
    {
        return c_identifier;
    }

    const TypeObject* c_type_object = GetTypeObject("CompleteStruct");
    if (c_type_object != nullptr)
    {
        return &(c_type_object->minimal().struct_type().header().base_type());
    }
    else
    {
        const TypeObject* type_object = GetCompleteStructObject();
        // Just for other methods
        return &(type_object->minimal().struct_type().header().base_type());
    }
}

const TypeObject* TestTypeFactory::GetCompleteStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::GetInstance()->GetTypeObject("CompleteStruct");
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*GetMyUnionIdentifier());
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);

    MinimalStructMember mst_my_union_2;
    mst_my_union_2.common().member_id(memberId++);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union_2.common().member_flags().IS_EXTERNAL(false);
    mst_my_union_2.common().member_flags().IS_OPTIONAL(false);
    mst_my_union_2.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union_2.common().member_flags().IS_KEY(false);
    mst_my_union_2.common().member_flags().IS_DEFAULT(false);
    mst_my_union_2.common().member_type_id(*GetMyUnion2Identifier());
    MD5 my_union_2_hash("my_union_2");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union_2.detail().name_hash()[i] = my_union_2_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union_2);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos sólo con miembros... ¿también con flags?
    // Como no soportamos de momento tipos recursivos, esto debería bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::GetInstance()->AddTypeObject("CompleteStruct", &(type_object->minimal().struct_type().header().base_type()), type_object);
    delete type_object;
    return GetTypeObject("CompleteStruct");
}
