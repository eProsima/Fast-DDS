// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file TestTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "Test.h"
#include "TestTypeObject.h"
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

TestTypeFactory::TestTypeFactory()
{
    // Generate basic TypeIdentifiers
    TypeIdentifier *auxIdent;
    // TK_BOOLEAN:
    if (m_Identifiers.find("bool") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_BOOLEAN);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("bool", auxIdent));
    }
    // TK_BYTE:
    if (m_Identifiers.find("uint8_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_BYTE);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("uint8_t", auxIdent));
    }
    // TK_INT16:
    if (m_Identifiers.find("int16_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_INT16);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("int16_t", auxIdent));
    }
    // TK_INT32:
    if (m_Identifiers.find("int32_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_INT32);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("int32_t", auxIdent));
    }
    // TK_INT64:
    if (m_Identifiers.find("int64_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_INT64);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("int64_t", auxIdent));
    }
    // TK_UINT16:
    if (m_Identifiers.find("uint16_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_UINT16);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("uint16_t", auxIdent));
    }
    // TK_UINT32:
    if (m_Identifiers.find("uint32_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_UINT32);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("uint32_t", auxIdent));
    }
    // TK_UINT64:
    if (m_Identifiers.find("uint64_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_UINT64);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("uint64_t", auxIdent));
    }
    // TK_FLOAT32:
    if (m_Identifiers.find("float") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_FLOAT32);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("float", auxIdent));
    }
    // TK_FLOAT64:
    if (m_Identifiers.find("double") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_FLOAT64);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("double", auxIdent));
    }
    // TK_FLOAT128:
    if (m_Identifiers.find("longdouble") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_FLOAT128);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("longdouble", auxIdent));
    }
    // TK_CHAR8:
    if (m_Identifiers.find("char") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_CHAR8);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("char", auxIdent));
    }
    // TK_CHAR16:
    if (m_Identifiers.find("wchar_t") == m_Identifiers.end())
    {
        auxIdent = new TypeIdentifier;
        auxIdent->_d(TK_CHAR16);
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("wchar_t", auxIdent));
    }

    registerTypes();
}

TestTypeFactory::~TestTypeFactory()
{
    auto id_it = m_Identifiers.begin();
    while (id_it != m_Identifiers.end())
    {
        delete (id_it->second);
        ++id_it;
    }
    m_Identifiers.clear();

    auto obj_it = m_Objects.begin();
    while (obj_it != m_Objects.end())
    {
        delete (obj_it->second);
        ++obj_it;
    }
    m_Objects.clear();
}

static bool g_AlreadyRegistered = false;
void TestTypeFactory::registerTypes()
{
    if (g_AlreadyRegistered) return;

    TypeObjectFactory *factory = TypeObjectFactory::GetInstance();
    factory->AddTypeObject("MyEnum", getMyEnumIdentifier(), getMyEnumObject());
    factory->AddTypeObject("MyAliasEnum", getMyAliasEnumIdentifier(), getMyAliasEnumObject());
    factory->AddTypeObject("MyAliasEnum2", getMyAliasEnum2Identifier(), getMyAliasEnum2Object());
    factory->AddTypeObject("MyAliasEnum3", getMyAliasEnum3Identifier(), getMyAliasEnum3Object());
    factory->AddTypeObject("BasicStruct", getBasicStructIdentifier(), getBasicStructObject());
    factory->AddTypeObject("MyOctetArray500", getMyOctetArray500Identifier(), getMyOctetArray500Object());
    factory->AddTypeObject("BSAlias5", getBSAlias5Identifier(), getBSAlias5Object());
    factory->AddTypeObject("MA3", getMA3Identifier(), getMA3Object());
    factory->AddTypeObject("MyMiniArray", getMyMiniArrayIdentifier(), getMyMiniArrayObject());
    factory->AddTypeObject("MySequenceLong", getMySequenceLongIdentifier(), getMySequenceLongObject());
    factory->AddTypeObject("ComplexStruct", getComplexStructIdentifier(), getComplexStructObject());
    factory->AddTypeObject("MyUnion", getMyUnionIdentifier(), getMyUnionObject());
    factory->AddTypeObject("MyUnion2", getMyUnion2Identifier(), getMyUnion2Object());
    factory->AddTypeObject("CompleteStruct", getCompleteStructIdentifier(), getCompleteStructObject());

    g_AlreadyRegistered = true;
}

EquivalenceKind TestTypeFactory::getEquivalenceKind(const std::string &type_name) const
{
    if (type_name == "bool")
    {
        return TK_BOOLEAN;
    }
    else if (type_name == "int16_t")
    {
        return TK_INT16;
    }
    else if (type_name == "int32_t")
    {
        return TK_INT32;
    }
    else if (type_name == "uint16_t")
    {
        return TK_UINT16;
    }
    else if (type_name == "uint32_t")
    {
        return TK_UINT32;
    }
    else if (type_name == "float")
    {
        return TK_FLOAT32;
    }
    else if (type_name == "double")
    {
        return TK_FLOAT64;
    }
    else if (type_name == "char")
    {
        return TK_CHAR8;
    }
    else if (type_name == "octet")
    {
        return TK_BYTE;
    }
    else if (type_name.find("strings_") == 0)
    {
        return TI_STRING8_SMALL;
    }
    else if (type_name.find("stringl_") == 0)
    {
        return TI_STRING8_LARGE;
    }
    else if (type_name.find("sets_") == 0)
    {
        return TI_PLAIN_SEQUENCE_SMALL;
    }
    else if (type_name.find("setl_") == 0)
    {
        return TI_PLAIN_SEQUENCE_LARGE;
    }
    else if (type_name.find("arrays_") == 0)
    {
        return TI_PLAIN_ARRAY_SMALL;
    }
    else if (type_name.find("arrayl_") == 0)
    {
        return TI_PLAIN_ARRAY_LARGE;
    }
    else if (type_name == "int64_t")
    {
        return TK_INT64;
    }
    else if (type_name == "uint64_t")
    {
        return TK_UINT64;
    }
    else if (type_name == "longdouble")
    {
        return TK_FLOAT128;
    }
    else if (type_name == "wchar")
    {
        return TK_CHAR16;
    }
    else if (type_name.find("wstrings_") == 0)
    {
        return TI_STRING16_SMALL;
    }
    else if (type_name.find("wstringl_") == 0)
    {
        return TI_STRING16_LARGE;
    }
    else if (type_name.find("sequences_") == 0)
    {
        return TI_PLAIN_SEQUENCE_SMALL;
    }
    else if (type_name.find("sequencel_") == 0)
    {
        return TI_PLAIN_SEQUENCE_LARGE;
    }
    else if (type_name.find("maps_") == 0)
    {
        return TI_PLAIN_MAP_SMALL;
    }
    else if (type_name.find("mapl_") == 0)
    {
        return TI_PLAIN_MAP_LARGE;
    }
    else if (getTypeIdentifier(type_name) != nullptr)
    {
        return EK_MINIMAL;
    }
    else
    {
        return TK_NONE;
    }
}

TypeIdentifier* TestTypeFactory::tryCreateTypeIdentifier(const std::string &type_name)
{
    // Try users types.
    if (type_name == "MyEnum") return getMyEnumIdentifier();
    if (type_name == "MyAliasEnum") return getMyAliasEnumIdentifier();
    if (type_name == "MyAliasEnum2") return getMyAliasEnum2Identifier();
    if (type_name == "MyAliasEnum3") return getMyAliasEnum3Identifier();
    if (type_name == "BasicStruct") return getBasicStructIdentifier();
    if (type_name == "MyOctetArray500") return getMyOctetArray500Identifier();
    if (type_name == "BSAlias5") return getBSAlias5Identifier();
    if (type_name == "MA3") return getMA3Identifier();
    if (type_name == "MyMiniArray") return getMyMiniArrayIdentifier();
    if (type_name == "MySequenceLong") return getMySequenceLongIdentifier();
    if (type_name == "ComplexStruct") return getComplexStructIdentifier();
    if (type_name == "MyUnion") return getMyUnionIdentifier();
    if (type_name == "MyUnion2") return getMyUnion2Identifier();
    if (type_name == "CompleteStruct") return getCompleteStructIdentifier();

    switch (getEquivalenceKind(type_name))
    {
        // Primitive types, already defined (never will be asked, but ok)
        case TK_BOOLEAN:
        case TK_INT16:
        case TK_INT32:
        case TK_UINT16:
        case TK_UINT32:
        case TK_FLOAT32:
        case TK_FLOAT64:
        case TK_CHAR8:
        case TK_BYTE:
        case TK_INT64:
        case TK_UINT64:
        case TK_FLOAT128:
        case TK_CHAR16:
            return m_Identifiers.at(type_name);
            break;

        // TODO. Maybe, for users commodity, we want to create dinamycally this types.
        // To do it, type_name must be parsed and call recursively this method.
        //else if (type_name.find("std::strings_") == 0)
        case TI_STRING8_SMALL:
            break;
        //else if (type_name.find("std::stringl_") == 0)
        case TI_STRING8_LARGE:
            break;
        //else if (type_name.find("arrays_") == 0)
        case TI_PLAIN_ARRAY_SMALL:
            break;
        //else if (type_name.find("arrayl_") == 0)
        case TI_PLAIN_ARRAY_LARGE:
            break;
        //else if (type_name.find("std::wstrings_") == 0)
        case TI_STRING16_SMALL:
            break;
        //else if (type_name.find("std::wstringl_") == 0)
        case TI_STRING16_LARGE:
            break;
        //else if (type_name.find("sequences_") == 0)
        case TI_PLAIN_SEQUENCE_SMALL:
            break;
        //else if (type_name.find("sequencel_") == 0)
        case TI_PLAIN_SEQUENCE_LARGE:
            break;
        //else if (type_name.find("maps_") == 0)
        case TI_PLAIN_MAP_SMALL:
            break;
        //else if (type_name.find("mapl_") == 0)
        case TI_PLAIN_MAP_LARGE:
            break;
        //else if (getTypeIdentifier(type_name) != nullptr)
        case EK_MINIMAL:
            break;
        //else
        case TK_NONE:
            break;
    }
    return m_Identifiers.at(type_name);
}

static size_t split(const std::string &txt, std::vector<uint32_t> &strs, char ch)
{
    size_t pos = txt.find( ch );
    size_t initialPos = 0;
    strs.clear();

    // Decompose statement
    while( pos != std::string::npos ) {
        strs.push_back( std::stoi( txt.substr( initialPos, pos - initialPos ) ) );
        initialPos = pos + 1;

        pos = txt.find( ch, initialPos );
    }

    // Add the last one
    strs.push_back( std::stoi( txt.substr( initialPos, std::min( pos, txt.size() ) - initialPos + 1 ) ) );

    return strs.size();
}

TypeIdentifier* TestTypeFactory::getTypeIdentifier(const std::string &basic_type_name) const
{
    if (m_Identifiers.find(basic_type_name) != m_Identifiers.end())
    {
        return m_Identifiers.at(basic_type_name);
    }

    if (m_Aliases.find(basic_type_name) != m_Aliases.end())
    {
        return getTypeIdentifier(m_Aliases.at(basic_type_name));
    }

    return nullptr;
}

std::string TestTypeFactory::getStringTypeName(uint32_t bound, bool wide, bool generate_identifier)
{
    std::stringstream type;
    type << ((wide) ? "wstring" : "string");
    type << ((bound < 256) ? "s_" : "l_") << bound;
    if (generate_identifier) { getStringIdentifier(bound, wide); }
    return type.str();
}

std::string TestTypeFactory::getSequenceTypeName(const std::string &type_name, uint32_t bound,
    bool generate_identifier)
{
    std::stringstream auxType;
    auxType << ((bound < 256) ? "sequences_" : "sequencel_");
    auxType << type_name << "_" << bound;
    if (generate_identifier) { getSequenceIdentifier(type_name, bound); }
    return auxType.str();
}

std::string TestTypeFactory::getArrayTypeName(const std::string &type_name, const std::string &bound,
    bool generate_identifier)
{
    std::vector<uint32_t> vecBound;
    split(bound, vecBound, ' ');
    return getArrayTypeName(type_name, vecBound, generate_identifier);
}

std::string TestTypeFactory::getArrayTypeName(const std::string &type_name,
    const std::vector<uint32_t> &bound, bool generate_identifier)
{
    uint32_t unused;
    return getArrayTypeName(type_name, bound, unused, generate_identifier);
}

std::string TestTypeFactory::getArrayTypeName(const std::string &type_name,
    const std::vector<uint32_t> &bound, uint32_t &ret_size, bool generate_identifier)
{
    std::stringstream auxType;
    std::stringstream auxType2;
    auxType2 << type_name;
    uint32_t size = 0;
    for (uint32_t b : bound)
    {
        auxType2 << "_" << b;
        size += b;
    }
    if (size < 256)
    {
        auxType << "arrays_";
    }
    else
    {
        auxType << "arrayl_";
    }
    auxType << auxType2.str();
    ret_size = size;
    if (generate_identifier) { getArrayIdentifier(type_name, bound); }
    return auxType.str();
}

std::string TestTypeFactory::getMapTypeName(const std::string &key_type_name,
    const std::string &value_type_name, uint32_t bound, bool generate_identifier)
{
    std::stringstream auxType;
    auxType << ((bound < 256) ? "maps_" : "mapl_");
    auxType << key_type_name << "_" << value_type_name << "_" << bound;
    if (generate_identifier) { getMapIdentifier(key_type_name, value_type_name, bound); }
    return auxType.str();
}

TypeIdentifier* TestTypeFactory::getStringIdentifier(uint32_t bound, bool wide)
{
    std::string type = getStringTypeName(bound, wide, false);

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(type) != m_Identifiers.end())
    {
        return m_Identifiers.at(type);
    }
    else
    {
        auxIdent = new TypeIdentifier;
        if (bound < 256)
        {
            auxIdent->_d(wide ? TI_STRING16_SMALL : TI_STRING8_SMALL);
            auxIdent->string_sdefn().bound(static_cast<octet>(bound));
        }
        else
        {
            auxIdent->_d(wide ? TI_STRING16_LARGE : TI_STRING8_LARGE);
            auxIdent->string_ldefn().bound(bound);
        }
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>(type, auxIdent));
    }
    return auxIdent;
}

TypeIdentifier* TestTypeFactory::getSequenceIdentifier(const std::string &type_name, uint32_t bound)
{
    std::string auxType = getSequenceTypeName(type_name, bound, false);

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType) != m_Identifiers.end())
    {
        return m_Identifiers.at(auxType);
    }
    else
    {
        TypeIdentifier* innerIdent = getTypeIdentifier(type_name);
        if (innerIdent == nullptr)
        {
            innerIdent = tryCreateTypeIdentifier(type_name);
        }

        auxIdent = new TypeIdentifier;
        if (bound < 256)
        {
            auxIdent->_d(TI_PLAIN_SEQUENCE_SMALL);
            auxIdent->seq_sdefn().bound(static_cast<octet>(bound));
            auxIdent->seq_sdefn().element_identifier(innerIdent);
            auxIdent->seq_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->seq_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->seq_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->seq_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->seq_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->seq_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->seq_sdefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->seq_sdefn().header().equiv_kind(getEquivalenceKind(type_name));
        }
        else
        {
            auxIdent->_d(TI_PLAIN_SEQUENCE_LARGE);
            auxIdent->seq_ldefn().bound(bound);
            auxIdent->seq_ldefn().element_identifier(innerIdent);
            auxIdent->seq_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->seq_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->seq_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->seq_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->seq_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->seq_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->seq_ldefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->seq_ldefn().header().equiv_kind(getEquivalenceKind(type_name));
        }
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>(auxType, auxIdent));
    }

    return auxIdent;
}

TypeIdentifier* TestTypeFactory::getArrayIdentifier(const std::string &type_name, const std::vector<uint32_t> &bound)
{
    uint32_t size;
    std::string auxType = getArrayTypeName(type_name, bound, size, false);

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType) != m_Identifiers.end())
    {
        return m_Identifiers.at(auxType);
    }
    else
    {
        TypeIdentifier* innerIdent = getTypeIdentifier(type_name);
        if (innerIdent == nullptr)
        {
            innerIdent = tryCreateTypeIdentifier(type_name);
        }

        auxIdent = new TypeIdentifier;
        if (size < 256)
        {
            auxIdent->_d(TI_PLAIN_ARRAY_SMALL);
            for (uint32_t b : bound)
            {
                auxIdent->array_sdefn().array_bound_seq().push_back(static_cast<octet>(b));
            }
            auxIdent->array_sdefn().element_identifier(innerIdent);
            auxIdent->array_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->array_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->array_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->array_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->array_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->array_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->array_sdefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->array_sdefn().header().equiv_kind(getEquivalenceKind(type_name));
        }
        else
        {
            auxIdent->_d(TI_PLAIN_ARRAY_LARGE);
            for (uint32_t b : bound)
            {
                auxIdent->array_ldefn().array_bound_seq().push_back(b);
            }
            auxIdent->array_ldefn().element_identifier(innerIdent);
            auxIdent->array_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->array_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->array_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->array_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->array_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->array_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->array_ldefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->array_ldefn().header().equiv_kind(getEquivalenceKind(type_name));
        }
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>(auxType, auxIdent));
    }

    return auxIdent;
}

TypeIdentifier* TestTypeFactory::getArrayIdentifier(const std::string &type_name, const std::string &bound)
{
    std::vector<uint32_t> vecBound;
    split(bound, vecBound, ' ');
    return getArrayIdentifier(type_name, vecBound);
}

TypeIdentifier* TestTypeFactory::getMapIdentifier(const std::string &key_type_name,
    const std::string &value_type_name, uint32_t bound)
{
    std::string auxType = getMapTypeName(key_type_name, value_type_name, bound, false);

    TypeIdentifier* auxIdent;

    if (m_Identifiers.find(auxType) != m_Identifiers.end())
    {
        return m_Identifiers.at(auxType);
    }
    else
    {
        TypeIdentifier* keyIdent = getTypeIdentifier(key_type_name);
        TypeIdentifier* valIdent = getTypeIdentifier(value_type_name);

        if (keyIdent == nullptr)
        {
            keyIdent = tryCreateTypeIdentifier(key_type_name);
        }

        if (valIdent == nullptr)
        {
            valIdent = tryCreateTypeIdentifier(value_type_name);
        }

        auxIdent = new TypeIdentifier;
        if (bound < 256)
        {
            auxIdent->_d(TI_PLAIN_MAP_SMALL);
            auxIdent->map_sdefn().bound(static_cast<octet>(bound));
            auxIdent->map_sdefn().element_identifier(valIdent);
            auxIdent->map_sdefn().key_identifier(keyIdent);
            auxIdent->map_sdefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_sdefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_sdefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->map_sdefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->map_sdefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_sdefn().header().element_flags().IS_KEY(false);
            auxIdent->map_sdefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->map_sdefn().key_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_sdefn().key_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_sdefn().key_flags().IS_EXTERNAL(false);
            auxIdent->map_sdefn().key_flags().IS_OPTIONAL(false);
            auxIdent->map_sdefn().key_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_sdefn().key_flags().IS_KEY(false);
            auxIdent->map_sdefn().key_flags().IS_DEFAULT(false);
            auxIdent->map_sdefn().header().equiv_kind(getEquivalenceKind(value_type_name));
        }
        else
        {
            auxIdent->_d(TI_PLAIN_MAP_LARGE);
            auxIdent->map_ldefn().bound(bound);
            auxIdent->map_ldefn().element_identifier(valIdent);
            auxIdent->map_ldefn().key_identifier(keyIdent);
            auxIdent->map_ldefn().header().element_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_ldefn().header().element_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_ldefn().header().element_flags().IS_EXTERNAL(false);
            auxIdent->map_ldefn().header().element_flags().IS_OPTIONAL(false);
            auxIdent->map_ldefn().header().element_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_ldefn().header().element_flags().IS_KEY(false);
            auxIdent->map_ldefn().header().element_flags().IS_DEFAULT(false);
            auxIdent->map_ldefn().key_flags().TRY_CONSTRUCT1(false);
            auxIdent->map_ldefn().key_flags().TRY_CONSTRUCT2(false);
            auxIdent->map_ldefn().key_flags().IS_EXTERNAL(false);
            auxIdent->map_ldefn().key_flags().IS_OPTIONAL(false);
            auxIdent->map_ldefn().key_flags().IS_MUST_UNDERSTAND(false);
            auxIdent->map_ldefn().key_flags().IS_KEY(false);
            auxIdent->map_ldefn().key_flags().IS_DEFAULT(false);
            auxIdent->map_ldefn().header().equiv_kind(getEquivalenceKind(value_type_name));
        }
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>(auxType, auxIdent));
    }

    return auxIdent;
}

TypeIdentifier* TestTypeFactory::getMyEnumIdentifier()
{
    if (m_Identifiers.find("MyEnum") != m_Identifiers.end())
    {
        return m_Identifiers.at("MyEnum");
    }

    TypeObject* type_object;
    if (m_Objects.find("MyEnum") != m_Objects.end())
    {
        type_object = m_Objects.at("MyEnum");
    }
    else
    {
        type_object = getMyEnumObject();
    }

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalEnumeratedType::getCdrSerializedSize(type_object->minimal().enumerated_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;


    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("MyEnum", identifier));
    return identifier;
}

TypeObject* TestTypeFactory::getMyEnumObject()
{
    if (m_Objects.find("MyEnum") != m_Objects.end())
    {
        return m_Objects.at("MyEnum");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ENUM);
    // Unused
    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

    uint32_t value = 0;
    MinimalEnumeratedLiteral mel_A;
    mel_A.common().flags().TRY_CONSTRUCT1(false);
    mel_A.common().flags().TRY_CONSTRUCT2(false);
    mel_A.common().flags().IS_EXTERNAL(false);
    mel_A.common().flags().IS_OPTIONAL(false);
    mel_A.common().flags().IS_MUST_UNDERSTAND(false);
    mel_A.common().flags().IS_KEY(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().flags().IS_DEFAULT(false);
    mel_A.common().value(value++);
    MD5 A_hash("A");
    for(int i = 0; i < 4; ++i)
    {
        mel_A.detail().name_hash()[i] = A_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_A);

    MinimalEnumeratedLiteral mel_B;
    mel_B.common().flags().TRY_CONSTRUCT1(false);
    mel_B.common().flags().TRY_CONSTRUCT2(false);
    mel_B.common().flags().IS_EXTERNAL(false);
    mel_B.common().flags().IS_OPTIONAL(false);
    mel_B.common().flags().IS_MUST_UNDERSTAND(false);
    mel_B.common().flags().IS_KEY(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().flags().IS_DEFAULT(false);
    mel_B.common().value(value++);
    MD5 B_hash("B");
    for(int i = 0; i < 4; ++i)
    {
        mel_B.detail().name_hash()[i] = B_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_B);

    MinimalEnumeratedLiteral mel_C;
    mel_C.common().flags().TRY_CONSTRUCT1(false);
    mel_C.common().flags().TRY_CONSTRUCT2(false);
    mel_C.common().flags().IS_EXTERNAL(false);
    mel_C.common().flags().IS_OPTIONAL(false);
    mel_C.common().flags().IS_MUST_UNDERSTAND(false);
    mel_C.common().flags().IS_KEY(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().flags().IS_DEFAULT(false);
    mel_C.common().value(value++);
    MD5 C_hash("C");
    for(int i = 0; i < 4; ++i)
    {
        mel_C.detail().name_hash()[i] = C_hash.digest[i];
    }
    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_C);


    m_Objects.insert(std::pair<std::string, TypeObject*>("MyEnum", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyAliasEnumIdentifier()
{
    return getMyEnumIdentifier();
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMyAliasEnumObject()
{
    if (m_Objects.find("MyAliasEnum") != m_Objects.end())
    {
        return m_Objects.at("MyAliasEnum");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("MyEnum") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("MyEnum"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("MyEnum") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("MyEnum"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum", "MyEnum"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyAliasEnum", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyAliasEnum2Identifier()
{
    return getMyAliasEnumIdentifier();
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMyAliasEnum2Object()
{
    if (m_Objects.find("MyAliasEnum2") != m_Objects.end())
    {
        return m_Objects.at("MyAliasEnum2");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("MyAliasEnum") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("MyAliasEnum"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("MyAliasEnum") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("MyAliasEnum"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum2", "MyAliasEnum"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyAliasEnum2", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyAliasEnum3Identifier()
{
    return getMyAliasEnum2Identifier();
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMyAliasEnum3Object()
{
    if (m_Objects.find("MyAliasEnum3") != m_Objects.end())
    {
        return m_Objects.at("MyAliasEnum3");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("MyAliasEnum2") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("MyAliasEnum2"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("MyAliasEnum2") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("MyAliasEnum2"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyAliasEnum3", "MyAliasEnum2"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyAliasEnum3", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getBasicStructIdentifier()
{
    TypeObject* type_object;
    if (m_Objects.find("BasicStruct") != m_Objects.end())
    {
        type_object = m_Objects.at("BasicStruct");
    }
    else
    {
        type_object = getBasicStructObject();
        // Just for other methods
        TypeIdentifier *copy = new TypeIdentifier();
        *copy = type_object->minimal().struct_type().header().base_type();
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("BasicStruct", copy)); // A copy to be freed by destructor.
    }

    return &(type_object->minimal().struct_type().header().base_type());
}

TypeObject* TestTypeFactory::getBasicStructObject()
{
    if (m_Objects.find("BasicStruct") != m_Objects.end())
    {
        return m_Objects.at("BasicStruct");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_bool;
    mst_my_bool.common().member_id(memberId++);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_bool.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_bool.common().member_flags().IS_EXTERNAL(false);
    mst_my_bool.common().member_flags().IS_OPTIONAL(false);
    mst_my_bool.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_bool.common().member_flags().IS_KEY(false);
    mst_my_bool.common().member_flags().IS_DEFAULT(false);
    mst_my_bool.common().member_type_id(*m_Identifiers.at("bool"));

    MD5 my_bool_hash("my_bool");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_bool.detail().name_hash()[i] = my_bool_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_bool);

    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_octet.common().member_type_id(*m_Identifiers.at("uint8_t"));

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_int16;
    mst_my_int16.common().member_id(memberId++);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int16.common().member_flags().IS_EXTERNAL(false);
    mst_my_int16.common().member_flags().IS_OPTIONAL(false);
    mst_my_int16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int16.common().member_flags().IS_KEY(false);
    mst_my_int16.common().member_flags().IS_DEFAULT(false);
    mst_my_int16.common().member_type_id(*m_Identifiers.at("int16_t"));

    MD5 my_int16_hash("my_int16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int16.detail().name_hash()[i] = my_int16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int16);

    MinimalStructMember mst_my_int32;
    mst_my_int32.common().member_id(memberId++);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int32.common().member_flags().IS_EXTERNAL(false);
    mst_my_int32.common().member_flags().IS_OPTIONAL(false);
    mst_my_int32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int32.common().member_flags().IS_KEY(false);
    mst_my_int32.common().member_flags().IS_DEFAULT(false);
    mst_my_int32.common().member_type_id(*m_Identifiers.at("int32_t"));

    MD5 my_int32_hash("my_int32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int32.detail().name_hash()[i] = my_int32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int32);

    MinimalStructMember mst_my_int64;
    mst_my_int64.common().member_id(memberId++);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_int64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_int64.common().member_flags().IS_EXTERNAL(false);
    mst_my_int64.common().member_flags().IS_OPTIONAL(false);
    mst_my_int64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_int64.common().member_flags().IS_KEY(false);
    mst_my_int64.common().member_flags().IS_DEFAULT(false);
    mst_my_int64.common().member_type_id(*m_Identifiers.at("int64_t"));

    MD5 my_int64_hash("my_int64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_int64.detail().name_hash()[i] = my_int64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_int64);

    MinimalStructMember mst_my_uint16;
    mst_my_uint16.common().member_id(memberId++);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint16.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint16.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint16.common().member_flags().IS_KEY(false);
    mst_my_uint16.common().member_flags().IS_DEFAULT(false);
    mst_my_uint16.common().member_type_id(*m_Identifiers.at("uint16_t"));

    MD5 my_uint16_hash("my_uint16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint16.detail().name_hash()[i] = my_uint16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint16);

    MinimalStructMember mst_my_uint32;
    mst_my_uint32.common().member_id(memberId++);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint32.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint32.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint32.common().member_flags().IS_KEY(false);
    mst_my_uint32.common().member_flags().IS_DEFAULT(false);
    mst_my_uint32.common().member_type_id(*m_Identifiers.at("uint32_t"));

    MD5 my_uint32_hash("my_uint32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint32.detail().name_hash()[i] = my_uint32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint32);

    MinimalStructMember mst_my_uint64;
    mst_my_uint64.common().member_id(memberId++);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_uint64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_uint64.common().member_flags().IS_EXTERNAL(false);
    mst_my_uint64.common().member_flags().IS_OPTIONAL(false);
    mst_my_uint64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_uint64.common().member_flags().IS_KEY(false);
    mst_my_uint64.common().member_flags().IS_DEFAULT(false);
    mst_my_uint64.common().member_type_id(*m_Identifiers.at("uint64_t"));

    MD5 my_uint64_hash("my_uint64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_uint64.detail().name_hash()[i] = my_uint64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_uint64);

    MinimalStructMember mst_my_float32;
    mst_my_float32.common().member_id(memberId++);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float32.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float32.common().member_flags().IS_EXTERNAL(false);
    mst_my_float32.common().member_flags().IS_OPTIONAL(false);
    mst_my_float32.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float32.common().member_flags().IS_KEY(false);
    mst_my_float32.common().member_flags().IS_DEFAULT(false);
    mst_my_float32.common().member_type_id(*m_Identifiers.at("float"));

    MD5 my_float32_hash("my_float32");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float32.detail().name_hash()[i] = my_float32_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float32);

    MinimalStructMember mst_my_float64;
    mst_my_float64.common().member_id(memberId++);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float64.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float64.common().member_flags().IS_EXTERNAL(false);
    mst_my_float64.common().member_flags().IS_OPTIONAL(false);
    mst_my_float64.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float64.common().member_flags().IS_KEY(false);
    mst_my_float64.common().member_flags().IS_DEFAULT(false);
    mst_my_float64.common().member_type_id(*m_Identifiers.at("double"));

    MD5 my_float64_hash("my_float64");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float64.detail().name_hash()[i] = my_float64_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float64);

    MinimalStructMember mst_my_float128;
    mst_my_float128.common().member_id(memberId++);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_float128.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_float128.common().member_flags().IS_EXTERNAL(false);
    mst_my_float128.common().member_flags().IS_OPTIONAL(false);
    mst_my_float128.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_float128.common().member_flags().IS_KEY(false);
    mst_my_float128.common().member_flags().IS_DEFAULT(false);
    mst_my_float128.common().member_type_id(*m_Identifiers.at("long double"));

    MD5 my_float128_hash("my_float128");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_float128.detail().name_hash()[i] = my_float128_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_float128);

    MinimalStructMember mst_my_char;
    mst_my_char.common().member_id(memberId++);
    mst_my_char.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_char.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_char.common().member_flags().IS_EXTERNAL(false);
    mst_my_char.common().member_flags().IS_OPTIONAL(false);
    mst_my_char.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_char.common().member_flags().IS_KEY(false);
    mst_my_char.common().member_flags().IS_DEFAULT(false);
    mst_my_char.common().member_type_id(*m_Identifiers.at("char"));

    MD5 my_char_hash("my_char");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_char.detail().name_hash()[i] = my_char_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_char);

    MinimalStructMember mst_my_wchar;
    mst_my_wchar.common().member_id(memberId++);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wchar.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wchar.common().member_flags().IS_EXTERNAL(false);
    mst_my_wchar.common().member_flags().IS_OPTIONAL(false);
    mst_my_wchar.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wchar.common().member_flags().IS_KEY(false);
    mst_my_wchar.common().member_flags().IS_DEFAULT(false);
    mst_my_wchar.common().member_type_id(*m_Identifiers.at("wchar_t"));

    MD5 my_wchar_hash("my_wchar");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wchar.detail().name_hash()[i] = my_wchar_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wchar);

    MinimalStructMember mst_my_string;
    mst_my_string.common().member_id(memberId++);
    mst_my_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_string.common().member_flags().IS_KEY(false);
    mst_my_string.common().member_flags().IS_DEFAULT(false);
    mst_my_string.common().member_type_id(*getStringIdentifier(255, false));


    MD5 my_string_hash("my_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_string.detail().name_hash()[i] = my_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_string);

    MinimalStructMember mst_my_wstring;
    mst_my_wstring.common().member_id(memberId++);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_wstring.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_wstring.common().member_flags().IS_EXTERNAL(false);
    mst_my_wstring.common().member_flags().IS_OPTIONAL(false);
    mst_my_wstring.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_wstring.common().member_flags().IS_KEY(false);
    mst_my_wstring.common().member_flags().IS_DEFAULT(false);
    mst_my_wstring.common().member_type_id(*getStringIdentifier(255, true));


    MD5 my_wstring_hash("my_wstring");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_wstring.detail().name_hash()[i] = my_wstring_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_wstring);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos slo con miembros... tambin con flags?
    // Como no soportamos de momento tipos recursivos, esto debera bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Objects.insert(std::pair<std::string, TypeObject*>("BasicStruct", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyOctetArray500Identifier()
{
    return getArrayIdentifier("uint8_t", "500");
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMyOctetArray500Object()
{
    if (m_Objects.find("MyOctetArray500") != m_Objects.end())
    {
        return m_Objects.at("MyOctetArray500");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("std::array<uint8_t, 500>") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("std::array<uint8_t, 500>"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("std::array<uint8_t, 500>") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("std::array<uint8_t, 500>"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyOctetArray500", "std::array<uint8_t, 500>"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyOctetArray500", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getBSAlias5Identifier()
{
    return getArrayIdentifier("BasicStruct", "5");
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getBSAlias5Object()
{
    if (m_Objects.find("BSAlias5") != m_Objects.end())
    {
        return m_Objects.at("BSAlias5");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("std::array<BasicStruct, 5>") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("std::array<BasicStruct, 5>"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("std::array<BasicStruct, 5>") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("std::array<BasicStruct, 5>"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("BSAlias5", "std::array<BasicStruct, 5>"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("BSAlias5", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMA3Identifier()
{
    return getArrayIdentifier("MyAliasEnum3", "42");
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMA3Object()
{
    if (m_Objects.find("MA3") != m_Objects.end())
    {
        return m_Objects.at("MA3");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("std::array<MyAliasEnum3, 42>") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("std::array<MyAliasEnum3, 42>"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("std::array<MyAliasEnum3, 42>") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("std::array<MyAliasEnum3, 42>"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MA3", "std::array<MyAliasEnum3, 42>"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MA3", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyMiniArrayIdentifier()
{
    return getArrayIdentifier("int32_t", "2");
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMyMiniArrayObject()
{
    if (m_Objects.find("MyMiniArray") != m_Objects.end())
    {
        return m_Objects.at("MyMiniArray");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("std::array<int32_t, 2>") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("std::array<int32_t, 2>"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("std::array<int32_t, 2>") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("std::array<int32_t, 2>"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MyMiniArray", "std::array<int32_t, 2>"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyMiniArray", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMySequenceLongIdentifier()
{
    return getSequenceIdentifier("int32_t", 100);
    //return getIdentifier();
}

TypeObject* TestTypeFactory::getMySequenceLongObject()
{
    if (m_Objects.find("MySequenceLong") != m_Objects.end())
    {
        return m_Objects.at("MySequenceLong");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_ALIAS);
    type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
    type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
    type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
    type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

    // type_object->minimal().alias_type().header()... Is empty

    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
    type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

    // Must be defined already, if don't, may be an recursive alias
    if (m_Identifiers.find("std::vector<int32_t>") != m_Identifiers.end())
    {
        type_object->minimal().alias_type().body().common().related_type() =
            *m_Identifiers.at("std::vector<int32_t>"); // Make a copy
    }
    else
    {
        if (m_Aliases.find("std::vector<int32_t>") != m_Aliases.end())
        {
            type_object->minimal().alias_type().body().common().related_type() =
                *getTypeIdentifier(m_Aliases.at("std::vector<int32_t>"));
        }
        else
        {
            // Cannot determine base type
            return nullptr;
        }
    }

    // Don't add our TypeIdentifier but our alias
    m_Aliases.emplace(std::pair<std::string, std::string>("MySequenceLong", "std::vector<int32_t>"));

    m_Objects.insert(std::pair<std::string, TypeObject*>("MySequenceLong", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getComplexStructIdentifier()
{
    TypeObject* type_object;
    if (m_Objects.find("ComplexStruct") != m_Objects.end())
    {
        type_object = m_Objects.at("ComplexStruct");
    }
    else
    {
        type_object = getComplexStructObject();
        // Just for other methods
        TypeIdentifier *copy = new TypeIdentifier();
        *copy = type_object->minimal().struct_type().header().base_type();
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("ComplexStruct", copy)); // A copy to be freed by destructor.
    }

    return &(type_object->minimal().struct_type().header().base_type());
}

TypeObject* TestTypeFactory::getComplexStructObject()
{
    if (m_Objects.find("ComplexStruct") != m_Objects.end())
    {
        return m_Objects.at("ComplexStruct");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_octet;
    mst_my_octet.common().member_id(memberId++);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet.common().member_flags().IS_KEY(false);
    mst_my_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_octet.common().member_type_id(*m_Identifiers.at("uint8_t"));

    MD5 my_octet_hash("my_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet.detail().name_hash()[i] = my_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet);

    MinimalStructMember mst_my_basic_struct;
    mst_my_basic_struct.common().member_id(memberId++);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_basic_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_basic_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_basic_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_basic_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_basic_struct.common().member_flags().IS_KEY(false);
    mst_my_basic_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_basic_struct.common().member_type_id(*getBasicStructIdentifier());
    MD5 my_basic_struct_hash("my_basic_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_basic_struct.detail().name_hash()[i] = my_basic_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_basic_struct);

    MinimalStructMember mst_my_alias_enum;
    mst_my_alias_enum.common().member_id(memberId++);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_alias_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_alias_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_alias_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_alias_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_alias_enum.common().member_flags().IS_KEY(false);
    mst_my_alias_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_alias_enum.common().member_type_id(*getMyAliasEnumIdentifier());
    MD5 my_alias_enum_hash("my_alias_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_alias_enum.detail().name_hash()[i] = my_alias_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_alias_enum);

    MinimalStructMember mst_my_enum;
    mst_my_enum.common().member_id(memberId++);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_enum.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_enum.common().member_flags().IS_EXTERNAL(false);
    mst_my_enum.common().member_flags().IS_OPTIONAL(false);
    mst_my_enum.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_enum.common().member_flags().IS_KEY(false);
    mst_my_enum.common().member_flags().IS_DEFAULT(false);
    mst_my_enum.common().member_type_id(*getMyEnumIdentifier());
    MD5 my_enum_hash("my_enum");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_enum.detail().name_hash()[i] = my_enum_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_enum);

    MinimalStructMember mst_my_sequence_octet;
    mst_my_sequence_octet.common().member_id(memberId++);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_octet.common().member_flags().IS_KEY(false);
    mst_my_sequence_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_octet.common().member_type_id(*getSequenceIdentifier("uint8_t", 55));


    MD5 my_sequence_octet_hash("my_sequence_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_octet.detail().name_hash()[i] = my_sequence_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_octet);

    MinimalStructMember mst_my_sequence_struct;
    mst_my_sequence_struct.common().member_id(memberId++);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequence_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequence_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequence_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequence_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequence_struct.common().member_flags().IS_KEY(false);
    mst_my_sequence_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_sequence_struct.common().member_type_id(*getSequenceIdentifier("BasicStruct", 100));


    MD5 my_sequence_struct_hash("my_sequence_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequence_struct.detail().name_hash()[i] = my_sequence_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequence_struct);

    MinimalStructMember mst_my_array_octet;
    mst_my_array_octet.common().member_id(memberId++);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_octet.common().member_flags().IS_KEY(false);
    mst_my_array_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_array_octet.common().member_type_id(*getArrayIdentifier("char", "500 5 4"));


    MD5 my_array_octet_hash("my_array_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_octet.detail().name_hash()[i] = my_array_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_octet);

    MinimalStructMember mst_my_octet_array_500;
    mst_my_octet_array_500.common().member_id(memberId++);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_octet_array_500.common().member_type_id(*getMyOctetArray500Identifier());
    MD5 my_octet_array_500_hash("my_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_octet_array_500.detail().name_hash()[i] = my_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_octet_array_500);

    MinimalStructMember mst_my_array_struct;
    mst_my_array_struct.common().member_id(memberId++);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_struct.common().member_flags().IS_KEY(false);
    mst_my_array_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_array_struct.common().member_type_id(*getArrayIdentifier("BasicStruct", "5"));


    MD5 my_array_struct_hash("my_array_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_struct.detail().name_hash()[i] = my_array_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_struct);

    MinimalStructMember mst_my_map_octet_short;
    mst_my_map_octet_short.common().member_id(memberId++);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_octet_short.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_octet_short.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_octet_short.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_octet_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_octet_short.common().member_flags().IS_KEY(false);
    mst_my_map_octet_short.common().member_flags().IS_DEFAULT(false);
    mst_my_map_octet_short.common().member_type_id(*getMapIdentifier("uint8_t", "int16_t", 100));


    MD5 my_map_octet_short_hash("my_map_octet_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_octet_short.detail().name_hash()[i] = my_map_octet_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_octet_short);

    MinimalStructMember mst_my_map_long_struct;
    mst_my_map_long_struct.common().member_id(memberId++);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_struct.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_struct.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_struct.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_struct.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_struct.common().member_flags().IS_KEY(false);
    mst_my_map_long_struct.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_struct.common().member_type_id(*getMapIdentifier("int32_t", "BasicStruct", 100));


    MD5 my_map_long_struct_hash("my_map_long_struct");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_struct.detail().name_hash()[i] = my_map_long_struct_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_struct);

    MinimalStructMember mst_my_map_long_seq_octet;
    mst_my_map_long_seq_octet.common().member_id(memberId++);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_seq_octet.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_KEY(false);
    mst_my_map_long_seq_octet.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_seq_octet.common().member_type_id(*getMapIdentifier("int32_t", getSequenceTypeName(getSequenceTypeName("uint8_t", 100), 100), 100));


    MD5 my_map_long_seq_octet_hash("my_map_long_seq_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_seq_octet.detail().name_hash()[i] = my_map_long_seq_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_seq_octet);

    MinimalStructMember mst_my_map_long_octet_array_500;
    mst_my_map_long_octet_array_500.common().member_id(memberId++);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_octet_array_500.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_KEY(false);
    mst_my_map_long_octet_array_500.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_octet_array_500.common().member_type_id(*getMapIdentifier("int32_t", "MyOctetArray500", 100));


    MD5 my_map_long_octet_array_500_hash("my_map_long_octet_array_500");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_octet_array_500.detail().name_hash()[i] = my_map_long_octet_array_500_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_octet_array_500);

    MinimalStructMember mst_my_map_long_lol_type;
    mst_my_map_long_lol_type.common().member_id(memberId++);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_map_long_lol_type.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_map_long_lol_type.common().member_flags().IS_EXTERNAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_OPTIONAL(false);
    mst_my_map_long_lol_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_map_long_lol_type.common().member_flags().IS_KEY(false);
    mst_my_map_long_lol_type.common().member_flags().IS_DEFAULT(false);
    mst_my_map_long_lol_type.common().member_type_id(*getMapIdentifier("int32_t", getMapTypeName("uint8_t", "BSAlias5", 100), 100));


    MD5 my_map_long_lol_type_hash("my_map_long_lol_type");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_map_long_lol_type.detail().name_hash()[i] = my_map_long_lol_type_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_map_long_lol_type);

    MinimalStructMember mst_my_small_string_8;
    mst_my_small_string_8.common().member_id(memberId++);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_8.common().member_flags().IS_KEY(false);
    mst_my_small_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_8.common().member_type_id(*getStringIdentifier(128, false));


    MD5 my_small_string_8_hash("my_small_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_8.detail().name_hash()[i] = my_small_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_8);

    MinimalStructMember mst_my_small_string_16;
    mst_my_small_string_16.common().member_id(memberId++);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_small_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_small_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_small_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_small_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_small_string_16.common().member_flags().IS_KEY(false);
    mst_my_small_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_small_string_16.common().member_type_id(*getStringIdentifier(64, true));


    MD5 my_small_string_16_hash("my_small_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_small_string_16.detail().name_hash()[i] = my_small_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_small_string_16);

    MinimalStructMember mst_my_large_string_8;
    mst_my_large_string_8.common().member_id(memberId++);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_8.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_8.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_8.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_8.common().member_flags().IS_KEY(false);
    mst_my_large_string_8.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_8.common().member_type_id(*getStringIdentifier(500, false));


    MD5 my_large_string_8_hash("my_large_string_8");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_8.detail().name_hash()[i] = my_large_string_8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_8);

    MinimalStructMember mst_my_large_string_16;
    mst_my_large_string_16.common().member_id(memberId++);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_large_string_16.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_large_string_16.common().member_flags().IS_EXTERNAL(false);
    mst_my_large_string_16.common().member_flags().IS_OPTIONAL(false);
    mst_my_large_string_16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_large_string_16.common().member_flags().IS_KEY(false);
    mst_my_large_string_16.common().member_flags().IS_DEFAULT(false);
    mst_my_large_string_16.common().member_type_id(*getStringIdentifier(1024, true));


    MD5 my_large_string_16_hash("my_large_string_16");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_large_string_16.detail().name_hash()[i] = my_large_string_16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_large_string_16);

    MinimalStructMember mst_my_array_string;
    mst_my_array_string.common().member_id(memberId++);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_string.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_string.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_string.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_string.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_string.common().member_flags().IS_KEY(false);
    mst_my_array_string.common().member_flags().IS_DEFAULT(false);
    mst_my_array_string.common().member_type_id(*getArrayIdentifier(getStringTypeName(75, false), "5 5"));


    MD5 my_array_string_hash("my_array_string");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_string.detail().name_hash()[i] = my_array_string_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_string);

    MinimalStructMember mst_multi_alias_array_42;
    mst_multi_alias_array_42.common().member_id(memberId++);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT1(false);
    mst_multi_alias_array_42.common().member_flags().TRY_CONSTRUCT2(false);
    mst_multi_alias_array_42.common().member_flags().IS_EXTERNAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_OPTIONAL(false);
    mst_multi_alias_array_42.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_multi_alias_array_42.common().member_flags().IS_KEY(false);
    mst_multi_alias_array_42.common().member_flags().IS_DEFAULT(false);
    mst_multi_alias_array_42.common().member_type_id(*getMA3Identifier());
    MD5 multi_alias_array_42_hash("multi_alias_array_42");
    for(int i = 0; i < 4; ++i)
    {
        mst_multi_alias_array_42.detail().name_hash()[i] = multi_alias_array_42_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_multi_alias_array_42);

    MinimalStructMember mst_my_array_arrays;
    mst_my_array_arrays.common().member_id(memberId++);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_array_arrays.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_array_arrays.common().member_flags().IS_EXTERNAL(false);
    mst_my_array_arrays.common().member_flags().IS_OPTIONAL(false);
    mst_my_array_arrays.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_array_arrays.common().member_flags().IS_KEY(false);
    mst_my_array_arrays.common().member_flags().IS_DEFAULT(false);
    mst_my_array_arrays.common().member_type_id(*getArrayIdentifier("MyMiniArray", "5"));


    MD5 my_array_arrays_hash("my_array_arrays");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_array_arrays.detail().name_hash()[i] = my_array_arrays_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_array_arrays);

    MinimalStructMember mst_my_sequences_array;
    mst_my_sequences_array.common().member_id(memberId++);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_sequences_array.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_sequences_array.common().member_flags().IS_EXTERNAL(false);
    mst_my_sequences_array.common().member_flags().IS_OPTIONAL(false);
    mst_my_sequences_array.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_sequences_array.common().member_flags().IS_KEY(false);
    mst_my_sequences_array.common().member_flags().IS_DEFAULT(false);
    mst_my_sequences_array.common().member_type_id(*getArrayIdentifier("MySequenceLong", "23"));


    MD5 my_sequences_array_hash("my_sequences_array");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_sequences_array.detail().name_hash()[i] = my_sequences_array_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_sequences_array);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos slo con miembros... tambin con flags?
    // Como no soportamos de momento tipos recursivos, esto debera bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Objects.insert(std::pair<std::string, TypeObject*>("ComplexStruct", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyUnionIdentifier()
{
    if (m_Identifiers.find("MyUnion") != m_Identifiers.end())
    {
        return m_Identifiers.at("MyUnion");
    }

    TypeObject* type_object;
    if (m_Objects.find("MyUnion") != m_Objects.end())
    {
        type_object = m_Objects.at("MyUnion");
    }
    else
    {
        type_object = getMyUnionObject();
    }

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;


    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("MyUnion", identifier));
    return identifier;
}

TypeObject* TestTypeFactory::getMyUnionObject()
{
    if (m_Objects.find("MyUnion") != m_Objects.end())
    {
        return m_Objects.at("MyUnion");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*getMyEnumIdentifier());

    MemberId memberId = 0;
    MinimalUnionMember mst_basic;
    mst_basic.common().member_id(memberId++);
    mst_basic.common().member_flags().TRY_CONSTRUCT1(false);
    mst_basic.common().member_flags().TRY_CONSTRUCT2(false);
    mst_basic.common().member_flags().IS_EXTERNAL(false);
    mst_basic.common().member_flags().IS_OPTIONAL(false);
    mst_basic.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_basic.common().member_flags().IS_KEY(false);
    mst_basic.common().member_flags().IS_DEFAULT(false);
    mst_basic.common().type_id(*getBasicStructIdentifier());
    mst_basic.common().label_seq().emplace_back(::A);
    MD5 basic_hash("basic");
    for(int i = 0; i < 4; ++i)
    {
        mst_basic.detail().name_hash()[i] = basic_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_basic);

    MinimalUnionMember mst_complex;
    mst_complex.common().member_id(memberId++);
    mst_complex.common().member_flags().TRY_CONSTRUCT1(false);
    mst_complex.common().member_flags().TRY_CONSTRUCT2(false);
    mst_complex.common().member_flags().IS_EXTERNAL(false);
    mst_complex.common().member_flags().IS_OPTIONAL(false);
    mst_complex.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_complex.common().member_flags().IS_KEY(false);
    mst_complex.common().member_flags().IS_DEFAULT(false);
    mst_complex.common().type_id(*getComplexStructIdentifier());
    mst_complex.common().label_seq().emplace_back(::B);
    mst_complex.common().label_seq().emplace_back(::C);
    MD5 complex_hash("complex");
    for(int i = 0; i < 4; ++i)
    {
        mst_complex.detail().name_hash()[i] = complex_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_complex);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyUnion", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getMyUnion2Identifier()
{
    if (m_Identifiers.find("MyUnion2") != m_Identifiers.end())
    {
        return m_Identifiers.at("MyUnion2");
    }

    TypeObject* type_object;
    if (m_Objects.find("MyUnion2") != m_Objects.end())
    {
        type_object = m_Objects.at("MyUnion2");
    }
    else
    {
        type_object = getMyUnion2Object();
    }

    TypeIdentifier* identifier = new TypeIdentifier();
    identifier->_d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalUnionType::getCdrSerializedSize(type_object->minimal().union_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;


    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier->equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("MyUnion2", identifier));
    return identifier;
}

TypeObject* TestTypeFactory::getMyUnion2Object()
{
    if (m_Objects.find("MyUnion2") != m_Objects.end())
    {
        return m_Objects.at("MyUnion2");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_UNION);

    type_object->minimal().union_type().union_flags().IS_FINAL(false);
    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
    type_object->minimal().union_type().union_flags().IS_NESTED(false);
    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false);

    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false);
    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false);
    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false);

    type_object->minimal().union_type().discriminator().common().type_id(*m_Identifiers.at("uint8_t"));

    MemberId memberId = 0;
    MinimalUnionMember mst_uno;
    mst_uno.common().member_id(memberId++);
    mst_uno.common().member_flags().TRY_CONSTRUCT1(false);
    mst_uno.common().member_flags().TRY_CONSTRUCT2(false);
    mst_uno.common().member_flags().IS_EXTERNAL(false);
    mst_uno.common().member_flags().IS_OPTIONAL(false);
    mst_uno.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_uno.common().member_flags().IS_KEY(false);
    mst_uno.common().member_flags().IS_DEFAULT(false);
    mst_uno.common().type_id(*m_Identifiers.at("int32_t"));

    mst_uno.common().label_seq().emplace_back(A);
    MD5 uno_hash("uno");
    for(int i = 0; i < 4; ++i)
    {
        mst_uno.detail().name_hash()[i] = uno_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_uno);

    MinimalUnionMember mst_imString;
    mst_imString.common().member_id(memberId++);
    mst_imString.common().member_flags().TRY_CONSTRUCT1(false);
    mst_imString.common().member_flags().TRY_CONSTRUCT2(false);
    mst_imString.common().member_flags().IS_EXTERNAL(false);
    mst_imString.common().member_flags().IS_OPTIONAL(false);
    mst_imString.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_imString.common().member_flags().IS_KEY(false);
    mst_imString.common().member_flags().IS_DEFAULT(false);
    mst_imString.common().type_id(*getStringIdentifier(255, false));


    mst_imString.common().label_seq().emplace_back(B);
    MD5 imString_hash("imString");
    for(int i = 0; i < 4; ++i)
    {
        mst_imString.detail().name_hash()[i] = imString_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_imString);

    MinimalUnionMember mst_tres;
    mst_tres.common().member_id(memberId++);
    mst_tres.common().member_flags().TRY_CONSTRUCT1(false);
    mst_tres.common().member_flags().TRY_CONSTRUCT2(false);
    mst_tres.common().member_flags().IS_EXTERNAL(false);
    mst_tres.common().member_flags().IS_OPTIONAL(false);
    mst_tres.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_tres.common().member_flags().IS_KEY(false);
    mst_tres.common().member_flags().IS_DEFAULT(false);
    mst_tres.common().type_id(*m_Identifiers.at("int32_t"));

    mst_tres.common().label_seq().emplace_back(C);
    MD5 tres_hash("tres");
    for(int i = 0; i < 4; ++i)
    {
        mst_tres.detail().name_hash()[i] = tres_hash.digest[i];
    }
    type_object->minimal().union_type().member_seq().emplace_back(mst_tres);


    // Header
    //type_object->minimal().union_type().header().detail()... // Empty

    m_Objects.insert(std::pair<std::string, TypeObject*>("MyUnion2", type_object));
    return type_object;
}

TypeIdentifier* TestTypeFactory::getCompleteStructIdentifier()
{
    TypeObject* type_object;
    if (m_Objects.find("CompleteStruct") != m_Objects.end())
    {
        type_object = m_Objects.at("CompleteStruct");
    }
    else
    {
        type_object = getCompleteStructObject();
        // Just for other methods
        TypeIdentifier *copy = new TypeIdentifier();
        *copy = type_object->minimal().struct_type().header().base_type();
        m_Identifiers.insert(std::pair<std::string, TypeIdentifier*>("CompleteStruct", copy)); // A copy to be freed by destructor.
    }

    return &(type_object->minimal().struct_type().header().base_type());
}

TypeObject* TestTypeFactory::getCompleteStructObject()
{
    if (m_Objects.find("CompleteStruct") != m_Objects.end())
    {
        return m_Objects.at("CompleteStruct");
    }

    TypeObject* type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);

    MemberId memberId = 0;
    MinimalStructMember mst_my_union;
    mst_my_union.common().member_id(memberId++);
    mst_my_union.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union.common().member_flags().IS_EXTERNAL(false);
    mst_my_union.common().member_flags().IS_OPTIONAL(false);
    mst_my_union.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union.common().member_flags().IS_KEY(false);
    mst_my_union.common().member_flags().IS_DEFAULT(false);
    mst_my_union.common().member_type_id(*getMyUnionIdentifier());
    MD5 my_union_hash("my_union");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union.detail().name_hash()[i] = my_union_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union);

    MinimalStructMember mst_my_union_2;
    mst_my_union_2.common().member_id(memberId++);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT1(false);
    mst_my_union_2.common().member_flags().TRY_CONSTRUCT2(false);
    mst_my_union_2.common().member_flags().IS_EXTERNAL(false);
    mst_my_union_2.common().member_flags().IS_OPTIONAL(false);
    mst_my_union_2.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_my_union_2.common().member_flags().IS_KEY(false);
    mst_my_union_2.common().member_flags().IS_DEFAULT(false);
    mst_my_union_2.common().member_type_id(*getMyUnion2Identifier());
    MD5 my_union_2_hash("my_union_2");
    for(int i = 0; i < 4; ++i)
    {
        mst_my_union_2.detail().name_hash()[i] = my_union_2_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_my_union_2);


    // Header
    type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    // TODO De momento lo haremos slo con miembros... tambin con flags?
    // Como no soportamos de momento tipos recursivos, esto debera bastar.
    SerializedPayload_t payload(static_cast<uint32_t>(
        type_object->minimal().struct_type().member_seq().size() * sizeof(MinimalStructMember) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size); // Object that manages the raw buffer.

    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;
    // Serialize encapsulation

    for (MinimalStructMember &st : type_object->minimal().struct_type().member_seq())
    {
        ser << st;
    }
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        type_object->minimal().struct_type().header().base_type().equivalence_hash()[i] = objectHash.digest[i];
    }

    m_Objects.insert(std::pair<std::string, TypeObject*>("CompleteStruct", type_object));
    return type_object;
}
