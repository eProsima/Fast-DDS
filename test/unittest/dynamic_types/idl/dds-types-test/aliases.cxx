// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file aliases.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "aliases.h"
#include "aliasesTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define InnerStructureHelper_max_cdr_typesize 8ULL;


#define AliasMap_max_cdr_typesize 404ULL;


#define AliasInt64_max_cdr_typesize 8ULL;

#define AliasFloat128_max_cdr_typesize 16ULL;
#define AliasInt16_max_cdr_typesize 2ULL;

#define AliasEnum_max_cdr_typesize 4ULL;


#define AliasFloat64_max_cdr_typesize 8ULL;
#define AliasOctet_max_cdr_typesize 1ULL;
#define AliasAlias_max_cdr_typesize 4ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;
#define AliasArray_max_cdr_typesize 4ULL;
#define AliasUint16_max_cdr_typesize 2ULL;
#define AliasString16_max_cdr_typesize 1024ULL;

#define AliasInt32_max_cdr_typesize 4ULL;

#define AliasString8_max_cdr_typesize 260ULL;


#define AliasStruct_max_cdr_typesize 8ULL;







#define AliasFloat32_max_cdr_typesize 4ULL;

#define AliasBitmask_max_cdr_typesize 4ULL;
#define AliasUnion_max_cdr_typesize 4ULL;
#define AliasMultiArray_max_cdr_typesize 8ULL;
#define AliasUInt32_max_cdr_typesize 4ULL;
#define AliasChar16_max_cdr_typesize 4ULL;





#define AliasChar8_max_cdr_typesize 1ULL;
#define AliasUInt64_max_cdr_typesize 8ULL;


#define AliasSequence_max_cdr_typesize 204ULL;






#define AliasBool_max_cdr_typesize 1ULL;

#define AliasBitset_max_cdr_typesize 8ULL;

#define InnerStructureHelper_max_key_cdr_typesize 0ULL;


#define AliasMap_max_key_cdr_typesize 0ULL;


#define AliasInt64_max_key_cdr_typesize 0ULL;

#define AliasFloat128_max_key_cdr_typesize 0ULL;
#define AliasInt16_max_key_cdr_typesize 0ULL;

#define AliasEnum_max_key_cdr_typesize 0ULL;


#define AliasFloat64_max_key_cdr_typesize 0ULL;
#define AliasOctet_max_key_cdr_typesize 0ULL;
#define AliasAlias_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;
#define AliasArray_max_key_cdr_typesize 0ULL;
#define AliasUint16_max_key_cdr_typesize 0ULL;
#define AliasString16_max_key_cdr_typesize 0ULL;

#define AliasInt32_max_key_cdr_typesize 0ULL;

#define AliasString8_max_key_cdr_typesize 0ULL;


#define AliasStruct_max_key_cdr_typesize 0ULL;







#define AliasFloat32_max_key_cdr_typesize 0ULL;

#define AliasBitmask_max_key_cdr_typesize 0ULL;
#define AliasUnion_max_key_cdr_typesize 0ULL;
#define AliasMultiArray_max_key_cdr_typesize 0ULL;
#define AliasUInt32_max_key_cdr_typesize 0ULL;
#define AliasChar16_max_key_cdr_typesize 0ULL;





#define AliasChar8_max_key_cdr_typesize 0ULL;
#define AliasUInt64_max_key_cdr_typesize 0ULL;


#define AliasSequence_max_key_cdr_typesize 0ULL;






#define AliasBool_max_key_cdr_typesize 0ULL;

#define AliasBitset_max_key_cdr_typesize 0ULL;

































AliasInt16::AliasInt16()
{
    // alias_int16 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasInt16::~AliasInt16()
{
}

AliasInt16::AliasInt16(
        const AliasInt16& x)
{
    m_value = x.m_value;
}

AliasInt16::AliasInt16(
        AliasInt16&& x) noexcept 
{
    m_value = x.m_value;
}

AliasInt16& AliasInt16::operator =(
        const AliasInt16& x)
{

    m_value = x.m_value;

    return *this;
}

AliasInt16& AliasInt16::operator =(
        AliasInt16&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasInt16::operator ==(
        const AliasInt16& x) const
{

    return (m_value == x.m_value);
}

bool AliasInt16::operator !=(
        const AliasInt16& x) const
{
    return !(*this == x);
}

size_t AliasInt16::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt16_max_cdr_typesize;
}

size_t AliasInt16::getCdrSerializedSize(
        const AliasInt16& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void AliasInt16::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasInt16::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasInt16::value(
        alias_int16 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_int16 AliasInt16::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_int16& AliasInt16::value()
{
    return m_value;
}



size_t AliasInt16::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt16_max_key_cdr_typesize;
}

bool AliasInt16::isKeyDefined()
{
    return false;
}

void AliasInt16::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasUint16::AliasUint16()
{
    // alias_uint16 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasUint16::~AliasUint16()
{
}

AliasUint16::AliasUint16(
        const AliasUint16& x)
{
    m_value = x.m_value;
}

AliasUint16::AliasUint16(
        AliasUint16&& x) noexcept 
{
    m_value = x.m_value;
}

AliasUint16& AliasUint16::operator =(
        const AliasUint16& x)
{

    m_value = x.m_value;

    return *this;
}

AliasUint16& AliasUint16::operator =(
        AliasUint16&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasUint16::operator ==(
        const AliasUint16& x) const
{

    return (m_value == x.m_value);
}

bool AliasUint16::operator !=(
        const AliasUint16& x) const
{
    return !(*this == x);
}

size_t AliasUint16::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUint16_max_cdr_typesize;
}

size_t AliasUint16::getCdrSerializedSize(
        const AliasUint16& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void AliasUint16::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasUint16::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasUint16::value(
        alias_uint16 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_uint16 AliasUint16::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_uint16& AliasUint16::value()
{
    return m_value;
}



size_t AliasUint16::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUint16_max_key_cdr_typesize;
}

bool AliasUint16::isKeyDefined()
{
    return false;
}

void AliasUint16::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasInt32::AliasInt32()
{
    // alias_int32 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasInt32::~AliasInt32()
{
}

AliasInt32::AliasInt32(
        const AliasInt32& x)
{
    m_value = x.m_value;
}

AliasInt32::AliasInt32(
        AliasInt32&& x) noexcept 
{
    m_value = x.m_value;
}

AliasInt32& AliasInt32::operator =(
        const AliasInt32& x)
{

    m_value = x.m_value;

    return *this;
}

AliasInt32& AliasInt32::operator =(
        AliasInt32&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasInt32::operator ==(
        const AliasInt32& x) const
{

    return (m_value == x.m_value);
}

bool AliasInt32::operator !=(
        const AliasInt32& x) const
{
    return !(*this == x);
}

size_t AliasInt32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt32_max_cdr_typesize;
}

size_t AliasInt32::getCdrSerializedSize(
        const AliasInt32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasInt32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasInt32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasInt32::value(
        alias_int32 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_int32 AliasInt32::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_int32& AliasInt32::value()
{
    return m_value;
}



size_t AliasInt32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt32_max_key_cdr_typesize;
}

bool AliasInt32::isKeyDefined()
{
    return false;
}

void AliasInt32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasUInt32::AliasUInt32()
{
    // alias_uint32 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasUInt32::~AliasUInt32()
{
}

AliasUInt32::AliasUInt32(
        const AliasUInt32& x)
{
    m_value = x.m_value;
}

AliasUInt32::AliasUInt32(
        AliasUInt32&& x) noexcept 
{
    m_value = x.m_value;
}

AliasUInt32& AliasUInt32::operator =(
        const AliasUInt32& x)
{

    m_value = x.m_value;

    return *this;
}

AliasUInt32& AliasUInt32::operator =(
        AliasUInt32&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasUInt32::operator ==(
        const AliasUInt32& x) const
{

    return (m_value == x.m_value);
}

bool AliasUInt32::operator !=(
        const AliasUInt32& x) const
{
    return !(*this == x);
}

size_t AliasUInt32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUInt32_max_cdr_typesize;
}

size_t AliasUInt32::getCdrSerializedSize(
        const AliasUInt32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasUInt32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasUInt32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasUInt32::value(
        alias_uint32 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_uint32 AliasUInt32::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_uint32& AliasUInt32::value()
{
    return m_value;
}



size_t AliasUInt32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUInt32_max_key_cdr_typesize;
}

bool AliasUInt32::isKeyDefined()
{
    return false;
}

void AliasUInt32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasInt64::AliasInt64()
{
    // alias_int64 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasInt64::~AliasInt64()
{
}

AliasInt64::AliasInt64(
        const AliasInt64& x)
{
    m_value = x.m_value;
}

AliasInt64::AliasInt64(
        AliasInt64&& x) noexcept 
{
    m_value = x.m_value;
}

AliasInt64& AliasInt64::operator =(
        const AliasInt64& x)
{

    m_value = x.m_value;

    return *this;
}

AliasInt64& AliasInt64::operator =(
        AliasInt64&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasInt64::operator ==(
        const AliasInt64& x) const
{

    return (m_value == x.m_value);
}

bool AliasInt64::operator !=(
        const AliasInt64& x) const
{
    return !(*this == x);
}

size_t AliasInt64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt64_max_cdr_typesize;
}

size_t AliasInt64::getCdrSerializedSize(
        const AliasInt64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AliasInt64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasInt64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasInt64::value(
        alias_int64 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_int64 AliasInt64::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_int64& AliasInt64::value()
{
    return m_value;
}



size_t AliasInt64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasInt64_max_key_cdr_typesize;
}

bool AliasInt64::isKeyDefined()
{
    return false;
}

void AliasInt64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasUInt64::AliasUInt64()
{
    // alias_uint64 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasUInt64::~AliasUInt64()
{
}

AliasUInt64::AliasUInt64(
        const AliasUInt64& x)
{
    m_value = x.m_value;
}

AliasUInt64::AliasUInt64(
        AliasUInt64&& x) noexcept 
{
    m_value = x.m_value;
}

AliasUInt64& AliasUInt64::operator =(
        const AliasUInt64& x)
{

    m_value = x.m_value;

    return *this;
}

AliasUInt64& AliasUInt64::operator =(
        AliasUInt64&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasUInt64::operator ==(
        const AliasUInt64& x) const
{

    return (m_value == x.m_value);
}

bool AliasUInt64::operator !=(
        const AliasUInt64& x) const
{
    return !(*this == x);
}

size_t AliasUInt64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUInt64_max_cdr_typesize;
}

size_t AliasUInt64::getCdrSerializedSize(
        const AliasUInt64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AliasUInt64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasUInt64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasUInt64::value(
        alias_uint64 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_uint64 AliasUInt64::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_uint64& AliasUInt64::value()
{
    return m_value;
}



size_t AliasUInt64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUInt64_max_key_cdr_typesize;
}

bool AliasUInt64::isKeyDefined()
{
    return false;
}

void AliasUInt64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasFloat32::AliasFloat32()
{
    // alias_float32 m_value
    m_value = 0.0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasFloat32::~AliasFloat32()
{
}

AliasFloat32::AliasFloat32(
        const AliasFloat32& x)
{
    m_value = x.m_value;
}

AliasFloat32::AliasFloat32(
        AliasFloat32&& x) noexcept 
{
    m_value = x.m_value;
}

AliasFloat32& AliasFloat32::operator =(
        const AliasFloat32& x)
{

    m_value = x.m_value;

    return *this;
}

AliasFloat32& AliasFloat32::operator =(
        AliasFloat32&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasFloat32::operator ==(
        const AliasFloat32& x) const
{

    return (m_value == x.m_value);
}

bool AliasFloat32::operator !=(
        const AliasFloat32& x) const
{
    return !(*this == x);
}

size_t AliasFloat32::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat32_max_cdr_typesize;
}

size_t AliasFloat32::getCdrSerializedSize(
        const AliasFloat32& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasFloat32::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasFloat32::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasFloat32::value(
        alias_float32 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_float32 AliasFloat32::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_float32& AliasFloat32::value()
{
    return m_value;
}



size_t AliasFloat32::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat32_max_key_cdr_typesize;
}

bool AliasFloat32::isKeyDefined()
{
    return false;
}

void AliasFloat32::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasFloat64::AliasFloat64()
{
    // alias_float64 m_value
    m_value = 0.0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasFloat64::~AliasFloat64()
{
}

AliasFloat64::AliasFloat64(
        const AliasFloat64& x)
{
    m_value = x.m_value;
}

AliasFloat64::AliasFloat64(
        AliasFloat64&& x) noexcept 
{
    m_value = x.m_value;
}

AliasFloat64& AliasFloat64::operator =(
        const AliasFloat64& x)
{

    m_value = x.m_value;

    return *this;
}

AliasFloat64& AliasFloat64::operator =(
        AliasFloat64&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasFloat64::operator ==(
        const AliasFloat64& x) const
{

    return (m_value == x.m_value);
}

bool AliasFloat64::operator !=(
        const AliasFloat64& x) const
{
    return !(*this == x);
}

size_t AliasFloat64::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat64_max_cdr_typesize;
}

size_t AliasFloat64::getCdrSerializedSize(
        const AliasFloat64& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AliasFloat64::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasFloat64::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasFloat64::value(
        alias_float64 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_float64 AliasFloat64::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_float64& AliasFloat64::value()
{
    return m_value;
}



size_t AliasFloat64::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat64_max_key_cdr_typesize;
}

bool AliasFloat64::isKeyDefined()
{
    return false;
}

void AliasFloat64::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasFloat128::AliasFloat128()
{
    // alias_float128 m_value
    m_value = 0.0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasFloat128::~AliasFloat128()
{
}

AliasFloat128::AliasFloat128(
        const AliasFloat128& x)
{
    m_value = x.m_value;
}

AliasFloat128::AliasFloat128(
        AliasFloat128&& x) noexcept 
{
    m_value = x.m_value;
}

AliasFloat128& AliasFloat128::operator =(
        const AliasFloat128& x)
{

    m_value = x.m_value;

    return *this;
}

AliasFloat128& AliasFloat128::operator =(
        AliasFloat128&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasFloat128::operator ==(
        const AliasFloat128& x) const
{

    return (m_value == x.m_value);
}

bool AliasFloat128::operator !=(
        const AliasFloat128& x) const
{
    return !(*this == x);
}

size_t AliasFloat128::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat128_max_cdr_typesize;
}

size_t AliasFloat128::getCdrSerializedSize(
        const AliasFloat128& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 16);


    return current_alignment - initial_alignment;
}

void AliasFloat128::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasFloat128::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasFloat128::value(
        alias_float128 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_float128 AliasFloat128::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_float128& AliasFloat128::value()
{
    return m_value;
}



size_t AliasFloat128::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasFloat128_max_key_cdr_typesize;
}

bool AliasFloat128::isKeyDefined()
{
    return false;
}

void AliasFloat128::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasBool::AliasBool()
{
    // alias_bool m_value
    m_value = false;

    // Just to register all known types
    registeraliasesTypes();
}

AliasBool::~AliasBool()
{
}

AliasBool::AliasBool(
        const AliasBool& x)
{
    m_value = x.m_value;
}

AliasBool::AliasBool(
        AliasBool&& x) noexcept 
{
    m_value = x.m_value;
}

AliasBool& AliasBool::operator =(
        const AliasBool& x)
{

    m_value = x.m_value;

    return *this;
}

AliasBool& AliasBool::operator =(
        AliasBool&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasBool::operator ==(
        const AliasBool& x) const
{

    return (m_value == x.m_value);
}

bool AliasBool::operator !=(
        const AliasBool& x) const
{
    return !(*this == x);
}

size_t AliasBool::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBool_max_cdr_typesize;
}

size_t AliasBool::getCdrSerializedSize(
        const AliasBool& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AliasBool::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasBool::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasBool::value(
        alias_bool _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_bool AliasBool::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_bool& AliasBool::value()
{
    return m_value;
}



size_t AliasBool::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBool_max_key_cdr_typesize;
}

bool AliasBool::isKeyDefined()
{
    return false;
}

void AliasBool::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasOctet::AliasOctet()
{
    // alias_octet m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasOctet::~AliasOctet()
{
}

AliasOctet::AliasOctet(
        const AliasOctet& x)
{
    m_value = x.m_value;
}

AliasOctet::AliasOctet(
        AliasOctet&& x) noexcept 
{
    m_value = x.m_value;
}

AliasOctet& AliasOctet::operator =(
        const AliasOctet& x)
{

    m_value = x.m_value;

    return *this;
}

AliasOctet& AliasOctet::operator =(
        AliasOctet&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasOctet::operator ==(
        const AliasOctet& x) const
{

    return (m_value == x.m_value);
}

bool AliasOctet::operator !=(
        const AliasOctet& x) const
{
    return !(*this == x);
}

size_t AliasOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasOctet_max_cdr_typesize;
}

size_t AliasOctet::getCdrSerializedSize(
        const AliasOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AliasOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasOctet::value(
        alias_octet _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_octet AliasOctet::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_octet& AliasOctet::value()
{
    return m_value;
}



size_t AliasOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasOctet_max_key_cdr_typesize;
}

bool AliasOctet::isKeyDefined()
{
    return false;
}

void AliasOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasChar8::AliasChar8()
{
    // alias_char8 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasChar8::~AliasChar8()
{
}

AliasChar8::AliasChar8(
        const AliasChar8& x)
{
    m_value = x.m_value;
}

AliasChar8::AliasChar8(
        AliasChar8&& x) noexcept 
{
    m_value = x.m_value;
}

AliasChar8& AliasChar8::operator =(
        const AliasChar8& x)
{

    m_value = x.m_value;

    return *this;
}

AliasChar8& AliasChar8::operator =(
        AliasChar8&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasChar8::operator ==(
        const AliasChar8& x) const
{

    return (m_value == x.m_value);
}

bool AliasChar8::operator !=(
        const AliasChar8& x) const
{
    return !(*this == x);
}

size_t AliasChar8::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasChar8_max_cdr_typesize;
}

size_t AliasChar8::getCdrSerializedSize(
        const AliasChar8& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AliasChar8::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasChar8::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasChar8::value(
        alias_char8 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_char8 AliasChar8::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_char8& AliasChar8::value()
{
    return m_value;
}



size_t AliasChar8::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasChar8_max_key_cdr_typesize;
}

bool AliasChar8::isKeyDefined()
{
    return false;
}

void AliasChar8::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasChar16::AliasChar16()
{
    // alias_char16 m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasChar16::~AliasChar16()
{
}

AliasChar16::AliasChar16(
        const AliasChar16& x)
{
    m_value = x.m_value;
}

AliasChar16::AliasChar16(
        AliasChar16&& x) noexcept 
{
    m_value = x.m_value;
}

AliasChar16& AliasChar16::operator =(
        const AliasChar16& x)
{

    m_value = x.m_value;

    return *this;
}

AliasChar16& AliasChar16::operator =(
        AliasChar16&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasChar16::operator ==(
        const AliasChar16& x) const
{

    return (m_value == x.m_value);
}

bool AliasChar16::operator !=(
        const AliasChar16& x) const
{
    return !(*this == x);
}

size_t AliasChar16::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasChar16_max_cdr_typesize;
}

size_t AliasChar16::getCdrSerializedSize(
        const AliasChar16& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasChar16::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasChar16::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasChar16::value(
        alias_char16 _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_char16 AliasChar16::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_char16& AliasChar16::value()
{
    return m_value;
}



size_t AliasChar16::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasChar16_max_key_cdr_typesize;
}

bool AliasChar16::isKeyDefined()
{
    return false;
}

void AliasChar16::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasString8::AliasString8()
{
    // alias_string8 m_value
    m_value = "";


    // Just to register all known types
    registeraliasesTypes();
}

AliasString8::~AliasString8()
{
}

AliasString8::AliasString8(
        const AliasString8& x)
{
    m_value = x.m_value;
}

AliasString8::AliasString8(
        AliasString8&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasString8& AliasString8::operator =(
        const AliasString8& x)
{

    m_value = x.m_value;

    return *this;
}

AliasString8& AliasString8::operator =(
        AliasString8&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasString8::operator ==(
        const AliasString8& x) const
{

    return (m_value == x.m_value);
}

bool AliasString8::operator !=(
        const AliasString8& x) const
{
    return !(*this == x);
}

size_t AliasString8::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasString8_max_cdr_typesize;
}

size_t AliasString8::getCdrSerializedSize(
        const AliasString8& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;

    return current_alignment - initial_alignment;
}

void AliasString8::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value.c_str();
}

void AliasString8::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasString8::value(
        const alias_string8& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasString8::value(
        alias_string8&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_string8& AliasString8::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_string8& AliasString8::value()
{
    return m_value;
}


size_t AliasString8::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasString8_max_key_cdr_typesize;
}

bool AliasString8::isKeyDefined()
{
    return false;
}

void AliasString8::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasString16::AliasString16()
{
    // alias_string16 m_value
    m_value = L"";


    // Just to register all known types
    registeraliasesTypes();
}

AliasString16::~AliasString16()
{
}

AliasString16::AliasString16(
        const AliasString16& x)
{
    m_value = x.m_value;
}

AliasString16::AliasString16(
        AliasString16&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasString16& AliasString16::operator =(
        const AliasString16& x)
{

    m_value = x.m_value;

    return *this;
}

AliasString16& AliasString16::operator =(
        AliasString16&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasString16::operator ==(
        const AliasString16& x) const
{

    return (m_value == x.m_value);
}

bool AliasString16::operator !=(
        const AliasString16& x) const
{
    return !(*this == x);
}

size_t AliasString16::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasString16_max_cdr_typesize;
}

size_t AliasString16::getCdrSerializedSize(
        const AliasString16& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.value().size()) * 4; // 32 bits

    return current_alignment - initial_alignment;
}

void AliasString16::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasString16::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasString16::value(
        const alias_string16& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasString16::value(
        alias_string16&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_string16& AliasString16::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_string16& AliasString16::value()
{
    return m_value;
}


size_t AliasString16::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasString16_max_key_cdr_typesize;
}

bool AliasString16::isKeyDefined()
{
    return false;
}

void AliasString16::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasEnum::AliasEnum()
{
    // alias_enum m_value
    m_value = ::ENUM_VALUE_1;

    // Just to register all known types
    registeraliasesTypes();
}

AliasEnum::~AliasEnum()
{
}

AliasEnum::AliasEnum(
        const AliasEnum& x)
{
    m_value = x.m_value;
}

AliasEnum::AliasEnum(
        AliasEnum&& x) noexcept 
{
    m_value = x.m_value;
}

AliasEnum& AliasEnum::operator =(
        const AliasEnum& x)
{

    m_value = x.m_value;

    return *this;
}

AliasEnum& AliasEnum::operator =(
        AliasEnum&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasEnum::operator ==(
        const AliasEnum& x) const
{

    return (m_value == x.m_value);
}

bool AliasEnum::operator !=(
        const AliasEnum& x) const
{
    return !(*this == x);
}

size_t AliasEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasEnum_max_cdr_typesize;
}

size_t AliasEnum::getCdrSerializedSize(
        const AliasEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_value;
}

void AliasEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_value = (alias_enum)enum_value;
    }

}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasEnum::value(
        alias_enum _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_enum AliasEnum::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_enum& AliasEnum::value()
{
    return m_value;
}



size_t AliasEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasEnum_max_key_cdr_typesize;
}

bool AliasEnum::isKeyDefined()
{
    return false;
}

void AliasEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasBitmask::AliasBitmask()
{
    // alias_bitmask m_value
    m_value = static_cast<alias_bitmask>(0);

    // Just to register all known types
    registeraliasesTypes();
}

AliasBitmask::~AliasBitmask()
{
}

AliasBitmask::AliasBitmask(
        const AliasBitmask& x)
{
    m_value = x.m_value;
}

AliasBitmask::AliasBitmask(
        AliasBitmask&& x) noexcept 
{
    m_value = x.m_value;
}

AliasBitmask& AliasBitmask::operator =(
        const AliasBitmask& x)
{

    m_value = x.m_value;

    return *this;
}

AliasBitmask& AliasBitmask::operator =(
        AliasBitmask&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasBitmask::operator ==(
        const AliasBitmask& x) const
{

    return (m_value == x.m_value);
}

bool AliasBitmask::operator !=(
        const AliasBitmask& x) const
{
    return !(*this == x);
}

size_t AliasBitmask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBitmask_max_cdr_typesize;
}

size_t AliasBitmask::getCdrSerializedSize(
        const AliasBitmask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasBitmask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_value;
}

void AliasBitmask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t bitmask_value = 0;
        dcdr >> bitmask_value;
        m_value = (alias_bitmask)bitmask_value;
    }

}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasBitmask::value(
        alias_bitmask _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_bitmask AliasBitmask::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_bitmask& AliasBitmask::value()
{
    return m_value;
}



size_t AliasBitmask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBitmask_max_key_cdr_typesize;
}

bool AliasBitmask::isKeyDefined()
{
    return false;
}

void AliasBitmask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasAlias::AliasAlias()
{
    // alias_alias m_value
    m_value = 0;

    // Just to register all known types
    registeraliasesTypes();
}

AliasAlias::~AliasAlias()
{
}

AliasAlias::AliasAlias(
        const AliasAlias& x)
{
    m_value = x.m_value;
}

AliasAlias::AliasAlias(
        AliasAlias&& x) noexcept 
{
    m_value = x.m_value;
}

AliasAlias& AliasAlias::operator =(
        const AliasAlias& x)
{

    m_value = x.m_value;

    return *this;
}

AliasAlias& AliasAlias::operator =(
        AliasAlias&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasAlias::operator ==(
        const AliasAlias& x) const
{

    return (m_value == x.m_value);
}

bool AliasAlias::operator !=(
        const AliasAlias& x) const
{
    return !(*this == x);
}

size_t AliasAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasAlias_max_cdr_typesize;
}

size_t AliasAlias::getCdrSerializedSize(
        const AliasAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasAlias::value(
        alias_alias _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_alias AliasAlias::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_alias& AliasAlias::value()
{
    return m_value;
}



size_t AliasAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasAlias_max_key_cdr_typesize;
}

bool AliasAlias::isKeyDefined()
{
    return false;
}

void AliasAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasArray::AliasArray()
{
    // alias_array m_value
    memset(&m_value, 0, (2) * 2);


    // Just to register all known types
    registeraliasesTypes();
}

AliasArray::~AliasArray()
{
}

AliasArray::AliasArray(
        const AliasArray& x)
{
    m_value = x.m_value;
}

AliasArray::AliasArray(
        AliasArray&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasArray& AliasArray::operator =(
        const AliasArray& x)
{

    m_value = x.m_value;

    return *this;
}

AliasArray& AliasArray::operator =(
        AliasArray&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasArray::operator ==(
        const AliasArray& x) const
{

    return (m_value == x.m_value);
}

bool AliasArray::operator !=(
        const AliasArray& x) const
{
    return !(*this == x);
}

size_t AliasArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasArray_max_cdr_typesize;
}

size_t AliasArray::getCdrSerializedSize(
        const AliasArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((2) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void AliasArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;

}

void AliasArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;

}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasArray::value(
        const alias_array& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasArray::value(
        alias_array&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_array& AliasArray::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_array& AliasArray::value()
{
    return m_value;
}


size_t AliasArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasArray_max_key_cdr_typesize;
}

bool AliasArray::isKeyDefined()
{
    return false;
}

void AliasArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasMultiArray::AliasMultiArray()
{
    // alias_multiarray m_value
    memset(&m_value, 0, (2 * 2) * 2);


    // Just to register all known types
    registeraliasesTypes();
}

AliasMultiArray::~AliasMultiArray()
{
}

AliasMultiArray::AliasMultiArray(
        const AliasMultiArray& x)
{
    m_value = x.m_value;
}

AliasMultiArray::AliasMultiArray(
        AliasMultiArray&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasMultiArray& AliasMultiArray::operator =(
        const AliasMultiArray& x)
{

    m_value = x.m_value;

    return *this;
}

AliasMultiArray& AliasMultiArray::operator =(
        AliasMultiArray&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasMultiArray::operator ==(
        const AliasMultiArray& x) const
{

    return (m_value == x.m_value);
}

bool AliasMultiArray::operator !=(
        const AliasMultiArray& x) const
{
    return !(*this == x);
}

size_t AliasMultiArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasMultiArray_max_cdr_typesize;
}

size_t AliasMultiArray::getCdrSerializedSize(
        const AliasMultiArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((2 * 2) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void AliasMultiArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_value.size(); ++b)
    {
        scdr << m_value[b];
    }    

}

void AliasMultiArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t d = 0; d < m_value.size(); ++d)
    {
        dcdr >> m_value[d];
    }

}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasMultiArray::value(
        const alias_multiarray& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasMultiArray::value(
        alias_multiarray&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_multiarray& AliasMultiArray::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_multiarray& AliasMultiArray::value()
{
    return m_value;
}


size_t AliasMultiArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasMultiArray_max_key_cdr_typesize;
}

bool AliasMultiArray::isKeyDefined()
{
    return false;
}

void AliasMultiArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasSequence::AliasSequence()
{
    // alias_sequence m_value


    // Just to register all known types
    registeraliasesTypes();
}

AliasSequence::~AliasSequence()
{
}

AliasSequence::AliasSequence(
        const AliasSequence& x)
{
    m_value = x.m_value;
}

AliasSequence::AliasSequence(
        AliasSequence&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasSequence& AliasSequence::operator =(
        const AliasSequence& x)
{

    m_value = x.m_value;

    return *this;
}

AliasSequence& AliasSequence::operator =(
        AliasSequence&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasSequence::operator ==(
        const AliasSequence& x) const
{

    return (m_value == x.m_value);
}

bool AliasSequence::operator !=(
        const AliasSequence& x) const
{
    return !(*this == x);
}

size_t AliasSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasSequence_max_cdr_typesize;
}

size_t AliasSequence::getCdrSerializedSize(
        const AliasSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    return current_alignment - initial_alignment;
}

void AliasSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasSequence::value(
        const alias_sequence& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasSequence::value(
        alias_sequence&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_sequence& AliasSequence::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_sequence& AliasSequence::value()
{
    return m_value;
}


size_t AliasSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasSequence_max_key_cdr_typesize;
}

bool AliasSequence::isKeyDefined()
{
    return false;
}

void AliasSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasMap::AliasMap()
{
    // alias_map m_value


    // Just to register all known types
    registeraliasesTypes();
}

AliasMap::~AliasMap()
{
}

AliasMap::AliasMap(
        const AliasMap& x)
{
    m_value = x.m_value;
}

AliasMap::AliasMap(
        AliasMap&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasMap& AliasMap::operator =(
        const AliasMap& x)
{

    m_value = x.m_value;

    return *this;
}

AliasMap& AliasMap::operator =(
        AliasMap&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasMap::operator ==(
        const AliasMap& x) const
{

    return (m_value == x.m_value);
}

bool AliasMap::operator !=(
        const AliasMap& x) const
{
    return !(*this == x);
}

size_t AliasMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasMap_max_cdr_typesize;
}

size_t AliasMap::getCdrSerializedSize(
        const AliasMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.value())
    {
        (void)a;

            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
            current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }

    return current_alignment - initial_alignment;
}

void AliasMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << static_cast<uint32_t>(m_value.size());
    for (const auto& pair : m_value)
    {
        scdr << pair.first;    scdr << pair.second;}}

void AliasMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{


        dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasMap::value(
        const alias_map& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasMap::value(
        alias_map&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_map& AliasMap::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_map& AliasMap::value()
{
    return m_value;
}


size_t AliasMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasMap_max_key_cdr_typesize;
}

bool AliasMap::isKeyDefined()
{
    return false;
}

void AliasMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasUnion::AliasUnion()
{
    // alias_union m_value
    m_value = ::ENUM_VALUE_1;

    // Just to register all known types
    registeraliasesTypes();
}

AliasUnion::~AliasUnion()
{
}

AliasUnion::AliasUnion(
        const AliasUnion& x)
{
    m_value = x.m_value;
}

AliasUnion::AliasUnion(
        AliasUnion&& x) noexcept 
{
    m_value = x.m_value;
}

AliasUnion& AliasUnion::operator =(
        const AliasUnion& x)
{

    m_value = x.m_value;

    return *this;
}

AliasUnion& AliasUnion::operator =(
        AliasUnion&& x) noexcept
{

    m_value = x.m_value;

    return *this;
}

bool AliasUnion::operator ==(
        const AliasUnion& x) const
{

    return (m_value == x.m_value);
}

bool AliasUnion::operator !=(
        const AliasUnion& x) const
{
    return !(*this == x);
}

size_t AliasUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUnion_max_cdr_typesize;
}

size_t AliasUnion::getCdrSerializedSize(
        const AliasUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AliasUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_value;
}

void AliasUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_value = (alias_union)enum_value;
    }

}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void AliasUnion::value(
        alias_union _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
alias_union AliasUnion::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_union& AliasUnion::value()
{
    return m_value;
}



size_t AliasUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasUnion_max_key_cdr_typesize;
}

bool AliasUnion::isKeyDefined()
{
    return false;
}

void AliasUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasStruct::AliasStruct()
{
    // alias_structure m_value


    // Just to register all known types
    registeraliasesTypes();
}

AliasStruct::~AliasStruct()
{
}

AliasStruct::AliasStruct(
        const AliasStruct& x)
{
    m_value = x.m_value;
}

AliasStruct::AliasStruct(
        AliasStruct&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasStruct& AliasStruct::operator =(
        const AliasStruct& x)
{

    m_value = x.m_value;

    return *this;
}

AliasStruct& AliasStruct::operator =(
        AliasStruct&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasStruct::operator ==(
        const AliasStruct& x) const
{

    return (m_value == x.m_value);
}

bool AliasStruct::operator !=(
        const AliasStruct& x) const
{
    return !(*this == x);
}

size_t AliasStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasStruct_max_cdr_typesize;
}

size_t AliasStruct::getCdrSerializedSize(
        const AliasStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += alias_structure::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void AliasStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasStruct::value(
        const alias_structure& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasStruct::value(
        alias_structure&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_structure& AliasStruct::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_structure& AliasStruct::value()
{
    return m_value;
}


size_t AliasStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasStruct_max_key_cdr_typesize;
}

bool AliasStruct::isKeyDefined()
{
    return false;
}

void AliasStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AliasBitset::AliasBitset()
{
    // alias_bitset m_value


    // Just to register all known types
    registeraliasesTypes();
}

AliasBitset::~AliasBitset()
{
}

AliasBitset::AliasBitset(
        const AliasBitset& x)
{
    m_value = x.m_value;
}

AliasBitset::AliasBitset(
        AliasBitset&& x) noexcept 
{
    m_value = std::move(x.m_value);
}

AliasBitset& AliasBitset::operator =(
        const AliasBitset& x)
{

    m_value = x.m_value;

    return *this;
}

AliasBitset& AliasBitset::operator =(
        AliasBitset&& x) noexcept
{

    m_value = std::move(x.m_value);

    return *this;
}

bool AliasBitset::operator ==(
        const AliasBitset& x) const
{

    return (m_value == x.m_value);
}

bool AliasBitset::operator !=(
        const AliasBitset& x) const
{
    return !(*this == x);
}

size_t AliasBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBitset_max_cdr_typesize;
}

size_t AliasBitset::getCdrSerializedSize(
        const AliasBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += alias_bitset::getCdrSerializedSize(data.value(), current_alignment);

    return current_alignment - initial_alignment;
}

void AliasBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
}

void AliasBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AliasBitset::value(
        const alias_bitset& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AliasBitset::value(
        alias_bitset&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const alias_bitset& AliasBitset::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
alias_bitset& AliasBitset::value()
{
    return m_value;
}


size_t AliasBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AliasBitset_max_key_cdr_typesize;
}

bool AliasBitset::isKeyDefined()
{
    return false;
}

void AliasBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

