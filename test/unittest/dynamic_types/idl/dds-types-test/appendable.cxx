// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file appendable.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "appendable.h"
#include "appendableTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define AppendableWCharStruct_max_cdr_typesize 4ULL;
#define AppendableEmptyStruct_max_cdr_typesize 0ULL;
#define AppendableULongLongStruct_max_cdr_typesize 8ULL;
#define AppendableShortStruct_max_cdr_typesize 2ULL;
#define AppendableLongLongStruct_max_cdr_typesize 8ULL;
#define AppendableBooleanStruct_max_cdr_typesize 1ULL;
#define AppendableEmptyInheritanceStruct_max_cdr_typesize 260ULL;
#define AppendableOctetStruct_max_cdr_typesize 1ULL;
#define AppendableCharStruct_max_cdr_typesize 1ULL;
#define AppendableInheritanceStruct_max_cdr_typesize 264ULL;
#define AppendableInheritanceEmptyStruct_max_cdr_typesize 2ULL;
#define AppendableULongStruct_max_cdr_typesize 4ULL;
#define AppendableFloatStruct_max_cdr_typesize 4ULL;
#define AppendableLongDoubleStruct_max_cdr_typesize 16ULL;
#define AppendableLongStruct_max_cdr_typesize 4ULL;
#define AppendableDoubleStruct_max_cdr_typesize 8ULL;
#define AppendableUShortStruct_max_cdr_typesize 2ULL;
#define AppendableWCharStruct_max_key_cdr_typesize 0ULL;
#define AppendableEmptyStruct_max_key_cdr_typesize 0ULL;
#define AppendableULongLongStruct_max_key_cdr_typesize 0ULL;
#define AppendableShortStruct_max_key_cdr_typesize 0ULL;
#define AppendableLongLongStruct_max_key_cdr_typesize 0ULL;
#define AppendableBooleanStruct_max_key_cdr_typesize 0ULL;
#define AppendableEmptyInheritanceStruct_max_key_cdr_typesize 0ULL;
#define AppendableOctetStruct_max_key_cdr_typesize 0ULL;
#define AppendableCharStruct_max_key_cdr_typesize 0ULL;
#define AppendableInheritanceStruct_max_key_cdr_typesize 0ULL;
#define AppendableInheritanceEmptyStruct_max_key_cdr_typesize 0ULL;
#define AppendableULongStruct_max_key_cdr_typesize 0ULL;
#define AppendableFloatStruct_max_key_cdr_typesize 0ULL;
#define AppendableLongDoubleStruct_max_key_cdr_typesize 0ULL;
#define AppendableLongStruct_max_key_cdr_typesize 0ULL;
#define AppendableDoubleStruct_max_key_cdr_typesize 0ULL;
#define AppendableUShortStruct_max_key_cdr_typesize 0ULL;

AppendableShortStruct::AppendableShortStruct()
{
    // short m_var_short
    m_var_short = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableShortStruct::~AppendableShortStruct()
{
}

AppendableShortStruct::AppendableShortStruct(
        const AppendableShortStruct& x)
{
    m_var_short = x.m_var_short;
}

AppendableShortStruct::AppendableShortStruct(
        AppendableShortStruct&& x) noexcept 
{
    m_var_short = x.m_var_short;
}

AppendableShortStruct& AppendableShortStruct::operator =(
        const AppendableShortStruct& x)
{

    m_var_short = x.m_var_short;

    return *this;
}

AppendableShortStruct& AppendableShortStruct::operator =(
        AppendableShortStruct&& x) noexcept
{

    m_var_short = x.m_var_short;

    return *this;
}

bool AppendableShortStruct::operator ==(
        const AppendableShortStruct& x) const
{

    return (m_var_short == x.m_var_short);
}

bool AppendableShortStruct::operator !=(
        const AppendableShortStruct& x) const
{
    return !(*this == x);
}

size_t AppendableShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableShortStruct_max_cdr_typesize;
}

size_t AppendableShortStruct::getCdrSerializedSize(
        const AppendableShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void AppendableShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_short;
}

void AppendableShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_short;
}

/*!
 * @brief This function sets a value in member var_short
 * @param _var_short New value for member var_short
 */
void AppendableShortStruct::var_short(
        int16_t _var_short)
{
    m_var_short = _var_short;
}

/*!
 * @brief This function returns the value of member var_short
 * @return Value of member var_short
 */
int16_t AppendableShortStruct::var_short() const
{
    return m_var_short;
}

/*!
 * @brief This function returns a reference to member var_short
 * @return Reference to member var_short
 */
int16_t& AppendableShortStruct::var_short()
{
    return m_var_short;
}



size_t AppendableShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableShortStruct_max_key_cdr_typesize;
}

bool AppendableShortStruct::isKeyDefined()
{
    return false;
}

void AppendableShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableUShortStruct::AppendableUShortStruct()
{
    // unsigned short m_var_ushort
    m_var_ushort = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableUShortStruct::~AppendableUShortStruct()
{
}

AppendableUShortStruct::AppendableUShortStruct(
        const AppendableUShortStruct& x)
{
    m_var_ushort = x.m_var_ushort;
}

AppendableUShortStruct::AppendableUShortStruct(
        AppendableUShortStruct&& x) noexcept 
{
    m_var_ushort = x.m_var_ushort;
}

AppendableUShortStruct& AppendableUShortStruct::operator =(
        const AppendableUShortStruct& x)
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

AppendableUShortStruct& AppendableUShortStruct::operator =(
        AppendableUShortStruct&& x) noexcept
{

    m_var_ushort = x.m_var_ushort;

    return *this;
}

bool AppendableUShortStruct::operator ==(
        const AppendableUShortStruct& x) const
{

    return (m_var_ushort == x.m_var_ushort);
}

bool AppendableUShortStruct::operator !=(
        const AppendableUShortStruct& x) const
{
    return !(*this == x);
}

size_t AppendableUShortStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableUShortStruct_max_cdr_typesize;
}

size_t AppendableUShortStruct::getCdrSerializedSize(
        const AppendableUShortStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void AppendableUShortStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ushort;
}

void AppendableUShortStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ushort;
}

/*!
 * @brief This function sets a value in member var_ushort
 * @param _var_ushort New value for member var_ushort
 */
void AppendableUShortStruct::var_ushort(
        uint16_t _var_ushort)
{
    m_var_ushort = _var_ushort;
}

/*!
 * @brief This function returns the value of member var_ushort
 * @return Value of member var_ushort
 */
uint16_t AppendableUShortStruct::var_ushort() const
{
    return m_var_ushort;
}

/*!
 * @brief This function returns a reference to member var_ushort
 * @return Reference to member var_ushort
 */
uint16_t& AppendableUShortStruct::var_ushort()
{
    return m_var_ushort;
}



size_t AppendableUShortStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableUShortStruct_max_key_cdr_typesize;
}

bool AppendableUShortStruct::isKeyDefined()
{
    return false;
}

void AppendableUShortStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableLongStruct::AppendableLongStruct()
{
    // long m_var_long
    m_var_long = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableLongStruct::~AppendableLongStruct()
{
}

AppendableLongStruct::AppendableLongStruct(
        const AppendableLongStruct& x)
{
    m_var_long = x.m_var_long;
}

AppendableLongStruct::AppendableLongStruct(
        AppendableLongStruct&& x) noexcept 
{
    m_var_long = x.m_var_long;
}

AppendableLongStruct& AppendableLongStruct::operator =(
        const AppendableLongStruct& x)
{

    m_var_long = x.m_var_long;

    return *this;
}

AppendableLongStruct& AppendableLongStruct::operator =(
        AppendableLongStruct&& x) noexcept
{

    m_var_long = x.m_var_long;

    return *this;
}

bool AppendableLongStruct::operator ==(
        const AppendableLongStruct& x) const
{

    return (m_var_long == x.m_var_long);
}

bool AppendableLongStruct::operator !=(
        const AppendableLongStruct& x) const
{
    return !(*this == x);
}

size_t AppendableLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongStruct_max_cdr_typesize;
}

size_t AppendableLongStruct::getCdrSerializedSize(
        const AppendableLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AppendableLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_long;
}

void AppendableLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_long;
}

/*!
 * @brief This function sets a value in member var_long
 * @param _var_long New value for member var_long
 */
void AppendableLongStruct::var_long(
        int32_t _var_long)
{
    m_var_long = _var_long;
}

/*!
 * @brief This function returns the value of member var_long
 * @return Value of member var_long
 */
int32_t AppendableLongStruct::var_long() const
{
    return m_var_long;
}

/*!
 * @brief This function returns a reference to member var_long
 * @return Reference to member var_long
 */
int32_t& AppendableLongStruct::var_long()
{
    return m_var_long;
}



size_t AppendableLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongStruct_max_key_cdr_typesize;
}

bool AppendableLongStruct::isKeyDefined()
{
    return false;
}

void AppendableLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableULongStruct::AppendableULongStruct()
{
    // unsigned long m_var_ulong
    m_var_ulong = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableULongStruct::~AppendableULongStruct()
{
}

AppendableULongStruct::AppendableULongStruct(
        const AppendableULongStruct& x)
{
    m_var_ulong = x.m_var_ulong;
}

AppendableULongStruct::AppendableULongStruct(
        AppendableULongStruct&& x) noexcept 
{
    m_var_ulong = x.m_var_ulong;
}

AppendableULongStruct& AppendableULongStruct::operator =(
        const AppendableULongStruct& x)
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

AppendableULongStruct& AppendableULongStruct::operator =(
        AppendableULongStruct&& x) noexcept
{

    m_var_ulong = x.m_var_ulong;

    return *this;
}

bool AppendableULongStruct::operator ==(
        const AppendableULongStruct& x) const
{

    return (m_var_ulong == x.m_var_ulong);
}

bool AppendableULongStruct::operator !=(
        const AppendableULongStruct& x) const
{
    return !(*this == x);
}

size_t AppendableULongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableULongStruct_max_cdr_typesize;
}

size_t AppendableULongStruct::getCdrSerializedSize(
        const AppendableULongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AppendableULongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulong;
}

void AppendableULongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulong;
}

/*!
 * @brief This function sets a value in member var_ulong
 * @param _var_ulong New value for member var_ulong
 */
void AppendableULongStruct::var_ulong(
        uint32_t _var_ulong)
{
    m_var_ulong = _var_ulong;
}

/*!
 * @brief This function returns the value of member var_ulong
 * @return Value of member var_ulong
 */
uint32_t AppendableULongStruct::var_ulong() const
{
    return m_var_ulong;
}

/*!
 * @brief This function returns a reference to member var_ulong
 * @return Reference to member var_ulong
 */
uint32_t& AppendableULongStruct::var_ulong()
{
    return m_var_ulong;
}



size_t AppendableULongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableULongStruct_max_key_cdr_typesize;
}

bool AppendableULongStruct::isKeyDefined()
{
    return false;
}

void AppendableULongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableLongLongStruct::AppendableLongLongStruct()
{
    // long long m_var_longlong
    m_var_longlong = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableLongLongStruct::~AppendableLongLongStruct()
{
}

AppendableLongLongStruct::AppendableLongLongStruct(
        const AppendableLongLongStruct& x)
{
    m_var_longlong = x.m_var_longlong;
}

AppendableLongLongStruct::AppendableLongLongStruct(
        AppendableLongLongStruct&& x) noexcept 
{
    m_var_longlong = x.m_var_longlong;
}

AppendableLongLongStruct& AppendableLongLongStruct::operator =(
        const AppendableLongLongStruct& x)
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

AppendableLongLongStruct& AppendableLongLongStruct::operator =(
        AppendableLongLongStruct&& x) noexcept
{

    m_var_longlong = x.m_var_longlong;

    return *this;
}

bool AppendableLongLongStruct::operator ==(
        const AppendableLongLongStruct& x) const
{

    return (m_var_longlong == x.m_var_longlong);
}

bool AppendableLongLongStruct::operator !=(
        const AppendableLongLongStruct& x) const
{
    return !(*this == x);
}

size_t AppendableLongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongLongStruct_max_cdr_typesize;
}

size_t AppendableLongLongStruct::getCdrSerializedSize(
        const AppendableLongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AppendableLongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longlong;
}

void AppendableLongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longlong;
}

/*!
 * @brief This function sets a value in member var_longlong
 * @param _var_longlong New value for member var_longlong
 */
void AppendableLongLongStruct::var_longlong(
        int64_t _var_longlong)
{
    m_var_longlong = _var_longlong;
}

/*!
 * @brief This function returns the value of member var_longlong
 * @return Value of member var_longlong
 */
int64_t AppendableLongLongStruct::var_longlong() const
{
    return m_var_longlong;
}

/*!
 * @brief This function returns a reference to member var_longlong
 * @return Reference to member var_longlong
 */
int64_t& AppendableLongLongStruct::var_longlong()
{
    return m_var_longlong;
}



size_t AppendableLongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongLongStruct_max_key_cdr_typesize;
}

bool AppendableLongLongStruct::isKeyDefined()
{
    return false;
}

void AppendableLongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableULongLongStruct::AppendableULongLongStruct()
{
    // unsigned long long m_var_ulonglong
    m_var_ulonglong = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableULongLongStruct::~AppendableULongLongStruct()
{
}

AppendableULongLongStruct::AppendableULongLongStruct(
        const AppendableULongLongStruct& x)
{
    m_var_ulonglong = x.m_var_ulonglong;
}

AppendableULongLongStruct::AppendableULongLongStruct(
        AppendableULongLongStruct&& x) noexcept 
{
    m_var_ulonglong = x.m_var_ulonglong;
}

AppendableULongLongStruct& AppendableULongLongStruct::operator =(
        const AppendableULongLongStruct& x)
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

AppendableULongLongStruct& AppendableULongLongStruct::operator =(
        AppendableULongLongStruct&& x) noexcept
{

    m_var_ulonglong = x.m_var_ulonglong;

    return *this;
}

bool AppendableULongLongStruct::operator ==(
        const AppendableULongLongStruct& x) const
{

    return (m_var_ulonglong == x.m_var_ulonglong);
}

bool AppendableULongLongStruct::operator !=(
        const AppendableULongLongStruct& x) const
{
    return !(*this == x);
}

size_t AppendableULongLongStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableULongLongStruct_max_cdr_typesize;
}

size_t AppendableULongLongStruct::getCdrSerializedSize(
        const AppendableULongLongStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AppendableULongLongStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_ulonglong;
}

void AppendableULongLongStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_ulonglong;
}

/*!
 * @brief This function sets a value in member var_ulonglong
 * @param _var_ulonglong New value for member var_ulonglong
 */
void AppendableULongLongStruct::var_ulonglong(
        uint64_t _var_ulonglong)
{
    m_var_ulonglong = _var_ulonglong;
}

/*!
 * @brief This function returns the value of member var_ulonglong
 * @return Value of member var_ulonglong
 */
uint64_t AppendableULongLongStruct::var_ulonglong() const
{
    return m_var_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_ulonglong
 * @return Reference to member var_ulonglong
 */
uint64_t& AppendableULongLongStruct::var_ulonglong()
{
    return m_var_ulonglong;
}



size_t AppendableULongLongStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableULongLongStruct_max_key_cdr_typesize;
}

bool AppendableULongLongStruct::isKeyDefined()
{
    return false;
}

void AppendableULongLongStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableFloatStruct::AppendableFloatStruct()
{
    // float m_var_float
    m_var_float = 0.0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableFloatStruct::~AppendableFloatStruct()
{
}

AppendableFloatStruct::AppendableFloatStruct(
        const AppendableFloatStruct& x)
{
    m_var_float = x.m_var_float;
}

AppendableFloatStruct::AppendableFloatStruct(
        AppendableFloatStruct&& x) noexcept 
{
    m_var_float = x.m_var_float;
}

AppendableFloatStruct& AppendableFloatStruct::operator =(
        const AppendableFloatStruct& x)
{

    m_var_float = x.m_var_float;

    return *this;
}

AppendableFloatStruct& AppendableFloatStruct::operator =(
        AppendableFloatStruct&& x) noexcept
{

    m_var_float = x.m_var_float;

    return *this;
}

bool AppendableFloatStruct::operator ==(
        const AppendableFloatStruct& x) const
{

    return (m_var_float == x.m_var_float);
}

bool AppendableFloatStruct::operator !=(
        const AppendableFloatStruct& x) const
{
    return !(*this == x);
}

size_t AppendableFloatStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableFloatStruct_max_cdr_typesize;
}

size_t AppendableFloatStruct::getCdrSerializedSize(
        const AppendableFloatStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AppendableFloatStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_float;
}

void AppendableFloatStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_float;
}

/*!
 * @brief This function sets a value in member var_float
 * @param _var_float New value for member var_float
 */
void AppendableFloatStruct::var_float(
        float _var_float)
{
    m_var_float = _var_float;
}

/*!
 * @brief This function returns the value of member var_float
 * @return Value of member var_float
 */
float AppendableFloatStruct::var_float() const
{
    return m_var_float;
}

/*!
 * @brief This function returns a reference to member var_float
 * @return Reference to member var_float
 */
float& AppendableFloatStruct::var_float()
{
    return m_var_float;
}



size_t AppendableFloatStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableFloatStruct_max_key_cdr_typesize;
}

bool AppendableFloatStruct::isKeyDefined()
{
    return false;
}

void AppendableFloatStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableDoubleStruct::AppendableDoubleStruct()
{
    // double m_var_double
    m_var_double = 0.0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableDoubleStruct::~AppendableDoubleStruct()
{
}

AppendableDoubleStruct::AppendableDoubleStruct(
        const AppendableDoubleStruct& x)
{
    m_var_double = x.m_var_double;
}

AppendableDoubleStruct::AppendableDoubleStruct(
        AppendableDoubleStruct&& x) noexcept 
{
    m_var_double = x.m_var_double;
}

AppendableDoubleStruct& AppendableDoubleStruct::operator =(
        const AppendableDoubleStruct& x)
{

    m_var_double = x.m_var_double;

    return *this;
}

AppendableDoubleStruct& AppendableDoubleStruct::operator =(
        AppendableDoubleStruct&& x) noexcept
{

    m_var_double = x.m_var_double;

    return *this;
}

bool AppendableDoubleStruct::operator ==(
        const AppendableDoubleStruct& x) const
{

    return (m_var_double == x.m_var_double);
}

bool AppendableDoubleStruct::operator !=(
        const AppendableDoubleStruct& x) const
{
    return !(*this == x);
}

size_t AppendableDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableDoubleStruct_max_cdr_typesize;
}

size_t AppendableDoubleStruct::getCdrSerializedSize(
        const AppendableDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AppendableDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_double;
}

void AppendableDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_double;
}

/*!
 * @brief This function sets a value in member var_double
 * @param _var_double New value for member var_double
 */
void AppendableDoubleStruct::var_double(
        double _var_double)
{
    m_var_double = _var_double;
}

/*!
 * @brief This function returns the value of member var_double
 * @return Value of member var_double
 */
double AppendableDoubleStruct::var_double() const
{
    return m_var_double;
}

/*!
 * @brief This function returns a reference to member var_double
 * @return Reference to member var_double
 */
double& AppendableDoubleStruct::var_double()
{
    return m_var_double;
}



size_t AppendableDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableDoubleStruct_max_key_cdr_typesize;
}

bool AppendableDoubleStruct::isKeyDefined()
{
    return false;
}

void AppendableDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableLongDoubleStruct::AppendableLongDoubleStruct()
{
    // long double m_var_longdouble
    m_var_longdouble = 0.0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableLongDoubleStruct::~AppendableLongDoubleStruct()
{
}

AppendableLongDoubleStruct::AppendableLongDoubleStruct(
        const AppendableLongDoubleStruct& x)
{
    m_var_longdouble = x.m_var_longdouble;
}

AppendableLongDoubleStruct::AppendableLongDoubleStruct(
        AppendableLongDoubleStruct&& x) noexcept 
{
    m_var_longdouble = x.m_var_longdouble;
}

AppendableLongDoubleStruct& AppendableLongDoubleStruct::operator =(
        const AppendableLongDoubleStruct& x)
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

AppendableLongDoubleStruct& AppendableLongDoubleStruct::operator =(
        AppendableLongDoubleStruct&& x) noexcept
{

    m_var_longdouble = x.m_var_longdouble;

    return *this;
}

bool AppendableLongDoubleStruct::operator ==(
        const AppendableLongDoubleStruct& x) const
{

    return (m_var_longdouble == x.m_var_longdouble);
}

bool AppendableLongDoubleStruct::operator !=(
        const AppendableLongDoubleStruct& x) const
{
    return !(*this == x);
}

size_t AppendableLongDoubleStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongDoubleStruct_max_cdr_typesize;
}

size_t AppendableLongDoubleStruct::getCdrSerializedSize(
        const AppendableLongDoubleStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 16 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8); // 128 bits, but aligned as 64


    return current_alignment - initial_alignment;
}

void AppendableLongDoubleStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_longdouble;
}

void AppendableLongDoubleStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_longdouble;
}

/*!
 * @brief This function sets a value in member var_longdouble
 * @param _var_longdouble New value for member var_longdouble
 */
void AppendableLongDoubleStruct::var_longdouble(
        long double _var_longdouble)
{
    m_var_longdouble = _var_longdouble;
}

/*!
 * @brief This function returns the value of member var_longdouble
 * @return Value of member var_longdouble
 */
long double AppendableLongDoubleStruct::var_longdouble() const
{
    return m_var_longdouble;
}

/*!
 * @brief This function returns a reference to member var_longdouble
 * @return Reference to member var_longdouble
 */
long double& AppendableLongDoubleStruct::var_longdouble()
{
    return m_var_longdouble;
}



size_t AppendableLongDoubleStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableLongDoubleStruct_max_key_cdr_typesize;
}

bool AppendableLongDoubleStruct::isKeyDefined()
{
    return false;
}

void AppendableLongDoubleStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableBooleanStruct::AppendableBooleanStruct()
{
    // boolean m_var_boolean
    m_var_boolean = false;

    // Just to register all known types
    registerappendableTypes();
}

AppendableBooleanStruct::~AppendableBooleanStruct()
{
}

AppendableBooleanStruct::AppendableBooleanStruct(
        const AppendableBooleanStruct& x)
{
    m_var_boolean = x.m_var_boolean;
}

AppendableBooleanStruct::AppendableBooleanStruct(
        AppendableBooleanStruct&& x) noexcept 
{
    m_var_boolean = x.m_var_boolean;
}

AppendableBooleanStruct& AppendableBooleanStruct::operator =(
        const AppendableBooleanStruct& x)
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

AppendableBooleanStruct& AppendableBooleanStruct::operator =(
        AppendableBooleanStruct&& x) noexcept
{

    m_var_boolean = x.m_var_boolean;

    return *this;
}

bool AppendableBooleanStruct::operator ==(
        const AppendableBooleanStruct& x) const
{

    return (m_var_boolean == x.m_var_boolean);
}

bool AppendableBooleanStruct::operator !=(
        const AppendableBooleanStruct& x) const
{
    return !(*this == x);
}

size_t AppendableBooleanStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableBooleanStruct_max_cdr_typesize;
}

size_t AppendableBooleanStruct::getCdrSerializedSize(
        const AppendableBooleanStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AppendableBooleanStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_boolean;
}

void AppendableBooleanStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_boolean;
}

/*!
 * @brief This function sets a value in member var_boolean
 * @param _var_boolean New value for member var_boolean
 */
void AppendableBooleanStruct::var_boolean(
        bool _var_boolean)
{
    m_var_boolean = _var_boolean;
}

/*!
 * @brief This function returns the value of member var_boolean
 * @return Value of member var_boolean
 */
bool AppendableBooleanStruct::var_boolean() const
{
    return m_var_boolean;
}

/*!
 * @brief This function returns a reference to member var_boolean
 * @return Reference to member var_boolean
 */
bool& AppendableBooleanStruct::var_boolean()
{
    return m_var_boolean;
}



size_t AppendableBooleanStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableBooleanStruct_max_key_cdr_typesize;
}

bool AppendableBooleanStruct::isKeyDefined()
{
    return false;
}

void AppendableBooleanStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableOctetStruct::AppendableOctetStruct()
{
    // octet m_var_octet
    m_var_octet = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableOctetStruct::~AppendableOctetStruct()
{
}

AppendableOctetStruct::AppendableOctetStruct(
        const AppendableOctetStruct& x)
{
    m_var_octet = x.m_var_octet;
}

AppendableOctetStruct::AppendableOctetStruct(
        AppendableOctetStruct&& x) noexcept 
{
    m_var_octet = x.m_var_octet;
}

AppendableOctetStruct& AppendableOctetStruct::operator =(
        const AppendableOctetStruct& x)
{

    m_var_octet = x.m_var_octet;

    return *this;
}

AppendableOctetStruct& AppendableOctetStruct::operator =(
        AppendableOctetStruct&& x) noexcept
{

    m_var_octet = x.m_var_octet;

    return *this;
}

bool AppendableOctetStruct::operator ==(
        const AppendableOctetStruct& x) const
{

    return (m_var_octet == x.m_var_octet);
}

bool AppendableOctetStruct::operator !=(
        const AppendableOctetStruct& x) const
{
    return !(*this == x);
}

size_t AppendableOctetStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableOctetStruct_max_cdr_typesize;
}

size_t AppendableOctetStruct::getCdrSerializedSize(
        const AppendableOctetStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AppendableOctetStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_octet;
}

void AppendableOctetStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_octet;
}

/*!
 * @brief This function sets a value in member var_octet
 * @param _var_octet New value for member var_octet
 */
void AppendableOctetStruct::var_octet(
        uint8_t _var_octet)
{
    m_var_octet = _var_octet;
}

/*!
 * @brief This function returns the value of member var_octet
 * @return Value of member var_octet
 */
uint8_t AppendableOctetStruct::var_octet() const
{
    return m_var_octet;
}

/*!
 * @brief This function returns a reference to member var_octet
 * @return Reference to member var_octet
 */
uint8_t& AppendableOctetStruct::var_octet()
{
    return m_var_octet;
}



size_t AppendableOctetStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableOctetStruct_max_key_cdr_typesize;
}

bool AppendableOctetStruct::isKeyDefined()
{
    return false;
}

void AppendableOctetStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableCharStruct::AppendableCharStruct()
{
    // char m_var_char8
    m_var_char8 = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableCharStruct::~AppendableCharStruct()
{
}

AppendableCharStruct::AppendableCharStruct(
        const AppendableCharStruct& x)
{
    m_var_char8 = x.m_var_char8;
}

AppendableCharStruct::AppendableCharStruct(
        AppendableCharStruct&& x) noexcept 
{
    m_var_char8 = x.m_var_char8;
}

AppendableCharStruct& AppendableCharStruct::operator =(
        const AppendableCharStruct& x)
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

AppendableCharStruct& AppendableCharStruct::operator =(
        AppendableCharStruct&& x) noexcept
{

    m_var_char8 = x.m_var_char8;

    return *this;
}

bool AppendableCharStruct::operator ==(
        const AppendableCharStruct& x) const
{

    return (m_var_char8 == x.m_var_char8);
}

bool AppendableCharStruct::operator !=(
        const AppendableCharStruct& x) const
{
    return !(*this == x);
}

size_t AppendableCharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableCharStruct_max_cdr_typesize;
}

size_t AppendableCharStruct::getCdrSerializedSize(
        const AppendableCharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void AppendableCharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char8;
}

void AppendableCharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char8;
}

/*!
 * @brief This function sets a value in member var_char8
 * @param _var_char8 New value for member var_char8
 */
void AppendableCharStruct::var_char8(
        char _var_char8)
{
    m_var_char8 = _var_char8;
}

/*!
 * @brief This function returns the value of member var_char8
 * @return Value of member var_char8
 */
char AppendableCharStruct::var_char8() const
{
    return m_var_char8;
}

/*!
 * @brief This function returns a reference to member var_char8
 * @return Reference to member var_char8
 */
char& AppendableCharStruct::var_char8()
{
    return m_var_char8;
}



size_t AppendableCharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableCharStruct_max_key_cdr_typesize;
}

bool AppendableCharStruct::isKeyDefined()
{
    return false;
}

void AppendableCharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableWCharStruct::AppendableWCharStruct()
{
    // wchar m_var_char16
    m_var_char16 = 0;

    // Just to register all known types
    registerappendableTypes();
}

AppendableWCharStruct::~AppendableWCharStruct()
{
}

AppendableWCharStruct::AppendableWCharStruct(
        const AppendableWCharStruct& x)
{
    m_var_char16 = x.m_var_char16;
}

AppendableWCharStruct::AppendableWCharStruct(
        AppendableWCharStruct&& x) noexcept 
{
    m_var_char16 = x.m_var_char16;
}

AppendableWCharStruct& AppendableWCharStruct::operator =(
        const AppendableWCharStruct& x)
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

AppendableWCharStruct& AppendableWCharStruct::operator =(
        AppendableWCharStruct&& x) noexcept
{

    m_var_char16 = x.m_var_char16;

    return *this;
}

bool AppendableWCharStruct::operator ==(
        const AppendableWCharStruct& x) const
{

    return (m_var_char16 == x.m_var_char16);
}

bool AppendableWCharStruct::operator !=(
        const AppendableWCharStruct& x) const
{
    return !(*this == x);
}

size_t AppendableWCharStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableWCharStruct_max_cdr_typesize;
}

size_t AppendableWCharStruct::getCdrSerializedSize(
        const AppendableWCharStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AppendableWCharStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_char16;
}

void AppendableWCharStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_char16;
}

/*!
 * @brief This function sets a value in member var_char16
 * @param _var_char16 New value for member var_char16
 */
void AppendableWCharStruct::var_char16(
        wchar_t _var_char16)
{
    m_var_char16 = _var_char16;
}

/*!
 * @brief This function returns the value of member var_char16
 * @return Value of member var_char16
 */
wchar_t AppendableWCharStruct::var_char16() const
{
    return m_var_char16;
}

/*!
 * @brief This function returns a reference to member var_char16
 * @return Reference to member var_char16
 */
wchar_t& AppendableWCharStruct::var_char16()
{
    return m_var_char16;
}



size_t AppendableWCharStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableWCharStruct_max_key_cdr_typesize;
}

bool AppendableWCharStruct::isKeyDefined()
{
    return false;
}

void AppendableWCharStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableEmptyStruct::AppendableEmptyStruct()
{

    // Just to register all known types
    registerappendableTypes();
}

AppendableEmptyStruct::~AppendableEmptyStruct()
{
}

AppendableEmptyStruct::AppendableEmptyStruct(
        const AppendableEmptyStruct& x)
{
}

AppendableEmptyStruct::AppendableEmptyStruct(
        AppendableEmptyStruct&& x) noexcept 
{
}

AppendableEmptyStruct& AppendableEmptyStruct::operator =(
        const AppendableEmptyStruct& x)
{


    return *this;
}

AppendableEmptyStruct& AppendableEmptyStruct::operator =(
        AppendableEmptyStruct&& x) noexcept
{


    return *this;
}

bool AppendableEmptyStruct::operator ==(
        const AppendableEmptyStruct& x) const
{

    return true;
}

bool AppendableEmptyStruct::operator !=(
        const AppendableEmptyStruct& x) const
{
    return !(*this == x);
}

size_t AppendableEmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableEmptyStruct_max_cdr_typesize;
}

size_t AppendableEmptyStruct::getCdrSerializedSize(
        const AppendableEmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    return current_alignment - initial_alignment;
}

void AppendableEmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

}

void AppendableEmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

}



size_t AppendableEmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableEmptyStruct_max_key_cdr_typesize;
}

bool AppendableEmptyStruct::isKeyDefined()
{
    return false;
}

void AppendableEmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


AppendableEmptyInheritanceStruct::AppendableEmptyInheritanceStruct()    : AppendableEmptyStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registerappendableTypes();
}

AppendableEmptyInheritanceStruct::~AppendableEmptyInheritanceStruct()
{
}

AppendableEmptyInheritanceStruct::AppendableEmptyInheritanceStruct(
        const AppendableEmptyInheritanceStruct& x)    : AppendableEmptyStruct(x) 
{
    m_var_str = x.m_var_str;
}

AppendableEmptyInheritanceStruct::AppendableEmptyInheritanceStruct(
        AppendableEmptyInheritanceStruct&& x) noexcept     : AppendableEmptyStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

AppendableEmptyInheritanceStruct& AppendableEmptyInheritanceStruct::operator =(
        const AppendableEmptyInheritanceStruct& x)
{
    AppendableEmptyStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

AppendableEmptyInheritanceStruct& AppendableEmptyInheritanceStruct::operator =(
        AppendableEmptyInheritanceStruct&& x) noexcept
{
    AppendableEmptyStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool AppendableEmptyInheritanceStruct::operator ==(
        const AppendableEmptyInheritanceStruct& x) const
{
     if (AppendableEmptyStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool AppendableEmptyInheritanceStruct::operator !=(
        const AppendableEmptyInheritanceStruct& x) const
{
    return !(*this == x);
}

size_t AppendableEmptyInheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableEmptyInheritanceStruct_max_cdr_typesize;
}

size_t AppendableEmptyInheritanceStruct::getCdrSerializedSize(
        const AppendableEmptyInheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AppendableEmptyStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void AppendableEmptyInheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    AppendableEmptyStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void AppendableEmptyInheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    AppendableEmptyStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void AppendableEmptyInheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void AppendableEmptyInheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& AppendableEmptyInheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& AppendableEmptyInheritanceStruct::var_str()
{
    return m_var_str;
}


size_t AppendableEmptyInheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableEmptyInheritanceStruct_max_key_cdr_typesize;
}

bool AppendableEmptyInheritanceStruct::isKeyDefined()
{
    if (AppendableEmptyStruct::isKeyDefined())
        return true;
     return false;
}

void AppendableEmptyInheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 AppendableEmptyStruct::serializeKey(scdr);  
}


AppendableInheritanceStruct::AppendableInheritanceStruct()    : AppendableShortStruct() 
{
    // string m_var_str
    m_var_str = "";


    // Just to register all known types
    registerappendableTypes();
}

AppendableInheritanceStruct::~AppendableInheritanceStruct()
{
}

AppendableInheritanceStruct::AppendableInheritanceStruct(
        const AppendableInheritanceStruct& x)    : AppendableShortStruct(x) 
{
    m_var_str = x.m_var_str;
}

AppendableInheritanceStruct::AppendableInheritanceStruct(
        AppendableInheritanceStruct&& x) noexcept     : AppendableShortStruct(std::move(x)) 
{
    m_var_str = std::move(x.m_var_str);
}

AppendableInheritanceStruct& AppendableInheritanceStruct::operator =(
        const AppendableInheritanceStruct& x)
{
    AppendableShortStruct::operator =(x); 

    m_var_str = x.m_var_str;

    return *this;
}

AppendableInheritanceStruct& AppendableInheritanceStruct::operator =(
        AppendableInheritanceStruct&& x) noexcept
{
    AppendableShortStruct::operator =(std::move(x)); 

    m_var_str = std::move(x.m_var_str);

    return *this;
}

bool AppendableInheritanceStruct::operator ==(
        const AppendableInheritanceStruct& x) const
{
     if (AppendableShortStruct::operator !=(x)) return false; 

    return (m_var_str == x.m_var_str);
}

bool AppendableInheritanceStruct::operator !=(
        const AppendableInheritanceStruct& x) const
{
    return !(*this == x);
}

size_t AppendableInheritanceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableInheritanceStruct_max_cdr_typesize;
}

size_t AppendableInheritanceStruct::getCdrSerializedSize(
        const AppendableInheritanceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AppendableShortStruct::getCdrSerializedSize(data, current_alignment); 

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_str().size() + 1;

    return current_alignment - initial_alignment;
}

void AppendableInheritanceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    AppendableShortStruct::serialize(scdr); 

    scdr << m_var_str.c_str();
}

void AppendableInheritanceStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    AppendableShortStruct::deserialize(dcdr); 

    dcdr >> m_var_str;}

/*!
 * @brief This function copies the value in member var_str
 * @param _var_str New value to be copied in member var_str
 */
void AppendableInheritanceStruct::var_str(
        const std::string& _var_str)
{
    m_var_str = _var_str;
}

/*!
 * @brief This function moves the value in member var_str
 * @param _var_str New value to be moved in member var_str
 */
void AppendableInheritanceStruct::var_str(
        std::string&& _var_str)
{
    m_var_str = std::move(_var_str);
}

/*!
 * @brief This function returns a constant reference to member var_str
 * @return Constant reference to member var_str
 */
const std::string& AppendableInheritanceStruct::var_str() const
{
    return m_var_str;
}

/*!
 * @brief This function returns a reference to member var_str
 * @return Reference to member var_str
 */
std::string& AppendableInheritanceStruct::var_str()
{
    return m_var_str;
}


size_t AppendableInheritanceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableInheritanceStruct_max_key_cdr_typesize;
}

bool AppendableInheritanceStruct::isKeyDefined()
{
    if (AppendableShortStruct::isKeyDefined())
        return true;
     return false;
}

void AppendableInheritanceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 AppendableShortStruct::serializeKey(scdr);  
}


AppendableInheritanceEmptyStruct::AppendableInheritanceEmptyStruct()    : AppendableShortStruct() 
{

    // Just to register all known types
    registerappendableTypes();
}

AppendableInheritanceEmptyStruct::~AppendableInheritanceEmptyStruct()
{
}

AppendableInheritanceEmptyStruct::AppendableInheritanceEmptyStruct(
        const AppendableInheritanceEmptyStruct& x)    : AppendableShortStruct(x) 
{
}

AppendableInheritanceEmptyStruct::AppendableInheritanceEmptyStruct(
        AppendableInheritanceEmptyStruct&& x) noexcept     : AppendableShortStruct(std::move(x)) 
{
}

AppendableInheritanceEmptyStruct& AppendableInheritanceEmptyStruct::operator =(
        const AppendableInheritanceEmptyStruct& x)
{
    AppendableShortStruct::operator =(x); 


    return *this;
}

AppendableInheritanceEmptyStruct& AppendableInheritanceEmptyStruct::operator =(
        AppendableInheritanceEmptyStruct&& x) noexcept
{
    AppendableShortStruct::operator =(std::move(x)); 


    return *this;
}

bool AppendableInheritanceEmptyStruct::operator ==(
        const AppendableInheritanceEmptyStruct& x) const
{
     if (AppendableShortStruct::operator !=(x)) return false; 

    return true;
}

bool AppendableInheritanceEmptyStruct::operator !=(
        const AppendableInheritanceEmptyStruct& x) const
{
    return !(*this == x);
}

size_t AppendableInheritanceEmptyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableInheritanceEmptyStruct_max_cdr_typesize;
}

size_t AppendableInheritanceEmptyStruct::getCdrSerializedSize(
        const AppendableInheritanceEmptyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += AppendableShortStruct::getCdrSerializedSize(data, current_alignment); 


    return current_alignment - initial_alignment;
}

void AppendableInheritanceEmptyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    AppendableShortStruct::serialize(scdr); 

}

void AppendableInheritanceEmptyStruct::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    AppendableShortStruct::deserialize(dcdr); 

}



size_t AppendableInheritanceEmptyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return AppendableInheritanceEmptyStruct_max_key_cdr_typesize;
}

bool AppendableInheritanceEmptyStruct::isKeyDefined()
{
    if (AppendableShortStruct::isKeyDefined())
        return true;
     return false;
}

void AppendableInheritanceEmptyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
 AppendableShortStruct::serializeKey(scdr);  
}

