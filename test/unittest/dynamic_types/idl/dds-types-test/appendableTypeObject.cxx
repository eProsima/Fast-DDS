// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file appendableTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "appendable.h"
#include "appendableTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerappendableTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("AppendableShortStruct", GetAppendableShortStructIdentifier(true),
                GetAppendableShortStructObject(true));
                factory->add_type_object("AppendableShortStruct", GetAppendableShortStructIdentifier(false),
                GetAppendableShortStructObject(false));

                factory->add_type_object("AppendableUShortStruct", GetAppendableUShortStructIdentifier(true),
                GetAppendableUShortStructObject(true));
                factory->add_type_object("AppendableUShortStruct", GetAppendableUShortStructIdentifier(false),
                GetAppendableUShortStructObject(false));

                factory->add_type_object("AppendableLongStruct", GetAppendableLongStructIdentifier(true),
                GetAppendableLongStructObject(true));
                factory->add_type_object("AppendableLongStruct", GetAppendableLongStructIdentifier(false),
                GetAppendableLongStructObject(false));

                factory->add_type_object("AppendableULongStruct", GetAppendableULongStructIdentifier(true),
                GetAppendableULongStructObject(true));
                factory->add_type_object("AppendableULongStruct", GetAppendableULongStructIdentifier(false),
                GetAppendableULongStructObject(false));

                factory->add_type_object("AppendableLongLongStruct", GetAppendableLongLongStructIdentifier(true),
                GetAppendableLongLongStructObject(true));
                factory->add_type_object("AppendableLongLongStruct", GetAppendableLongLongStructIdentifier(false),
                GetAppendableLongLongStructObject(false));

                factory->add_type_object("AppendableULongLongStruct", GetAppendableULongLongStructIdentifier(true),
                GetAppendableULongLongStructObject(true));
                factory->add_type_object("AppendableULongLongStruct", GetAppendableULongLongStructIdentifier(false),
                GetAppendableULongLongStructObject(false));

                factory->add_type_object("AppendableFloatStruct", GetAppendableFloatStructIdentifier(true),
                GetAppendableFloatStructObject(true));
                factory->add_type_object("AppendableFloatStruct", GetAppendableFloatStructIdentifier(false),
                GetAppendableFloatStructObject(false));

                factory->add_type_object("AppendableDoubleStruct", GetAppendableDoubleStructIdentifier(true),
                GetAppendableDoubleStructObject(true));
                factory->add_type_object("AppendableDoubleStruct", GetAppendableDoubleStructIdentifier(false),
                GetAppendableDoubleStructObject(false));

                factory->add_type_object("AppendableLongDoubleStruct", GetAppendableLongDoubleStructIdentifier(true),
                GetAppendableLongDoubleStructObject(true));
                factory->add_type_object("AppendableLongDoubleStruct", GetAppendableLongDoubleStructIdentifier(false),
                GetAppendableLongDoubleStructObject(false));

                factory->add_type_object("AppendableBooleanStruct", GetAppendableBooleanStructIdentifier(true),
                GetAppendableBooleanStructObject(true));
                factory->add_type_object("AppendableBooleanStruct", GetAppendableBooleanStructIdentifier(false),
                GetAppendableBooleanStructObject(false));

                factory->add_type_object("AppendableOctetStruct", GetAppendableOctetStructIdentifier(true),
                GetAppendableOctetStructObject(true));
                factory->add_type_object("AppendableOctetStruct", GetAppendableOctetStructIdentifier(false),
                GetAppendableOctetStructObject(false));

                factory->add_type_object("AppendableCharStruct", GetAppendableCharStructIdentifier(true),
                GetAppendableCharStructObject(true));
                factory->add_type_object("AppendableCharStruct", GetAppendableCharStructIdentifier(false),
                GetAppendableCharStructObject(false));

                factory->add_type_object("AppendableWCharStruct", GetAppendableWCharStructIdentifier(true),
                GetAppendableWCharStructObject(true));
                factory->add_type_object("AppendableWCharStruct", GetAppendableWCharStructIdentifier(false),
                GetAppendableWCharStructObject(false));

                factory->add_type_object("AppendableEmptyStruct", GetAppendableEmptyStructIdentifier(true),
                GetAppendableEmptyStructObject(true));
                factory->add_type_object("AppendableEmptyStruct", GetAppendableEmptyStructIdentifier(false),
                GetAppendableEmptyStructObject(false));

                factory->add_type_object("AppendableEmptyInheritanceStruct", GetAppendableEmptyInheritanceStructIdentifier(true),
                GetAppendableEmptyInheritanceStructObject(true));
                factory->add_type_object("AppendableEmptyInheritanceStruct", GetAppendableEmptyInheritanceStructIdentifier(false),
                GetAppendableEmptyInheritanceStructObject(false));

                factory->add_type_object("AppendableInheritanceStruct", GetAppendableInheritanceStructIdentifier(true),
                GetAppendableInheritanceStructObject(true));
                factory->add_type_object("AppendableInheritanceStruct", GetAppendableInheritanceStructIdentifier(false),
                GetAppendableInheritanceStructObject(false));

                factory->add_type_object("AppendableInheritanceEmptyStruct", GetAppendableInheritanceEmptyStructIdentifier(true),
                GetAppendableInheritanceEmptyStructObject(true));
                factory->add_type_object("AppendableInheritanceEmptyStruct", GetAppendableInheritanceEmptyStructIdentifier(false),
                GetAppendableInheritanceEmptyStructObject(false));

            });
}

const TypeIdentifier* GetAppendableShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableShortStruct", complete);
}

const TypeObject* GetAppendableShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableShortStructObject();
    }
    //else
    return GetMinimalAppendableShortStructObject();
}

const TypeObject* GetMinimalAppendableShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_short;
    mst_var_short.common().member_id(memberId++);
    mst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_short.common().member_flags().IS_OPTIONAL(false);
    mst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_short.common().member_flags().IS_KEY(false);
    mst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    MD5 var_short_hash("var_short");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_short.detail().name_hash()[i] = var_short_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_short);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableShortStruct", false);
}

const TypeObject* GetCompleteAppendableShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_short;
    cst_var_short.common().member_id(memberId++);
    cst_var_short.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_short.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_short.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_short.common().member_flags().IS_OPTIONAL(false);
    cst_var_short.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_short.common().member_flags().IS_KEY(false);
    cst_var_short.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_short.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int16_t", false));

    cst_var_short.detail().name("var_short");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_short);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableShortStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableShortStruct", true);
}

const TypeIdentifier* GetAppendableUShortStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableUShortStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableUShortStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableUShortStruct", complete);
}

const TypeObject* GetAppendableUShortStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableUShortStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableUShortStructObject();
    }
    //else
    return GetMinimalAppendableUShortStructObject();
}

const TypeObject* GetMinimalAppendableUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableUShortStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ushort;
    mst_var_ushort.common().member_id(memberId++);
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    mst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ushort.common().member_flags().IS_KEY(false);
    mst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    MD5 var_ushort_hash("var_ushort");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ushort.detail().name_hash()[i] = var_ushort_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ushort);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableUShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableUShortStruct", false);
}

const TypeObject* GetCompleteAppendableUShortStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableUShortStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ushort;
    cst_var_ushort.common().member_id(memberId++);
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ushort.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ushort.common().member_flags().IS_OPTIONAL(false);
    cst_var_ushort.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ushort.common().member_flags().IS_KEY(false);
    cst_var_ushort.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ushort.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint16_t", false));

    cst_var_ushort.detail().name("var_ushort");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ushort);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableUShortStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableUShortStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableUShortStruct", true);
}

const TypeIdentifier* GetAppendableLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongStruct", complete);
}

const TypeObject* GetAppendableLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableLongStructObject();
    }
    //else
    return GetMinimalAppendableLongStructObject();
}

const TypeObject* GetMinimalAppendableLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_long;
    mst_var_long.common().member_id(memberId++);
    mst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_long.common().member_flags().IS_OPTIONAL(false);
    mst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_long.common().member_flags().IS_KEY(false);
    mst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    MD5 var_long_hash("var_long");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_long.detail().name_hash()[i] = var_long_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_long);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongStruct", false);
}

const TypeObject* GetCompleteAppendableLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_long;
    cst_var_long.common().member_id(memberId++);
    cst_var_long.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_long.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_long.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_long.common().member_flags().IS_OPTIONAL(false);
    cst_var_long.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_long.common().member_flags().IS_KEY(false);
    cst_var_long.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_long.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

    cst_var_long.detail().name("var_long");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_long);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongStruct", true);
}

const TypeIdentifier* GetAppendableULongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableULongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableULongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableULongStruct", complete);
}

const TypeObject* GetAppendableULongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableULongStructObject();
    }
    //else
    return GetMinimalAppendableULongStructObject();
}

const TypeObject* GetMinimalAppendableULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulong;
    mst_var_ulong.common().member_id(memberId++);
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulong.common().member_flags().IS_KEY(false);
    mst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 var_ulong_hash("var_ulong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulong.detail().name_hash()[i] = var_ulong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableULongStruct", false);
}

const TypeObject* GetCompleteAppendableULongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulong;
    cst_var_ulong.common().member_id(memberId++);
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulong.common().member_flags().IS_KEY(false);
    cst_var_ulong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_var_ulong.detail().name("var_ulong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableULongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableULongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableULongStruct", true);
}

const TypeIdentifier* GetAppendableLongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableLongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongLongStruct", complete);
}

const TypeObject* GetAppendableLongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableLongLongStructObject();
    }
    //else
    return GetMinimalAppendableLongLongStructObject();
}

const TypeObject* GetMinimalAppendableLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longlong;
    mst_var_longlong.common().member_id(memberId++);
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    mst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longlong.common().member_flags().IS_KEY(false);
    mst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    MD5 var_longlong_hash("var_longlong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longlong.detail().name_hash()[i] = var_longlong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longlong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongLongStruct", false);
}

const TypeObject* GetCompleteAppendableLongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longlong;
    cst_var_longlong.common().member_id(memberId++);
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longlong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longlong.common().member_flags().IS_OPTIONAL(false);
    cst_var_longlong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longlong.common().member_flags().IS_KEY(false);
    cst_var_longlong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longlong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int64_t", false));

    cst_var_longlong.detail().name("var_longlong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longlong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableLongLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongLongStruct", true);
}

const TypeIdentifier* GetAppendableULongLongStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableULongLongStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableULongLongStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableULongLongStruct", complete);
}

const TypeObject* GetAppendableULongLongStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongLongStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableULongLongStructObject();
    }
    //else
    return GetMinimalAppendableULongLongStructObject();
}

const TypeObject* GetMinimalAppendableULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongLongStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_ulonglong;
    mst_var_ulonglong.common().member_id(memberId++);
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    mst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_ulonglong.common().member_flags().IS_KEY(false);
    mst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 var_ulonglong_hash("var_ulonglong");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_ulonglong.detail().name_hash()[i] = var_ulonglong_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_ulonglong);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableULongLongStruct", false);
}

const TypeObject* GetCompleteAppendableULongLongStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableULongLongStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_ulonglong;
    cst_var_ulonglong.common().member_id(memberId++);
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_ulonglong.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_ulonglong.common().member_flags().IS_OPTIONAL(false);
    cst_var_ulonglong.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_ulonglong.common().member_flags().IS_KEY(false);
    cst_var_ulonglong.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_ulonglong.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_var_ulonglong.detail().name("var_ulonglong");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_ulonglong);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableULongLongStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableULongLongStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableULongLongStruct", true);
}

const TypeIdentifier* GetAppendableFloatStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableFloatStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableFloatStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableFloatStruct", complete);
}

const TypeObject* GetAppendableFloatStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableFloatStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableFloatStructObject();
    }
    //else
    return GetMinimalAppendableFloatStructObject();
}

const TypeObject* GetMinimalAppendableFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableFloatStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_float;
    mst_var_float.common().member_id(memberId++);
    mst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_float.common().member_flags().IS_OPTIONAL(false);
    mst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_float.common().member_flags().IS_KEY(false);
    mst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 var_float_hash("var_float");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_float.detail().name_hash()[i] = var_float_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_float);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableFloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableFloatStruct", false);
}

const TypeObject* GetCompleteAppendableFloatStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableFloatStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_float;
    cst_var_float.common().member_id(memberId++);
    cst_var_float.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_float.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_float.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_float.common().member_flags().IS_OPTIONAL(false);
    cst_var_float.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_float.common().member_flags().IS_KEY(false);
    cst_var_float.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_float.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_var_float.detail().name("var_float");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_float);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableFloatStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableFloatStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableFloatStruct", true);
}

const TypeIdentifier* GetAppendableDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableDoubleStruct", complete);
}

const TypeObject* GetAppendableDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableDoubleStructObject();
    }
    //else
    return GetMinimalAppendableDoubleStructObject();
}

const TypeObject* GetMinimalAppendableDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_double;
    mst_var_double.common().member_id(memberId++);
    mst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_double.common().member_flags().IS_OPTIONAL(false);
    mst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_double.common().member_flags().IS_KEY(false);
    mst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 var_double_hash("var_double");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_double.detail().name_hash()[i] = var_double_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_double);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableDoubleStruct", false);
}

const TypeObject* GetCompleteAppendableDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_double;
    cst_var_double.common().member_id(memberId++);
    cst_var_double.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_double.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_double.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_double.common().member_flags().IS_OPTIONAL(false);
    cst_var_double.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_double.common().member_flags().IS_KEY(false);
    cst_var_double.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_double.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_var_double.detail().name("var_double");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_double);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableDoubleStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableDoubleStruct", true);
}

const TypeIdentifier* GetAppendableLongDoubleStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongDoubleStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableLongDoubleStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableLongDoubleStruct", complete);
}

const TypeObject* GetAppendableLongDoubleStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongDoubleStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableLongDoubleStructObject();
    }
    //else
    return GetMinimalAppendableLongDoubleStructObject();
}

const TypeObject* GetMinimalAppendableLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongDoubleStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_longdouble;
    mst_var_longdouble.common().member_id(memberId++);
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    mst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_longdouble.common().member_flags().IS_KEY(false);
    mst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    MD5 var_longdouble_hash("var_longdouble");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_longdouble.detail().name_hash()[i] = var_longdouble_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_longdouble);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongDoubleStruct", false);
}

const TypeObject* GetCompleteAppendableLongDoubleStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableLongDoubleStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_longdouble;
    cst_var_longdouble.common().member_id(memberId++);
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_longdouble.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_longdouble.common().member_flags().IS_OPTIONAL(false);
    cst_var_longdouble.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_longdouble.common().member_flags().IS_KEY(false);
    cst_var_longdouble.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_longdouble.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("longdouble", false));

    cst_var_longdouble.detail().name("var_longdouble");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_longdouble);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableLongDoubleStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableLongDoubleStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableLongDoubleStruct", true);
}

const TypeIdentifier* GetAppendableBooleanStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableBooleanStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableBooleanStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableBooleanStruct", complete);
}

const TypeObject* GetAppendableBooleanStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableBooleanStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableBooleanStructObject();
    }
    //else
    return GetMinimalAppendableBooleanStructObject();
}

const TypeObject* GetMinimalAppendableBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableBooleanStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_boolean;
    mst_var_boolean.common().member_id(memberId++);
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    mst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_boolean.common().member_flags().IS_KEY(false);
    mst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    MD5 var_boolean_hash("var_boolean");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_boolean.detail().name_hash()[i] = var_boolean_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_boolean);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableBooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableBooleanStruct", false);
}

const TypeObject* GetCompleteAppendableBooleanStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableBooleanStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_boolean;
    cst_var_boolean.common().member_id(memberId++);
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_boolean.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_boolean.common().member_flags().IS_OPTIONAL(false);
    cst_var_boolean.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_boolean.common().member_flags().IS_KEY(false);
    cst_var_boolean.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_boolean.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("bool", false));

    cst_var_boolean.detail().name("var_boolean");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_boolean);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableBooleanStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableBooleanStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableBooleanStruct", true);
}

const TypeIdentifier* GetAppendableOctetStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableOctetStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableOctetStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableOctetStruct", complete);
}

const TypeObject* GetAppendableOctetStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableOctetStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableOctetStructObject();
    }
    //else
    return GetMinimalAppendableOctetStructObject();
}

const TypeObject* GetMinimalAppendableOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableOctetStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_octet;
    mst_var_octet.common().member_id(memberId++);
    mst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_octet.common().member_flags().IS_OPTIONAL(false);
    mst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_octet.common().member_flags().IS_KEY(false);
    mst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    MD5 var_octet_hash("var_octet");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_octet.detail().name_hash()[i] = var_octet_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_octet);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableOctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableOctetStruct", false);
}

const TypeObject* GetCompleteAppendableOctetStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableOctetStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_octet;
    cst_var_octet.common().member_id(memberId++);
    cst_var_octet.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_octet.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_octet.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_octet.common().member_flags().IS_OPTIONAL(false);
    cst_var_octet.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_octet.common().member_flags().IS_KEY(false);
    cst_var_octet.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_octet.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false));

    cst_var_octet.detail().name("var_octet");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_octet);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableOctetStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableOctetStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableOctetStruct", true);
}

const TypeIdentifier* GetAppendableCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableCharStruct", complete);
}

const TypeObject* GetAppendableCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableCharStructObject();
    }
    //else
    return GetMinimalAppendableCharStructObject();
}

const TypeObject* GetMinimalAppendableCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char8;
    mst_var_char8.common().member_id(memberId++);
    mst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char8.common().member_flags().IS_OPTIONAL(false);
    mst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char8.common().member_flags().IS_KEY(false);
    mst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    MD5 var_char8_hash("var_char8");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char8.detail().name_hash()[i] = var_char8_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char8);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableCharStruct", false);
}

const TypeObject* GetCompleteAppendableCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char8;
    cst_var_char8.common().member_id(memberId++);
    cst_var_char8.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char8.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char8.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char8.common().member_flags().IS_OPTIONAL(false);
    cst_var_char8.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char8.common().member_flags().IS_KEY(false);
    cst_var_char8.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char8.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("char", false));

    cst_var_char8.detail().name("var_char8");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char8);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableCharStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableCharStruct", true);
}

const TypeIdentifier* GetAppendableWCharStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableWCharStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableWCharStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableWCharStruct", complete);
}

const TypeObject* GetAppendableWCharStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableWCharStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableWCharStructObject();
    }
    //else
    return GetMinimalAppendableWCharStructObject();
}

const TypeObject* GetMinimalAppendableWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableWCharStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_char16;
    mst_var_char16.common().member_id(memberId++);
    mst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_char16.common().member_flags().IS_OPTIONAL(false);
    mst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_char16.common().member_flags().IS_KEY(false);
    mst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    MD5 var_char16_hash("var_char16");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_char16.detail().name_hash()[i] = var_char16_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_char16);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableWCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableWCharStruct", false);
}

const TypeObject* GetCompleteAppendableWCharStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableWCharStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_char16;
    cst_var_char16.common().member_id(memberId++);
    cst_var_char16.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_char16.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_char16.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_char16.common().member_flags().IS_OPTIONAL(false);
    cst_var_char16.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_char16.common().member_flags().IS_KEY(false);
    cst_var_char16.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_char16.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("wchar_t", false));

    cst_var_char16.detail().name("var_char16");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_char16);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableWCharStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableWCharStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableWCharStruct", true);
}

const TypeIdentifier* GetAppendableEmptyStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableEmptyStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableEmptyStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableEmptyStruct", complete);
}

const TypeObject* GetAppendableEmptyStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableEmptyStructObject();
    }
    //else
    return GetMinimalAppendableEmptyStructObject();
}

const TypeObject* GetMinimalAppendableEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyStruct", false);
}

const TypeObject* GetCompleteAppendableEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableEmptyStruct");
    // TODO inheritance

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyStruct", true);
}

const TypeIdentifier* GetAppendableEmptyInheritanceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableEmptyInheritanceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableEmptyInheritanceStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableEmptyInheritanceStruct", complete);
}

const TypeObject* GetAppendableEmptyInheritanceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyInheritanceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableEmptyInheritanceStructObject();
    }
    //else
    return GetMinimalAppendableEmptyInheritanceStructObject();
}

const TypeObject* GetMinimalAppendableEmptyInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyInheritanceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_str;
    mst_var_str.common().member_id(memberId++);
    mst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_str.common().member_flags().IS_OPTIONAL(false);
    mst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_str.common().member_flags().IS_KEY(false);
    mst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_str_hash("var_str");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_str.detail().name_hash()[i] = var_str_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_str);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetAppendableEmptyStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableEmptyInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyInheritanceStruct", false);
}

const TypeObject* GetCompleteAppendableEmptyInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyInheritanceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_str;
    cst_var_str.common().member_id(memberId++);
    cst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_str.common().member_flags().IS_OPTIONAL(false);
    cst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_str.common().member_flags().IS_KEY(false);
    cst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_str.detail().name("var_str");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_str);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableEmptyInheritanceStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetAppendableEmptyStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableEmptyInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableEmptyInheritanceStruct", true);
}

const TypeIdentifier* GetAppendableInheritanceStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableInheritanceStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableInheritanceStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableInheritanceStruct", complete);
}

const TypeObject* GetAppendableInheritanceStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableInheritanceStructObject();
    }
    //else
    return GetMinimalAppendableInheritanceStructObject();
}

const TypeObject* GetMinimalAppendableInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_var_str;
    mst_var_str.common().member_id(memberId++);
    mst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_var_str.common().member_flags().IS_OPTIONAL(false);
    mst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_var_str.common().member_flags().IS_KEY(false);
    mst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    MD5 var_str_hash("var_str");
    for(int i = 0; i < 4; ++i)
    {
        mst_var_str.detail().name_hash()[i] = var_str_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_var_str);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetAppendableShortStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceStruct", false);
}

const TypeObject* GetCompleteAppendableInheritanceStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_var_str;
    cst_var_str.common().member_id(memberId++);
    cst_var_str.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_var_str.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_var_str.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_var_str.common().member_flags().IS_OPTIONAL(false);
    cst_var_str.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_var_str.common().member_flags().IS_KEY(false);
    cst_var_str.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_var_str.common().member_type_id(*TypeObjectFactory::get_instance()->get_string_identifier(255, false));


    cst_var_str.detail().name("var_str");

    type_object->complete().struct_type().member_seq().emplace_back(cst_var_str);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableInheritanceStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetAppendableShortStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableInheritanceStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceStruct", true);
}

const TypeIdentifier* GetAppendableInheritanceEmptyStructIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AppendableInheritanceEmptyStruct", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAppendableInheritanceEmptyStructObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AppendableInheritanceEmptyStruct", complete);
}

const TypeObject* GetAppendableInheritanceEmptyStructObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceEmptyStruct", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAppendableInheritanceEmptyStructObject();
    }
    //else
    return GetMinimalAppendableInheritanceEmptyStructObject();
}

const TypeObject* GetMinimalAppendableInheritanceEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceEmptyStruct", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
    type_object->minimal().struct_type().header().base_type(*GetAppendableShortStructIdentifier(false));

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableInheritanceEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceEmptyStruct", false);
}

const TypeObject* GetCompleteAppendableInheritanceEmptyStructObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceEmptyStruct", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(true);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;

    // Header
    type_object->complete().struct_type().header().detail().type_name("AppendableInheritanceEmptyStruct");
    // TODO inheritance
    type_object->complete().struct_type().header().base_type(*GetAppendableShortStructIdentifier(true));

    {
        AppliedAnnotation ann;
        //ann.annotation_typeid(GetappendableIdentifier(true));
        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("appendable"));
        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
    }
        

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AppendableInheritanceEmptyStruct", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AppendableInheritanceEmptyStruct", true);
}
