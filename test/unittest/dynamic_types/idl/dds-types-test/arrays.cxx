// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file arrays.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "arrays.h"
#include "arraysTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define InnerStructureHelper_max_cdr_typesize 8ULL;
#define ArrayMultiDimensionULongLong_max_cdr_typesize 8000ULL;
#define ArraySingleDimensionLiteralsBitMask_max_cdr_typesize 40ULL;
#define ArrayMultiDimensionLiteralsEnum_max_cdr_typesize 2000ULL;
#define ArraySingleDimensionLiteralsStructure_max_cdr_typesize 40ULL;
#define ArrayStructure_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionSequence_max_cdr_typesize 404000ULL;
#define ArrayMultiDimensionBoolean_max_cdr_typesize 1000ULL;
#define ArrayMultiDimensionBitset_max_cdr_typesize 8000ULL;
#define ArrayMultiDimensionLiteralsDouble_max_cdr_typesize 2000ULL;
#define ArrayMultiDimensionLiteralsAlias_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionLiteralsWChar_max_cdr_typesize 2000ULL;
#define ArrayMultiDimensionLiteralsBitSet_max_cdr_typesize 8000ULL;
#define ArrayMultiDimensionUnion_max_cdr_typesize 8000ULL;
#define ArrayMultiDimensionChar_max_cdr_typesize 1000ULL;
#define ArrayShort_max_cdr_typesize 20ULL;
#define ArraySingleDimensionLiteralsUnsignedLongLong_max_cdr_typesize 80ULL;
#define InnerEmptyStructureHelper_max_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBoolean_max_cdr_typesize 250ULL;
#define ArrayMultiDimensionLiteralsStructure_max_cdr_typesize 2000ULL;
#define ArrayLong_max_cdr_typesize 40ULL;

#define ArraySingleDimensionLiteralsLongDouble_max_cdr_typesize 160ULL;
#define ArraySingleDimensionLiteralsSequence_max_cdr_typesize 2020ULL;
#define ArrayBitMask_max_cdr_typesize 40ULL;
#define ArrayMultiDimensionWString_max_cdr_typesize 1024000ULL;
#define ArrayULong_max_cdr_typesize 40ULL;

#define ArrayString_max_cdr_typesize 2600ULL;


#define ArraySingleDimensionLiteralsUnion_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionLiteralsBoundedWString_max_cdr_typesize 44000ULL;
#define ArrayMultiDimensionLong_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionLiteralsBoundedString_max_cdr_typesize 3999ULL;
#define ArrayMultiDimensionLiteralsSequence_max_cdr_typesize 202000ULL;
#define ArrayMultiDimensionString_max_cdr_typesize 260000ULL;
#define ArrayChar_max_cdr_typesize 10ULL;

#define ArraySingleDimensionLiteralsString_max_cdr_typesize 1300ULL;
#define ArraySingleDimensionLiteralsShortArray_max_cdr_typesize 200ULL;

#define ArrayMultiDimensionLiteralsUShort_max_cdr_typesize 500ULL;
#define ArrayMultiDimensionLiteralsUnion_max_cdr_typesize 8000ULL;
#define ArrayBoundedString_max_cdr_typesize 159ULL;
#define ArraySingleDimensionLiteralsEnum_max_cdr_typesize 20ULL;
#define ArrayMultiDimensionLongLong_max_cdr_typesize 8000ULL;
#define ArrayMultiDimensionDouble_max_cdr_typesize 8000ULL;
#define ArrayAlias_max_cdr_typesize 40ULL;
#define ArrayULongLong_max_cdr_typesize 80ULL;
#define ArraySingleDimensionLiteralsDouble_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionBitMask_max_cdr_typesize 4000ULL;

#define ArraySingleDimensionLiteralsMap_max_cdr_typesize 1608ULL;
#define ArraySingleDimensionLiteralsLongLong_max_cdr_typesize 80ULL;
#define ArraySingleDimensionLiteralsBoolean_max_cdr_typesize 5ULL;
#define ArrayFloat_max_cdr_typesize 40ULL;
#define ArrayMultiDimensionAlias_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionWChar_max_cdr_typesize 4000ULL;
#define ArrayUShort_max_cdr_typesize 20ULL;
#define ArrayWString_max_cdr_typesize 10240ULL;
#define ArrayMultiDimensionMap_max_cdr_typesize 804000ULL;
#define ArrayMultiDimensionLiteralsLong_max_cdr_typesize 1000ULL;
#define ArraySingleDimensionLiteralsAlias_max_cdr_typesize 40ULL;
#define ArraySingleDimensionLiteralsBitset_max_cdr_typesize 80ULL;
#define BoundedBigArrays_max_cdr_typesize 83850ULL;
#define ArraySingleDimensionLiteralsWString_max_cdr_typesize 10240ULL;
#define ArrayEnum_max_cdr_typesize 40ULL;
#define ArrayMap_max_cdr_typesize 8040ULL;
#define ArraySingleDimensionLiteralsShort_max_cdr_typesize 10ULL;
#define BoundedSmallArrays_max_cdr_typesize 2ULL;
#define ArrayMultiDimensionBoundedString_max_cdr_typesize 15999ULL;
#define ArrayMultiDimensionLiteralsChar_max_cdr_typesize 500ULL;
#define ArrayMultiDimensionLiteralsMap_max_cdr_typesize 201000ULL;
#define ArrayWChar_max_cdr_typesize 40ULL;
#define ArrayMultiDimensionBoundedWString_max_cdr_typesize 44000ULL;
#define ArrayOctet_max_cdr_typesize 10ULL;
#define ArraySequence_max_cdr_typesize 4040ULL;
#define ArrayBoolean_max_cdr_typesize 10ULL;
#define ArrayMultiDimensionLiteralsULongLong_max_cdr_typesize 8000ULL;
#define ArrayMultiDimensionLiteralsBitMask_max_cdr_typesize 1000ULL;
#define ArraySingleDimensionLiteralsChar_max_cdr_typesize 5ULL;
#define ArraySingleDimensionLiteralsBoundedWString_max_cdr_typesize 440ULL;
#define ArrayMultiDimensionLiteralsFloat_max_cdr_typesize 2000ULL;
#define ArrayBoundedWString_max_cdr_typesize 440ULL;
#define ArrayBitset_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionOctet_max_cdr_typesize 1000ULL;
#define ArrayMultiDimensionEnum_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionLiteralsOctet_max_cdr_typesize 250ULL;
#define ArraySingleDimensionLiteralsUnsignedLong_max_cdr_typesize 40ULL;
#define ArrayMultiDimensionUShort_max_cdr_typesize 2000ULL;
#define ArrayDouble_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionLongDouble_max_cdr_typesize 16000ULL;
#define ArrayMultiDimensionLiteralsULong_max_cdr_typesize 2000ULL;
#define ArraySingleDimensionLiteralsOctet_max_cdr_typesize 10ULL;
#define ArrayMultiDimensionULong_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionFloat_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionLiteralsLongDouble_max_cdr_typesize 4000ULL;
#define ArrayMultiDimensionLiteralsShort_max_cdr_typesize 200ULL;
#define ArrayMultiDimensionLiteralsLongLong_max_cdr_typesize 2000ULL;
#define ArraySingleDimensionLiteralsWChar_max_cdr_typesize 40ULL;
#define ArrayLongLong_max_cdr_typesize 80ULL;
#define ArrayMultiDimensionStructure_max_cdr_typesize 8000ULL;
#define ArraySingleDimensionLiteralsBoundedString_max_cdr_typesize 79ULL;
#define ArrayShortArray_max_cdr_typesize 200ULL;
#define ArrayUnion_max_cdr_typesize 80ULL;
#define ArraySingleDimensionLiteralsLong_max_cdr_typesize 40ULL;
#define ArrayLongDouble_max_cdr_typesize 160ULL;


#define ArrayMultiDimensionShort_max_cdr_typesize 2000ULL;
#define ArraySingleDimensionLiteralsUnsignedShort_max_cdr_typesize 20ULL;
#define ArraySingleDimensionLiteralsFloat_max_cdr_typesize 20ULL;
#define ArrayMultiDimensionLiteralsString_max_cdr_typesize 65000ULL;
#define ArrayMultiDimensionLiteralsWString_max_cdr_typesize 1024000ULL;

#define InnerStructureHelper_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionULongLong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsBitMask_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsEnum_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsStructure_max_key_cdr_typesize 0ULL;
#define ArrayStructure_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionSequence_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionBoolean_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionBitset_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsDouble_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsAlias_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsWChar_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBitSet_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionUnion_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionChar_max_key_cdr_typesize 0ULL;
#define ArrayShort_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsUnsignedLongLong_max_key_cdr_typesize 0ULL;
#define InnerEmptyStructureHelper_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBoolean_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsStructure_max_key_cdr_typesize 0ULL;
#define ArrayLong_max_key_cdr_typesize 0ULL;

#define ArraySingleDimensionLiteralsLongDouble_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsSequence_max_key_cdr_typesize 0ULL;
#define ArrayBitMask_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionWString_max_key_cdr_typesize 0ULL;
#define ArrayULong_max_key_cdr_typesize 0ULL;

#define ArrayString_max_key_cdr_typesize 0ULL;


#define ArraySingleDimensionLiteralsUnion_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBoundedWString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBoundedString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsSequence_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionString_max_key_cdr_typesize 0ULL;
#define ArrayChar_max_key_cdr_typesize 0ULL;

#define ArraySingleDimensionLiteralsString_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsShortArray_max_key_cdr_typesize 0ULL;

#define ArrayMultiDimensionLiteralsUShort_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsUnion_max_key_cdr_typesize 0ULL;
#define ArrayBoundedString_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsEnum_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLongLong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionDouble_max_key_cdr_typesize 0ULL;
#define ArrayAlias_max_key_cdr_typesize 0ULL;
#define ArrayULongLong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsDouble_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionBitMask_max_key_cdr_typesize 0ULL;

#define ArraySingleDimensionLiteralsMap_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsLongLong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsBoolean_max_key_cdr_typesize 0ULL;
#define ArrayFloat_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionAlias_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionWChar_max_key_cdr_typesize 0ULL;
#define ArrayUShort_max_key_cdr_typesize 0ULL;
#define ArrayWString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionMap_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsLong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsAlias_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsBitset_max_key_cdr_typesize 0ULL;
#define BoundedBigArrays_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsWString_max_key_cdr_typesize 0ULL;
#define ArrayEnum_max_key_cdr_typesize 0ULL;
#define ArrayMap_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsShort_max_key_cdr_typesize 0ULL;
#define BoundedSmallArrays_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionBoundedString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsChar_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsMap_max_key_cdr_typesize 0ULL;
#define ArrayWChar_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionBoundedWString_max_key_cdr_typesize 0ULL;
#define ArrayOctet_max_key_cdr_typesize 0ULL;
#define ArraySequence_max_key_cdr_typesize 0ULL;
#define ArrayBoolean_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsULongLong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsBitMask_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsChar_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsBoundedWString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsFloat_max_key_cdr_typesize 0ULL;
#define ArrayBoundedWString_max_key_cdr_typesize 0ULL;
#define ArrayBitset_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionOctet_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionEnum_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsOctet_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsUnsignedLong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionUShort_max_key_cdr_typesize 0ULL;
#define ArrayDouble_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLongDouble_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsULong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsOctet_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionULong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionFloat_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsLongDouble_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsShort_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsLongLong_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsWChar_max_key_cdr_typesize 0ULL;
#define ArrayLongLong_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionStructure_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsBoundedString_max_key_cdr_typesize 0ULL;
#define ArrayShortArray_max_key_cdr_typesize 0ULL;
#define ArrayUnion_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsLong_max_key_cdr_typesize 0ULL;
#define ArrayLongDouble_max_key_cdr_typesize 0ULL;


#define ArrayMultiDimensionShort_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsUnsignedShort_max_key_cdr_typesize 0ULL;
#define ArraySingleDimensionLiteralsFloat_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsString_max_key_cdr_typesize 0ULL;
#define ArrayMultiDimensionLiteralsWString_max_key_cdr_typesize 0ULL;








ArrayShort::ArrayShort()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayShort::~ArrayShort()
{
}

ArrayShort::ArrayShort(
        const ArrayShort& x)
{
    m_var_array_short = x.m_var_array_short;
}

ArrayShort::ArrayShort(
        ArrayShort&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

ArrayShort& ArrayShort::operator =(
        const ArrayShort& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

ArrayShort& ArrayShort::operator =(
        ArrayShort&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool ArrayShort::operator ==(
        const ArrayShort& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool ArrayShort::operator !=(
        const ArrayShort& x) const
{
    return !(*this == x);
}

size_t ArrayShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayShort_max_cdr_typesize;
}

size_t ArrayShort::getCdrSerializedSize(
        const ArrayShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_short;

}

void ArrayShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_short;

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void ArrayShort::var_array_short(
        const std::array<int16_t, 10>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void ArrayShort::var_array_short(
        std::array<int16_t, 10>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<int16_t, 10>& ArrayShort::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<int16_t, 10>& ArrayShort::var_array_short()
{
    return m_var_array_short;
}


size_t ArrayShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayShort_max_key_cdr_typesize;
}

bool ArrayShort::isKeyDefined()
{
    return false;
}

void ArrayShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayUShort::ArrayUShort()
{
    // unsigned short m_var_array_ushort
    memset(&m_var_array_ushort, 0, (10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayUShort::~ArrayUShort()
{
}

ArrayUShort::ArrayUShort(
        const ArrayUShort& x)
{
    m_var_array_ushort = x.m_var_array_ushort;
}

ArrayUShort::ArrayUShort(
        ArrayUShort&& x) noexcept 
{
    m_var_array_ushort = std::move(x.m_var_array_ushort);
}

ArrayUShort& ArrayUShort::operator =(
        const ArrayUShort& x)
{

    m_var_array_ushort = x.m_var_array_ushort;

    return *this;
}

ArrayUShort& ArrayUShort::operator =(
        ArrayUShort&& x) noexcept
{

    m_var_array_ushort = std::move(x.m_var_array_ushort);

    return *this;
}

bool ArrayUShort::operator ==(
        const ArrayUShort& x) const
{

    return (m_var_array_ushort == x.m_var_array_ushort);
}

bool ArrayUShort::operator !=(
        const ArrayUShort& x) const
{
    return !(*this == x);
}

size_t ArrayUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayUShort_max_cdr_typesize;
}

size_t ArrayUShort::getCdrSerializedSize(
        const ArrayUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ushort;

}

void ArrayUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ushort;

}

/*!
 * @brief This function copies the value in member var_array_ushort
 * @param _var_array_ushort New value to be copied in member var_array_ushort
 */
void ArrayUShort::var_array_ushort(
        const std::array<uint16_t, 10>& _var_array_ushort)
{
    m_var_array_ushort = _var_array_ushort;
}

/*!
 * @brief This function moves the value in member var_array_ushort
 * @param _var_array_ushort New value to be moved in member var_array_ushort
 */
void ArrayUShort::var_array_ushort(
        std::array<uint16_t, 10>&& _var_array_ushort)
{
    m_var_array_ushort = std::move(_var_array_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_array_ushort
 * @return Constant reference to member var_array_ushort
 */
const std::array<uint16_t, 10>& ArrayUShort::var_array_ushort() const
{
    return m_var_array_ushort;
}

/*!
 * @brief This function returns a reference to member var_array_ushort
 * @return Reference to member var_array_ushort
 */
std::array<uint16_t, 10>& ArrayUShort::var_array_ushort()
{
    return m_var_array_ushort;
}


size_t ArrayUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayUShort_max_key_cdr_typesize;
}

bool ArrayUShort::isKeyDefined()
{
    return false;
}

void ArrayUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayLong::ArrayLong()
{
    // long m_var_array_long
    memset(&m_var_array_long, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayLong::~ArrayLong()
{
}

ArrayLong::ArrayLong(
        const ArrayLong& x)
{
    m_var_array_long = x.m_var_array_long;
}

ArrayLong::ArrayLong(
        ArrayLong&& x) noexcept 
{
    m_var_array_long = std::move(x.m_var_array_long);
}

ArrayLong& ArrayLong::operator =(
        const ArrayLong& x)
{

    m_var_array_long = x.m_var_array_long;

    return *this;
}

ArrayLong& ArrayLong::operator =(
        ArrayLong&& x) noexcept
{

    m_var_array_long = std::move(x.m_var_array_long);

    return *this;
}

bool ArrayLong::operator ==(
        const ArrayLong& x) const
{

    return (m_var_array_long == x.m_var_array_long);
}

bool ArrayLong::operator !=(
        const ArrayLong& x) const
{
    return !(*this == x);
}

size_t ArrayLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLong_max_cdr_typesize;
}

size_t ArrayLong::getCdrSerializedSize(
        const ArrayLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_long;

}

void ArrayLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_long;

}

/*!
 * @brief This function copies the value in member var_array_long
 * @param _var_array_long New value to be copied in member var_array_long
 */
void ArrayLong::var_array_long(
        const std::array<int32_t, 10>& _var_array_long)
{
    m_var_array_long = _var_array_long;
}

/*!
 * @brief This function moves the value in member var_array_long
 * @param _var_array_long New value to be moved in member var_array_long
 */
void ArrayLong::var_array_long(
        std::array<int32_t, 10>&& _var_array_long)
{
    m_var_array_long = std::move(_var_array_long);
}

/*!
 * @brief This function returns a constant reference to member var_array_long
 * @return Constant reference to member var_array_long
 */
const std::array<int32_t, 10>& ArrayLong::var_array_long() const
{
    return m_var_array_long;
}

/*!
 * @brief This function returns a reference to member var_array_long
 * @return Reference to member var_array_long
 */
std::array<int32_t, 10>& ArrayLong::var_array_long()
{
    return m_var_array_long;
}


size_t ArrayLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLong_max_key_cdr_typesize;
}

bool ArrayLong::isKeyDefined()
{
    return false;
}

void ArrayLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayULong::ArrayULong()
{
    // unsigned long m_var_array_ulong
    memset(&m_var_array_ulong, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayULong::~ArrayULong()
{
}

ArrayULong::ArrayULong(
        const ArrayULong& x)
{
    m_var_array_ulong = x.m_var_array_ulong;
}

ArrayULong::ArrayULong(
        ArrayULong&& x) noexcept 
{
    m_var_array_ulong = std::move(x.m_var_array_ulong);
}

ArrayULong& ArrayULong::operator =(
        const ArrayULong& x)
{

    m_var_array_ulong = x.m_var_array_ulong;

    return *this;
}

ArrayULong& ArrayULong::operator =(
        ArrayULong&& x) noexcept
{

    m_var_array_ulong = std::move(x.m_var_array_ulong);

    return *this;
}

bool ArrayULong::operator ==(
        const ArrayULong& x) const
{

    return (m_var_array_ulong == x.m_var_array_ulong);
}

bool ArrayULong::operator !=(
        const ArrayULong& x) const
{
    return !(*this == x);
}

size_t ArrayULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayULong_max_cdr_typesize;
}

size_t ArrayULong::getCdrSerializedSize(
        const ArrayULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ulong;

}

void ArrayULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ulong;

}

/*!
 * @brief This function copies the value in member var_array_ulong
 * @param _var_array_ulong New value to be copied in member var_array_ulong
 */
void ArrayULong::var_array_ulong(
        const std::array<uint32_t, 10>& _var_array_ulong)
{
    m_var_array_ulong = _var_array_ulong;
}

/*!
 * @brief This function moves the value in member var_array_ulong
 * @param _var_array_ulong New value to be moved in member var_array_ulong
 */
void ArrayULong::var_array_ulong(
        std::array<uint32_t, 10>&& _var_array_ulong)
{
    m_var_array_ulong = std::move(_var_array_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulong
 * @return Constant reference to member var_array_ulong
 */
const std::array<uint32_t, 10>& ArrayULong::var_array_ulong() const
{
    return m_var_array_ulong;
}

/*!
 * @brief This function returns a reference to member var_array_ulong
 * @return Reference to member var_array_ulong
 */
std::array<uint32_t, 10>& ArrayULong::var_array_ulong()
{
    return m_var_array_ulong;
}


size_t ArrayULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayULong_max_key_cdr_typesize;
}

bool ArrayULong::isKeyDefined()
{
    return false;
}

void ArrayULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayLongLong::ArrayLongLong()
{
    // long long m_var_array_longlong
    memset(&m_var_array_longlong, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayLongLong::~ArrayLongLong()
{
}

ArrayLongLong::ArrayLongLong(
        const ArrayLongLong& x)
{
    m_var_array_longlong = x.m_var_array_longlong;
}

ArrayLongLong::ArrayLongLong(
        ArrayLongLong&& x) noexcept 
{
    m_var_array_longlong = std::move(x.m_var_array_longlong);
}

ArrayLongLong& ArrayLongLong::operator =(
        const ArrayLongLong& x)
{

    m_var_array_longlong = x.m_var_array_longlong;

    return *this;
}

ArrayLongLong& ArrayLongLong::operator =(
        ArrayLongLong&& x) noexcept
{

    m_var_array_longlong = std::move(x.m_var_array_longlong);

    return *this;
}

bool ArrayLongLong::operator ==(
        const ArrayLongLong& x) const
{

    return (m_var_array_longlong == x.m_var_array_longlong);
}

bool ArrayLongLong::operator !=(
        const ArrayLongLong& x) const
{
    return !(*this == x);
}

size_t ArrayLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLongLong_max_cdr_typesize;
}

size_t ArrayLongLong::getCdrSerializedSize(
        const ArrayLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_longlong;

}

void ArrayLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_longlong;

}

/*!
 * @brief This function copies the value in member var_array_longlong
 * @param _var_array_longlong New value to be copied in member var_array_longlong
 */
void ArrayLongLong::var_array_longlong(
        const std::array<int64_t, 10>& _var_array_longlong)
{
    m_var_array_longlong = _var_array_longlong;
}

/*!
 * @brief This function moves the value in member var_array_longlong
 * @param _var_array_longlong New value to be moved in member var_array_longlong
 */
void ArrayLongLong::var_array_longlong(
        std::array<int64_t, 10>&& _var_array_longlong)
{
    m_var_array_longlong = std::move(_var_array_longlong);
}

/*!
 * @brief This function returns a constant reference to member var_array_longlong
 * @return Constant reference to member var_array_longlong
 */
const std::array<int64_t, 10>& ArrayLongLong::var_array_longlong() const
{
    return m_var_array_longlong;
}

/*!
 * @brief This function returns a reference to member var_array_longlong
 * @return Reference to member var_array_longlong
 */
std::array<int64_t, 10>& ArrayLongLong::var_array_longlong()
{
    return m_var_array_longlong;
}


size_t ArrayLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLongLong_max_key_cdr_typesize;
}

bool ArrayLongLong::isKeyDefined()
{
    return false;
}

void ArrayLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayULongLong::ArrayULongLong()
{
    // unsigned long long m_var_array_ulonglong
    memset(&m_var_array_ulonglong, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayULongLong::~ArrayULongLong()
{
}

ArrayULongLong::ArrayULongLong(
        const ArrayULongLong& x)
{
    m_var_array_ulonglong = x.m_var_array_ulonglong;
}

ArrayULongLong::ArrayULongLong(
        ArrayULongLong&& x) noexcept 
{
    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);
}

ArrayULongLong& ArrayULongLong::operator =(
        const ArrayULongLong& x)
{

    m_var_array_ulonglong = x.m_var_array_ulonglong;

    return *this;
}

ArrayULongLong& ArrayULongLong::operator =(
        ArrayULongLong&& x) noexcept
{

    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);

    return *this;
}

bool ArrayULongLong::operator ==(
        const ArrayULongLong& x) const
{

    return (m_var_array_ulonglong == x.m_var_array_ulonglong);
}

bool ArrayULongLong::operator !=(
        const ArrayULongLong& x) const
{
    return !(*this == x);
}

size_t ArrayULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayULongLong_max_cdr_typesize;
}

size_t ArrayULongLong::getCdrSerializedSize(
        const ArrayULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ulonglong;

}

void ArrayULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ulonglong;

}

/*!
 * @brief This function copies the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be copied in member var_array_ulonglong
 */
void ArrayULongLong::var_array_ulonglong(
        const std::array<uint64_t, 10>& _var_array_ulonglong)
{
    m_var_array_ulonglong = _var_array_ulonglong;
}

/*!
 * @brief This function moves the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be moved in member var_array_ulonglong
 */
void ArrayULongLong::var_array_ulonglong(
        std::array<uint64_t, 10>&& _var_array_ulonglong)
{
    m_var_array_ulonglong = std::move(_var_array_ulonglong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulonglong
 * @return Constant reference to member var_array_ulonglong
 */
const std::array<uint64_t, 10>& ArrayULongLong::var_array_ulonglong() const
{
    return m_var_array_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_array_ulonglong
 * @return Reference to member var_array_ulonglong
 */
std::array<uint64_t, 10>& ArrayULongLong::var_array_ulonglong()
{
    return m_var_array_ulonglong;
}


size_t ArrayULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayULongLong_max_key_cdr_typesize;
}

bool ArrayULongLong::isKeyDefined()
{
    return false;
}

void ArrayULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayFloat::ArrayFloat()
{
    // float m_var_array_float
    memset(&m_var_array_float, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayFloat::~ArrayFloat()
{
}

ArrayFloat::ArrayFloat(
        const ArrayFloat& x)
{
    m_var_array_float = x.m_var_array_float;
}

ArrayFloat::ArrayFloat(
        ArrayFloat&& x) noexcept 
{
    m_var_array_float = std::move(x.m_var_array_float);
}

ArrayFloat& ArrayFloat::operator =(
        const ArrayFloat& x)
{

    m_var_array_float = x.m_var_array_float;

    return *this;
}

ArrayFloat& ArrayFloat::operator =(
        ArrayFloat&& x) noexcept
{

    m_var_array_float = std::move(x.m_var_array_float);

    return *this;
}

bool ArrayFloat::operator ==(
        const ArrayFloat& x) const
{

    return (m_var_array_float == x.m_var_array_float);
}

bool ArrayFloat::operator !=(
        const ArrayFloat& x) const
{
    return !(*this == x);
}

size_t ArrayFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayFloat_max_cdr_typesize;
}

size_t ArrayFloat::getCdrSerializedSize(
        const ArrayFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_float;

}

void ArrayFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_float;

}

/*!
 * @brief This function copies the value in member var_array_float
 * @param _var_array_float New value to be copied in member var_array_float
 */
void ArrayFloat::var_array_float(
        const std::array<float, 10>& _var_array_float)
{
    m_var_array_float = _var_array_float;
}

/*!
 * @brief This function moves the value in member var_array_float
 * @param _var_array_float New value to be moved in member var_array_float
 */
void ArrayFloat::var_array_float(
        std::array<float, 10>&& _var_array_float)
{
    m_var_array_float = std::move(_var_array_float);
}

/*!
 * @brief This function returns a constant reference to member var_array_float
 * @return Constant reference to member var_array_float
 */
const std::array<float, 10>& ArrayFloat::var_array_float() const
{
    return m_var_array_float;
}

/*!
 * @brief This function returns a reference to member var_array_float
 * @return Reference to member var_array_float
 */
std::array<float, 10>& ArrayFloat::var_array_float()
{
    return m_var_array_float;
}


size_t ArrayFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayFloat_max_key_cdr_typesize;
}

bool ArrayFloat::isKeyDefined()
{
    return false;
}

void ArrayFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayDouble::ArrayDouble()
{
    // double m_var_array_double
    memset(&m_var_array_double, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayDouble::~ArrayDouble()
{
}

ArrayDouble::ArrayDouble(
        const ArrayDouble& x)
{
    m_var_array_double = x.m_var_array_double;
}

ArrayDouble::ArrayDouble(
        ArrayDouble&& x) noexcept 
{
    m_var_array_double = std::move(x.m_var_array_double);
}

ArrayDouble& ArrayDouble::operator =(
        const ArrayDouble& x)
{

    m_var_array_double = x.m_var_array_double;

    return *this;
}

ArrayDouble& ArrayDouble::operator =(
        ArrayDouble&& x) noexcept
{

    m_var_array_double = std::move(x.m_var_array_double);

    return *this;
}

bool ArrayDouble::operator ==(
        const ArrayDouble& x) const
{

    return (m_var_array_double == x.m_var_array_double);
}

bool ArrayDouble::operator !=(
        const ArrayDouble& x) const
{
    return !(*this == x);
}

size_t ArrayDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayDouble_max_cdr_typesize;
}

size_t ArrayDouble::getCdrSerializedSize(
        const ArrayDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_double;

}

void ArrayDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_double;

}

/*!
 * @brief This function copies the value in member var_array_double
 * @param _var_array_double New value to be copied in member var_array_double
 */
void ArrayDouble::var_array_double(
        const std::array<double, 10>& _var_array_double)
{
    m_var_array_double = _var_array_double;
}

/*!
 * @brief This function moves the value in member var_array_double
 * @param _var_array_double New value to be moved in member var_array_double
 */
void ArrayDouble::var_array_double(
        std::array<double, 10>&& _var_array_double)
{
    m_var_array_double = std::move(_var_array_double);
}

/*!
 * @brief This function returns a constant reference to member var_array_double
 * @return Constant reference to member var_array_double
 */
const std::array<double, 10>& ArrayDouble::var_array_double() const
{
    return m_var_array_double;
}

/*!
 * @brief This function returns a reference to member var_array_double
 * @return Reference to member var_array_double
 */
std::array<double, 10>& ArrayDouble::var_array_double()
{
    return m_var_array_double;
}


size_t ArrayDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayDouble_max_key_cdr_typesize;
}

bool ArrayDouble::isKeyDefined()
{
    return false;
}

void ArrayDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayLongDouble::ArrayLongDouble()
{
    // long double m_var_array_longdouble
    memset(&m_var_array_longdouble, 0, (10) * 16);


    // Just to register all known types
    registerarraysTypes();
}

ArrayLongDouble::~ArrayLongDouble()
{
}

ArrayLongDouble::ArrayLongDouble(
        const ArrayLongDouble& x)
{
    m_var_array_longdouble = x.m_var_array_longdouble;
}

ArrayLongDouble::ArrayLongDouble(
        ArrayLongDouble&& x) noexcept 
{
    m_var_array_longdouble = std::move(x.m_var_array_longdouble);
}

ArrayLongDouble& ArrayLongDouble::operator =(
        const ArrayLongDouble& x)
{

    m_var_array_longdouble = x.m_var_array_longdouble;

    return *this;
}

ArrayLongDouble& ArrayLongDouble::operator =(
        ArrayLongDouble&& x) noexcept
{

    m_var_array_longdouble = std::move(x.m_var_array_longdouble);

    return *this;
}

bool ArrayLongDouble::operator ==(
        const ArrayLongDouble& x) const
{

    return (m_var_array_longdouble == x.m_var_array_longdouble);
}

bool ArrayLongDouble::operator !=(
        const ArrayLongDouble& x) const
{
    return !(*this == x);
}

size_t ArrayLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLongDouble_max_cdr_typesize;
}

size_t ArrayLongDouble::getCdrSerializedSize(
        const ArrayLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 16) + eprosima::fastcdr::Cdr::alignment(current_alignment, 16);

    return current_alignment - initial_alignment;
}

void ArrayLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_longdouble;

}

void ArrayLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_longdouble;

}

/*!
 * @brief This function copies the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be copied in member var_array_longdouble
 */
void ArrayLongDouble::var_array_longdouble(
        const std::array<long double, 10>& _var_array_longdouble)
{
    m_var_array_longdouble = _var_array_longdouble;
}

/*!
 * @brief This function moves the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be moved in member var_array_longdouble
 */
void ArrayLongDouble::var_array_longdouble(
        std::array<long double, 10>&& _var_array_longdouble)
{
    m_var_array_longdouble = std::move(_var_array_longdouble);
}

/*!
 * @brief This function returns a constant reference to member var_array_longdouble
 * @return Constant reference to member var_array_longdouble
 */
const std::array<long double, 10>& ArrayLongDouble::var_array_longdouble() const
{
    return m_var_array_longdouble;
}

/*!
 * @brief This function returns a reference to member var_array_longdouble
 * @return Reference to member var_array_longdouble
 */
std::array<long double, 10>& ArrayLongDouble::var_array_longdouble()
{
    return m_var_array_longdouble;
}


size_t ArrayLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayLongDouble_max_key_cdr_typesize;
}

bool ArrayLongDouble::isKeyDefined()
{
    return false;
}

void ArrayLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayBoolean::ArrayBoolean()
{
    // boolean m_var_array_boolean
    memset(&m_var_array_boolean, 0, (10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayBoolean::~ArrayBoolean()
{
}

ArrayBoolean::ArrayBoolean(
        const ArrayBoolean& x)
{
    m_var_array_boolean = x.m_var_array_boolean;
}

ArrayBoolean::ArrayBoolean(
        ArrayBoolean&& x) noexcept 
{
    m_var_array_boolean = std::move(x.m_var_array_boolean);
}

ArrayBoolean& ArrayBoolean::operator =(
        const ArrayBoolean& x)
{

    m_var_array_boolean = x.m_var_array_boolean;

    return *this;
}

ArrayBoolean& ArrayBoolean::operator =(
        ArrayBoolean&& x) noexcept
{

    m_var_array_boolean = std::move(x.m_var_array_boolean);

    return *this;
}

bool ArrayBoolean::operator ==(
        const ArrayBoolean& x) const
{

    return (m_var_array_boolean == x.m_var_array_boolean);
}

bool ArrayBoolean::operator !=(
        const ArrayBoolean& x) const
{
    return !(*this == x);
}

size_t ArrayBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoolean_max_cdr_typesize;
}

size_t ArrayBoolean::getCdrSerializedSize(
        const ArrayBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_boolean;

}

void ArrayBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_boolean;

}

/*!
 * @brief This function copies the value in member var_array_boolean
 * @param _var_array_boolean New value to be copied in member var_array_boolean
 */
void ArrayBoolean::var_array_boolean(
        const std::array<bool, 10>& _var_array_boolean)
{
    m_var_array_boolean = _var_array_boolean;
}

/*!
 * @brief This function moves the value in member var_array_boolean
 * @param _var_array_boolean New value to be moved in member var_array_boolean
 */
void ArrayBoolean::var_array_boolean(
        std::array<bool, 10>&& _var_array_boolean)
{
    m_var_array_boolean = std::move(_var_array_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_array_boolean
 * @return Constant reference to member var_array_boolean
 */
const std::array<bool, 10>& ArrayBoolean::var_array_boolean() const
{
    return m_var_array_boolean;
}

/*!
 * @brief This function returns a reference to member var_array_boolean
 * @return Reference to member var_array_boolean
 */
std::array<bool, 10>& ArrayBoolean::var_array_boolean()
{
    return m_var_array_boolean;
}


size_t ArrayBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoolean_max_key_cdr_typesize;
}

bool ArrayBoolean::isKeyDefined()
{
    return false;
}

void ArrayBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayOctet::ArrayOctet()
{
    // octet m_var_array_octet
    memset(&m_var_array_octet, 0, (10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayOctet::~ArrayOctet()
{
}

ArrayOctet::ArrayOctet(
        const ArrayOctet& x)
{
    m_var_array_octet = x.m_var_array_octet;
}

ArrayOctet::ArrayOctet(
        ArrayOctet&& x) noexcept 
{
    m_var_array_octet = std::move(x.m_var_array_octet);
}

ArrayOctet& ArrayOctet::operator =(
        const ArrayOctet& x)
{

    m_var_array_octet = x.m_var_array_octet;

    return *this;
}

ArrayOctet& ArrayOctet::operator =(
        ArrayOctet&& x) noexcept
{

    m_var_array_octet = std::move(x.m_var_array_octet);

    return *this;
}

bool ArrayOctet::operator ==(
        const ArrayOctet& x) const
{

    return (m_var_array_octet == x.m_var_array_octet);
}

bool ArrayOctet::operator !=(
        const ArrayOctet& x) const
{
    return !(*this == x);
}

size_t ArrayOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayOctet_max_cdr_typesize;
}

size_t ArrayOctet::getCdrSerializedSize(
        const ArrayOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_octet;

}

void ArrayOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_octet;

}

/*!
 * @brief This function copies the value in member var_array_octet
 * @param _var_array_octet New value to be copied in member var_array_octet
 */
void ArrayOctet::var_array_octet(
        const std::array<uint8_t, 10>& _var_array_octet)
{
    m_var_array_octet = _var_array_octet;
}

/*!
 * @brief This function moves the value in member var_array_octet
 * @param _var_array_octet New value to be moved in member var_array_octet
 */
void ArrayOctet::var_array_octet(
        std::array<uint8_t, 10>&& _var_array_octet)
{
    m_var_array_octet = std::move(_var_array_octet);
}

/*!
 * @brief This function returns a constant reference to member var_array_octet
 * @return Constant reference to member var_array_octet
 */
const std::array<uint8_t, 10>& ArrayOctet::var_array_octet() const
{
    return m_var_array_octet;
}

/*!
 * @brief This function returns a reference to member var_array_octet
 * @return Reference to member var_array_octet
 */
std::array<uint8_t, 10>& ArrayOctet::var_array_octet()
{
    return m_var_array_octet;
}


size_t ArrayOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayOctet_max_key_cdr_typesize;
}

bool ArrayOctet::isKeyDefined()
{
    return false;
}

void ArrayOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayChar::ArrayChar()
{
    // char m_var_array_char
    memset(&m_var_array_char, 0, (10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayChar::~ArrayChar()
{
}

ArrayChar::ArrayChar(
        const ArrayChar& x)
{
    m_var_array_char = x.m_var_array_char;
}

ArrayChar::ArrayChar(
        ArrayChar&& x) noexcept 
{
    m_var_array_char = std::move(x.m_var_array_char);
}

ArrayChar& ArrayChar::operator =(
        const ArrayChar& x)
{

    m_var_array_char = x.m_var_array_char;

    return *this;
}

ArrayChar& ArrayChar::operator =(
        ArrayChar&& x) noexcept
{

    m_var_array_char = std::move(x.m_var_array_char);

    return *this;
}

bool ArrayChar::operator ==(
        const ArrayChar& x) const
{

    return (m_var_array_char == x.m_var_array_char);
}

bool ArrayChar::operator !=(
        const ArrayChar& x) const
{
    return !(*this == x);
}

size_t ArrayChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayChar_max_cdr_typesize;
}

size_t ArrayChar::getCdrSerializedSize(
        const ArrayChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_char;

}

void ArrayChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_char;

}

/*!
 * @brief This function copies the value in member var_array_char
 * @param _var_array_char New value to be copied in member var_array_char
 */
void ArrayChar::var_array_char(
        const std::array<char, 10>& _var_array_char)
{
    m_var_array_char = _var_array_char;
}

/*!
 * @brief This function moves the value in member var_array_char
 * @param _var_array_char New value to be moved in member var_array_char
 */
void ArrayChar::var_array_char(
        std::array<char, 10>&& _var_array_char)
{
    m_var_array_char = std::move(_var_array_char);
}

/*!
 * @brief This function returns a constant reference to member var_array_char
 * @return Constant reference to member var_array_char
 */
const std::array<char, 10>& ArrayChar::var_array_char() const
{
    return m_var_array_char;
}

/*!
 * @brief This function returns a reference to member var_array_char
 * @return Reference to member var_array_char
 */
std::array<char, 10>& ArrayChar::var_array_char()
{
    return m_var_array_char;
}


size_t ArrayChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayChar_max_key_cdr_typesize;
}

bool ArrayChar::isKeyDefined()
{
    return false;
}

void ArrayChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayWChar::ArrayWChar()
{
    // wchar m_var_array_wchar
    memset(&m_var_array_wchar, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayWChar::~ArrayWChar()
{
}

ArrayWChar::ArrayWChar(
        const ArrayWChar& x)
{
    m_var_array_wchar = x.m_var_array_wchar;
}

ArrayWChar::ArrayWChar(
        ArrayWChar&& x) noexcept 
{
    m_var_array_wchar = std::move(x.m_var_array_wchar);
}

ArrayWChar& ArrayWChar::operator =(
        const ArrayWChar& x)
{

    m_var_array_wchar = x.m_var_array_wchar;

    return *this;
}

ArrayWChar& ArrayWChar::operator =(
        ArrayWChar&& x) noexcept
{

    m_var_array_wchar = std::move(x.m_var_array_wchar);

    return *this;
}

bool ArrayWChar::operator ==(
        const ArrayWChar& x) const
{

    return (m_var_array_wchar == x.m_var_array_wchar);
}

bool ArrayWChar::operator !=(
        const ArrayWChar& x) const
{
    return !(*this == x);
}

size_t ArrayWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayWChar_max_cdr_typesize;
}

size_t ArrayWChar::getCdrSerializedSize(
        const ArrayWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_wchar;

}

void ArrayWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_wchar;

}

/*!
 * @brief This function copies the value in member var_array_wchar
 * @param _var_array_wchar New value to be copied in member var_array_wchar
 */
void ArrayWChar::var_array_wchar(
        const std::array<wchar_t, 10>& _var_array_wchar)
{
    m_var_array_wchar = _var_array_wchar;
}

/*!
 * @brief This function moves the value in member var_array_wchar
 * @param _var_array_wchar New value to be moved in member var_array_wchar
 */
void ArrayWChar::var_array_wchar(
        std::array<wchar_t, 10>&& _var_array_wchar)
{
    m_var_array_wchar = std::move(_var_array_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_array_wchar
 * @return Constant reference to member var_array_wchar
 */
const std::array<wchar_t, 10>& ArrayWChar::var_array_wchar() const
{
    return m_var_array_wchar;
}

/*!
 * @brief This function returns a reference to member var_array_wchar
 * @return Reference to member var_array_wchar
 */
std::array<wchar_t, 10>& ArrayWChar::var_array_wchar()
{
    return m_var_array_wchar;
}


size_t ArrayWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayWChar_max_key_cdr_typesize;
}

bool ArrayWChar::isKeyDefined()
{
    return false;
}

void ArrayWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayString::ArrayString()
{
    // string m_var_array_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayString::~ArrayString()
{
}

ArrayString::ArrayString(
        const ArrayString& x)
{
    m_var_array_string = x.m_var_array_string;
}

ArrayString::ArrayString(
        ArrayString&& x) noexcept 
{
    m_var_array_string = std::move(x.m_var_array_string);
}

ArrayString& ArrayString::operator =(
        const ArrayString& x)
{

    m_var_array_string = x.m_var_array_string;

    return *this;
}

ArrayString& ArrayString::operator =(
        ArrayString&& x) noexcept
{

    m_var_array_string = std::move(x.m_var_array_string);

    return *this;
}

bool ArrayString::operator ==(
        const ArrayString& x) const
{

    return (m_var_array_string == x.m_var_array_string);
}

bool ArrayString::operator !=(
        const ArrayString& x) const
{
    return !(*this == x);
}

size_t ArrayString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayString_max_cdr_typesize;
}

size_t ArrayString::getCdrSerializedSize(
        const ArrayString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_string().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_string().at(a).size() + 1;


    }
    return current_alignment - initial_alignment;
}

void ArrayString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (const auto& str : m_var_array_string)
    {
        scdr << str.c_str();
    }



}

void ArrayString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (auto& str : m_var_array_string)
    {
        dcdr >> str;}



}

/*!
 * @brief This function copies the value in member var_array_string
 * @param _var_array_string New value to be copied in member var_array_string
 */
void ArrayString::var_array_string(
        const std::array<std::string, 10>& _var_array_string)
{
    m_var_array_string = _var_array_string;
}

/*!
 * @brief This function moves the value in member var_array_string
 * @param _var_array_string New value to be moved in member var_array_string
 */
void ArrayString::var_array_string(
        std::array<std::string, 10>&& _var_array_string)
{
    m_var_array_string = std::move(_var_array_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_string
 * @return Constant reference to member var_array_string
 */
const std::array<std::string, 10>& ArrayString::var_array_string() const
{
    return m_var_array_string;
}

/*!
 * @brief This function returns a reference to member var_array_string
 * @return Reference to member var_array_string
 */
std::array<std::string, 10>& ArrayString::var_array_string()
{
    return m_var_array_string;
}


size_t ArrayString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayString_max_key_cdr_typesize;
}

bool ArrayString::isKeyDefined()
{
    return false;
}

void ArrayString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayWString::ArrayWString()
{
    // wstring m_var_array_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayWString::~ArrayWString()
{
}

ArrayWString::ArrayWString(
        const ArrayWString& x)
{
    m_var_array_wstring = x.m_var_array_wstring;
}

ArrayWString::ArrayWString(
        ArrayWString&& x) noexcept 
{
    m_var_array_wstring = std::move(x.m_var_array_wstring);
}

ArrayWString& ArrayWString::operator =(
        const ArrayWString& x)
{

    m_var_array_wstring = x.m_var_array_wstring;

    return *this;
}

ArrayWString& ArrayWString::operator =(
        ArrayWString&& x) noexcept
{

    m_var_array_wstring = std::move(x.m_var_array_wstring);

    return *this;
}

bool ArrayWString::operator ==(
        const ArrayWString& x) const
{

    return (m_var_array_wstring == x.m_var_array_wstring);
}

bool ArrayWString::operator !=(
        const ArrayWString& x) const
{
    return !(*this == x);
}

size_t ArrayWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayWString_max_cdr_typesize;
}

size_t ArrayWString::getCdrSerializedSize(
        const ArrayWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_wstring().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_wstring().at(a).size() * 4);


    }
    return current_alignment - initial_alignment;
}

void ArrayWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_wstring;

}

void ArrayWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_wstring;

}

/*!
 * @brief This function copies the value in member var_array_wstring
 * @param _var_array_wstring New value to be copied in member var_array_wstring
 */
void ArrayWString::var_array_wstring(
        const std::array<std::wstring, 10>& _var_array_wstring)
{
    m_var_array_wstring = _var_array_wstring;
}

/*!
 * @brief This function moves the value in member var_array_wstring
 * @param _var_array_wstring New value to be moved in member var_array_wstring
 */
void ArrayWString::var_array_wstring(
        std::array<std::wstring, 10>&& _var_array_wstring)
{
    m_var_array_wstring = std::move(_var_array_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_wstring
 * @return Constant reference to member var_array_wstring
 */
const std::array<std::wstring, 10>& ArrayWString::var_array_wstring() const
{
    return m_var_array_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_wstring
 * @return Reference to member var_array_wstring
 */
std::array<std::wstring, 10>& ArrayWString::var_array_wstring()
{
    return m_var_array_wstring;
}


size_t ArrayWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayWString_max_key_cdr_typesize;
}

bool ArrayWString::isKeyDefined()
{
    return false;
}

void ArrayWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayBoundedString::ArrayBoundedString()
{
    // Inner_alias_bounded_string_helper m_var_array_bounded_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayBoundedString::~ArrayBoundedString()
{
}

ArrayBoundedString::ArrayBoundedString(
        const ArrayBoundedString& x)
{
    m_var_array_bounded_string = x.m_var_array_bounded_string;
}

ArrayBoundedString::ArrayBoundedString(
        ArrayBoundedString&& x) noexcept 
{
    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);
}

ArrayBoundedString& ArrayBoundedString::operator =(
        const ArrayBoundedString& x)
{

    m_var_array_bounded_string = x.m_var_array_bounded_string;

    return *this;
}

ArrayBoundedString& ArrayBoundedString::operator =(
        ArrayBoundedString&& x) noexcept
{

    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);

    return *this;
}

bool ArrayBoundedString::operator ==(
        const ArrayBoundedString& x) const
{

    return (m_var_array_bounded_string == x.m_var_array_bounded_string);
}

bool ArrayBoundedString::operator !=(
        const ArrayBoundedString& x) const
{
    return !(*this == x);
}

size_t ArrayBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoundedString_max_cdr_typesize;
}

size_t ArrayBoundedString::getCdrSerializedSize(
        const ArrayBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_string().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_bounded_string().at(a).size() + 1;


    }
    return current_alignment - initial_alignment;
}

void ArrayBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (const auto& str : m_var_array_bounded_string)
    {
        scdr << str.c_str();
    }



}

void ArrayBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (auto& str : m_var_array_bounded_string)
    {
    {
        std::string aux_str;
        dcdr >> aux_str;
        str = aux_str.c_str();
    }}



}

/*!
 * @brief This function copies the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be copied in member var_array_bounded_string
 */
void ArrayBoundedString::var_array_bounded_string(
        const std::array<Inner_alias_bounded_string_helper, 10>& _var_array_bounded_string)
{
    m_var_array_bounded_string = _var_array_bounded_string;
}

/*!
 * @brief This function moves the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be moved in member var_array_bounded_string
 */
void ArrayBoundedString::var_array_bounded_string(
        std::array<Inner_alias_bounded_string_helper, 10>&& _var_array_bounded_string)
{
    m_var_array_bounded_string = std::move(_var_array_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_string
 * @return Constant reference to member var_array_bounded_string
 */
const std::array<Inner_alias_bounded_string_helper, 10>& ArrayBoundedString::var_array_bounded_string() const
{
    return m_var_array_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_string
 * @return Reference to member var_array_bounded_string
 */
std::array<Inner_alias_bounded_string_helper, 10>& ArrayBoundedString::var_array_bounded_string()
{
    return m_var_array_bounded_string;
}


size_t ArrayBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoundedString_max_key_cdr_typesize;
}

bool ArrayBoundedString::isKeyDefined()
{
    return false;
}

void ArrayBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayBoundedWString::ArrayBoundedWString()
{
    // Inner_alias_bounded_wstring_helper m_var_array_bounded_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayBoundedWString::~ArrayBoundedWString()
{
}

ArrayBoundedWString::ArrayBoundedWString(
        const ArrayBoundedWString& x)
{
    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;
}

ArrayBoundedWString::ArrayBoundedWString(
        ArrayBoundedWString&& x) noexcept 
{
    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);
}

ArrayBoundedWString& ArrayBoundedWString::operator =(
        const ArrayBoundedWString& x)
{

    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;

    return *this;
}

ArrayBoundedWString& ArrayBoundedWString::operator =(
        ArrayBoundedWString&& x) noexcept
{

    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);

    return *this;
}

bool ArrayBoundedWString::operator ==(
        const ArrayBoundedWString& x) const
{

    return (m_var_array_bounded_wstring == x.m_var_array_bounded_wstring);
}

bool ArrayBoundedWString::operator !=(
        const ArrayBoundedWString& x) const
{
    return !(*this == x);
}

size_t ArrayBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoundedWString_max_cdr_typesize;
}

size_t ArrayBoundedWString::getCdrSerializedSize(
        const ArrayBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_wstring().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_bounded_wstring().at(a).size() * 4);


    }
    return current_alignment - initial_alignment;
}

void ArrayBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_bounded_wstring;

}

void ArrayBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_bounded_wstring;

}

/*!
 * @brief This function copies the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be copied in member var_array_bounded_wstring
 */
void ArrayBoundedWString::var_array_bounded_wstring(
        const std::array<Inner_alias_bounded_wstring_helper, 10>& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = _var_array_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be moved in member var_array_bounded_wstring
 */
void ArrayBoundedWString::var_array_bounded_wstring(
        std::array<Inner_alias_bounded_wstring_helper, 10>&& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = std::move(_var_array_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_wstring
 * @return Constant reference to member var_array_bounded_wstring
 */
const std::array<Inner_alias_bounded_wstring_helper, 10>& ArrayBoundedWString::var_array_bounded_wstring() const
{
    return m_var_array_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_wstring
 * @return Reference to member var_array_bounded_wstring
 */
std::array<Inner_alias_bounded_wstring_helper, 10>& ArrayBoundedWString::var_array_bounded_wstring()
{
    return m_var_array_bounded_wstring;
}


size_t ArrayBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBoundedWString_max_key_cdr_typesize;
}

bool ArrayBoundedWString::isKeyDefined()
{
    return false;
}

void ArrayBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayEnum::ArrayEnum()
{
    // InnerEnumHelper m_var_array_enum
    memset(&m_var_array_enum, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayEnum::~ArrayEnum()
{
}

ArrayEnum::ArrayEnum(
        const ArrayEnum& x)
{
    m_var_array_enum = x.m_var_array_enum;
}

ArrayEnum::ArrayEnum(
        ArrayEnum&& x) noexcept 
{
    m_var_array_enum = std::move(x.m_var_array_enum);
}

ArrayEnum& ArrayEnum::operator =(
        const ArrayEnum& x)
{

    m_var_array_enum = x.m_var_array_enum;

    return *this;
}

ArrayEnum& ArrayEnum::operator =(
        ArrayEnum&& x) noexcept
{

    m_var_array_enum = std::move(x.m_var_array_enum);

    return *this;
}

bool ArrayEnum::operator ==(
        const ArrayEnum& x) const
{

    return (m_var_array_enum == x.m_var_array_enum);
}

bool ArrayEnum::operator !=(
        const ArrayEnum& x) const
{
    return !(*this == x);
}

size_t ArrayEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayEnum_max_cdr_typesize;
}

size_t ArrayEnum::getCdrSerializedSize(
        const ArrayEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_enum.data()), m_var_array_enum.size());
}

void ArrayEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_enum.data()), m_var_array_enum.size());
}

/*!
 * @brief This function copies the value in member var_array_enum
 * @param _var_array_enum New value to be copied in member var_array_enum
 */
void ArrayEnum::var_array_enum(
        const std::array<InnerEnumHelper, 10>& _var_array_enum)
{
    m_var_array_enum = _var_array_enum;
}

/*!
 * @brief This function moves the value in member var_array_enum
 * @param _var_array_enum New value to be moved in member var_array_enum
 */
void ArrayEnum::var_array_enum(
        std::array<InnerEnumHelper, 10>&& _var_array_enum)
{
    m_var_array_enum = std::move(_var_array_enum);
}

/*!
 * @brief This function returns a constant reference to member var_array_enum
 * @return Constant reference to member var_array_enum
 */
const std::array<InnerEnumHelper, 10>& ArrayEnum::var_array_enum() const
{
    return m_var_array_enum;
}

/*!
 * @brief This function returns a reference to member var_array_enum
 * @return Reference to member var_array_enum
 */
std::array<InnerEnumHelper, 10>& ArrayEnum::var_array_enum()
{
    return m_var_array_enum;
}


size_t ArrayEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayEnum_max_key_cdr_typesize;
}

bool ArrayEnum::isKeyDefined()
{
    return false;
}

void ArrayEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayBitMask::ArrayBitMask()
{
    // InnerBitMaskHelper m_var_array_bitmask
    memset(&m_var_array_bitmask, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayBitMask::~ArrayBitMask()
{
}

ArrayBitMask::ArrayBitMask(
        const ArrayBitMask& x)
{
    m_var_array_bitmask = x.m_var_array_bitmask;
}

ArrayBitMask::ArrayBitMask(
        ArrayBitMask&& x) noexcept 
{
    m_var_array_bitmask = std::move(x.m_var_array_bitmask);
}

ArrayBitMask& ArrayBitMask::operator =(
        const ArrayBitMask& x)
{

    m_var_array_bitmask = x.m_var_array_bitmask;

    return *this;
}

ArrayBitMask& ArrayBitMask::operator =(
        ArrayBitMask&& x) noexcept
{

    m_var_array_bitmask = std::move(x.m_var_array_bitmask);

    return *this;
}

bool ArrayBitMask::operator ==(
        const ArrayBitMask& x) const
{

    return (m_var_array_bitmask == x.m_var_array_bitmask);
}

bool ArrayBitMask::operator !=(
        const ArrayBitMask& x) const
{
    return !(*this == x);
}

size_t ArrayBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBitMask_max_cdr_typesize;
}

size_t ArrayBitMask::getCdrSerializedSize(
        const ArrayBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_bitmask.data()), m_var_array_bitmask.size());
}

void ArrayBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_bitmask.data()), m_var_array_bitmask.size());}

/*!
 * @brief This function copies the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be copied in member var_array_bitmask
 */
void ArrayBitMask::var_array_bitmask(
        const std::array<InnerBitMaskHelper, 10>& _var_array_bitmask)
{
    m_var_array_bitmask = _var_array_bitmask;
}

/*!
 * @brief This function moves the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be moved in member var_array_bitmask
 */
void ArrayBitMask::var_array_bitmask(
        std::array<InnerBitMaskHelper, 10>&& _var_array_bitmask)
{
    m_var_array_bitmask = std::move(_var_array_bitmask);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitmask
 * @return Constant reference to member var_array_bitmask
 */
const std::array<InnerBitMaskHelper, 10>& ArrayBitMask::var_array_bitmask() const
{
    return m_var_array_bitmask;
}

/*!
 * @brief This function returns a reference to member var_array_bitmask
 * @return Reference to member var_array_bitmask
 */
std::array<InnerBitMaskHelper, 10>& ArrayBitMask::var_array_bitmask()
{
    return m_var_array_bitmask;
}


size_t ArrayBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBitMask_max_key_cdr_typesize;
}

bool ArrayBitMask::isKeyDefined()
{
    return false;
}

void ArrayBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayAlias::ArrayAlias()
{
    // InnerAliasHelper m_var_array_alias
    memset(&m_var_array_alias, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayAlias::~ArrayAlias()
{
}

ArrayAlias::ArrayAlias(
        const ArrayAlias& x)
{
    m_var_array_alias = x.m_var_array_alias;
}

ArrayAlias::ArrayAlias(
        ArrayAlias&& x) noexcept 
{
    m_var_array_alias = std::move(x.m_var_array_alias);
}

ArrayAlias& ArrayAlias::operator =(
        const ArrayAlias& x)
{

    m_var_array_alias = x.m_var_array_alias;

    return *this;
}

ArrayAlias& ArrayAlias::operator =(
        ArrayAlias&& x) noexcept
{

    m_var_array_alias = std::move(x.m_var_array_alias);

    return *this;
}

bool ArrayAlias::operator ==(
        const ArrayAlias& x) const
{

    return (m_var_array_alias == x.m_var_array_alias);
}

bool ArrayAlias::operator !=(
        const ArrayAlias& x) const
{
    return !(*this == x);
}

size_t ArrayAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayAlias_max_cdr_typesize;
}

size_t ArrayAlias::getCdrSerializedSize(
        const ArrayAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_alias;

}

void ArrayAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_alias;

}

/*!
 * @brief This function copies the value in member var_array_alias
 * @param _var_array_alias New value to be copied in member var_array_alias
 */
void ArrayAlias::var_array_alias(
        const std::array<InnerAliasHelper, 10>& _var_array_alias)
{
    m_var_array_alias = _var_array_alias;
}

/*!
 * @brief This function moves the value in member var_array_alias
 * @param _var_array_alias New value to be moved in member var_array_alias
 */
void ArrayAlias::var_array_alias(
        std::array<InnerAliasHelper, 10>&& _var_array_alias)
{
    m_var_array_alias = std::move(_var_array_alias);
}

/*!
 * @brief This function returns a constant reference to member var_array_alias
 * @return Constant reference to member var_array_alias
 */
const std::array<InnerAliasHelper, 10>& ArrayAlias::var_array_alias() const
{
    return m_var_array_alias;
}

/*!
 * @brief This function returns a reference to member var_array_alias
 * @return Reference to member var_array_alias
 */
std::array<InnerAliasHelper, 10>& ArrayAlias::var_array_alias()
{
    return m_var_array_alias;
}


size_t ArrayAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayAlias_max_key_cdr_typesize;
}

bool ArrayAlias::isKeyDefined()
{
    return false;
}

void ArrayAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayShortArray::ArrayShortArray()
{
    // short m_var_array_short_array
    memset(&m_var_array_short_array, 0, (10 * 10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayShortArray::~ArrayShortArray()
{
}

ArrayShortArray::ArrayShortArray(
        const ArrayShortArray& x)
{
    m_var_array_short_array = x.m_var_array_short_array;
}

ArrayShortArray::ArrayShortArray(
        ArrayShortArray&& x) noexcept 
{
    m_var_array_short_array = std::move(x.m_var_array_short_array);
}

ArrayShortArray& ArrayShortArray::operator =(
        const ArrayShortArray& x)
{

    m_var_array_short_array = x.m_var_array_short_array;

    return *this;
}

ArrayShortArray& ArrayShortArray::operator =(
        ArrayShortArray&& x) noexcept
{

    m_var_array_short_array = std::move(x.m_var_array_short_array);

    return *this;
}

bool ArrayShortArray::operator ==(
        const ArrayShortArray& x) const
{

    return (m_var_array_short_array == x.m_var_array_short_array);
}

bool ArrayShortArray::operator !=(
        const ArrayShortArray& x) const
{
    return !(*this == x);
}

size_t ArrayShortArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayShortArray_max_cdr_typesize;
}

size_t ArrayShortArray::getCdrSerializedSize(
        const ArrayShortArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayShortArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_short_array.size(); ++b)
    {
        scdr << m_var_array_short_array[b];
    }    

}

void ArrayShortArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t d = 0; d < m_var_array_short_array.size(); ++d)
    {
        dcdr >> m_var_array_short_array[d];
    }

}

/*!
 * @brief This function copies the value in member var_array_short_array
 * @param _var_array_short_array New value to be copied in member var_array_short_array
 */
void ArrayShortArray::var_array_short_array(
        const std::array<std::array<int16_t, 10>, 10>& _var_array_short_array)
{
    m_var_array_short_array = _var_array_short_array;
}

/*!
 * @brief This function moves the value in member var_array_short_array
 * @param _var_array_short_array New value to be moved in member var_array_short_array
 */
void ArrayShortArray::var_array_short_array(
        std::array<std::array<int16_t, 10>, 10>&& _var_array_short_array)
{
    m_var_array_short_array = std::move(_var_array_short_array);
}

/*!
 * @brief This function returns a constant reference to member var_array_short_array
 * @return Constant reference to member var_array_short_array
 */
const std::array<std::array<int16_t, 10>, 10>& ArrayShortArray::var_array_short_array() const
{
    return m_var_array_short_array;
}

/*!
 * @brief This function returns a reference to member var_array_short_array
 * @return Reference to member var_array_short_array
 */
std::array<std::array<int16_t, 10>, 10>& ArrayShortArray::var_array_short_array()
{
    return m_var_array_short_array;
}


size_t ArrayShortArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayShortArray_max_key_cdr_typesize;
}

bool ArrayShortArray::isKeyDefined()
{
    return false;
}

void ArrayShortArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySequence::ArraySequence()
{
    // sequence<long> m_var_array_sequence


    // Just to register all known types
    registerarraysTypes();
}

ArraySequence::~ArraySequence()
{
}

ArraySequence::ArraySequence(
        const ArraySequence& x)
{
    m_var_array_sequence = x.m_var_array_sequence;
}

ArraySequence::ArraySequence(
        ArraySequence&& x) noexcept 
{
    m_var_array_sequence = std::move(x.m_var_array_sequence);
}

ArraySequence& ArraySequence::operator =(
        const ArraySequence& x)
{

    m_var_array_sequence = x.m_var_array_sequence;

    return *this;
}

ArraySequence& ArraySequence::operator =(
        ArraySequence&& x) noexcept
{

    m_var_array_sequence = std::move(x.m_var_array_sequence);

    return *this;
}

bool ArraySequence::operator ==(
        const ArraySequence& x) const
{

    return (m_var_array_sequence == x.m_var_array_sequence);
}

bool ArraySequence::operator !=(
        const ArraySequence& x) const
{
    return !(*this == x);
}

size_t ArraySequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySequence_max_cdr_typesize;
}

size_t ArraySequence::getCdrSerializedSize(
        const ArraySequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_sequence().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            if (data.var_array_sequence().at(a).size() > 0)
            {
                current_alignment += (data.var_array_sequence().at(a).size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            }



    }
    return current_alignment - initial_alignment;
}

void ArraySequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_sequence;

}

void ArraySequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_sequence;

}

/*!
 * @brief This function copies the value in member var_array_sequence
 * @param _var_array_sequence New value to be copied in member var_array_sequence
 */
void ArraySequence::var_array_sequence(
        const std::array<std::vector<int32_t>, 10>& _var_array_sequence)
{
    m_var_array_sequence = _var_array_sequence;
}

/*!
 * @brief This function moves the value in member var_array_sequence
 * @param _var_array_sequence New value to be moved in member var_array_sequence
 */
void ArraySequence::var_array_sequence(
        std::array<std::vector<int32_t>, 10>&& _var_array_sequence)
{
    m_var_array_sequence = std::move(_var_array_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_array_sequence
 * @return Constant reference to member var_array_sequence
 */
const std::array<std::vector<int32_t>, 10>& ArraySequence::var_array_sequence() const
{
    return m_var_array_sequence;
}

/*!
 * @brief This function returns a reference to member var_array_sequence
 * @return Reference to member var_array_sequence
 */
std::array<std::vector<int32_t>, 10>& ArraySequence::var_array_sequence()
{
    return m_var_array_sequence;
}


size_t ArraySequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySequence_max_key_cdr_typesize;
}

bool ArraySequence::isKeyDefined()
{
    return false;
}

void ArraySequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMap::ArrayMap()
{
    // map<long, long> m_var_array_map


    // Just to register all known types
    registerarraysTypes();
}

ArrayMap::~ArrayMap()
{
}

ArrayMap::ArrayMap(
        const ArrayMap& x)
{
    m_var_array_map = x.m_var_array_map;
}

ArrayMap::ArrayMap(
        ArrayMap&& x) noexcept 
{
    m_var_array_map = std::move(x.m_var_array_map);
}

ArrayMap& ArrayMap::operator =(
        const ArrayMap& x)
{

    m_var_array_map = x.m_var_array_map;

    return *this;
}

ArrayMap& ArrayMap::operator =(
        ArrayMap&& x) noexcept
{

    m_var_array_map = std::move(x.m_var_array_map);

    return *this;
}

bool ArrayMap::operator ==(
        const ArrayMap& x) const
{

    return (m_var_array_map == x.m_var_array_map);
}

bool ArrayMap::operator !=(
        const ArrayMap& x) const
{
    return !(*this == x);
}

size_t ArrayMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMap_max_cdr_typesize;
}

size_t ArrayMap::getCdrSerializedSize(
        const ArrayMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_map().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            for(auto b : data.var_array_map().at(a))
            {
                (void)b;

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            }

    }
    return current_alignment - initial_alignment;
}

void ArrayMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_map;

}

void ArrayMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_map;

}

/*!
 * @brief This function copies the value in member var_array_map
 * @param _var_array_map New value to be copied in member var_array_map
 */
void ArrayMap::var_array_map(
        const std::array<std::map<int32_t, int32_t>, 10>& _var_array_map)
{
    m_var_array_map = _var_array_map;
}

/*!
 * @brief This function moves the value in member var_array_map
 * @param _var_array_map New value to be moved in member var_array_map
 */
void ArrayMap::var_array_map(
        std::array<std::map<int32_t, int32_t>, 10>&& _var_array_map)
{
    m_var_array_map = std::move(_var_array_map);
}

/*!
 * @brief This function returns a constant reference to member var_array_map
 * @return Constant reference to member var_array_map
 */
const std::array<std::map<int32_t, int32_t>, 10>& ArrayMap::var_array_map() const
{
    return m_var_array_map;
}

/*!
 * @brief This function returns a reference to member var_array_map
 * @return Reference to member var_array_map
 */
std::array<std::map<int32_t, int32_t>, 10>& ArrayMap::var_array_map()
{
    return m_var_array_map;
}


size_t ArrayMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMap_max_key_cdr_typesize;
}

bool ArrayMap::isKeyDefined()
{
    return false;
}

void ArrayMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayUnion::ArrayUnion()
{
    // InnerUnionHelper m_var_array_union


    // Just to register all known types
    registerarraysTypes();
}

ArrayUnion::~ArrayUnion()
{
}

ArrayUnion::ArrayUnion(
        const ArrayUnion& x)
{
    m_var_array_union = x.m_var_array_union;
}

ArrayUnion::ArrayUnion(
        ArrayUnion&& x) noexcept 
{
    m_var_array_union = std::move(x.m_var_array_union);
}

ArrayUnion& ArrayUnion::operator =(
        const ArrayUnion& x)
{

    m_var_array_union = x.m_var_array_union;

    return *this;
}

ArrayUnion& ArrayUnion::operator =(
        ArrayUnion&& x) noexcept
{

    m_var_array_union = std::move(x.m_var_array_union);

    return *this;
}

bool ArrayUnion::operator ==(
        const ArrayUnion& x) const
{

    return (m_var_array_union == x.m_var_array_union);
}

bool ArrayUnion::operator !=(
        const ArrayUnion& x) const
{
    return !(*this == x);
}

size_t ArrayUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayUnion_max_cdr_typesize;
}

size_t ArrayUnion::getCdrSerializedSize(
        const ArrayUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_union().size(); ++a)
    {

            current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_array_union().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArrayUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_union;

}

void ArrayUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_union;

}

/*!
 * @brief This function copies the value in member var_array_union
 * @param _var_array_union New value to be copied in member var_array_union
 */
void ArrayUnion::var_array_union(
        const std::array<InnerUnionHelper, 10>& _var_array_union)
{
    m_var_array_union = _var_array_union;
}

/*!
 * @brief This function moves the value in member var_array_union
 * @param _var_array_union New value to be moved in member var_array_union
 */
void ArrayUnion::var_array_union(
        std::array<InnerUnionHelper, 10>&& _var_array_union)
{
    m_var_array_union = std::move(_var_array_union);
}

/*!
 * @brief This function returns a constant reference to member var_array_union
 * @return Constant reference to member var_array_union
 */
const std::array<InnerUnionHelper, 10>& ArrayUnion::var_array_union() const
{
    return m_var_array_union;
}

/*!
 * @brief This function returns a reference to member var_array_union
 * @return Reference to member var_array_union
 */
std::array<InnerUnionHelper, 10>& ArrayUnion::var_array_union()
{
    return m_var_array_union;
}


size_t ArrayUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayUnion_max_key_cdr_typesize;
}

bool ArrayUnion::isKeyDefined()
{
    return false;
}

void ArrayUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayStructure::ArrayStructure()
{
    // InnerStructureHelper m_var_array_structure


    // Just to register all known types
    registerarraysTypes();
}

ArrayStructure::~ArrayStructure()
{
}

ArrayStructure::ArrayStructure(
        const ArrayStructure& x)
{
    m_var_array_structure = x.m_var_array_structure;
}

ArrayStructure::ArrayStructure(
        ArrayStructure&& x) noexcept 
{
    m_var_array_structure = std::move(x.m_var_array_structure);
}

ArrayStructure& ArrayStructure::operator =(
        const ArrayStructure& x)
{

    m_var_array_structure = x.m_var_array_structure;

    return *this;
}

ArrayStructure& ArrayStructure::operator =(
        ArrayStructure&& x) noexcept
{

    m_var_array_structure = std::move(x.m_var_array_structure);

    return *this;
}

bool ArrayStructure::operator ==(
        const ArrayStructure& x) const
{

    return (m_var_array_structure == x.m_var_array_structure);
}

bool ArrayStructure::operator !=(
        const ArrayStructure& x) const
{
    return !(*this == x);
}

size_t ArrayStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStructure_max_cdr_typesize;
}

size_t ArrayStructure::getCdrSerializedSize(
        const ArrayStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_structure().size(); ++a)
    {

            current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_array_structure().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArrayStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_structure;

}

void ArrayStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_structure;

}

/*!
 * @brief This function copies the value in member var_array_structure
 * @param _var_array_structure New value to be copied in member var_array_structure
 */
void ArrayStructure::var_array_structure(
        const std::array<InnerStructureHelper, 10>& _var_array_structure)
{
    m_var_array_structure = _var_array_structure;
}

/*!
 * @brief This function moves the value in member var_array_structure
 * @param _var_array_structure New value to be moved in member var_array_structure
 */
void ArrayStructure::var_array_structure(
        std::array<InnerStructureHelper, 10>&& _var_array_structure)
{
    m_var_array_structure = std::move(_var_array_structure);
}

/*!
 * @brief This function returns a constant reference to member var_array_structure
 * @return Constant reference to member var_array_structure
 */
const std::array<InnerStructureHelper, 10>& ArrayStructure::var_array_structure() const
{
    return m_var_array_structure;
}

/*!
 * @brief This function returns a reference to member var_array_structure
 * @return Reference to member var_array_structure
 */
std::array<InnerStructureHelper, 10>& ArrayStructure::var_array_structure()
{
    return m_var_array_structure;
}


size_t ArrayStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStructure_max_key_cdr_typesize;
}

bool ArrayStructure::isKeyDefined()
{
    return false;
}

void ArrayStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayBitset::ArrayBitset()
{
    // InnerBitsetHelper m_var_array_bitset


    // Just to register all known types
    registerarraysTypes();
}

ArrayBitset::~ArrayBitset()
{
}

ArrayBitset::ArrayBitset(
        const ArrayBitset& x)
{
    m_var_array_bitset = x.m_var_array_bitset;
}

ArrayBitset::ArrayBitset(
        ArrayBitset&& x) noexcept 
{
    m_var_array_bitset = std::move(x.m_var_array_bitset);
}

ArrayBitset& ArrayBitset::operator =(
        const ArrayBitset& x)
{

    m_var_array_bitset = x.m_var_array_bitset;

    return *this;
}

ArrayBitset& ArrayBitset::operator =(
        ArrayBitset&& x) noexcept
{

    m_var_array_bitset = std::move(x.m_var_array_bitset);

    return *this;
}

bool ArrayBitset::operator ==(
        const ArrayBitset& x) const
{

    return (m_var_array_bitset == x.m_var_array_bitset);
}

bool ArrayBitset::operator !=(
        const ArrayBitset& x) const
{
    return !(*this == x);
}

size_t ArrayBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBitset_max_cdr_typesize;
}

size_t ArrayBitset::getCdrSerializedSize(
        const ArrayBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bitset().size(); ++a)
    {

            current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_array_bitset().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArrayBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_bitset;

}

void ArrayBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_bitset;

}

/*!
 * @brief This function copies the value in member var_array_bitset
 * @param _var_array_bitset New value to be copied in member var_array_bitset
 */
void ArrayBitset::var_array_bitset(
        const std::array<InnerBitsetHelper, 10>& _var_array_bitset)
{
    m_var_array_bitset = _var_array_bitset;
}

/*!
 * @brief This function moves the value in member var_array_bitset
 * @param _var_array_bitset New value to be moved in member var_array_bitset
 */
void ArrayBitset::var_array_bitset(
        std::array<InnerBitsetHelper, 10>&& _var_array_bitset)
{
    m_var_array_bitset = std::move(_var_array_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitset
 * @return Constant reference to member var_array_bitset
 */
const std::array<InnerBitsetHelper, 10>& ArrayBitset::var_array_bitset() const
{
    return m_var_array_bitset;
}

/*!
 * @brief This function returns a reference to member var_array_bitset
 * @return Reference to member var_array_bitset
 */
std::array<InnerBitsetHelper, 10>& ArrayBitset::var_array_bitset()
{
    return m_var_array_bitset;
}


size_t ArrayBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBitset_max_key_cdr_typesize;
}

bool ArrayBitset::isKeyDefined()
{
    return false;
}

void ArrayBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionShort::ArrayMultiDimensionShort()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (10 * 10 * 10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionShort::~ArrayMultiDimensionShort()
{
}

ArrayMultiDimensionShort::ArrayMultiDimensionShort(
        const ArrayMultiDimensionShort& x)
{
    m_var_array_short = x.m_var_array_short;
}

ArrayMultiDimensionShort::ArrayMultiDimensionShort(
        ArrayMultiDimensionShort&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

ArrayMultiDimensionShort& ArrayMultiDimensionShort::operator =(
        const ArrayMultiDimensionShort& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

ArrayMultiDimensionShort& ArrayMultiDimensionShort::operator =(
        ArrayMultiDimensionShort&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool ArrayMultiDimensionShort::operator ==(
        const ArrayMultiDimensionShort& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool ArrayMultiDimensionShort::operator !=(
        const ArrayMultiDimensionShort& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionShort_max_cdr_typesize;
}

size_t ArrayMultiDimensionShort::getCdrSerializedSize(
        const ArrayMultiDimensionShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_short.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_short[b].size(); ++c)
        {
            scdr << m_var_array_short[b][c];
        }    

    }    

}

void ArrayMultiDimensionShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_short.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_short[e].size(); ++f)
        {
            dcdr >> m_var_array_short[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void ArrayMultiDimensionShort::var_array_short(
        const std::array<std::array<std::array<int16_t, 10>, 10>, 10>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void ArrayMultiDimensionShort::var_array_short(
        std::array<std::array<std::array<int16_t, 10>, 10>, 10>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<std::array<std::array<int16_t, 10>, 10>, 10>& ArrayMultiDimensionShort::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<std::array<std::array<int16_t, 10>, 10>, 10>& ArrayMultiDimensionShort::var_array_short()
{
    return m_var_array_short;
}


size_t ArrayMultiDimensionShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionShort_max_key_cdr_typesize;
}

bool ArrayMultiDimensionShort::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionUShort::ArrayMultiDimensionUShort()
{
    // unsigned short m_var_array_ushort
    memset(&m_var_array_ushort, 0, (10 * 10 * 10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionUShort::~ArrayMultiDimensionUShort()
{
}

ArrayMultiDimensionUShort::ArrayMultiDimensionUShort(
        const ArrayMultiDimensionUShort& x)
{
    m_var_array_ushort = x.m_var_array_ushort;
}

ArrayMultiDimensionUShort::ArrayMultiDimensionUShort(
        ArrayMultiDimensionUShort&& x) noexcept 
{
    m_var_array_ushort = std::move(x.m_var_array_ushort);
}

ArrayMultiDimensionUShort& ArrayMultiDimensionUShort::operator =(
        const ArrayMultiDimensionUShort& x)
{

    m_var_array_ushort = x.m_var_array_ushort;

    return *this;
}

ArrayMultiDimensionUShort& ArrayMultiDimensionUShort::operator =(
        ArrayMultiDimensionUShort&& x) noexcept
{

    m_var_array_ushort = std::move(x.m_var_array_ushort);

    return *this;
}

bool ArrayMultiDimensionUShort::operator ==(
        const ArrayMultiDimensionUShort& x) const
{

    return (m_var_array_ushort == x.m_var_array_ushort);
}

bool ArrayMultiDimensionUShort::operator !=(
        const ArrayMultiDimensionUShort& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionUShort_max_cdr_typesize;
}

size_t ArrayMultiDimensionUShort::getCdrSerializedSize(
        const ArrayMultiDimensionUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ushort.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ushort[b].size(); ++c)
        {
            scdr << m_var_array_ushort[b][c];
        }    

    }    

}

void ArrayMultiDimensionUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ushort.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ushort[e].size(); ++f)
        {
            dcdr >> m_var_array_ushort[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ushort
 * @param _var_array_ushort New value to be copied in member var_array_ushort
 */
void ArrayMultiDimensionUShort::var_array_ushort(
        const std::array<std::array<std::array<uint16_t, 10>, 10>, 10>& _var_array_ushort)
{
    m_var_array_ushort = _var_array_ushort;
}

/*!
 * @brief This function moves the value in member var_array_ushort
 * @param _var_array_ushort New value to be moved in member var_array_ushort
 */
void ArrayMultiDimensionUShort::var_array_ushort(
        std::array<std::array<std::array<uint16_t, 10>, 10>, 10>&& _var_array_ushort)
{
    m_var_array_ushort = std::move(_var_array_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_array_ushort
 * @return Constant reference to member var_array_ushort
 */
const std::array<std::array<std::array<uint16_t, 10>, 10>, 10>& ArrayMultiDimensionUShort::var_array_ushort() const
{
    return m_var_array_ushort;
}

/*!
 * @brief This function returns a reference to member var_array_ushort
 * @return Reference to member var_array_ushort
 */
std::array<std::array<std::array<uint16_t, 10>, 10>, 10>& ArrayMultiDimensionUShort::var_array_ushort()
{
    return m_var_array_ushort;
}


size_t ArrayMultiDimensionUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionUShort_max_key_cdr_typesize;
}

bool ArrayMultiDimensionUShort::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLong::ArrayMultiDimensionLong()
{
    // long m_var_array_long
    memset(&m_var_array_long, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLong::~ArrayMultiDimensionLong()
{
}

ArrayMultiDimensionLong::ArrayMultiDimensionLong(
        const ArrayMultiDimensionLong& x)
{
    m_var_array_long = x.m_var_array_long;
}

ArrayMultiDimensionLong::ArrayMultiDimensionLong(
        ArrayMultiDimensionLong&& x) noexcept 
{
    m_var_array_long = std::move(x.m_var_array_long);
}

ArrayMultiDimensionLong& ArrayMultiDimensionLong::operator =(
        const ArrayMultiDimensionLong& x)
{

    m_var_array_long = x.m_var_array_long;

    return *this;
}

ArrayMultiDimensionLong& ArrayMultiDimensionLong::operator =(
        ArrayMultiDimensionLong&& x) noexcept
{

    m_var_array_long = std::move(x.m_var_array_long);

    return *this;
}

bool ArrayMultiDimensionLong::operator ==(
        const ArrayMultiDimensionLong& x) const
{

    return (m_var_array_long == x.m_var_array_long);
}

bool ArrayMultiDimensionLong::operator !=(
        const ArrayMultiDimensionLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLong::getCdrSerializedSize(
        const ArrayMultiDimensionLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_long.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_long[b].size(); ++c)
        {
            scdr << m_var_array_long[b][c];
        }    

    }    

}

void ArrayMultiDimensionLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_long.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_long[e].size(); ++f)
        {
            dcdr >> m_var_array_long[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_long
 * @param _var_array_long New value to be copied in member var_array_long
 */
void ArrayMultiDimensionLong::var_array_long(
        const std::array<std::array<std::array<int32_t, 10>, 10>, 10>& _var_array_long)
{
    m_var_array_long = _var_array_long;
}

/*!
 * @brief This function moves the value in member var_array_long
 * @param _var_array_long New value to be moved in member var_array_long
 */
void ArrayMultiDimensionLong::var_array_long(
        std::array<std::array<std::array<int32_t, 10>, 10>, 10>&& _var_array_long)
{
    m_var_array_long = std::move(_var_array_long);
}

/*!
 * @brief This function returns a constant reference to member var_array_long
 * @return Constant reference to member var_array_long
 */
const std::array<std::array<std::array<int32_t, 10>, 10>, 10>& ArrayMultiDimensionLong::var_array_long() const
{
    return m_var_array_long;
}

/*!
 * @brief This function returns a reference to member var_array_long
 * @return Reference to member var_array_long
 */
std::array<std::array<std::array<int32_t, 10>, 10>, 10>& ArrayMultiDimensionLong::var_array_long()
{
    return m_var_array_long;
}


size_t ArrayMultiDimensionLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionULong::ArrayMultiDimensionULong()
{
    // unsigned long m_var_array_ulong
    memset(&m_var_array_ulong, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionULong::~ArrayMultiDimensionULong()
{
}

ArrayMultiDimensionULong::ArrayMultiDimensionULong(
        const ArrayMultiDimensionULong& x)
{
    m_var_array_ulong = x.m_var_array_ulong;
}

ArrayMultiDimensionULong::ArrayMultiDimensionULong(
        ArrayMultiDimensionULong&& x) noexcept 
{
    m_var_array_ulong = std::move(x.m_var_array_ulong);
}

ArrayMultiDimensionULong& ArrayMultiDimensionULong::operator =(
        const ArrayMultiDimensionULong& x)
{

    m_var_array_ulong = x.m_var_array_ulong;

    return *this;
}

ArrayMultiDimensionULong& ArrayMultiDimensionULong::operator =(
        ArrayMultiDimensionULong&& x) noexcept
{

    m_var_array_ulong = std::move(x.m_var_array_ulong);

    return *this;
}

bool ArrayMultiDimensionULong::operator ==(
        const ArrayMultiDimensionULong& x) const
{

    return (m_var_array_ulong == x.m_var_array_ulong);
}

bool ArrayMultiDimensionULong::operator !=(
        const ArrayMultiDimensionULong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionULong_max_cdr_typesize;
}

size_t ArrayMultiDimensionULong::getCdrSerializedSize(
        const ArrayMultiDimensionULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ulong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ulong[b].size(); ++c)
        {
            scdr << m_var_array_ulong[b][c];
        }    

    }    

}

void ArrayMultiDimensionULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ulong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ulong[e].size(); ++f)
        {
            dcdr >> m_var_array_ulong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ulong
 * @param _var_array_ulong New value to be copied in member var_array_ulong
 */
void ArrayMultiDimensionULong::var_array_ulong(
        const std::array<std::array<std::array<uint32_t, 10>, 10>, 10>& _var_array_ulong)
{
    m_var_array_ulong = _var_array_ulong;
}

/*!
 * @brief This function moves the value in member var_array_ulong
 * @param _var_array_ulong New value to be moved in member var_array_ulong
 */
void ArrayMultiDimensionULong::var_array_ulong(
        std::array<std::array<std::array<uint32_t, 10>, 10>, 10>&& _var_array_ulong)
{
    m_var_array_ulong = std::move(_var_array_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulong
 * @return Constant reference to member var_array_ulong
 */
const std::array<std::array<std::array<uint32_t, 10>, 10>, 10>& ArrayMultiDimensionULong::var_array_ulong() const
{
    return m_var_array_ulong;
}

/*!
 * @brief This function returns a reference to member var_array_ulong
 * @return Reference to member var_array_ulong
 */
std::array<std::array<std::array<uint32_t, 10>, 10>, 10>& ArrayMultiDimensionULong::var_array_ulong()
{
    return m_var_array_ulong;
}


size_t ArrayMultiDimensionULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionULong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionULong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLongLong::ArrayMultiDimensionLongLong()
{
    // long long m_var_array_longlong
    memset(&m_var_array_longlong, 0, (10 * 10 * 10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLongLong::~ArrayMultiDimensionLongLong()
{
}

ArrayMultiDimensionLongLong::ArrayMultiDimensionLongLong(
        const ArrayMultiDimensionLongLong& x)
{
    m_var_array_longlong = x.m_var_array_longlong;
}

ArrayMultiDimensionLongLong::ArrayMultiDimensionLongLong(
        ArrayMultiDimensionLongLong&& x) noexcept 
{
    m_var_array_longlong = std::move(x.m_var_array_longlong);
}

ArrayMultiDimensionLongLong& ArrayMultiDimensionLongLong::operator =(
        const ArrayMultiDimensionLongLong& x)
{

    m_var_array_longlong = x.m_var_array_longlong;

    return *this;
}

ArrayMultiDimensionLongLong& ArrayMultiDimensionLongLong::operator =(
        ArrayMultiDimensionLongLong&& x) noexcept
{

    m_var_array_longlong = std::move(x.m_var_array_longlong);

    return *this;
}

bool ArrayMultiDimensionLongLong::operator ==(
        const ArrayMultiDimensionLongLong& x) const
{

    return (m_var_array_longlong == x.m_var_array_longlong);
}

bool ArrayMultiDimensionLongLong::operator !=(
        const ArrayMultiDimensionLongLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLongLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLongLong::getCdrSerializedSize(
        const ArrayMultiDimensionLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_longlong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_longlong[b].size(); ++c)
        {
            scdr << m_var_array_longlong[b][c];
        }    

    }    

}

void ArrayMultiDimensionLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_longlong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_longlong[e].size(); ++f)
        {
            dcdr >> m_var_array_longlong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_longlong
 * @param _var_array_longlong New value to be copied in member var_array_longlong
 */
void ArrayMultiDimensionLongLong::var_array_longlong(
        const std::array<std::array<std::array<int64_t, 10>, 10>, 10>& _var_array_longlong)
{
    m_var_array_longlong = _var_array_longlong;
}

/*!
 * @brief This function moves the value in member var_array_longlong
 * @param _var_array_longlong New value to be moved in member var_array_longlong
 */
void ArrayMultiDimensionLongLong::var_array_longlong(
        std::array<std::array<std::array<int64_t, 10>, 10>, 10>&& _var_array_longlong)
{
    m_var_array_longlong = std::move(_var_array_longlong);
}

/*!
 * @brief This function returns a constant reference to member var_array_longlong
 * @return Constant reference to member var_array_longlong
 */
const std::array<std::array<std::array<int64_t, 10>, 10>, 10>& ArrayMultiDimensionLongLong::var_array_longlong() const
{
    return m_var_array_longlong;
}

/*!
 * @brief This function returns a reference to member var_array_longlong
 * @return Reference to member var_array_longlong
 */
std::array<std::array<std::array<int64_t, 10>, 10>, 10>& ArrayMultiDimensionLongLong::var_array_longlong()
{
    return m_var_array_longlong;
}


size_t ArrayMultiDimensionLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLongLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLongLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionULongLong::ArrayMultiDimensionULongLong()
{
    // unsigned long long m_var_array_ulonglong
    memset(&m_var_array_ulonglong, 0, (10 * 10 * 10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionULongLong::~ArrayMultiDimensionULongLong()
{
}

ArrayMultiDimensionULongLong::ArrayMultiDimensionULongLong(
        const ArrayMultiDimensionULongLong& x)
{
    m_var_array_ulonglong = x.m_var_array_ulonglong;
}

ArrayMultiDimensionULongLong::ArrayMultiDimensionULongLong(
        ArrayMultiDimensionULongLong&& x) noexcept 
{
    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);
}

ArrayMultiDimensionULongLong& ArrayMultiDimensionULongLong::operator =(
        const ArrayMultiDimensionULongLong& x)
{

    m_var_array_ulonglong = x.m_var_array_ulonglong;

    return *this;
}

ArrayMultiDimensionULongLong& ArrayMultiDimensionULongLong::operator =(
        ArrayMultiDimensionULongLong&& x) noexcept
{

    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);

    return *this;
}

bool ArrayMultiDimensionULongLong::operator ==(
        const ArrayMultiDimensionULongLong& x) const
{

    return (m_var_array_ulonglong == x.m_var_array_ulonglong);
}

bool ArrayMultiDimensionULongLong::operator !=(
        const ArrayMultiDimensionULongLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionULongLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionULongLong::getCdrSerializedSize(
        const ArrayMultiDimensionULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ulonglong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ulonglong[b].size(); ++c)
        {
            scdr << m_var_array_ulonglong[b][c];
        }    

    }    

}

void ArrayMultiDimensionULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ulonglong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ulonglong[e].size(); ++f)
        {
            dcdr >> m_var_array_ulonglong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be copied in member var_array_ulonglong
 */
void ArrayMultiDimensionULongLong::var_array_ulonglong(
        const std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& _var_array_ulonglong)
{
    m_var_array_ulonglong = _var_array_ulonglong;
}

/*!
 * @brief This function moves the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be moved in member var_array_ulonglong
 */
void ArrayMultiDimensionULongLong::var_array_ulonglong(
        std::array<std::array<std::array<uint64_t, 10>, 10>, 10>&& _var_array_ulonglong)
{
    m_var_array_ulonglong = std::move(_var_array_ulonglong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulonglong
 * @return Constant reference to member var_array_ulonglong
 */
const std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& ArrayMultiDimensionULongLong::var_array_ulonglong() const
{
    return m_var_array_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_array_ulonglong
 * @return Reference to member var_array_ulonglong
 */
std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& ArrayMultiDimensionULongLong::var_array_ulonglong()
{
    return m_var_array_ulonglong;
}


size_t ArrayMultiDimensionULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionULongLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionULongLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionFloat::ArrayMultiDimensionFloat()
{
    // float m_var_array_float
    memset(&m_var_array_float, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionFloat::~ArrayMultiDimensionFloat()
{
}

ArrayMultiDimensionFloat::ArrayMultiDimensionFloat(
        const ArrayMultiDimensionFloat& x)
{
    m_var_array_float = x.m_var_array_float;
}

ArrayMultiDimensionFloat::ArrayMultiDimensionFloat(
        ArrayMultiDimensionFloat&& x) noexcept 
{
    m_var_array_float = std::move(x.m_var_array_float);
}

ArrayMultiDimensionFloat& ArrayMultiDimensionFloat::operator =(
        const ArrayMultiDimensionFloat& x)
{

    m_var_array_float = x.m_var_array_float;

    return *this;
}

ArrayMultiDimensionFloat& ArrayMultiDimensionFloat::operator =(
        ArrayMultiDimensionFloat&& x) noexcept
{

    m_var_array_float = std::move(x.m_var_array_float);

    return *this;
}

bool ArrayMultiDimensionFloat::operator ==(
        const ArrayMultiDimensionFloat& x) const
{

    return (m_var_array_float == x.m_var_array_float);
}

bool ArrayMultiDimensionFloat::operator !=(
        const ArrayMultiDimensionFloat& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionFloat_max_cdr_typesize;
}

size_t ArrayMultiDimensionFloat::getCdrSerializedSize(
        const ArrayMultiDimensionFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_float.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_float[b].size(); ++c)
        {
            scdr << m_var_array_float[b][c];
        }    

    }    

}

void ArrayMultiDimensionFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_float.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_float[e].size(); ++f)
        {
            dcdr >> m_var_array_float[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_float
 * @param _var_array_float New value to be copied in member var_array_float
 */
void ArrayMultiDimensionFloat::var_array_float(
        const std::array<std::array<std::array<float, 10>, 10>, 10>& _var_array_float)
{
    m_var_array_float = _var_array_float;
}

/*!
 * @brief This function moves the value in member var_array_float
 * @param _var_array_float New value to be moved in member var_array_float
 */
void ArrayMultiDimensionFloat::var_array_float(
        std::array<std::array<std::array<float, 10>, 10>, 10>&& _var_array_float)
{
    m_var_array_float = std::move(_var_array_float);
}

/*!
 * @brief This function returns a constant reference to member var_array_float
 * @return Constant reference to member var_array_float
 */
const std::array<std::array<std::array<float, 10>, 10>, 10>& ArrayMultiDimensionFloat::var_array_float() const
{
    return m_var_array_float;
}

/*!
 * @brief This function returns a reference to member var_array_float
 * @return Reference to member var_array_float
 */
std::array<std::array<std::array<float, 10>, 10>, 10>& ArrayMultiDimensionFloat::var_array_float()
{
    return m_var_array_float;
}


size_t ArrayMultiDimensionFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionFloat_max_key_cdr_typesize;
}

bool ArrayMultiDimensionFloat::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionDouble::ArrayMultiDimensionDouble()
{
    // double m_var_array_double
    memset(&m_var_array_double, 0, (10 * 10 * 10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionDouble::~ArrayMultiDimensionDouble()
{
}

ArrayMultiDimensionDouble::ArrayMultiDimensionDouble(
        const ArrayMultiDimensionDouble& x)
{
    m_var_array_double = x.m_var_array_double;
}

ArrayMultiDimensionDouble::ArrayMultiDimensionDouble(
        ArrayMultiDimensionDouble&& x) noexcept 
{
    m_var_array_double = std::move(x.m_var_array_double);
}

ArrayMultiDimensionDouble& ArrayMultiDimensionDouble::operator =(
        const ArrayMultiDimensionDouble& x)
{

    m_var_array_double = x.m_var_array_double;

    return *this;
}

ArrayMultiDimensionDouble& ArrayMultiDimensionDouble::operator =(
        ArrayMultiDimensionDouble&& x) noexcept
{

    m_var_array_double = std::move(x.m_var_array_double);

    return *this;
}

bool ArrayMultiDimensionDouble::operator ==(
        const ArrayMultiDimensionDouble& x) const
{

    return (m_var_array_double == x.m_var_array_double);
}

bool ArrayMultiDimensionDouble::operator !=(
        const ArrayMultiDimensionDouble& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionDouble_max_cdr_typesize;
}

size_t ArrayMultiDimensionDouble::getCdrSerializedSize(
        const ArrayMultiDimensionDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_double.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_double[b].size(); ++c)
        {
            scdr << m_var_array_double[b][c];
        }    

    }    

}

void ArrayMultiDimensionDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_double.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_double[e].size(); ++f)
        {
            dcdr >> m_var_array_double[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_double
 * @param _var_array_double New value to be copied in member var_array_double
 */
void ArrayMultiDimensionDouble::var_array_double(
        const std::array<std::array<std::array<double, 10>, 10>, 10>& _var_array_double)
{
    m_var_array_double = _var_array_double;
}

/*!
 * @brief This function moves the value in member var_array_double
 * @param _var_array_double New value to be moved in member var_array_double
 */
void ArrayMultiDimensionDouble::var_array_double(
        std::array<std::array<std::array<double, 10>, 10>, 10>&& _var_array_double)
{
    m_var_array_double = std::move(_var_array_double);
}

/*!
 * @brief This function returns a constant reference to member var_array_double
 * @return Constant reference to member var_array_double
 */
const std::array<std::array<std::array<double, 10>, 10>, 10>& ArrayMultiDimensionDouble::var_array_double() const
{
    return m_var_array_double;
}

/*!
 * @brief This function returns a reference to member var_array_double
 * @return Reference to member var_array_double
 */
std::array<std::array<std::array<double, 10>, 10>, 10>& ArrayMultiDimensionDouble::var_array_double()
{
    return m_var_array_double;
}


size_t ArrayMultiDimensionDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionDouble_max_key_cdr_typesize;
}

bool ArrayMultiDimensionDouble::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLongDouble::ArrayMultiDimensionLongDouble()
{
    // long double m_var_array_longdouble
    memset(&m_var_array_longdouble, 0, (10 * 10 * 10) * 16);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLongDouble::~ArrayMultiDimensionLongDouble()
{
}

ArrayMultiDimensionLongDouble::ArrayMultiDimensionLongDouble(
        const ArrayMultiDimensionLongDouble& x)
{
    m_var_array_longdouble = x.m_var_array_longdouble;
}

ArrayMultiDimensionLongDouble::ArrayMultiDimensionLongDouble(
        ArrayMultiDimensionLongDouble&& x) noexcept 
{
    m_var_array_longdouble = std::move(x.m_var_array_longdouble);
}

ArrayMultiDimensionLongDouble& ArrayMultiDimensionLongDouble::operator =(
        const ArrayMultiDimensionLongDouble& x)
{

    m_var_array_longdouble = x.m_var_array_longdouble;

    return *this;
}

ArrayMultiDimensionLongDouble& ArrayMultiDimensionLongDouble::operator =(
        ArrayMultiDimensionLongDouble&& x) noexcept
{

    m_var_array_longdouble = std::move(x.m_var_array_longdouble);

    return *this;
}

bool ArrayMultiDimensionLongDouble::operator ==(
        const ArrayMultiDimensionLongDouble& x) const
{

    return (m_var_array_longdouble == x.m_var_array_longdouble);
}

bool ArrayMultiDimensionLongDouble::operator !=(
        const ArrayMultiDimensionLongDouble& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLongDouble_max_cdr_typesize;
}

size_t ArrayMultiDimensionLongDouble::getCdrSerializedSize(
        const ArrayMultiDimensionLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 16) + eprosima::fastcdr::Cdr::alignment(current_alignment, 16);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_longdouble.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_longdouble[b].size(); ++c)
        {
            scdr << m_var_array_longdouble[b][c];
        }    

    }    

}

void ArrayMultiDimensionLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_longdouble.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_longdouble[e].size(); ++f)
        {
            dcdr >> m_var_array_longdouble[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be copied in member var_array_longdouble
 */
void ArrayMultiDimensionLongDouble::var_array_longdouble(
        const std::array<std::array<std::array<long double, 10>, 10>, 10>& _var_array_longdouble)
{
    m_var_array_longdouble = _var_array_longdouble;
}

/*!
 * @brief This function moves the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be moved in member var_array_longdouble
 */
void ArrayMultiDimensionLongDouble::var_array_longdouble(
        std::array<std::array<std::array<long double, 10>, 10>, 10>&& _var_array_longdouble)
{
    m_var_array_longdouble = std::move(_var_array_longdouble);
}

/*!
 * @brief This function returns a constant reference to member var_array_longdouble
 * @return Constant reference to member var_array_longdouble
 */
const std::array<std::array<std::array<long double, 10>, 10>, 10>& ArrayMultiDimensionLongDouble::var_array_longdouble() const
{
    return m_var_array_longdouble;
}

/*!
 * @brief This function returns a reference to member var_array_longdouble
 * @return Reference to member var_array_longdouble
 */
std::array<std::array<std::array<long double, 10>, 10>, 10>& ArrayMultiDimensionLongDouble::var_array_longdouble()
{
    return m_var_array_longdouble;
}


size_t ArrayMultiDimensionLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLongDouble_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLongDouble::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionBoolean::ArrayMultiDimensionBoolean()
{
    // boolean m_var_array_boolean
    memset(&m_var_array_boolean, 0, (10 * 10 * 10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionBoolean::~ArrayMultiDimensionBoolean()
{
}

ArrayMultiDimensionBoolean::ArrayMultiDimensionBoolean(
        const ArrayMultiDimensionBoolean& x)
{
    m_var_array_boolean = x.m_var_array_boolean;
}

ArrayMultiDimensionBoolean::ArrayMultiDimensionBoolean(
        ArrayMultiDimensionBoolean&& x) noexcept 
{
    m_var_array_boolean = std::move(x.m_var_array_boolean);
}

ArrayMultiDimensionBoolean& ArrayMultiDimensionBoolean::operator =(
        const ArrayMultiDimensionBoolean& x)
{

    m_var_array_boolean = x.m_var_array_boolean;

    return *this;
}

ArrayMultiDimensionBoolean& ArrayMultiDimensionBoolean::operator =(
        ArrayMultiDimensionBoolean&& x) noexcept
{

    m_var_array_boolean = std::move(x.m_var_array_boolean);

    return *this;
}

bool ArrayMultiDimensionBoolean::operator ==(
        const ArrayMultiDimensionBoolean& x) const
{

    return (m_var_array_boolean == x.m_var_array_boolean);
}

bool ArrayMultiDimensionBoolean::operator !=(
        const ArrayMultiDimensionBoolean& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoolean_max_cdr_typesize;
}

size_t ArrayMultiDimensionBoolean::getCdrSerializedSize(
        const ArrayMultiDimensionBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_boolean.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_boolean[b].size(); ++c)
        {
            scdr << m_var_array_boolean[b][c];
        }    

    }    

}

void ArrayMultiDimensionBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_boolean.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_boolean[e].size(); ++f)
        {
            dcdr >> m_var_array_boolean[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_boolean
 * @param _var_array_boolean New value to be copied in member var_array_boolean
 */
void ArrayMultiDimensionBoolean::var_array_boolean(
        const std::array<std::array<std::array<bool, 10>, 10>, 10>& _var_array_boolean)
{
    m_var_array_boolean = _var_array_boolean;
}

/*!
 * @brief This function moves the value in member var_array_boolean
 * @param _var_array_boolean New value to be moved in member var_array_boolean
 */
void ArrayMultiDimensionBoolean::var_array_boolean(
        std::array<std::array<std::array<bool, 10>, 10>, 10>&& _var_array_boolean)
{
    m_var_array_boolean = std::move(_var_array_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_array_boolean
 * @return Constant reference to member var_array_boolean
 */
const std::array<std::array<std::array<bool, 10>, 10>, 10>& ArrayMultiDimensionBoolean::var_array_boolean() const
{
    return m_var_array_boolean;
}

/*!
 * @brief This function returns a reference to member var_array_boolean
 * @return Reference to member var_array_boolean
 */
std::array<std::array<std::array<bool, 10>, 10>, 10>& ArrayMultiDimensionBoolean::var_array_boolean()
{
    return m_var_array_boolean;
}


size_t ArrayMultiDimensionBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoolean_max_key_cdr_typesize;
}

bool ArrayMultiDimensionBoolean::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionOctet::ArrayMultiDimensionOctet()
{
    // octet m_var_array_octet
    memset(&m_var_array_octet, 0, (10 * 10 * 10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionOctet::~ArrayMultiDimensionOctet()
{
}

ArrayMultiDimensionOctet::ArrayMultiDimensionOctet(
        const ArrayMultiDimensionOctet& x)
{
    m_var_array_octet = x.m_var_array_octet;
}

ArrayMultiDimensionOctet::ArrayMultiDimensionOctet(
        ArrayMultiDimensionOctet&& x) noexcept 
{
    m_var_array_octet = std::move(x.m_var_array_octet);
}

ArrayMultiDimensionOctet& ArrayMultiDimensionOctet::operator =(
        const ArrayMultiDimensionOctet& x)
{

    m_var_array_octet = x.m_var_array_octet;

    return *this;
}

ArrayMultiDimensionOctet& ArrayMultiDimensionOctet::operator =(
        ArrayMultiDimensionOctet&& x) noexcept
{

    m_var_array_octet = std::move(x.m_var_array_octet);

    return *this;
}

bool ArrayMultiDimensionOctet::operator ==(
        const ArrayMultiDimensionOctet& x) const
{

    return (m_var_array_octet == x.m_var_array_octet);
}

bool ArrayMultiDimensionOctet::operator !=(
        const ArrayMultiDimensionOctet& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionOctet_max_cdr_typesize;
}

size_t ArrayMultiDimensionOctet::getCdrSerializedSize(
        const ArrayMultiDimensionOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_octet.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_octet[b].size(); ++c)
        {
            scdr << m_var_array_octet[b][c];
        }    

    }    

}

void ArrayMultiDimensionOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_octet.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_octet[e].size(); ++f)
        {
            dcdr >> m_var_array_octet[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_octet
 * @param _var_array_octet New value to be copied in member var_array_octet
 */
void ArrayMultiDimensionOctet::var_array_octet(
        const std::array<std::array<std::array<uint8_t, 10>, 10>, 10>& _var_array_octet)
{
    m_var_array_octet = _var_array_octet;
}

/*!
 * @brief This function moves the value in member var_array_octet
 * @param _var_array_octet New value to be moved in member var_array_octet
 */
void ArrayMultiDimensionOctet::var_array_octet(
        std::array<std::array<std::array<uint8_t, 10>, 10>, 10>&& _var_array_octet)
{
    m_var_array_octet = std::move(_var_array_octet);
}

/*!
 * @brief This function returns a constant reference to member var_array_octet
 * @return Constant reference to member var_array_octet
 */
const std::array<std::array<std::array<uint8_t, 10>, 10>, 10>& ArrayMultiDimensionOctet::var_array_octet() const
{
    return m_var_array_octet;
}

/*!
 * @brief This function returns a reference to member var_array_octet
 * @return Reference to member var_array_octet
 */
std::array<std::array<std::array<uint8_t, 10>, 10>, 10>& ArrayMultiDimensionOctet::var_array_octet()
{
    return m_var_array_octet;
}


size_t ArrayMultiDimensionOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionOctet_max_key_cdr_typesize;
}

bool ArrayMultiDimensionOctet::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionChar::ArrayMultiDimensionChar()
{
    // char m_var_array_char
    memset(&m_var_array_char, 0, (10 * 10 * 10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionChar::~ArrayMultiDimensionChar()
{
}

ArrayMultiDimensionChar::ArrayMultiDimensionChar(
        const ArrayMultiDimensionChar& x)
{
    m_var_array_char = x.m_var_array_char;
}

ArrayMultiDimensionChar::ArrayMultiDimensionChar(
        ArrayMultiDimensionChar&& x) noexcept 
{
    m_var_array_char = std::move(x.m_var_array_char);
}

ArrayMultiDimensionChar& ArrayMultiDimensionChar::operator =(
        const ArrayMultiDimensionChar& x)
{

    m_var_array_char = x.m_var_array_char;

    return *this;
}

ArrayMultiDimensionChar& ArrayMultiDimensionChar::operator =(
        ArrayMultiDimensionChar&& x) noexcept
{

    m_var_array_char = std::move(x.m_var_array_char);

    return *this;
}

bool ArrayMultiDimensionChar::operator ==(
        const ArrayMultiDimensionChar& x) const
{

    return (m_var_array_char == x.m_var_array_char);
}

bool ArrayMultiDimensionChar::operator !=(
        const ArrayMultiDimensionChar& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionChar_max_cdr_typesize;
}

size_t ArrayMultiDimensionChar::getCdrSerializedSize(
        const ArrayMultiDimensionChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_char.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_char[b].size(); ++c)
        {
            scdr << m_var_array_char[b][c];
        }    

    }    

}

void ArrayMultiDimensionChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_char.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_char[e].size(); ++f)
        {
            dcdr >> m_var_array_char[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_char
 * @param _var_array_char New value to be copied in member var_array_char
 */
void ArrayMultiDimensionChar::var_array_char(
        const std::array<std::array<std::array<char, 10>, 10>, 10>& _var_array_char)
{
    m_var_array_char = _var_array_char;
}

/*!
 * @brief This function moves the value in member var_array_char
 * @param _var_array_char New value to be moved in member var_array_char
 */
void ArrayMultiDimensionChar::var_array_char(
        std::array<std::array<std::array<char, 10>, 10>, 10>&& _var_array_char)
{
    m_var_array_char = std::move(_var_array_char);
}

/*!
 * @brief This function returns a constant reference to member var_array_char
 * @return Constant reference to member var_array_char
 */
const std::array<std::array<std::array<char, 10>, 10>, 10>& ArrayMultiDimensionChar::var_array_char() const
{
    return m_var_array_char;
}

/*!
 * @brief This function returns a reference to member var_array_char
 * @return Reference to member var_array_char
 */
std::array<std::array<std::array<char, 10>, 10>, 10>& ArrayMultiDimensionChar::var_array_char()
{
    return m_var_array_char;
}


size_t ArrayMultiDimensionChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionChar_max_key_cdr_typesize;
}

bool ArrayMultiDimensionChar::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionWChar::ArrayMultiDimensionWChar()
{
    // wchar m_var_array_wchar
    memset(&m_var_array_wchar, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionWChar::~ArrayMultiDimensionWChar()
{
}

ArrayMultiDimensionWChar::ArrayMultiDimensionWChar(
        const ArrayMultiDimensionWChar& x)
{
    m_var_array_wchar = x.m_var_array_wchar;
}

ArrayMultiDimensionWChar::ArrayMultiDimensionWChar(
        ArrayMultiDimensionWChar&& x) noexcept 
{
    m_var_array_wchar = std::move(x.m_var_array_wchar);
}

ArrayMultiDimensionWChar& ArrayMultiDimensionWChar::operator =(
        const ArrayMultiDimensionWChar& x)
{

    m_var_array_wchar = x.m_var_array_wchar;

    return *this;
}

ArrayMultiDimensionWChar& ArrayMultiDimensionWChar::operator =(
        ArrayMultiDimensionWChar&& x) noexcept
{

    m_var_array_wchar = std::move(x.m_var_array_wchar);

    return *this;
}

bool ArrayMultiDimensionWChar::operator ==(
        const ArrayMultiDimensionWChar& x) const
{

    return (m_var_array_wchar == x.m_var_array_wchar);
}

bool ArrayMultiDimensionWChar::operator !=(
        const ArrayMultiDimensionWChar& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionWChar_max_cdr_typesize;
}

size_t ArrayMultiDimensionWChar::getCdrSerializedSize(
        const ArrayMultiDimensionWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_wchar.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_wchar[b].size(); ++c)
        {
            scdr << m_var_array_wchar[b][c];
        }    

    }    

}

void ArrayMultiDimensionWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_wchar.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_wchar[e].size(); ++f)
        {
            dcdr >> m_var_array_wchar[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_wchar
 * @param _var_array_wchar New value to be copied in member var_array_wchar
 */
void ArrayMultiDimensionWChar::var_array_wchar(
        const std::array<std::array<std::array<wchar_t, 10>, 10>, 10>& _var_array_wchar)
{
    m_var_array_wchar = _var_array_wchar;
}

/*!
 * @brief This function moves the value in member var_array_wchar
 * @param _var_array_wchar New value to be moved in member var_array_wchar
 */
void ArrayMultiDimensionWChar::var_array_wchar(
        std::array<std::array<std::array<wchar_t, 10>, 10>, 10>&& _var_array_wchar)
{
    m_var_array_wchar = std::move(_var_array_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_array_wchar
 * @return Constant reference to member var_array_wchar
 */
const std::array<std::array<std::array<wchar_t, 10>, 10>, 10>& ArrayMultiDimensionWChar::var_array_wchar() const
{
    return m_var_array_wchar;
}

/*!
 * @brief This function returns a reference to member var_array_wchar
 * @return Reference to member var_array_wchar
 */
std::array<std::array<std::array<wchar_t, 10>, 10>, 10>& ArrayMultiDimensionWChar::var_array_wchar()
{
    return m_var_array_wchar;
}


size_t ArrayMultiDimensionWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionWChar_max_key_cdr_typesize;
}

bool ArrayMultiDimensionWChar::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionString::ArrayMultiDimensionString()
{
    // string m_var_array_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionString::~ArrayMultiDimensionString()
{
}

ArrayMultiDimensionString::ArrayMultiDimensionString(
        const ArrayMultiDimensionString& x)
{
    m_var_array_string = x.m_var_array_string;
}

ArrayMultiDimensionString::ArrayMultiDimensionString(
        ArrayMultiDimensionString&& x) noexcept 
{
    m_var_array_string = std::move(x.m_var_array_string);
}

ArrayMultiDimensionString& ArrayMultiDimensionString::operator =(
        const ArrayMultiDimensionString& x)
{

    m_var_array_string = x.m_var_array_string;

    return *this;
}

ArrayMultiDimensionString& ArrayMultiDimensionString::operator =(
        ArrayMultiDimensionString&& x) noexcept
{

    m_var_array_string = std::move(x.m_var_array_string);

    return *this;
}

bool ArrayMultiDimensionString::operator ==(
        const ArrayMultiDimensionString& x) const
{

    return (m_var_array_string == x.m_var_array_string);
}

bool ArrayMultiDimensionString::operator !=(
        const ArrayMultiDimensionString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionString_max_cdr_typesize;
}

size_t ArrayMultiDimensionString::getCdrSerializedSize(
        const ArrayMultiDimensionString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_string().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_string().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_string().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_string().at(a).at(b).at(c).size() + 1;


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_string.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_string[e].size(); ++f)
        {
            for (const auto& str : m_var_array_string[e][f])
            {
                scdr << str.c_str();
            }
        }

    }




}

void ArrayMultiDimensionString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_string.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_string[h].size(); ++i)
        {
            for (auto& str : m_var_array_string[h][i])
            {
                dcdr >> str;}
        }

    }




}

/*!
 * @brief This function copies the value in member var_array_string
 * @param _var_array_string New value to be copied in member var_array_string
 */
void ArrayMultiDimensionString::var_array_string(
        const std::array<std::array<std::array<std::string, 10>, 10>, 10>& _var_array_string)
{
    m_var_array_string = _var_array_string;
}

/*!
 * @brief This function moves the value in member var_array_string
 * @param _var_array_string New value to be moved in member var_array_string
 */
void ArrayMultiDimensionString::var_array_string(
        std::array<std::array<std::array<std::string, 10>, 10>, 10>&& _var_array_string)
{
    m_var_array_string = std::move(_var_array_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_string
 * @return Constant reference to member var_array_string
 */
const std::array<std::array<std::array<std::string, 10>, 10>, 10>& ArrayMultiDimensionString::var_array_string() const
{
    return m_var_array_string;
}

/*!
 * @brief This function returns a reference to member var_array_string
 * @return Reference to member var_array_string
 */
std::array<std::array<std::array<std::string, 10>, 10>, 10>& ArrayMultiDimensionString::var_array_string()
{
    return m_var_array_string;
}


size_t ArrayMultiDimensionString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionWString::ArrayMultiDimensionWString()
{
    // wstring m_var_array_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionWString::~ArrayMultiDimensionWString()
{
}

ArrayMultiDimensionWString::ArrayMultiDimensionWString(
        const ArrayMultiDimensionWString& x)
{
    m_var_array_wstring = x.m_var_array_wstring;
}

ArrayMultiDimensionWString::ArrayMultiDimensionWString(
        ArrayMultiDimensionWString&& x) noexcept 
{
    m_var_array_wstring = std::move(x.m_var_array_wstring);
}

ArrayMultiDimensionWString& ArrayMultiDimensionWString::operator =(
        const ArrayMultiDimensionWString& x)
{

    m_var_array_wstring = x.m_var_array_wstring;

    return *this;
}

ArrayMultiDimensionWString& ArrayMultiDimensionWString::operator =(
        ArrayMultiDimensionWString&& x) noexcept
{

    m_var_array_wstring = std::move(x.m_var_array_wstring);

    return *this;
}

bool ArrayMultiDimensionWString::operator ==(
        const ArrayMultiDimensionWString& x) const
{

    return (m_var_array_wstring == x.m_var_array_wstring);
}

bool ArrayMultiDimensionWString::operator !=(
        const ArrayMultiDimensionWString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionWString_max_cdr_typesize;
}

size_t ArrayMultiDimensionWString::getCdrSerializedSize(
        const ArrayMultiDimensionWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_wstring().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_wstring().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_wstring().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_wstring().at(a).at(b).at(c).size() * 4);


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_wstring.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_wstring[e].size(); ++f)
        {
            scdr << m_var_array_wstring[e][f];
        }    

    }    

}

void ArrayMultiDimensionWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_wstring.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_wstring[h].size(); ++i)
        {
            dcdr >> m_var_array_wstring[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_wstring
 * @param _var_array_wstring New value to be copied in member var_array_wstring
 */
void ArrayMultiDimensionWString::var_array_wstring(
        const std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& _var_array_wstring)
{
    m_var_array_wstring = _var_array_wstring;
}

/*!
 * @brief This function moves the value in member var_array_wstring
 * @param _var_array_wstring New value to be moved in member var_array_wstring
 */
void ArrayMultiDimensionWString::var_array_wstring(
        std::array<std::array<std::array<std::wstring, 10>, 10>, 10>&& _var_array_wstring)
{
    m_var_array_wstring = std::move(_var_array_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_wstring
 * @return Constant reference to member var_array_wstring
 */
const std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& ArrayMultiDimensionWString::var_array_wstring() const
{
    return m_var_array_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_wstring
 * @return Reference to member var_array_wstring
 */
std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& ArrayMultiDimensionWString::var_array_wstring()
{
    return m_var_array_wstring;
}


size_t ArrayMultiDimensionWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionWString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionWString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionBoundedString::ArrayMultiDimensionBoundedString()
{
    // Inner_alias_bounded_string_helper m_var_array_bounded_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionBoundedString::~ArrayMultiDimensionBoundedString()
{
}

ArrayMultiDimensionBoundedString::ArrayMultiDimensionBoundedString(
        const ArrayMultiDimensionBoundedString& x)
{
    m_var_array_bounded_string = x.m_var_array_bounded_string;
}

ArrayMultiDimensionBoundedString::ArrayMultiDimensionBoundedString(
        ArrayMultiDimensionBoundedString&& x) noexcept 
{
    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);
}

ArrayMultiDimensionBoundedString& ArrayMultiDimensionBoundedString::operator =(
        const ArrayMultiDimensionBoundedString& x)
{

    m_var_array_bounded_string = x.m_var_array_bounded_string;

    return *this;
}

ArrayMultiDimensionBoundedString& ArrayMultiDimensionBoundedString::operator =(
        ArrayMultiDimensionBoundedString&& x) noexcept
{

    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);

    return *this;
}

bool ArrayMultiDimensionBoundedString::operator ==(
        const ArrayMultiDimensionBoundedString& x) const
{

    return (m_var_array_bounded_string == x.m_var_array_bounded_string);
}

bool ArrayMultiDimensionBoundedString::operator !=(
        const ArrayMultiDimensionBoundedString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoundedString_max_cdr_typesize;
}

size_t ArrayMultiDimensionBoundedString::getCdrSerializedSize(
        const ArrayMultiDimensionBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_string().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bounded_string().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bounded_string().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_bounded_string().at(a).at(b).at(c).size() + 1;


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bounded_string.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bounded_string[e].size(); ++f)
        {
            for (const auto& str : m_var_array_bounded_string[e][f])
            {
                scdr << str.c_str();
            }
        }

    }




}

void ArrayMultiDimensionBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bounded_string.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bounded_string[h].size(); ++i)
        {
            for (auto& str : m_var_array_bounded_string[h][i])
            {
            {
                std::string aux_str;
                dcdr >> aux_str;
                str = aux_str.c_str();
            }}
        }

    }




}

/*!
 * @brief This function copies the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be copied in member var_array_bounded_string
 */
void ArrayMultiDimensionBoundedString::var_array_bounded_string(
        const std::array<std::array<std::array<Inner_alias_bounded_string_helper, 10>, 10>, 10>& _var_array_bounded_string)
{
    m_var_array_bounded_string = _var_array_bounded_string;
}

/*!
 * @brief This function moves the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be moved in member var_array_bounded_string
 */
void ArrayMultiDimensionBoundedString::var_array_bounded_string(
        std::array<std::array<std::array<Inner_alias_bounded_string_helper, 10>, 10>, 10>&& _var_array_bounded_string)
{
    m_var_array_bounded_string = std::move(_var_array_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_string
 * @return Constant reference to member var_array_bounded_string
 */
const std::array<std::array<std::array<Inner_alias_bounded_string_helper, 10>, 10>, 10>& ArrayMultiDimensionBoundedString::var_array_bounded_string() const
{
    return m_var_array_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_string
 * @return Reference to member var_array_bounded_string
 */
std::array<std::array<std::array<Inner_alias_bounded_string_helper, 10>, 10>, 10>& ArrayMultiDimensionBoundedString::var_array_bounded_string()
{
    return m_var_array_bounded_string;
}


size_t ArrayMultiDimensionBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoundedString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionBoundedString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionBoundedWString::ArrayMultiDimensionBoundedWString()
{
    // Inner_alias_bounded_wstring_helper m_var_array_bounded_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionBoundedWString::~ArrayMultiDimensionBoundedWString()
{
}

ArrayMultiDimensionBoundedWString::ArrayMultiDimensionBoundedWString(
        const ArrayMultiDimensionBoundedWString& x)
{
    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;
}

ArrayMultiDimensionBoundedWString::ArrayMultiDimensionBoundedWString(
        ArrayMultiDimensionBoundedWString&& x) noexcept 
{
    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);
}

ArrayMultiDimensionBoundedWString& ArrayMultiDimensionBoundedWString::operator =(
        const ArrayMultiDimensionBoundedWString& x)
{

    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;

    return *this;
}

ArrayMultiDimensionBoundedWString& ArrayMultiDimensionBoundedWString::operator =(
        ArrayMultiDimensionBoundedWString&& x) noexcept
{

    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);

    return *this;
}

bool ArrayMultiDimensionBoundedWString::operator ==(
        const ArrayMultiDimensionBoundedWString& x) const
{

    return (m_var_array_bounded_wstring == x.m_var_array_bounded_wstring);
}

bool ArrayMultiDimensionBoundedWString::operator !=(
        const ArrayMultiDimensionBoundedWString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoundedWString_max_cdr_typesize;
}

size_t ArrayMultiDimensionBoundedWString::getCdrSerializedSize(
        const ArrayMultiDimensionBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_wstring().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bounded_wstring().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bounded_wstring().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_bounded_wstring().at(a).at(b).at(c).size() * 4);


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bounded_wstring.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bounded_wstring[e].size(); ++f)
        {
            scdr << m_var_array_bounded_wstring[e][f];
        }    

    }    

}

void ArrayMultiDimensionBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bounded_wstring.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bounded_wstring[h].size(); ++i)
        {
            dcdr >> m_var_array_bounded_wstring[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be copied in member var_array_bounded_wstring
 */
void ArrayMultiDimensionBoundedWString::var_array_bounded_wstring(
        const std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = _var_array_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be moved in member var_array_bounded_wstring
 */
void ArrayMultiDimensionBoundedWString::var_array_bounded_wstring(
        std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>&& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = std::move(_var_array_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_wstring
 * @return Constant reference to member var_array_bounded_wstring
 */
const std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& ArrayMultiDimensionBoundedWString::var_array_bounded_wstring() const
{
    return m_var_array_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_wstring
 * @return Reference to member var_array_bounded_wstring
 */
std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& ArrayMultiDimensionBoundedWString::var_array_bounded_wstring()
{
    return m_var_array_bounded_wstring;
}


size_t ArrayMultiDimensionBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBoundedWString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionBoundedWString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionEnum::ArrayMultiDimensionEnum()
{
    // InnerEnumHelper m_var_array_enum
    memset(&m_var_array_enum, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionEnum::~ArrayMultiDimensionEnum()
{
}

ArrayMultiDimensionEnum::ArrayMultiDimensionEnum(
        const ArrayMultiDimensionEnum& x)
{
    m_var_array_enum = x.m_var_array_enum;
}

ArrayMultiDimensionEnum::ArrayMultiDimensionEnum(
        ArrayMultiDimensionEnum&& x) noexcept 
{
    m_var_array_enum = std::move(x.m_var_array_enum);
}

ArrayMultiDimensionEnum& ArrayMultiDimensionEnum::operator =(
        const ArrayMultiDimensionEnum& x)
{

    m_var_array_enum = x.m_var_array_enum;

    return *this;
}

ArrayMultiDimensionEnum& ArrayMultiDimensionEnum::operator =(
        ArrayMultiDimensionEnum&& x) noexcept
{

    m_var_array_enum = std::move(x.m_var_array_enum);

    return *this;
}

bool ArrayMultiDimensionEnum::operator ==(
        const ArrayMultiDimensionEnum& x) const
{

    return (m_var_array_enum == x.m_var_array_enum);
}

bool ArrayMultiDimensionEnum::operator !=(
        const ArrayMultiDimensionEnum& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionEnum_max_cdr_typesize;
}

size_t ArrayMultiDimensionEnum::getCdrSerializedSize(
        const ArrayMultiDimensionEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_enum.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_enum[b].size(); ++c)
        {
            scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_enum[b][c].data()), m_var_array_enum[b][c].size());
        }    

    }    

}

void ArrayMultiDimensionEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_enum.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_enum[e].size(); ++f)
        {
            dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_enum[e][f].data()), m_var_array_enum[e][f].size());
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_enum
 * @param _var_array_enum New value to be copied in member var_array_enum
 */
void ArrayMultiDimensionEnum::var_array_enum(
        const std::array<std::array<std::array<InnerEnumHelper, 10>, 10>, 10>& _var_array_enum)
{
    m_var_array_enum = _var_array_enum;
}

/*!
 * @brief This function moves the value in member var_array_enum
 * @param _var_array_enum New value to be moved in member var_array_enum
 */
void ArrayMultiDimensionEnum::var_array_enum(
        std::array<std::array<std::array<InnerEnumHelper, 10>, 10>, 10>&& _var_array_enum)
{
    m_var_array_enum = std::move(_var_array_enum);
}

/*!
 * @brief This function returns a constant reference to member var_array_enum
 * @return Constant reference to member var_array_enum
 */
const std::array<std::array<std::array<InnerEnumHelper, 10>, 10>, 10>& ArrayMultiDimensionEnum::var_array_enum() const
{
    return m_var_array_enum;
}

/*!
 * @brief This function returns a reference to member var_array_enum
 * @return Reference to member var_array_enum
 */
std::array<std::array<std::array<InnerEnumHelper, 10>, 10>, 10>& ArrayMultiDimensionEnum::var_array_enum()
{
    return m_var_array_enum;
}


size_t ArrayMultiDimensionEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionEnum_max_key_cdr_typesize;
}

bool ArrayMultiDimensionEnum::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionBitMask::ArrayMultiDimensionBitMask()
{
    // InnerBitMaskHelper m_var_array_bitmask
    memset(&m_var_array_bitmask, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionBitMask::~ArrayMultiDimensionBitMask()
{
}

ArrayMultiDimensionBitMask::ArrayMultiDimensionBitMask(
        const ArrayMultiDimensionBitMask& x)
{
    m_var_array_bitmask = x.m_var_array_bitmask;
}

ArrayMultiDimensionBitMask::ArrayMultiDimensionBitMask(
        ArrayMultiDimensionBitMask&& x) noexcept 
{
    m_var_array_bitmask = std::move(x.m_var_array_bitmask);
}

ArrayMultiDimensionBitMask& ArrayMultiDimensionBitMask::operator =(
        const ArrayMultiDimensionBitMask& x)
{

    m_var_array_bitmask = x.m_var_array_bitmask;

    return *this;
}

ArrayMultiDimensionBitMask& ArrayMultiDimensionBitMask::operator =(
        ArrayMultiDimensionBitMask&& x) noexcept
{

    m_var_array_bitmask = std::move(x.m_var_array_bitmask);

    return *this;
}

bool ArrayMultiDimensionBitMask::operator ==(
        const ArrayMultiDimensionBitMask& x) const
{

    return (m_var_array_bitmask == x.m_var_array_bitmask);
}

bool ArrayMultiDimensionBitMask::operator !=(
        const ArrayMultiDimensionBitMask& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBitMask_max_cdr_typesize;
}

size_t ArrayMultiDimensionBitMask::getCdrSerializedSize(
        const ArrayMultiDimensionBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_bitmask.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_bitmask[b].size(); ++c)
        {
            scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_bitmask[b][c].data()), m_var_array_bitmask[b][c].size());
        }    

    }    

}

void ArrayMultiDimensionBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_bitmask.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bitmask[e].size(); ++f)
        {
            dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_bitmask[e][f].data()), m_var_array_bitmask[e][f].size());
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be copied in member var_array_bitmask
 */
void ArrayMultiDimensionBitMask::var_array_bitmask(
        const std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10>& _var_array_bitmask)
{
    m_var_array_bitmask = _var_array_bitmask;
}

/*!
 * @brief This function moves the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be moved in member var_array_bitmask
 */
void ArrayMultiDimensionBitMask::var_array_bitmask(
        std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10>&& _var_array_bitmask)
{
    m_var_array_bitmask = std::move(_var_array_bitmask);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitmask
 * @return Constant reference to member var_array_bitmask
 */
const std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10>& ArrayMultiDimensionBitMask::var_array_bitmask() const
{
    return m_var_array_bitmask;
}

/*!
 * @brief This function returns a reference to member var_array_bitmask
 * @return Reference to member var_array_bitmask
 */
std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10>& ArrayMultiDimensionBitMask::var_array_bitmask()
{
    return m_var_array_bitmask;
}


size_t ArrayMultiDimensionBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBitMask_max_key_cdr_typesize;
}

bool ArrayMultiDimensionBitMask::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionAlias::ArrayMultiDimensionAlias()
{
    // InnerAliasHelper m_var_array_alias
    memset(&m_var_array_alias, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionAlias::~ArrayMultiDimensionAlias()
{
}

ArrayMultiDimensionAlias::ArrayMultiDimensionAlias(
        const ArrayMultiDimensionAlias& x)
{
    m_var_array_alias = x.m_var_array_alias;
}

ArrayMultiDimensionAlias::ArrayMultiDimensionAlias(
        ArrayMultiDimensionAlias&& x) noexcept 
{
    m_var_array_alias = std::move(x.m_var_array_alias);
}

ArrayMultiDimensionAlias& ArrayMultiDimensionAlias::operator =(
        const ArrayMultiDimensionAlias& x)
{

    m_var_array_alias = x.m_var_array_alias;

    return *this;
}

ArrayMultiDimensionAlias& ArrayMultiDimensionAlias::operator =(
        ArrayMultiDimensionAlias&& x) noexcept
{

    m_var_array_alias = std::move(x.m_var_array_alias);

    return *this;
}

bool ArrayMultiDimensionAlias::operator ==(
        const ArrayMultiDimensionAlias& x) const
{

    return (m_var_array_alias == x.m_var_array_alias);
}

bool ArrayMultiDimensionAlias::operator !=(
        const ArrayMultiDimensionAlias& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionAlias_max_cdr_typesize;
}

size_t ArrayMultiDimensionAlias::getCdrSerializedSize(
        const ArrayMultiDimensionAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_alias.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_alias[b].size(); ++c)
        {
            scdr << m_var_array_alias[b][c];
        }    

    }    

}

void ArrayMultiDimensionAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_alias.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_alias[e].size(); ++f)
        {
            dcdr >> m_var_array_alias[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_alias
 * @param _var_array_alias New value to be copied in member var_array_alias
 */
void ArrayMultiDimensionAlias::var_array_alias(
        const std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& _var_array_alias)
{
    m_var_array_alias = _var_array_alias;
}

/*!
 * @brief This function moves the value in member var_array_alias
 * @param _var_array_alias New value to be moved in member var_array_alias
 */
void ArrayMultiDimensionAlias::var_array_alias(
        std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>&& _var_array_alias)
{
    m_var_array_alias = std::move(_var_array_alias);
}

/*!
 * @brief This function returns a constant reference to member var_array_alias
 * @return Constant reference to member var_array_alias
 */
const std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& ArrayMultiDimensionAlias::var_array_alias() const
{
    return m_var_array_alias;
}

/*!
 * @brief This function returns a reference to member var_array_alias
 * @return Reference to member var_array_alias
 */
std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& ArrayMultiDimensionAlias::var_array_alias()
{
    return m_var_array_alias;
}


size_t ArrayMultiDimensionAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionAlias_max_key_cdr_typesize;
}

bool ArrayMultiDimensionAlias::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionSequence::ArrayMultiDimensionSequence()
{
    // sequence<long> m_var_array_sequence


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionSequence::~ArrayMultiDimensionSequence()
{
}

ArrayMultiDimensionSequence::ArrayMultiDimensionSequence(
        const ArrayMultiDimensionSequence& x)
{
    m_var_array_sequence = x.m_var_array_sequence;
}

ArrayMultiDimensionSequence::ArrayMultiDimensionSequence(
        ArrayMultiDimensionSequence&& x) noexcept 
{
    m_var_array_sequence = std::move(x.m_var_array_sequence);
}

ArrayMultiDimensionSequence& ArrayMultiDimensionSequence::operator =(
        const ArrayMultiDimensionSequence& x)
{

    m_var_array_sequence = x.m_var_array_sequence;

    return *this;
}

ArrayMultiDimensionSequence& ArrayMultiDimensionSequence::operator =(
        ArrayMultiDimensionSequence&& x) noexcept
{

    m_var_array_sequence = std::move(x.m_var_array_sequence);

    return *this;
}

bool ArrayMultiDimensionSequence::operator ==(
        const ArrayMultiDimensionSequence& x) const
{

    return (m_var_array_sequence == x.m_var_array_sequence);
}

bool ArrayMultiDimensionSequence::operator !=(
        const ArrayMultiDimensionSequence& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionSequence_max_cdr_typesize;
}

size_t ArrayMultiDimensionSequence::getCdrSerializedSize(
        const ArrayMultiDimensionSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_sequence().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_sequence().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_sequence().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    if (data.var_array_sequence().at(a).at(b).at(c).size() > 0)
                    {
                        current_alignment += (data.var_array_sequence().at(a).at(b).at(c).size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    }



            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t f = 0; f < m_var_array_sequence.size(); ++f)
    {
        for (uint32_t g = 0; g < m_var_array_sequence[f].size(); ++g)
        {
            scdr << m_var_array_sequence[f][g];
        }    

    }    

}

void ArrayMultiDimensionSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t i = 0; i < m_var_array_sequence.size(); ++i)
    {
        for (uint32_t j = 0; j < m_var_array_sequence[i].size(); ++j)
        {
            dcdr >> m_var_array_sequence[i][j];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_sequence
 * @param _var_array_sequence New value to be copied in member var_array_sequence
 */
void ArrayMultiDimensionSequence::var_array_sequence(
        const std::array<std::array<std::array<std::vector<int32_t>, 10>, 10>, 10>& _var_array_sequence)
{
    m_var_array_sequence = _var_array_sequence;
}

/*!
 * @brief This function moves the value in member var_array_sequence
 * @param _var_array_sequence New value to be moved in member var_array_sequence
 */
void ArrayMultiDimensionSequence::var_array_sequence(
        std::array<std::array<std::array<std::vector<int32_t>, 10>, 10>, 10>&& _var_array_sequence)
{
    m_var_array_sequence = std::move(_var_array_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_array_sequence
 * @return Constant reference to member var_array_sequence
 */
const std::array<std::array<std::array<std::vector<int32_t>, 10>, 10>, 10>& ArrayMultiDimensionSequence::var_array_sequence() const
{
    return m_var_array_sequence;
}

/*!
 * @brief This function returns a reference to member var_array_sequence
 * @return Reference to member var_array_sequence
 */
std::array<std::array<std::array<std::vector<int32_t>, 10>, 10>, 10>& ArrayMultiDimensionSequence::var_array_sequence()
{
    return m_var_array_sequence;
}


size_t ArrayMultiDimensionSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionSequence_max_key_cdr_typesize;
}

bool ArrayMultiDimensionSequence::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionMap::ArrayMultiDimensionMap()
{
    // map<long, long> m_var_array_map


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionMap::~ArrayMultiDimensionMap()
{
}

ArrayMultiDimensionMap::ArrayMultiDimensionMap(
        const ArrayMultiDimensionMap& x)
{
    m_var_array_map = x.m_var_array_map;
}

ArrayMultiDimensionMap::ArrayMultiDimensionMap(
        ArrayMultiDimensionMap&& x) noexcept 
{
    m_var_array_map = std::move(x.m_var_array_map);
}

ArrayMultiDimensionMap& ArrayMultiDimensionMap::operator =(
        const ArrayMultiDimensionMap& x)
{

    m_var_array_map = x.m_var_array_map;

    return *this;
}

ArrayMultiDimensionMap& ArrayMultiDimensionMap::operator =(
        ArrayMultiDimensionMap&& x) noexcept
{

    m_var_array_map = std::move(x.m_var_array_map);

    return *this;
}

bool ArrayMultiDimensionMap::operator ==(
        const ArrayMultiDimensionMap& x) const
{

    return (m_var_array_map == x.m_var_array_map);
}

bool ArrayMultiDimensionMap::operator !=(
        const ArrayMultiDimensionMap& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionMap_max_cdr_typesize;
}

size_t ArrayMultiDimensionMap::getCdrSerializedSize(
        const ArrayMultiDimensionMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_map().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_map().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_map().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    for(auto d : data.var_array_map().at(a).at(b).at(c))
                    {
                        (void)d;

                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    }

            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_map.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_map[e].size(); ++f)
        {
            scdr << m_var_array_map[e][f];
        }    

    }    

}

void ArrayMultiDimensionMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_map.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_map[h].size(); ++i)
        {
            dcdr >> m_var_array_map[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_map
 * @param _var_array_map New value to be copied in member var_array_map
 */
void ArrayMultiDimensionMap::var_array_map(
        const std::array<std::array<std::array<std::map<int32_t, int32_t>, 10>, 10>, 10>& _var_array_map)
{
    m_var_array_map = _var_array_map;
}

/*!
 * @brief This function moves the value in member var_array_map
 * @param _var_array_map New value to be moved in member var_array_map
 */
void ArrayMultiDimensionMap::var_array_map(
        std::array<std::array<std::array<std::map<int32_t, int32_t>, 10>, 10>, 10>&& _var_array_map)
{
    m_var_array_map = std::move(_var_array_map);
}

/*!
 * @brief This function returns a constant reference to member var_array_map
 * @return Constant reference to member var_array_map
 */
const std::array<std::array<std::array<std::map<int32_t, int32_t>, 10>, 10>, 10>& ArrayMultiDimensionMap::var_array_map() const
{
    return m_var_array_map;
}

/*!
 * @brief This function returns a reference to member var_array_map
 * @return Reference to member var_array_map
 */
std::array<std::array<std::array<std::map<int32_t, int32_t>, 10>, 10>, 10>& ArrayMultiDimensionMap::var_array_map()
{
    return m_var_array_map;
}


size_t ArrayMultiDimensionMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionMap_max_key_cdr_typesize;
}

bool ArrayMultiDimensionMap::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionUnion::ArrayMultiDimensionUnion()
{
    // InnerUnionHelper m_var_array_union


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionUnion::~ArrayMultiDimensionUnion()
{
}

ArrayMultiDimensionUnion::ArrayMultiDimensionUnion(
        const ArrayMultiDimensionUnion& x)
{
    m_var_array_union = x.m_var_array_union;
}

ArrayMultiDimensionUnion::ArrayMultiDimensionUnion(
        ArrayMultiDimensionUnion&& x) noexcept 
{
    m_var_array_union = std::move(x.m_var_array_union);
}

ArrayMultiDimensionUnion& ArrayMultiDimensionUnion::operator =(
        const ArrayMultiDimensionUnion& x)
{

    m_var_array_union = x.m_var_array_union;

    return *this;
}

ArrayMultiDimensionUnion& ArrayMultiDimensionUnion::operator =(
        ArrayMultiDimensionUnion&& x) noexcept
{

    m_var_array_union = std::move(x.m_var_array_union);

    return *this;
}

bool ArrayMultiDimensionUnion::operator ==(
        const ArrayMultiDimensionUnion& x) const
{

    return (m_var_array_union == x.m_var_array_union);
}

bool ArrayMultiDimensionUnion::operator !=(
        const ArrayMultiDimensionUnion& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionUnion_max_cdr_typesize;
}

size_t ArrayMultiDimensionUnion::getCdrSerializedSize(
        const ArrayMultiDimensionUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_union().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_union().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_union().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_array_union().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_union.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_union[e].size(); ++f)
        {
            scdr << m_var_array_union[e][f];
        }    

    }    

}

void ArrayMultiDimensionUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_union.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_union[h].size(); ++i)
        {
            dcdr >> m_var_array_union[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_union
 * @param _var_array_union New value to be copied in member var_array_union
 */
void ArrayMultiDimensionUnion::var_array_union(
        const std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& _var_array_union)
{
    m_var_array_union = _var_array_union;
}

/*!
 * @brief This function moves the value in member var_array_union
 * @param _var_array_union New value to be moved in member var_array_union
 */
void ArrayMultiDimensionUnion::var_array_union(
        std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>&& _var_array_union)
{
    m_var_array_union = std::move(_var_array_union);
}

/*!
 * @brief This function returns a constant reference to member var_array_union
 * @return Constant reference to member var_array_union
 */
const std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& ArrayMultiDimensionUnion::var_array_union() const
{
    return m_var_array_union;
}

/*!
 * @brief This function returns a reference to member var_array_union
 * @return Reference to member var_array_union
 */
std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& ArrayMultiDimensionUnion::var_array_union()
{
    return m_var_array_union;
}


size_t ArrayMultiDimensionUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionUnion_max_key_cdr_typesize;
}

bool ArrayMultiDimensionUnion::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionStructure::ArrayMultiDimensionStructure()
{
    // InnerStructureHelper m_var_array_structure


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionStructure::~ArrayMultiDimensionStructure()
{
}

ArrayMultiDimensionStructure::ArrayMultiDimensionStructure(
        const ArrayMultiDimensionStructure& x)
{
    m_var_array_structure = x.m_var_array_structure;
}

ArrayMultiDimensionStructure::ArrayMultiDimensionStructure(
        ArrayMultiDimensionStructure&& x) noexcept 
{
    m_var_array_structure = std::move(x.m_var_array_structure);
}

ArrayMultiDimensionStructure& ArrayMultiDimensionStructure::operator =(
        const ArrayMultiDimensionStructure& x)
{

    m_var_array_structure = x.m_var_array_structure;

    return *this;
}

ArrayMultiDimensionStructure& ArrayMultiDimensionStructure::operator =(
        ArrayMultiDimensionStructure&& x) noexcept
{

    m_var_array_structure = std::move(x.m_var_array_structure);

    return *this;
}

bool ArrayMultiDimensionStructure::operator ==(
        const ArrayMultiDimensionStructure& x) const
{

    return (m_var_array_structure == x.m_var_array_structure);
}

bool ArrayMultiDimensionStructure::operator !=(
        const ArrayMultiDimensionStructure& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionStructure_max_cdr_typesize;
}

size_t ArrayMultiDimensionStructure::getCdrSerializedSize(
        const ArrayMultiDimensionStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_structure().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_structure().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_structure().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_array_structure().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_structure.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_structure[e].size(); ++f)
        {
            scdr << m_var_array_structure[e][f];
        }    

    }    

}

void ArrayMultiDimensionStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_structure.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_structure[h].size(); ++i)
        {
            dcdr >> m_var_array_structure[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_structure
 * @param _var_array_structure New value to be copied in member var_array_structure
 */
void ArrayMultiDimensionStructure::var_array_structure(
        const std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10>& _var_array_structure)
{
    m_var_array_structure = _var_array_structure;
}

/*!
 * @brief This function moves the value in member var_array_structure
 * @param _var_array_structure New value to be moved in member var_array_structure
 */
void ArrayMultiDimensionStructure::var_array_structure(
        std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10>&& _var_array_structure)
{
    m_var_array_structure = std::move(_var_array_structure);
}

/*!
 * @brief This function returns a constant reference to member var_array_structure
 * @return Constant reference to member var_array_structure
 */
const std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10>& ArrayMultiDimensionStructure::var_array_structure() const
{
    return m_var_array_structure;
}

/*!
 * @brief This function returns a reference to member var_array_structure
 * @return Reference to member var_array_structure
 */
std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10>& ArrayMultiDimensionStructure::var_array_structure()
{
    return m_var_array_structure;
}


size_t ArrayMultiDimensionStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionStructure_max_key_cdr_typesize;
}

bool ArrayMultiDimensionStructure::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionBitset::ArrayMultiDimensionBitset()
{
    // InnerBitsetHelper m_var_array_bitset


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionBitset::~ArrayMultiDimensionBitset()
{
}

ArrayMultiDimensionBitset::ArrayMultiDimensionBitset(
        const ArrayMultiDimensionBitset& x)
{
    m_var_array_bitset = x.m_var_array_bitset;
}

ArrayMultiDimensionBitset::ArrayMultiDimensionBitset(
        ArrayMultiDimensionBitset&& x) noexcept 
{
    m_var_array_bitset = std::move(x.m_var_array_bitset);
}

ArrayMultiDimensionBitset& ArrayMultiDimensionBitset::operator =(
        const ArrayMultiDimensionBitset& x)
{

    m_var_array_bitset = x.m_var_array_bitset;

    return *this;
}

ArrayMultiDimensionBitset& ArrayMultiDimensionBitset::operator =(
        ArrayMultiDimensionBitset&& x) noexcept
{

    m_var_array_bitset = std::move(x.m_var_array_bitset);

    return *this;
}

bool ArrayMultiDimensionBitset::operator ==(
        const ArrayMultiDimensionBitset& x) const
{

    return (m_var_array_bitset == x.m_var_array_bitset);
}

bool ArrayMultiDimensionBitset::operator !=(
        const ArrayMultiDimensionBitset& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBitset_max_cdr_typesize;
}

size_t ArrayMultiDimensionBitset::getCdrSerializedSize(
        const ArrayMultiDimensionBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bitset().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bitset().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bitset().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_array_bitset().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bitset.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bitset[e].size(); ++f)
        {
            scdr << m_var_array_bitset[e][f];
        }    

    }    

}

void ArrayMultiDimensionBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bitset.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bitset[h].size(); ++i)
        {
            dcdr >> m_var_array_bitset[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bitset
 * @param _var_array_bitset New value to be copied in member var_array_bitset
 */
void ArrayMultiDimensionBitset::var_array_bitset(
        const std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& _var_array_bitset)
{
    m_var_array_bitset = _var_array_bitset;
}

/*!
 * @brief This function moves the value in member var_array_bitset
 * @param _var_array_bitset New value to be moved in member var_array_bitset
 */
void ArrayMultiDimensionBitset::var_array_bitset(
        std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>&& _var_array_bitset)
{
    m_var_array_bitset = std::move(_var_array_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitset
 * @return Constant reference to member var_array_bitset
 */
const std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& ArrayMultiDimensionBitset::var_array_bitset() const
{
    return m_var_array_bitset;
}

/*!
 * @brief This function returns a reference to member var_array_bitset
 * @return Reference to member var_array_bitset
 */
std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& ArrayMultiDimensionBitset::var_array_bitset()
{
    return m_var_array_bitset;
}


size_t ArrayMultiDimensionBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionBitset_max_key_cdr_typesize;
}

bool ArrayMultiDimensionBitset::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}




ArraySingleDimensionLiteralsShort::ArraySingleDimensionLiteralsShort()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (5) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsShort::~ArraySingleDimensionLiteralsShort()
{
}

ArraySingleDimensionLiteralsShort::ArraySingleDimensionLiteralsShort(
        const ArraySingleDimensionLiteralsShort& x)
{
    m_var_array_short = x.m_var_array_short;
}

ArraySingleDimensionLiteralsShort::ArraySingleDimensionLiteralsShort(
        ArraySingleDimensionLiteralsShort&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

ArraySingleDimensionLiteralsShort& ArraySingleDimensionLiteralsShort::operator =(
        const ArraySingleDimensionLiteralsShort& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

ArraySingleDimensionLiteralsShort& ArraySingleDimensionLiteralsShort::operator =(
        ArraySingleDimensionLiteralsShort&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool ArraySingleDimensionLiteralsShort::operator ==(
        const ArraySingleDimensionLiteralsShort& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool ArraySingleDimensionLiteralsShort::operator !=(
        const ArraySingleDimensionLiteralsShort& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsShort_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsShort::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_short;

}

void ArraySingleDimensionLiteralsShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_short;

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void ArraySingleDimensionLiteralsShort::var_array_short(
        const std::array<int16_t, 5>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void ArraySingleDimensionLiteralsShort::var_array_short(
        std::array<int16_t, 5>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<int16_t, 5>& ArraySingleDimensionLiteralsShort::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<int16_t, 5>& ArraySingleDimensionLiteralsShort::var_array_short()
{
    return m_var_array_short;
}


size_t ArraySingleDimensionLiteralsShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsShort_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsShort::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsUnsignedShort::ArraySingleDimensionLiteralsUnsignedShort()
{
    // unsigned short m_var_array_ushort
    memset(&m_var_array_ushort, 0, (10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsUnsignedShort::~ArraySingleDimensionLiteralsUnsignedShort()
{
}

ArraySingleDimensionLiteralsUnsignedShort::ArraySingleDimensionLiteralsUnsignedShort(
        const ArraySingleDimensionLiteralsUnsignedShort& x)
{
    m_var_array_ushort = x.m_var_array_ushort;
}

ArraySingleDimensionLiteralsUnsignedShort::ArraySingleDimensionLiteralsUnsignedShort(
        ArraySingleDimensionLiteralsUnsignedShort&& x) noexcept 
{
    m_var_array_ushort = std::move(x.m_var_array_ushort);
}

ArraySingleDimensionLiteralsUnsignedShort& ArraySingleDimensionLiteralsUnsignedShort::operator =(
        const ArraySingleDimensionLiteralsUnsignedShort& x)
{

    m_var_array_ushort = x.m_var_array_ushort;

    return *this;
}

ArraySingleDimensionLiteralsUnsignedShort& ArraySingleDimensionLiteralsUnsignedShort::operator =(
        ArraySingleDimensionLiteralsUnsignedShort&& x) noexcept
{

    m_var_array_ushort = std::move(x.m_var_array_ushort);

    return *this;
}

bool ArraySingleDimensionLiteralsUnsignedShort::operator ==(
        const ArraySingleDimensionLiteralsUnsignedShort& x) const
{

    return (m_var_array_ushort == x.m_var_array_ushort);
}

bool ArraySingleDimensionLiteralsUnsignedShort::operator !=(
        const ArraySingleDimensionLiteralsUnsignedShort& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsUnsignedShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedShort_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsUnsignedShort::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsUnsignedShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsUnsignedShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ushort;

}

void ArraySingleDimensionLiteralsUnsignedShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ushort;

}

/*!
 * @brief This function copies the value in member var_array_ushort
 * @param _var_array_ushort New value to be copied in member var_array_ushort
 */
void ArraySingleDimensionLiteralsUnsignedShort::var_array_ushort(
        const std::array<uint16_t, 10>& _var_array_ushort)
{
    m_var_array_ushort = _var_array_ushort;
}

/*!
 * @brief This function moves the value in member var_array_ushort
 * @param _var_array_ushort New value to be moved in member var_array_ushort
 */
void ArraySingleDimensionLiteralsUnsignedShort::var_array_ushort(
        std::array<uint16_t, 10>&& _var_array_ushort)
{
    m_var_array_ushort = std::move(_var_array_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_array_ushort
 * @return Constant reference to member var_array_ushort
 */
const std::array<uint16_t, 10>& ArraySingleDimensionLiteralsUnsignedShort::var_array_ushort() const
{
    return m_var_array_ushort;
}

/*!
 * @brief This function returns a reference to member var_array_ushort
 * @return Reference to member var_array_ushort
 */
std::array<uint16_t, 10>& ArraySingleDimensionLiteralsUnsignedShort::var_array_ushort()
{
    return m_var_array_ushort;
}


size_t ArraySingleDimensionLiteralsUnsignedShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedShort_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsUnsignedShort::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsUnsignedShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsLong::ArraySingleDimensionLiteralsLong()
{
    // long m_var_array_long
    memset(&m_var_array_long, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsLong::~ArraySingleDimensionLiteralsLong()
{
}

ArraySingleDimensionLiteralsLong::ArraySingleDimensionLiteralsLong(
        const ArraySingleDimensionLiteralsLong& x)
{
    m_var_array_long = x.m_var_array_long;
}

ArraySingleDimensionLiteralsLong::ArraySingleDimensionLiteralsLong(
        ArraySingleDimensionLiteralsLong&& x) noexcept 
{
    m_var_array_long = std::move(x.m_var_array_long);
}

ArraySingleDimensionLiteralsLong& ArraySingleDimensionLiteralsLong::operator =(
        const ArraySingleDimensionLiteralsLong& x)
{

    m_var_array_long = x.m_var_array_long;

    return *this;
}

ArraySingleDimensionLiteralsLong& ArraySingleDimensionLiteralsLong::operator =(
        ArraySingleDimensionLiteralsLong&& x) noexcept
{

    m_var_array_long = std::move(x.m_var_array_long);

    return *this;
}

bool ArraySingleDimensionLiteralsLong::operator ==(
        const ArraySingleDimensionLiteralsLong& x) const
{

    return (m_var_array_long == x.m_var_array_long);
}

bool ArraySingleDimensionLiteralsLong::operator !=(
        const ArraySingleDimensionLiteralsLong& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLong_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsLong::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_long;

}

void ArraySingleDimensionLiteralsLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_long;

}

/*!
 * @brief This function copies the value in member var_array_long
 * @param _var_array_long New value to be copied in member var_array_long
 */
void ArraySingleDimensionLiteralsLong::var_array_long(
        const std::array<int32_t, 10>& _var_array_long)
{
    m_var_array_long = _var_array_long;
}

/*!
 * @brief This function moves the value in member var_array_long
 * @param _var_array_long New value to be moved in member var_array_long
 */
void ArraySingleDimensionLiteralsLong::var_array_long(
        std::array<int32_t, 10>&& _var_array_long)
{
    m_var_array_long = std::move(_var_array_long);
}

/*!
 * @brief This function returns a constant reference to member var_array_long
 * @return Constant reference to member var_array_long
 */
const std::array<int32_t, 10>& ArraySingleDimensionLiteralsLong::var_array_long() const
{
    return m_var_array_long;
}

/*!
 * @brief This function returns a reference to member var_array_long
 * @return Reference to member var_array_long
 */
std::array<int32_t, 10>& ArraySingleDimensionLiteralsLong::var_array_long()
{
    return m_var_array_long;
}


size_t ArraySingleDimensionLiteralsLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLong_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsLong::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsUnsignedLong::ArraySingleDimensionLiteralsUnsignedLong()
{
    // unsigned long m_var_array_ulong
    memset(&m_var_array_ulong, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsUnsignedLong::~ArraySingleDimensionLiteralsUnsignedLong()
{
}

ArraySingleDimensionLiteralsUnsignedLong::ArraySingleDimensionLiteralsUnsignedLong(
        const ArraySingleDimensionLiteralsUnsignedLong& x)
{
    m_var_array_ulong = x.m_var_array_ulong;
}

ArraySingleDimensionLiteralsUnsignedLong::ArraySingleDimensionLiteralsUnsignedLong(
        ArraySingleDimensionLiteralsUnsignedLong&& x) noexcept 
{
    m_var_array_ulong = std::move(x.m_var_array_ulong);
}

ArraySingleDimensionLiteralsUnsignedLong& ArraySingleDimensionLiteralsUnsignedLong::operator =(
        const ArraySingleDimensionLiteralsUnsignedLong& x)
{

    m_var_array_ulong = x.m_var_array_ulong;

    return *this;
}

ArraySingleDimensionLiteralsUnsignedLong& ArraySingleDimensionLiteralsUnsignedLong::operator =(
        ArraySingleDimensionLiteralsUnsignedLong&& x) noexcept
{

    m_var_array_ulong = std::move(x.m_var_array_ulong);

    return *this;
}

bool ArraySingleDimensionLiteralsUnsignedLong::operator ==(
        const ArraySingleDimensionLiteralsUnsignedLong& x) const
{

    return (m_var_array_ulong == x.m_var_array_ulong);
}

bool ArraySingleDimensionLiteralsUnsignedLong::operator !=(
        const ArraySingleDimensionLiteralsUnsignedLong& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsUnsignedLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedLong_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsUnsignedLong::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsUnsignedLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsUnsignedLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ulong;

}

void ArraySingleDimensionLiteralsUnsignedLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ulong;

}

/*!
 * @brief This function copies the value in member var_array_ulong
 * @param _var_array_ulong New value to be copied in member var_array_ulong
 */
void ArraySingleDimensionLiteralsUnsignedLong::var_array_ulong(
        const std::array<uint32_t, 10>& _var_array_ulong)
{
    m_var_array_ulong = _var_array_ulong;
}

/*!
 * @brief This function moves the value in member var_array_ulong
 * @param _var_array_ulong New value to be moved in member var_array_ulong
 */
void ArraySingleDimensionLiteralsUnsignedLong::var_array_ulong(
        std::array<uint32_t, 10>&& _var_array_ulong)
{
    m_var_array_ulong = std::move(_var_array_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulong
 * @return Constant reference to member var_array_ulong
 */
const std::array<uint32_t, 10>& ArraySingleDimensionLiteralsUnsignedLong::var_array_ulong() const
{
    return m_var_array_ulong;
}

/*!
 * @brief This function returns a reference to member var_array_ulong
 * @return Reference to member var_array_ulong
 */
std::array<uint32_t, 10>& ArraySingleDimensionLiteralsUnsignedLong::var_array_ulong()
{
    return m_var_array_ulong;
}


size_t ArraySingleDimensionLiteralsUnsignedLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedLong_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsUnsignedLong::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsUnsignedLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsLongLong::ArraySingleDimensionLiteralsLongLong()
{
    // long long m_var_array_longlong
    memset(&m_var_array_longlong, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsLongLong::~ArraySingleDimensionLiteralsLongLong()
{
}

ArraySingleDimensionLiteralsLongLong::ArraySingleDimensionLiteralsLongLong(
        const ArraySingleDimensionLiteralsLongLong& x)
{
    m_var_array_longlong = x.m_var_array_longlong;
}

ArraySingleDimensionLiteralsLongLong::ArraySingleDimensionLiteralsLongLong(
        ArraySingleDimensionLiteralsLongLong&& x) noexcept 
{
    m_var_array_longlong = std::move(x.m_var_array_longlong);
}

ArraySingleDimensionLiteralsLongLong& ArraySingleDimensionLiteralsLongLong::operator =(
        const ArraySingleDimensionLiteralsLongLong& x)
{

    m_var_array_longlong = x.m_var_array_longlong;

    return *this;
}

ArraySingleDimensionLiteralsLongLong& ArraySingleDimensionLiteralsLongLong::operator =(
        ArraySingleDimensionLiteralsLongLong&& x) noexcept
{

    m_var_array_longlong = std::move(x.m_var_array_longlong);

    return *this;
}

bool ArraySingleDimensionLiteralsLongLong::operator ==(
        const ArraySingleDimensionLiteralsLongLong& x) const
{

    return (m_var_array_longlong == x.m_var_array_longlong);
}

bool ArraySingleDimensionLiteralsLongLong::operator !=(
        const ArraySingleDimensionLiteralsLongLong& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLongLong_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsLongLong::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_longlong;

}

void ArraySingleDimensionLiteralsLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_longlong;

}

/*!
 * @brief This function copies the value in member var_array_longlong
 * @param _var_array_longlong New value to be copied in member var_array_longlong
 */
void ArraySingleDimensionLiteralsLongLong::var_array_longlong(
        const std::array<int64_t, 10>& _var_array_longlong)
{
    m_var_array_longlong = _var_array_longlong;
}

/*!
 * @brief This function moves the value in member var_array_longlong
 * @param _var_array_longlong New value to be moved in member var_array_longlong
 */
void ArraySingleDimensionLiteralsLongLong::var_array_longlong(
        std::array<int64_t, 10>&& _var_array_longlong)
{
    m_var_array_longlong = std::move(_var_array_longlong);
}

/*!
 * @brief This function returns a constant reference to member var_array_longlong
 * @return Constant reference to member var_array_longlong
 */
const std::array<int64_t, 10>& ArraySingleDimensionLiteralsLongLong::var_array_longlong() const
{
    return m_var_array_longlong;
}

/*!
 * @brief This function returns a reference to member var_array_longlong
 * @return Reference to member var_array_longlong
 */
std::array<int64_t, 10>& ArraySingleDimensionLiteralsLongLong::var_array_longlong()
{
    return m_var_array_longlong;
}


size_t ArraySingleDimensionLiteralsLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLongLong_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsLongLong::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsUnsignedLongLong::ArraySingleDimensionLiteralsUnsignedLongLong()
{
    // unsigned long long m_var_array_ulonglong
    memset(&m_var_array_ulonglong, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsUnsignedLongLong::~ArraySingleDimensionLiteralsUnsignedLongLong()
{
}

ArraySingleDimensionLiteralsUnsignedLongLong::ArraySingleDimensionLiteralsUnsignedLongLong(
        const ArraySingleDimensionLiteralsUnsignedLongLong& x)
{
    m_var_array_ulonglong = x.m_var_array_ulonglong;
}

ArraySingleDimensionLiteralsUnsignedLongLong::ArraySingleDimensionLiteralsUnsignedLongLong(
        ArraySingleDimensionLiteralsUnsignedLongLong&& x) noexcept 
{
    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);
}

ArraySingleDimensionLiteralsUnsignedLongLong& ArraySingleDimensionLiteralsUnsignedLongLong::operator =(
        const ArraySingleDimensionLiteralsUnsignedLongLong& x)
{

    m_var_array_ulonglong = x.m_var_array_ulonglong;

    return *this;
}

ArraySingleDimensionLiteralsUnsignedLongLong& ArraySingleDimensionLiteralsUnsignedLongLong::operator =(
        ArraySingleDimensionLiteralsUnsignedLongLong&& x) noexcept
{

    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);

    return *this;
}

bool ArraySingleDimensionLiteralsUnsignedLongLong::operator ==(
        const ArraySingleDimensionLiteralsUnsignedLongLong& x) const
{

    return (m_var_array_ulonglong == x.m_var_array_ulonglong);
}

bool ArraySingleDimensionLiteralsUnsignedLongLong::operator !=(
        const ArraySingleDimensionLiteralsUnsignedLongLong& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsUnsignedLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedLongLong_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsUnsignedLongLong::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsUnsignedLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsUnsignedLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_ulonglong;

}

void ArraySingleDimensionLiteralsUnsignedLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_ulonglong;

}

/*!
 * @brief This function copies the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be copied in member var_array_ulonglong
 */
void ArraySingleDimensionLiteralsUnsignedLongLong::var_array_ulonglong(
        const std::array<uint64_t, 10>& _var_array_ulonglong)
{
    m_var_array_ulonglong = _var_array_ulonglong;
}

/*!
 * @brief This function moves the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be moved in member var_array_ulonglong
 */
void ArraySingleDimensionLiteralsUnsignedLongLong::var_array_ulonglong(
        std::array<uint64_t, 10>&& _var_array_ulonglong)
{
    m_var_array_ulonglong = std::move(_var_array_ulonglong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulonglong
 * @return Constant reference to member var_array_ulonglong
 */
const std::array<uint64_t, 10>& ArraySingleDimensionLiteralsUnsignedLongLong::var_array_ulonglong() const
{
    return m_var_array_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_array_ulonglong
 * @return Reference to member var_array_ulonglong
 */
std::array<uint64_t, 10>& ArraySingleDimensionLiteralsUnsignedLongLong::var_array_ulonglong()
{
    return m_var_array_ulonglong;
}


size_t ArraySingleDimensionLiteralsUnsignedLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnsignedLongLong_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsUnsignedLongLong::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsUnsignedLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsFloat::ArraySingleDimensionLiteralsFloat()
{
    // float m_var_array_float
    memset(&m_var_array_float, 0, (5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsFloat::~ArraySingleDimensionLiteralsFloat()
{
}

ArraySingleDimensionLiteralsFloat::ArraySingleDimensionLiteralsFloat(
        const ArraySingleDimensionLiteralsFloat& x)
{
    m_var_array_float = x.m_var_array_float;
}

ArraySingleDimensionLiteralsFloat::ArraySingleDimensionLiteralsFloat(
        ArraySingleDimensionLiteralsFloat&& x) noexcept 
{
    m_var_array_float = std::move(x.m_var_array_float);
}

ArraySingleDimensionLiteralsFloat& ArraySingleDimensionLiteralsFloat::operator =(
        const ArraySingleDimensionLiteralsFloat& x)
{

    m_var_array_float = x.m_var_array_float;

    return *this;
}

ArraySingleDimensionLiteralsFloat& ArraySingleDimensionLiteralsFloat::operator =(
        ArraySingleDimensionLiteralsFloat&& x) noexcept
{

    m_var_array_float = std::move(x.m_var_array_float);

    return *this;
}

bool ArraySingleDimensionLiteralsFloat::operator ==(
        const ArraySingleDimensionLiteralsFloat& x) const
{

    return (m_var_array_float == x.m_var_array_float);
}

bool ArraySingleDimensionLiteralsFloat::operator !=(
        const ArraySingleDimensionLiteralsFloat& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsFloat_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsFloat::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_float;

}

void ArraySingleDimensionLiteralsFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_float;

}

/*!
 * @brief This function copies the value in member var_array_float
 * @param _var_array_float New value to be copied in member var_array_float
 */
void ArraySingleDimensionLiteralsFloat::var_array_float(
        const std::array<float, 5>& _var_array_float)
{
    m_var_array_float = _var_array_float;
}

/*!
 * @brief This function moves the value in member var_array_float
 * @param _var_array_float New value to be moved in member var_array_float
 */
void ArraySingleDimensionLiteralsFloat::var_array_float(
        std::array<float, 5>&& _var_array_float)
{
    m_var_array_float = std::move(_var_array_float);
}

/*!
 * @brief This function returns a constant reference to member var_array_float
 * @return Constant reference to member var_array_float
 */
const std::array<float, 5>& ArraySingleDimensionLiteralsFloat::var_array_float() const
{
    return m_var_array_float;
}

/*!
 * @brief This function returns a reference to member var_array_float
 * @return Reference to member var_array_float
 */
std::array<float, 5>& ArraySingleDimensionLiteralsFloat::var_array_float()
{
    return m_var_array_float;
}


size_t ArraySingleDimensionLiteralsFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsFloat_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsFloat::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsDouble::ArraySingleDimensionLiteralsDouble()
{
    // double m_var_array_double
    memset(&m_var_array_double, 0, (10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsDouble::~ArraySingleDimensionLiteralsDouble()
{
}

ArraySingleDimensionLiteralsDouble::ArraySingleDimensionLiteralsDouble(
        const ArraySingleDimensionLiteralsDouble& x)
{
    m_var_array_double = x.m_var_array_double;
}

ArraySingleDimensionLiteralsDouble::ArraySingleDimensionLiteralsDouble(
        ArraySingleDimensionLiteralsDouble&& x) noexcept 
{
    m_var_array_double = std::move(x.m_var_array_double);
}

ArraySingleDimensionLiteralsDouble& ArraySingleDimensionLiteralsDouble::operator =(
        const ArraySingleDimensionLiteralsDouble& x)
{

    m_var_array_double = x.m_var_array_double;

    return *this;
}

ArraySingleDimensionLiteralsDouble& ArraySingleDimensionLiteralsDouble::operator =(
        ArraySingleDimensionLiteralsDouble&& x) noexcept
{

    m_var_array_double = std::move(x.m_var_array_double);

    return *this;
}

bool ArraySingleDimensionLiteralsDouble::operator ==(
        const ArraySingleDimensionLiteralsDouble& x) const
{

    return (m_var_array_double == x.m_var_array_double);
}

bool ArraySingleDimensionLiteralsDouble::operator !=(
        const ArraySingleDimensionLiteralsDouble& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsDouble_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsDouble::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_double;

}

void ArraySingleDimensionLiteralsDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_double;

}

/*!
 * @brief This function copies the value in member var_array_double
 * @param _var_array_double New value to be copied in member var_array_double
 */
void ArraySingleDimensionLiteralsDouble::var_array_double(
        const std::array<double, 10>& _var_array_double)
{
    m_var_array_double = _var_array_double;
}

/*!
 * @brief This function moves the value in member var_array_double
 * @param _var_array_double New value to be moved in member var_array_double
 */
void ArraySingleDimensionLiteralsDouble::var_array_double(
        std::array<double, 10>&& _var_array_double)
{
    m_var_array_double = std::move(_var_array_double);
}

/*!
 * @brief This function returns a constant reference to member var_array_double
 * @return Constant reference to member var_array_double
 */
const std::array<double, 10>& ArraySingleDimensionLiteralsDouble::var_array_double() const
{
    return m_var_array_double;
}

/*!
 * @brief This function returns a reference to member var_array_double
 * @return Reference to member var_array_double
 */
std::array<double, 10>& ArraySingleDimensionLiteralsDouble::var_array_double()
{
    return m_var_array_double;
}


size_t ArraySingleDimensionLiteralsDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsDouble_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsDouble::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsLongDouble::ArraySingleDimensionLiteralsLongDouble()
{
    // long double m_var_array_longdouble
    memset(&m_var_array_longdouble, 0, (10) * 16);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsLongDouble::~ArraySingleDimensionLiteralsLongDouble()
{
}

ArraySingleDimensionLiteralsLongDouble::ArraySingleDimensionLiteralsLongDouble(
        const ArraySingleDimensionLiteralsLongDouble& x)
{
    m_var_array_longdouble = x.m_var_array_longdouble;
}

ArraySingleDimensionLiteralsLongDouble::ArraySingleDimensionLiteralsLongDouble(
        ArraySingleDimensionLiteralsLongDouble&& x) noexcept 
{
    m_var_array_longdouble = std::move(x.m_var_array_longdouble);
}

ArraySingleDimensionLiteralsLongDouble& ArraySingleDimensionLiteralsLongDouble::operator =(
        const ArraySingleDimensionLiteralsLongDouble& x)
{

    m_var_array_longdouble = x.m_var_array_longdouble;

    return *this;
}

ArraySingleDimensionLiteralsLongDouble& ArraySingleDimensionLiteralsLongDouble::operator =(
        ArraySingleDimensionLiteralsLongDouble&& x) noexcept
{

    m_var_array_longdouble = std::move(x.m_var_array_longdouble);

    return *this;
}

bool ArraySingleDimensionLiteralsLongDouble::operator ==(
        const ArraySingleDimensionLiteralsLongDouble& x) const
{

    return (m_var_array_longdouble == x.m_var_array_longdouble);
}

bool ArraySingleDimensionLiteralsLongDouble::operator !=(
        const ArraySingleDimensionLiteralsLongDouble& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLongDouble_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsLongDouble::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 16) + eprosima::fastcdr::Cdr::alignment(current_alignment, 16);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_longdouble;

}

void ArraySingleDimensionLiteralsLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_longdouble;

}

/*!
 * @brief This function copies the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be copied in member var_array_longdouble
 */
void ArraySingleDimensionLiteralsLongDouble::var_array_longdouble(
        const std::array<long double, 10>& _var_array_longdouble)
{
    m_var_array_longdouble = _var_array_longdouble;
}

/*!
 * @brief This function moves the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be moved in member var_array_longdouble
 */
void ArraySingleDimensionLiteralsLongDouble::var_array_longdouble(
        std::array<long double, 10>&& _var_array_longdouble)
{
    m_var_array_longdouble = std::move(_var_array_longdouble);
}

/*!
 * @brief This function returns a constant reference to member var_array_longdouble
 * @return Constant reference to member var_array_longdouble
 */
const std::array<long double, 10>& ArraySingleDimensionLiteralsLongDouble::var_array_longdouble() const
{
    return m_var_array_longdouble;
}

/*!
 * @brief This function returns a reference to member var_array_longdouble
 * @return Reference to member var_array_longdouble
 */
std::array<long double, 10>& ArraySingleDimensionLiteralsLongDouble::var_array_longdouble()
{
    return m_var_array_longdouble;
}


size_t ArraySingleDimensionLiteralsLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsLongDouble_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsLongDouble::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsBoolean::ArraySingleDimensionLiteralsBoolean()
{
    // boolean m_var_array_boolean
    memset(&m_var_array_boolean, 0, (5) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsBoolean::~ArraySingleDimensionLiteralsBoolean()
{
}

ArraySingleDimensionLiteralsBoolean::ArraySingleDimensionLiteralsBoolean(
        const ArraySingleDimensionLiteralsBoolean& x)
{
    m_var_array_boolean = x.m_var_array_boolean;
}

ArraySingleDimensionLiteralsBoolean::ArraySingleDimensionLiteralsBoolean(
        ArraySingleDimensionLiteralsBoolean&& x) noexcept 
{
    m_var_array_boolean = std::move(x.m_var_array_boolean);
}

ArraySingleDimensionLiteralsBoolean& ArraySingleDimensionLiteralsBoolean::operator =(
        const ArraySingleDimensionLiteralsBoolean& x)
{

    m_var_array_boolean = x.m_var_array_boolean;

    return *this;
}

ArraySingleDimensionLiteralsBoolean& ArraySingleDimensionLiteralsBoolean::operator =(
        ArraySingleDimensionLiteralsBoolean&& x) noexcept
{

    m_var_array_boolean = std::move(x.m_var_array_boolean);

    return *this;
}

bool ArraySingleDimensionLiteralsBoolean::operator ==(
        const ArraySingleDimensionLiteralsBoolean& x) const
{

    return (m_var_array_boolean == x.m_var_array_boolean);
}

bool ArraySingleDimensionLiteralsBoolean::operator !=(
        const ArraySingleDimensionLiteralsBoolean& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoolean_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsBoolean::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_boolean;

}

void ArraySingleDimensionLiteralsBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_boolean;

}

/*!
 * @brief This function copies the value in member var_array_boolean
 * @param _var_array_boolean New value to be copied in member var_array_boolean
 */
void ArraySingleDimensionLiteralsBoolean::var_array_boolean(
        const std::array<bool, 5>& _var_array_boolean)
{
    m_var_array_boolean = _var_array_boolean;
}

/*!
 * @brief This function moves the value in member var_array_boolean
 * @param _var_array_boolean New value to be moved in member var_array_boolean
 */
void ArraySingleDimensionLiteralsBoolean::var_array_boolean(
        std::array<bool, 5>&& _var_array_boolean)
{
    m_var_array_boolean = std::move(_var_array_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_array_boolean
 * @return Constant reference to member var_array_boolean
 */
const std::array<bool, 5>& ArraySingleDimensionLiteralsBoolean::var_array_boolean() const
{
    return m_var_array_boolean;
}

/*!
 * @brief This function returns a reference to member var_array_boolean
 * @return Reference to member var_array_boolean
 */
std::array<bool, 5>& ArraySingleDimensionLiteralsBoolean::var_array_boolean()
{
    return m_var_array_boolean;
}


size_t ArraySingleDimensionLiteralsBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoolean_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsBoolean::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsOctet::ArraySingleDimensionLiteralsOctet()
{
    // octet m_var_array_octet
    memset(&m_var_array_octet, 0, (10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsOctet::~ArraySingleDimensionLiteralsOctet()
{
}

ArraySingleDimensionLiteralsOctet::ArraySingleDimensionLiteralsOctet(
        const ArraySingleDimensionLiteralsOctet& x)
{
    m_var_array_octet = x.m_var_array_octet;
}

ArraySingleDimensionLiteralsOctet::ArraySingleDimensionLiteralsOctet(
        ArraySingleDimensionLiteralsOctet&& x) noexcept 
{
    m_var_array_octet = std::move(x.m_var_array_octet);
}

ArraySingleDimensionLiteralsOctet& ArraySingleDimensionLiteralsOctet::operator =(
        const ArraySingleDimensionLiteralsOctet& x)
{

    m_var_array_octet = x.m_var_array_octet;

    return *this;
}

ArraySingleDimensionLiteralsOctet& ArraySingleDimensionLiteralsOctet::operator =(
        ArraySingleDimensionLiteralsOctet&& x) noexcept
{

    m_var_array_octet = std::move(x.m_var_array_octet);

    return *this;
}

bool ArraySingleDimensionLiteralsOctet::operator ==(
        const ArraySingleDimensionLiteralsOctet& x) const
{

    return (m_var_array_octet == x.m_var_array_octet);
}

bool ArraySingleDimensionLiteralsOctet::operator !=(
        const ArraySingleDimensionLiteralsOctet& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsOctet_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsOctet::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_octet;

}

void ArraySingleDimensionLiteralsOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_octet;

}

/*!
 * @brief This function copies the value in member var_array_octet
 * @param _var_array_octet New value to be copied in member var_array_octet
 */
void ArraySingleDimensionLiteralsOctet::var_array_octet(
        const std::array<uint8_t, 10>& _var_array_octet)
{
    m_var_array_octet = _var_array_octet;
}

/*!
 * @brief This function moves the value in member var_array_octet
 * @param _var_array_octet New value to be moved in member var_array_octet
 */
void ArraySingleDimensionLiteralsOctet::var_array_octet(
        std::array<uint8_t, 10>&& _var_array_octet)
{
    m_var_array_octet = std::move(_var_array_octet);
}

/*!
 * @brief This function returns a constant reference to member var_array_octet
 * @return Constant reference to member var_array_octet
 */
const std::array<uint8_t, 10>& ArraySingleDimensionLiteralsOctet::var_array_octet() const
{
    return m_var_array_octet;
}

/*!
 * @brief This function returns a reference to member var_array_octet
 * @return Reference to member var_array_octet
 */
std::array<uint8_t, 10>& ArraySingleDimensionLiteralsOctet::var_array_octet()
{
    return m_var_array_octet;
}


size_t ArraySingleDimensionLiteralsOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsOctet_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsOctet::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsChar::ArraySingleDimensionLiteralsChar()
{
    // char m_var_array_char
    memset(&m_var_array_char, 0, (5) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsChar::~ArraySingleDimensionLiteralsChar()
{
}

ArraySingleDimensionLiteralsChar::ArraySingleDimensionLiteralsChar(
        const ArraySingleDimensionLiteralsChar& x)
{
    m_var_array_char = x.m_var_array_char;
}

ArraySingleDimensionLiteralsChar::ArraySingleDimensionLiteralsChar(
        ArraySingleDimensionLiteralsChar&& x) noexcept 
{
    m_var_array_char = std::move(x.m_var_array_char);
}

ArraySingleDimensionLiteralsChar& ArraySingleDimensionLiteralsChar::operator =(
        const ArraySingleDimensionLiteralsChar& x)
{

    m_var_array_char = x.m_var_array_char;

    return *this;
}

ArraySingleDimensionLiteralsChar& ArraySingleDimensionLiteralsChar::operator =(
        ArraySingleDimensionLiteralsChar&& x) noexcept
{

    m_var_array_char = std::move(x.m_var_array_char);

    return *this;
}

bool ArraySingleDimensionLiteralsChar::operator ==(
        const ArraySingleDimensionLiteralsChar& x) const
{

    return (m_var_array_char == x.m_var_array_char);
}

bool ArraySingleDimensionLiteralsChar::operator !=(
        const ArraySingleDimensionLiteralsChar& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsChar_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsChar::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_char;

}

void ArraySingleDimensionLiteralsChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_char;

}

/*!
 * @brief This function copies the value in member var_array_char
 * @param _var_array_char New value to be copied in member var_array_char
 */
void ArraySingleDimensionLiteralsChar::var_array_char(
        const std::array<char, 5>& _var_array_char)
{
    m_var_array_char = _var_array_char;
}

/*!
 * @brief This function moves the value in member var_array_char
 * @param _var_array_char New value to be moved in member var_array_char
 */
void ArraySingleDimensionLiteralsChar::var_array_char(
        std::array<char, 5>&& _var_array_char)
{
    m_var_array_char = std::move(_var_array_char);
}

/*!
 * @brief This function returns a constant reference to member var_array_char
 * @return Constant reference to member var_array_char
 */
const std::array<char, 5>& ArraySingleDimensionLiteralsChar::var_array_char() const
{
    return m_var_array_char;
}

/*!
 * @brief This function returns a reference to member var_array_char
 * @return Reference to member var_array_char
 */
std::array<char, 5>& ArraySingleDimensionLiteralsChar::var_array_char()
{
    return m_var_array_char;
}


size_t ArraySingleDimensionLiteralsChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsChar_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsChar::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsWChar::ArraySingleDimensionLiteralsWChar()
{
    // wchar m_var_array_wchar
    memset(&m_var_array_wchar, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsWChar::~ArraySingleDimensionLiteralsWChar()
{
}

ArraySingleDimensionLiteralsWChar::ArraySingleDimensionLiteralsWChar(
        const ArraySingleDimensionLiteralsWChar& x)
{
    m_var_array_wchar = x.m_var_array_wchar;
}

ArraySingleDimensionLiteralsWChar::ArraySingleDimensionLiteralsWChar(
        ArraySingleDimensionLiteralsWChar&& x) noexcept 
{
    m_var_array_wchar = std::move(x.m_var_array_wchar);
}

ArraySingleDimensionLiteralsWChar& ArraySingleDimensionLiteralsWChar::operator =(
        const ArraySingleDimensionLiteralsWChar& x)
{

    m_var_array_wchar = x.m_var_array_wchar;

    return *this;
}

ArraySingleDimensionLiteralsWChar& ArraySingleDimensionLiteralsWChar::operator =(
        ArraySingleDimensionLiteralsWChar&& x) noexcept
{

    m_var_array_wchar = std::move(x.m_var_array_wchar);

    return *this;
}

bool ArraySingleDimensionLiteralsWChar::operator ==(
        const ArraySingleDimensionLiteralsWChar& x) const
{

    return (m_var_array_wchar == x.m_var_array_wchar);
}

bool ArraySingleDimensionLiteralsWChar::operator !=(
        const ArraySingleDimensionLiteralsWChar& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsWChar_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsWChar::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_wchar;

}

void ArraySingleDimensionLiteralsWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_wchar;

}

/*!
 * @brief This function copies the value in member var_array_wchar
 * @param _var_array_wchar New value to be copied in member var_array_wchar
 */
void ArraySingleDimensionLiteralsWChar::var_array_wchar(
        const std::array<wchar_t, 10>& _var_array_wchar)
{
    m_var_array_wchar = _var_array_wchar;
}

/*!
 * @brief This function moves the value in member var_array_wchar
 * @param _var_array_wchar New value to be moved in member var_array_wchar
 */
void ArraySingleDimensionLiteralsWChar::var_array_wchar(
        std::array<wchar_t, 10>&& _var_array_wchar)
{
    m_var_array_wchar = std::move(_var_array_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_array_wchar
 * @return Constant reference to member var_array_wchar
 */
const std::array<wchar_t, 10>& ArraySingleDimensionLiteralsWChar::var_array_wchar() const
{
    return m_var_array_wchar;
}

/*!
 * @brief This function returns a reference to member var_array_wchar
 * @return Reference to member var_array_wchar
 */
std::array<wchar_t, 10>& ArraySingleDimensionLiteralsWChar::var_array_wchar()
{
    return m_var_array_wchar;
}


size_t ArraySingleDimensionLiteralsWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsWChar_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsWChar::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsString::ArraySingleDimensionLiteralsString()
{
    // string m_var_array_string


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsString::~ArraySingleDimensionLiteralsString()
{
}

ArraySingleDimensionLiteralsString::ArraySingleDimensionLiteralsString(
        const ArraySingleDimensionLiteralsString& x)
{
    m_var_array_string = x.m_var_array_string;
}

ArraySingleDimensionLiteralsString::ArraySingleDimensionLiteralsString(
        ArraySingleDimensionLiteralsString&& x) noexcept 
{
    m_var_array_string = std::move(x.m_var_array_string);
}

ArraySingleDimensionLiteralsString& ArraySingleDimensionLiteralsString::operator =(
        const ArraySingleDimensionLiteralsString& x)
{

    m_var_array_string = x.m_var_array_string;

    return *this;
}

ArraySingleDimensionLiteralsString& ArraySingleDimensionLiteralsString::operator =(
        ArraySingleDimensionLiteralsString&& x) noexcept
{

    m_var_array_string = std::move(x.m_var_array_string);

    return *this;
}

bool ArraySingleDimensionLiteralsString::operator ==(
        const ArraySingleDimensionLiteralsString& x) const
{

    return (m_var_array_string == x.m_var_array_string);
}

bool ArraySingleDimensionLiteralsString::operator !=(
        const ArraySingleDimensionLiteralsString& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsString_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsString::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_string().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_string().at(a).size() + 1;


    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (const auto& str : m_var_array_string)
    {
        scdr << str.c_str();
    }



}

void ArraySingleDimensionLiteralsString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (auto& str : m_var_array_string)
    {
        dcdr >> str;}



}

/*!
 * @brief This function copies the value in member var_array_string
 * @param _var_array_string New value to be copied in member var_array_string
 */
void ArraySingleDimensionLiteralsString::var_array_string(
        const std::array<std::string, 5>& _var_array_string)
{
    m_var_array_string = _var_array_string;
}

/*!
 * @brief This function moves the value in member var_array_string
 * @param _var_array_string New value to be moved in member var_array_string
 */
void ArraySingleDimensionLiteralsString::var_array_string(
        std::array<std::string, 5>&& _var_array_string)
{
    m_var_array_string = std::move(_var_array_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_string
 * @return Constant reference to member var_array_string
 */
const std::array<std::string, 5>& ArraySingleDimensionLiteralsString::var_array_string() const
{
    return m_var_array_string;
}

/*!
 * @brief This function returns a reference to member var_array_string
 * @return Reference to member var_array_string
 */
std::array<std::string, 5>& ArraySingleDimensionLiteralsString::var_array_string()
{
    return m_var_array_string;
}


size_t ArraySingleDimensionLiteralsString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsString_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsString::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsWString::ArraySingleDimensionLiteralsWString()
{
    // wstring m_var_array_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsWString::~ArraySingleDimensionLiteralsWString()
{
}

ArraySingleDimensionLiteralsWString::ArraySingleDimensionLiteralsWString(
        const ArraySingleDimensionLiteralsWString& x)
{
    m_var_array_wstring = x.m_var_array_wstring;
}

ArraySingleDimensionLiteralsWString::ArraySingleDimensionLiteralsWString(
        ArraySingleDimensionLiteralsWString&& x) noexcept 
{
    m_var_array_wstring = std::move(x.m_var_array_wstring);
}

ArraySingleDimensionLiteralsWString& ArraySingleDimensionLiteralsWString::operator =(
        const ArraySingleDimensionLiteralsWString& x)
{

    m_var_array_wstring = x.m_var_array_wstring;

    return *this;
}

ArraySingleDimensionLiteralsWString& ArraySingleDimensionLiteralsWString::operator =(
        ArraySingleDimensionLiteralsWString&& x) noexcept
{

    m_var_array_wstring = std::move(x.m_var_array_wstring);

    return *this;
}

bool ArraySingleDimensionLiteralsWString::operator ==(
        const ArraySingleDimensionLiteralsWString& x) const
{

    return (m_var_array_wstring == x.m_var_array_wstring);
}

bool ArraySingleDimensionLiteralsWString::operator !=(
        const ArraySingleDimensionLiteralsWString& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsWString_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsWString::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_wstring().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_wstring().at(a).size() * 4);


    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_wstring;

}

void ArraySingleDimensionLiteralsWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_wstring;

}

/*!
 * @brief This function copies the value in member var_array_wstring
 * @param _var_array_wstring New value to be copied in member var_array_wstring
 */
void ArraySingleDimensionLiteralsWString::var_array_wstring(
        const std::array<std::wstring, 10>& _var_array_wstring)
{
    m_var_array_wstring = _var_array_wstring;
}

/*!
 * @brief This function moves the value in member var_array_wstring
 * @param _var_array_wstring New value to be moved in member var_array_wstring
 */
void ArraySingleDimensionLiteralsWString::var_array_wstring(
        std::array<std::wstring, 10>&& _var_array_wstring)
{
    m_var_array_wstring = std::move(_var_array_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_wstring
 * @return Constant reference to member var_array_wstring
 */
const std::array<std::wstring, 10>& ArraySingleDimensionLiteralsWString::var_array_wstring() const
{
    return m_var_array_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_wstring
 * @return Reference to member var_array_wstring
 */
std::array<std::wstring, 10>& ArraySingleDimensionLiteralsWString::var_array_wstring()
{
    return m_var_array_wstring;
}


size_t ArraySingleDimensionLiteralsWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsWString_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsWString::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsBoundedString::ArraySingleDimensionLiteralsBoundedString()
{
    // Inner_alias_bounded_string_helper m_var_array_bounded_string


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsBoundedString::~ArraySingleDimensionLiteralsBoundedString()
{
}

ArraySingleDimensionLiteralsBoundedString::ArraySingleDimensionLiteralsBoundedString(
        const ArraySingleDimensionLiteralsBoundedString& x)
{
    m_var_array_bounded_string = x.m_var_array_bounded_string;
}

ArraySingleDimensionLiteralsBoundedString::ArraySingleDimensionLiteralsBoundedString(
        ArraySingleDimensionLiteralsBoundedString&& x) noexcept 
{
    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);
}

ArraySingleDimensionLiteralsBoundedString& ArraySingleDimensionLiteralsBoundedString::operator =(
        const ArraySingleDimensionLiteralsBoundedString& x)
{

    m_var_array_bounded_string = x.m_var_array_bounded_string;

    return *this;
}

ArraySingleDimensionLiteralsBoundedString& ArraySingleDimensionLiteralsBoundedString::operator =(
        ArraySingleDimensionLiteralsBoundedString&& x) noexcept
{

    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);

    return *this;
}

bool ArraySingleDimensionLiteralsBoundedString::operator ==(
        const ArraySingleDimensionLiteralsBoundedString& x) const
{

    return (m_var_array_bounded_string == x.m_var_array_bounded_string);
}

bool ArraySingleDimensionLiteralsBoundedString::operator !=(
        const ArraySingleDimensionLiteralsBoundedString& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoundedString_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsBoundedString::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_string().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_bounded_string().at(a).size() + 1;


    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (const auto& str : m_var_array_bounded_string)
    {
        scdr << str.c_str();
    }



}

void ArraySingleDimensionLiteralsBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (auto& str : m_var_array_bounded_string)
    {
    {
        std::string aux_str;
        dcdr >> aux_str;
        str = aux_str.c_str();
    }}



}

/*!
 * @brief This function copies the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be copied in member var_array_bounded_string
 */
void ArraySingleDimensionLiteralsBoundedString::var_array_bounded_string(
        const std::array<Inner_alias_bounded_string_helper, 5>& _var_array_bounded_string)
{
    m_var_array_bounded_string = _var_array_bounded_string;
}

/*!
 * @brief This function moves the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be moved in member var_array_bounded_string
 */
void ArraySingleDimensionLiteralsBoundedString::var_array_bounded_string(
        std::array<Inner_alias_bounded_string_helper, 5>&& _var_array_bounded_string)
{
    m_var_array_bounded_string = std::move(_var_array_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_string
 * @return Constant reference to member var_array_bounded_string
 */
const std::array<Inner_alias_bounded_string_helper, 5>& ArraySingleDimensionLiteralsBoundedString::var_array_bounded_string() const
{
    return m_var_array_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_string
 * @return Reference to member var_array_bounded_string
 */
std::array<Inner_alias_bounded_string_helper, 5>& ArraySingleDimensionLiteralsBoundedString::var_array_bounded_string()
{
    return m_var_array_bounded_string;
}


size_t ArraySingleDimensionLiteralsBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoundedString_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsBoundedString::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsBoundedWString::ArraySingleDimensionLiteralsBoundedWString()
{
    // Inner_alias_bounded_wstring_helper m_var_array_bounded_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsBoundedWString::~ArraySingleDimensionLiteralsBoundedWString()
{
}

ArraySingleDimensionLiteralsBoundedWString::ArraySingleDimensionLiteralsBoundedWString(
        const ArraySingleDimensionLiteralsBoundedWString& x)
{
    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;
}

ArraySingleDimensionLiteralsBoundedWString::ArraySingleDimensionLiteralsBoundedWString(
        ArraySingleDimensionLiteralsBoundedWString&& x) noexcept 
{
    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);
}

ArraySingleDimensionLiteralsBoundedWString& ArraySingleDimensionLiteralsBoundedWString::operator =(
        const ArraySingleDimensionLiteralsBoundedWString& x)
{

    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;

    return *this;
}

ArraySingleDimensionLiteralsBoundedWString& ArraySingleDimensionLiteralsBoundedWString::operator =(
        ArraySingleDimensionLiteralsBoundedWString&& x) noexcept
{

    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);

    return *this;
}

bool ArraySingleDimensionLiteralsBoundedWString::operator ==(
        const ArraySingleDimensionLiteralsBoundedWString& x) const
{

    return (m_var_array_bounded_wstring == x.m_var_array_bounded_wstring);
}

bool ArraySingleDimensionLiteralsBoundedWString::operator !=(
        const ArraySingleDimensionLiteralsBoundedWString& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoundedWString_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsBoundedWString::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_wstring().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_bounded_wstring().at(a).size() * 4);


    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_bounded_wstring;

}

void ArraySingleDimensionLiteralsBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_bounded_wstring;

}

/*!
 * @brief This function copies the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be copied in member var_array_bounded_wstring
 */
void ArraySingleDimensionLiteralsBoundedWString::var_array_bounded_wstring(
        const std::array<Inner_alias_bounded_wstring_helper, 10>& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = _var_array_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be moved in member var_array_bounded_wstring
 */
void ArraySingleDimensionLiteralsBoundedWString::var_array_bounded_wstring(
        std::array<Inner_alias_bounded_wstring_helper, 10>&& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = std::move(_var_array_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_wstring
 * @return Constant reference to member var_array_bounded_wstring
 */
const std::array<Inner_alias_bounded_wstring_helper, 10>& ArraySingleDimensionLiteralsBoundedWString::var_array_bounded_wstring() const
{
    return m_var_array_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_wstring
 * @return Reference to member var_array_bounded_wstring
 */
std::array<Inner_alias_bounded_wstring_helper, 10>& ArraySingleDimensionLiteralsBoundedWString::var_array_bounded_wstring()
{
    return m_var_array_bounded_wstring;
}


size_t ArraySingleDimensionLiteralsBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBoundedWString_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsBoundedWString::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsEnum::ArraySingleDimensionLiteralsEnum()
{
    // InnerEnumHelper m_var_array_enum
    memset(&m_var_array_enum, 0, (5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsEnum::~ArraySingleDimensionLiteralsEnum()
{
}

ArraySingleDimensionLiteralsEnum::ArraySingleDimensionLiteralsEnum(
        const ArraySingleDimensionLiteralsEnum& x)
{
    m_var_array_enum = x.m_var_array_enum;
}

ArraySingleDimensionLiteralsEnum::ArraySingleDimensionLiteralsEnum(
        ArraySingleDimensionLiteralsEnum&& x) noexcept 
{
    m_var_array_enum = std::move(x.m_var_array_enum);
}

ArraySingleDimensionLiteralsEnum& ArraySingleDimensionLiteralsEnum::operator =(
        const ArraySingleDimensionLiteralsEnum& x)
{

    m_var_array_enum = x.m_var_array_enum;

    return *this;
}

ArraySingleDimensionLiteralsEnum& ArraySingleDimensionLiteralsEnum::operator =(
        ArraySingleDimensionLiteralsEnum&& x) noexcept
{

    m_var_array_enum = std::move(x.m_var_array_enum);

    return *this;
}

bool ArraySingleDimensionLiteralsEnum::operator ==(
        const ArraySingleDimensionLiteralsEnum& x) const
{

    return (m_var_array_enum == x.m_var_array_enum);
}

bool ArraySingleDimensionLiteralsEnum::operator !=(
        const ArraySingleDimensionLiteralsEnum& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsEnum_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsEnum::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_enum.data()), m_var_array_enum.size());
}

void ArraySingleDimensionLiteralsEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_enum.data()), m_var_array_enum.size());
}

/*!
 * @brief This function copies the value in member var_array_enum
 * @param _var_array_enum New value to be copied in member var_array_enum
 */
void ArraySingleDimensionLiteralsEnum::var_array_enum(
        const std::array<InnerEnumHelper, 5>& _var_array_enum)
{
    m_var_array_enum = _var_array_enum;
}

/*!
 * @brief This function moves the value in member var_array_enum
 * @param _var_array_enum New value to be moved in member var_array_enum
 */
void ArraySingleDimensionLiteralsEnum::var_array_enum(
        std::array<InnerEnumHelper, 5>&& _var_array_enum)
{
    m_var_array_enum = std::move(_var_array_enum);
}

/*!
 * @brief This function returns a constant reference to member var_array_enum
 * @return Constant reference to member var_array_enum
 */
const std::array<InnerEnumHelper, 5>& ArraySingleDimensionLiteralsEnum::var_array_enum() const
{
    return m_var_array_enum;
}

/*!
 * @brief This function returns a reference to member var_array_enum
 * @return Reference to member var_array_enum
 */
std::array<InnerEnumHelper, 5>& ArraySingleDimensionLiteralsEnum::var_array_enum()
{
    return m_var_array_enum;
}


size_t ArraySingleDimensionLiteralsEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsEnum_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsEnum::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsBitMask::ArraySingleDimensionLiteralsBitMask()
{
    // InnerBitMaskHelper m_var_array_bitmask
    memset(&m_var_array_bitmask, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsBitMask::~ArraySingleDimensionLiteralsBitMask()
{
}

ArraySingleDimensionLiteralsBitMask::ArraySingleDimensionLiteralsBitMask(
        const ArraySingleDimensionLiteralsBitMask& x)
{
    m_var_array_bitmask = x.m_var_array_bitmask;
}

ArraySingleDimensionLiteralsBitMask::ArraySingleDimensionLiteralsBitMask(
        ArraySingleDimensionLiteralsBitMask&& x) noexcept 
{
    m_var_array_bitmask = std::move(x.m_var_array_bitmask);
}

ArraySingleDimensionLiteralsBitMask& ArraySingleDimensionLiteralsBitMask::operator =(
        const ArraySingleDimensionLiteralsBitMask& x)
{

    m_var_array_bitmask = x.m_var_array_bitmask;

    return *this;
}

ArraySingleDimensionLiteralsBitMask& ArraySingleDimensionLiteralsBitMask::operator =(
        ArraySingleDimensionLiteralsBitMask&& x) noexcept
{

    m_var_array_bitmask = std::move(x.m_var_array_bitmask);

    return *this;
}

bool ArraySingleDimensionLiteralsBitMask::operator ==(
        const ArraySingleDimensionLiteralsBitMask& x) const
{

    return (m_var_array_bitmask == x.m_var_array_bitmask);
}

bool ArraySingleDimensionLiteralsBitMask::operator !=(
        const ArraySingleDimensionLiteralsBitMask& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBitMask_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsBitMask::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_bitmask.data()), m_var_array_bitmask.size());
}

void ArraySingleDimensionLiteralsBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_bitmask.data()), m_var_array_bitmask.size());}

/*!
 * @brief This function copies the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be copied in member var_array_bitmask
 */
void ArraySingleDimensionLiteralsBitMask::var_array_bitmask(
        const std::array<InnerBitMaskHelper, 10>& _var_array_bitmask)
{
    m_var_array_bitmask = _var_array_bitmask;
}

/*!
 * @brief This function moves the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be moved in member var_array_bitmask
 */
void ArraySingleDimensionLiteralsBitMask::var_array_bitmask(
        std::array<InnerBitMaskHelper, 10>&& _var_array_bitmask)
{
    m_var_array_bitmask = std::move(_var_array_bitmask);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitmask
 * @return Constant reference to member var_array_bitmask
 */
const std::array<InnerBitMaskHelper, 10>& ArraySingleDimensionLiteralsBitMask::var_array_bitmask() const
{
    return m_var_array_bitmask;
}

/*!
 * @brief This function returns a reference to member var_array_bitmask
 * @return Reference to member var_array_bitmask
 */
std::array<InnerBitMaskHelper, 10>& ArraySingleDimensionLiteralsBitMask::var_array_bitmask()
{
    return m_var_array_bitmask;
}


size_t ArraySingleDimensionLiteralsBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBitMask_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsBitMask::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsAlias::ArraySingleDimensionLiteralsAlias()
{
    // InnerAliasHelper m_var_array_alias
    memset(&m_var_array_alias, 0, (10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsAlias::~ArraySingleDimensionLiteralsAlias()
{
}

ArraySingleDimensionLiteralsAlias::ArraySingleDimensionLiteralsAlias(
        const ArraySingleDimensionLiteralsAlias& x)
{
    m_var_array_alias = x.m_var_array_alias;
}

ArraySingleDimensionLiteralsAlias::ArraySingleDimensionLiteralsAlias(
        ArraySingleDimensionLiteralsAlias&& x) noexcept 
{
    m_var_array_alias = std::move(x.m_var_array_alias);
}

ArraySingleDimensionLiteralsAlias& ArraySingleDimensionLiteralsAlias::operator =(
        const ArraySingleDimensionLiteralsAlias& x)
{

    m_var_array_alias = x.m_var_array_alias;

    return *this;
}

ArraySingleDimensionLiteralsAlias& ArraySingleDimensionLiteralsAlias::operator =(
        ArraySingleDimensionLiteralsAlias&& x) noexcept
{

    m_var_array_alias = std::move(x.m_var_array_alias);

    return *this;
}

bool ArraySingleDimensionLiteralsAlias::operator ==(
        const ArraySingleDimensionLiteralsAlias& x) const
{

    return (m_var_array_alias == x.m_var_array_alias);
}

bool ArraySingleDimensionLiteralsAlias::operator !=(
        const ArraySingleDimensionLiteralsAlias& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsAlias_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsAlias::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_alias;

}

void ArraySingleDimensionLiteralsAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_alias;

}

/*!
 * @brief This function copies the value in member var_array_alias
 * @param _var_array_alias New value to be copied in member var_array_alias
 */
void ArraySingleDimensionLiteralsAlias::var_array_alias(
        const std::array<InnerAliasHelper, 10>& _var_array_alias)
{
    m_var_array_alias = _var_array_alias;
}

/*!
 * @brief This function moves the value in member var_array_alias
 * @param _var_array_alias New value to be moved in member var_array_alias
 */
void ArraySingleDimensionLiteralsAlias::var_array_alias(
        std::array<InnerAliasHelper, 10>&& _var_array_alias)
{
    m_var_array_alias = std::move(_var_array_alias);
}

/*!
 * @brief This function returns a constant reference to member var_array_alias
 * @return Constant reference to member var_array_alias
 */
const std::array<InnerAliasHelper, 10>& ArraySingleDimensionLiteralsAlias::var_array_alias() const
{
    return m_var_array_alias;
}

/*!
 * @brief This function returns a reference to member var_array_alias
 * @return Reference to member var_array_alias
 */
std::array<InnerAliasHelper, 10>& ArraySingleDimensionLiteralsAlias::var_array_alias()
{
    return m_var_array_alias;
}


size_t ArraySingleDimensionLiteralsAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsAlias_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsAlias::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsShortArray::ArraySingleDimensionLiteralsShortArray()
{
    // short m_var_array_short_array
    memset(&m_var_array_short_array, 0, (10 * 10) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsShortArray::~ArraySingleDimensionLiteralsShortArray()
{
}

ArraySingleDimensionLiteralsShortArray::ArraySingleDimensionLiteralsShortArray(
        const ArraySingleDimensionLiteralsShortArray& x)
{
    m_var_array_short_array = x.m_var_array_short_array;
}

ArraySingleDimensionLiteralsShortArray::ArraySingleDimensionLiteralsShortArray(
        ArraySingleDimensionLiteralsShortArray&& x) noexcept 
{
    m_var_array_short_array = std::move(x.m_var_array_short_array);
}

ArraySingleDimensionLiteralsShortArray& ArraySingleDimensionLiteralsShortArray::operator =(
        const ArraySingleDimensionLiteralsShortArray& x)
{

    m_var_array_short_array = x.m_var_array_short_array;

    return *this;
}

ArraySingleDimensionLiteralsShortArray& ArraySingleDimensionLiteralsShortArray::operator =(
        ArraySingleDimensionLiteralsShortArray&& x) noexcept
{

    m_var_array_short_array = std::move(x.m_var_array_short_array);

    return *this;
}

bool ArraySingleDimensionLiteralsShortArray::operator ==(
        const ArraySingleDimensionLiteralsShortArray& x) const
{

    return (m_var_array_short_array == x.m_var_array_short_array);
}

bool ArraySingleDimensionLiteralsShortArray::operator !=(
        const ArraySingleDimensionLiteralsShortArray& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsShortArray::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsShortArray_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsShortArray::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsShortArray& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsShortArray::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_short_array.size(); ++b)
    {
        scdr << m_var_array_short_array[b];
    }    

}

void ArraySingleDimensionLiteralsShortArray::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t d = 0; d < m_var_array_short_array.size(); ++d)
    {
        dcdr >> m_var_array_short_array[d];
    }

}

/*!
 * @brief This function copies the value in member var_array_short_array
 * @param _var_array_short_array New value to be copied in member var_array_short_array
 */
void ArraySingleDimensionLiteralsShortArray::var_array_short_array(
        const std::array<std::array<int16_t, 10>, 10>& _var_array_short_array)
{
    m_var_array_short_array = _var_array_short_array;
}

/*!
 * @brief This function moves the value in member var_array_short_array
 * @param _var_array_short_array New value to be moved in member var_array_short_array
 */
void ArraySingleDimensionLiteralsShortArray::var_array_short_array(
        std::array<std::array<int16_t, 10>, 10>&& _var_array_short_array)
{
    m_var_array_short_array = std::move(_var_array_short_array);
}

/*!
 * @brief This function returns a constant reference to member var_array_short_array
 * @return Constant reference to member var_array_short_array
 */
const std::array<std::array<int16_t, 10>, 10>& ArraySingleDimensionLiteralsShortArray::var_array_short_array() const
{
    return m_var_array_short_array;
}

/*!
 * @brief This function returns a reference to member var_array_short_array
 * @return Reference to member var_array_short_array
 */
std::array<std::array<int16_t, 10>, 10>& ArraySingleDimensionLiteralsShortArray::var_array_short_array()
{
    return m_var_array_short_array;
}


size_t ArraySingleDimensionLiteralsShortArray::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsShortArray_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsShortArray::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsShortArray::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsSequence::ArraySingleDimensionLiteralsSequence()
{
    // sequence<long> m_var_array_sequence


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsSequence::~ArraySingleDimensionLiteralsSequence()
{
}

ArraySingleDimensionLiteralsSequence::ArraySingleDimensionLiteralsSequence(
        const ArraySingleDimensionLiteralsSequence& x)
{
    m_var_array_sequence = x.m_var_array_sequence;
}

ArraySingleDimensionLiteralsSequence::ArraySingleDimensionLiteralsSequence(
        ArraySingleDimensionLiteralsSequence&& x) noexcept 
{
    m_var_array_sequence = std::move(x.m_var_array_sequence);
}

ArraySingleDimensionLiteralsSequence& ArraySingleDimensionLiteralsSequence::operator =(
        const ArraySingleDimensionLiteralsSequence& x)
{

    m_var_array_sequence = x.m_var_array_sequence;

    return *this;
}

ArraySingleDimensionLiteralsSequence& ArraySingleDimensionLiteralsSequence::operator =(
        ArraySingleDimensionLiteralsSequence&& x) noexcept
{

    m_var_array_sequence = std::move(x.m_var_array_sequence);

    return *this;
}

bool ArraySingleDimensionLiteralsSequence::operator ==(
        const ArraySingleDimensionLiteralsSequence& x) const
{

    return (m_var_array_sequence == x.m_var_array_sequence);
}

bool ArraySingleDimensionLiteralsSequence::operator !=(
        const ArraySingleDimensionLiteralsSequence& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsSequence_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsSequence::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_sequence().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            if (data.var_array_sequence().at(a).size() > 0)
            {
                current_alignment += (data.var_array_sequence().at(a).size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            }



    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_sequence;

}

void ArraySingleDimensionLiteralsSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_sequence;

}

/*!
 * @brief This function copies the value in member var_array_sequence
 * @param _var_array_sequence New value to be copied in member var_array_sequence
 */
void ArraySingleDimensionLiteralsSequence::var_array_sequence(
        const std::array<std::vector<int32_t>, 5>& _var_array_sequence)
{
    m_var_array_sequence = _var_array_sequence;
}

/*!
 * @brief This function moves the value in member var_array_sequence
 * @param _var_array_sequence New value to be moved in member var_array_sequence
 */
void ArraySingleDimensionLiteralsSequence::var_array_sequence(
        std::array<std::vector<int32_t>, 5>&& _var_array_sequence)
{
    m_var_array_sequence = std::move(_var_array_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_array_sequence
 * @return Constant reference to member var_array_sequence
 */
const std::array<std::vector<int32_t>, 5>& ArraySingleDimensionLiteralsSequence::var_array_sequence() const
{
    return m_var_array_sequence;
}

/*!
 * @brief This function returns a reference to member var_array_sequence
 * @return Reference to member var_array_sequence
 */
std::array<std::vector<int32_t>, 5>& ArraySingleDimensionLiteralsSequence::var_array_sequence()
{
    return m_var_array_sequence;
}


size_t ArraySingleDimensionLiteralsSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsSequence_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsSequence::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsMap::ArraySingleDimensionLiteralsMap()
{
    // map<long, long> m_var_array_map


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsMap::~ArraySingleDimensionLiteralsMap()
{
}

ArraySingleDimensionLiteralsMap::ArraySingleDimensionLiteralsMap(
        const ArraySingleDimensionLiteralsMap& x)
{
    m_var_array_map = x.m_var_array_map;
}

ArraySingleDimensionLiteralsMap::ArraySingleDimensionLiteralsMap(
        ArraySingleDimensionLiteralsMap&& x) noexcept 
{
    m_var_array_map = std::move(x.m_var_array_map);
}

ArraySingleDimensionLiteralsMap& ArraySingleDimensionLiteralsMap::operator =(
        const ArraySingleDimensionLiteralsMap& x)
{

    m_var_array_map = x.m_var_array_map;

    return *this;
}

ArraySingleDimensionLiteralsMap& ArraySingleDimensionLiteralsMap::operator =(
        ArraySingleDimensionLiteralsMap&& x) noexcept
{

    m_var_array_map = std::move(x.m_var_array_map);

    return *this;
}

bool ArraySingleDimensionLiteralsMap::operator ==(
        const ArraySingleDimensionLiteralsMap& x) const
{

    return (m_var_array_map == x.m_var_array_map);
}

bool ArraySingleDimensionLiteralsMap::operator !=(
        const ArraySingleDimensionLiteralsMap& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsMap_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsMap::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_map().size(); ++a)
    {

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            for(auto b : data.var_array_map().at(a))
            {
                (void)b;

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            }

    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_map;

}

void ArraySingleDimensionLiteralsMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_map;

}

/*!
 * @brief This function copies the value in member var_array_map
 * @param _var_array_map New value to be copied in member var_array_map
 */
void ArraySingleDimensionLiteralsMap::var_array_map(
        const std::array<std::map<int32_t, int32_t>, 2>& _var_array_map)
{
    m_var_array_map = _var_array_map;
}

/*!
 * @brief This function moves the value in member var_array_map
 * @param _var_array_map New value to be moved in member var_array_map
 */
void ArraySingleDimensionLiteralsMap::var_array_map(
        std::array<std::map<int32_t, int32_t>, 2>&& _var_array_map)
{
    m_var_array_map = std::move(_var_array_map);
}

/*!
 * @brief This function returns a constant reference to member var_array_map
 * @return Constant reference to member var_array_map
 */
const std::array<std::map<int32_t, int32_t>, 2>& ArraySingleDimensionLiteralsMap::var_array_map() const
{
    return m_var_array_map;
}

/*!
 * @brief This function returns a reference to member var_array_map
 * @return Reference to member var_array_map
 */
std::array<std::map<int32_t, int32_t>, 2>& ArraySingleDimensionLiteralsMap::var_array_map()
{
    return m_var_array_map;
}


size_t ArraySingleDimensionLiteralsMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsMap_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsMap::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsUnion::ArraySingleDimensionLiteralsUnion()
{
    // InnerUnionHelper m_var_array_union


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsUnion::~ArraySingleDimensionLiteralsUnion()
{
}

ArraySingleDimensionLiteralsUnion::ArraySingleDimensionLiteralsUnion(
        const ArraySingleDimensionLiteralsUnion& x)
{
    m_var_array_union = x.m_var_array_union;
}

ArraySingleDimensionLiteralsUnion::ArraySingleDimensionLiteralsUnion(
        ArraySingleDimensionLiteralsUnion&& x) noexcept 
{
    m_var_array_union = std::move(x.m_var_array_union);
}

ArraySingleDimensionLiteralsUnion& ArraySingleDimensionLiteralsUnion::operator =(
        const ArraySingleDimensionLiteralsUnion& x)
{

    m_var_array_union = x.m_var_array_union;

    return *this;
}

ArraySingleDimensionLiteralsUnion& ArraySingleDimensionLiteralsUnion::operator =(
        ArraySingleDimensionLiteralsUnion&& x) noexcept
{

    m_var_array_union = std::move(x.m_var_array_union);

    return *this;
}

bool ArraySingleDimensionLiteralsUnion::operator ==(
        const ArraySingleDimensionLiteralsUnion& x) const
{

    return (m_var_array_union == x.m_var_array_union);
}

bool ArraySingleDimensionLiteralsUnion::operator !=(
        const ArraySingleDimensionLiteralsUnion& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnion_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsUnion::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_union().size(); ++a)
    {

            current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_array_union().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_union;

}

void ArraySingleDimensionLiteralsUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_union;

}

/*!
 * @brief This function copies the value in member var_array_union
 * @param _var_array_union New value to be copied in member var_array_union
 */
void ArraySingleDimensionLiteralsUnion::var_array_union(
        const std::array<InnerUnionHelper, 10>& _var_array_union)
{
    m_var_array_union = _var_array_union;
}

/*!
 * @brief This function moves the value in member var_array_union
 * @param _var_array_union New value to be moved in member var_array_union
 */
void ArraySingleDimensionLiteralsUnion::var_array_union(
        std::array<InnerUnionHelper, 10>&& _var_array_union)
{
    m_var_array_union = std::move(_var_array_union);
}

/*!
 * @brief This function returns a constant reference to member var_array_union
 * @return Constant reference to member var_array_union
 */
const std::array<InnerUnionHelper, 10>& ArraySingleDimensionLiteralsUnion::var_array_union() const
{
    return m_var_array_union;
}

/*!
 * @brief This function returns a reference to member var_array_union
 * @return Reference to member var_array_union
 */
std::array<InnerUnionHelper, 10>& ArraySingleDimensionLiteralsUnion::var_array_union()
{
    return m_var_array_union;
}


size_t ArraySingleDimensionLiteralsUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsUnion_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsUnion::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsStructure::ArraySingleDimensionLiteralsStructure()
{
    // InnerStructureHelper m_var_array_structure


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsStructure::~ArraySingleDimensionLiteralsStructure()
{
}

ArraySingleDimensionLiteralsStructure::ArraySingleDimensionLiteralsStructure(
        const ArraySingleDimensionLiteralsStructure& x)
{
    m_var_array_structure = x.m_var_array_structure;
}

ArraySingleDimensionLiteralsStructure::ArraySingleDimensionLiteralsStructure(
        ArraySingleDimensionLiteralsStructure&& x) noexcept 
{
    m_var_array_structure = std::move(x.m_var_array_structure);
}

ArraySingleDimensionLiteralsStructure& ArraySingleDimensionLiteralsStructure::operator =(
        const ArraySingleDimensionLiteralsStructure& x)
{

    m_var_array_structure = x.m_var_array_structure;

    return *this;
}

ArraySingleDimensionLiteralsStructure& ArraySingleDimensionLiteralsStructure::operator =(
        ArraySingleDimensionLiteralsStructure&& x) noexcept
{

    m_var_array_structure = std::move(x.m_var_array_structure);

    return *this;
}

bool ArraySingleDimensionLiteralsStructure::operator ==(
        const ArraySingleDimensionLiteralsStructure& x) const
{

    return (m_var_array_structure == x.m_var_array_structure);
}

bool ArraySingleDimensionLiteralsStructure::operator !=(
        const ArraySingleDimensionLiteralsStructure& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsStructure_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsStructure::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_structure().size(); ++a)
    {

            current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_array_structure().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_structure;

}

void ArraySingleDimensionLiteralsStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_structure;

}

/*!
 * @brief This function copies the value in member var_array_structure
 * @param _var_array_structure New value to be copied in member var_array_structure
 */
void ArraySingleDimensionLiteralsStructure::var_array_structure(
        const std::array<InnerStructureHelper, 5>& _var_array_structure)
{
    m_var_array_structure = _var_array_structure;
}

/*!
 * @brief This function moves the value in member var_array_structure
 * @param _var_array_structure New value to be moved in member var_array_structure
 */
void ArraySingleDimensionLiteralsStructure::var_array_structure(
        std::array<InnerStructureHelper, 5>&& _var_array_structure)
{
    m_var_array_structure = std::move(_var_array_structure);
}

/*!
 * @brief This function returns a constant reference to member var_array_structure
 * @return Constant reference to member var_array_structure
 */
const std::array<InnerStructureHelper, 5>& ArraySingleDimensionLiteralsStructure::var_array_structure() const
{
    return m_var_array_structure;
}

/*!
 * @brief This function returns a reference to member var_array_structure
 * @return Reference to member var_array_structure
 */
std::array<InnerStructureHelper, 5>& ArraySingleDimensionLiteralsStructure::var_array_structure()
{
    return m_var_array_structure;
}


size_t ArraySingleDimensionLiteralsStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsStructure_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsStructure::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArraySingleDimensionLiteralsBitset::ArraySingleDimensionLiteralsBitset()
{
    // InnerBitsetHelper m_var_array_bitset


    // Just to register all known types
    registerarraysTypes();
}

ArraySingleDimensionLiteralsBitset::~ArraySingleDimensionLiteralsBitset()
{
}

ArraySingleDimensionLiteralsBitset::ArraySingleDimensionLiteralsBitset(
        const ArraySingleDimensionLiteralsBitset& x)
{
    m_var_array_bitset = x.m_var_array_bitset;
}

ArraySingleDimensionLiteralsBitset::ArraySingleDimensionLiteralsBitset(
        ArraySingleDimensionLiteralsBitset&& x) noexcept 
{
    m_var_array_bitset = std::move(x.m_var_array_bitset);
}

ArraySingleDimensionLiteralsBitset& ArraySingleDimensionLiteralsBitset::operator =(
        const ArraySingleDimensionLiteralsBitset& x)
{

    m_var_array_bitset = x.m_var_array_bitset;

    return *this;
}

ArraySingleDimensionLiteralsBitset& ArraySingleDimensionLiteralsBitset::operator =(
        ArraySingleDimensionLiteralsBitset&& x) noexcept
{

    m_var_array_bitset = std::move(x.m_var_array_bitset);

    return *this;
}

bool ArraySingleDimensionLiteralsBitset::operator ==(
        const ArraySingleDimensionLiteralsBitset& x) const
{

    return (m_var_array_bitset == x.m_var_array_bitset);
}

bool ArraySingleDimensionLiteralsBitset::operator !=(
        const ArraySingleDimensionLiteralsBitset& x) const
{
    return !(*this == x);
}

size_t ArraySingleDimensionLiteralsBitset::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBitset_max_cdr_typesize;
}

size_t ArraySingleDimensionLiteralsBitset::getCdrSerializedSize(
        const ArraySingleDimensionLiteralsBitset& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bitset().size(); ++a)
    {

            current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_array_bitset().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void ArraySingleDimensionLiteralsBitset::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_bitset;

}

void ArraySingleDimensionLiteralsBitset::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_bitset;

}

/*!
 * @brief This function copies the value in member var_array_bitset
 * @param _var_array_bitset New value to be copied in member var_array_bitset
 */
void ArraySingleDimensionLiteralsBitset::var_array_bitset(
        const std::array<InnerBitsetHelper, 10>& _var_array_bitset)
{
    m_var_array_bitset = _var_array_bitset;
}

/*!
 * @brief This function moves the value in member var_array_bitset
 * @param _var_array_bitset New value to be moved in member var_array_bitset
 */
void ArraySingleDimensionLiteralsBitset::var_array_bitset(
        std::array<InnerBitsetHelper, 10>&& _var_array_bitset)
{
    m_var_array_bitset = std::move(_var_array_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitset
 * @return Constant reference to member var_array_bitset
 */
const std::array<InnerBitsetHelper, 10>& ArraySingleDimensionLiteralsBitset::var_array_bitset() const
{
    return m_var_array_bitset;
}

/*!
 * @brief This function returns a reference to member var_array_bitset
 * @return Reference to member var_array_bitset
 */
std::array<InnerBitsetHelper, 10>& ArraySingleDimensionLiteralsBitset::var_array_bitset()
{
    return m_var_array_bitset;
}


size_t ArraySingleDimensionLiteralsBitset::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySingleDimensionLiteralsBitset_max_key_cdr_typesize;
}

bool ArraySingleDimensionLiteralsBitset::isKeyDefined()
{
    return false;
}

void ArraySingleDimensionLiteralsBitset::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsShort::ArrayMultiDimensionLiteralsShort()
{
    // short m_var_array_short
    memset(&m_var_array_short, 0, (5 * 10 * 2) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsShort::~ArrayMultiDimensionLiteralsShort()
{
}

ArrayMultiDimensionLiteralsShort::ArrayMultiDimensionLiteralsShort(
        const ArrayMultiDimensionLiteralsShort& x)
{
    m_var_array_short = x.m_var_array_short;
}

ArrayMultiDimensionLiteralsShort::ArrayMultiDimensionLiteralsShort(
        ArrayMultiDimensionLiteralsShort&& x) noexcept 
{
    m_var_array_short = std::move(x.m_var_array_short);
}

ArrayMultiDimensionLiteralsShort& ArrayMultiDimensionLiteralsShort::operator =(
        const ArrayMultiDimensionLiteralsShort& x)
{

    m_var_array_short = x.m_var_array_short;

    return *this;
}

ArrayMultiDimensionLiteralsShort& ArrayMultiDimensionLiteralsShort::operator =(
        ArrayMultiDimensionLiteralsShort&& x) noexcept
{

    m_var_array_short = std::move(x.m_var_array_short);

    return *this;
}

bool ArrayMultiDimensionLiteralsShort::operator ==(
        const ArrayMultiDimensionLiteralsShort& x) const
{

    return (m_var_array_short == x.m_var_array_short);
}

bool ArrayMultiDimensionLiteralsShort::operator !=(
        const ArrayMultiDimensionLiteralsShort& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsShort_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsShort::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 2) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_short.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_short[b].size(); ++c)
        {
            scdr << m_var_array_short[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_short.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_short[e].size(); ++f)
        {
            dcdr >> m_var_array_short[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_short
 * @param _var_array_short New value to be copied in member var_array_short
 */
void ArrayMultiDimensionLiteralsShort::var_array_short(
        const std::array<std::array<std::array<int16_t, 2>, 10>, 5>& _var_array_short)
{
    m_var_array_short = _var_array_short;
}

/*!
 * @brief This function moves the value in member var_array_short
 * @param _var_array_short New value to be moved in member var_array_short
 */
void ArrayMultiDimensionLiteralsShort::var_array_short(
        std::array<std::array<std::array<int16_t, 2>, 10>, 5>&& _var_array_short)
{
    m_var_array_short = std::move(_var_array_short);
}

/*!
 * @brief This function returns a constant reference to member var_array_short
 * @return Constant reference to member var_array_short
 */
const std::array<std::array<std::array<int16_t, 2>, 10>, 5>& ArrayMultiDimensionLiteralsShort::var_array_short() const
{
    return m_var_array_short;
}

/*!
 * @brief This function returns a reference to member var_array_short
 * @return Reference to member var_array_short
 */
std::array<std::array<std::array<int16_t, 2>, 10>, 5>& ArrayMultiDimensionLiteralsShort::var_array_short()
{
    return m_var_array_short;
}


size_t ArrayMultiDimensionLiteralsShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsShort_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsShort::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsUShort::ArrayMultiDimensionLiteralsUShort()
{
    // unsigned short m_var_array_ushort
    memset(&m_var_array_ushort, 0, (5 * 10 * 5) * 2);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsUShort::~ArrayMultiDimensionLiteralsUShort()
{
}

ArrayMultiDimensionLiteralsUShort::ArrayMultiDimensionLiteralsUShort(
        const ArrayMultiDimensionLiteralsUShort& x)
{
    m_var_array_ushort = x.m_var_array_ushort;
}

ArrayMultiDimensionLiteralsUShort::ArrayMultiDimensionLiteralsUShort(
        ArrayMultiDimensionLiteralsUShort&& x) noexcept 
{
    m_var_array_ushort = std::move(x.m_var_array_ushort);
}

ArrayMultiDimensionLiteralsUShort& ArrayMultiDimensionLiteralsUShort::operator =(
        const ArrayMultiDimensionLiteralsUShort& x)
{

    m_var_array_ushort = x.m_var_array_ushort;

    return *this;
}

ArrayMultiDimensionLiteralsUShort& ArrayMultiDimensionLiteralsUShort::operator =(
        ArrayMultiDimensionLiteralsUShort&& x) noexcept
{

    m_var_array_ushort = std::move(x.m_var_array_ushort);

    return *this;
}

bool ArrayMultiDimensionLiteralsUShort::operator ==(
        const ArrayMultiDimensionLiteralsUShort& x) const
{

    return (m_var_array_ushort == x.m_var_array_ushort);
}

bool ArrayMultiDimensionLiteralsUShort::operator !=(
        const ArrayMultiDimensionLiteralsUShort& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsUShort::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsUShort_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsUShort::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsUShort& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 5) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsUShort::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ushort.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ushort[b].size(); ++c)
        {
            scdr << m_var_array_ushort[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsUShort::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ushort.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ushort[e].size(); ++f)
        {
            dcdr >> m_var_array_ushort[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ushort
 * @param _var_array_ushort New value to be copied in member var_array_ushort
 */
void ArrayMultiDimensionLiteralsUShort::var_array_ushort(
        const std::array<std::array<std::array<uint16_t, 5>, 10>, 5>& _var_array_ushort)
{
    m_var_array_ushort = _var_array_ushort;
}

/*!
 * @brief This function moves the value in member var_array_ushort
 * @param _var_array_ushort New value to be moved in member var_array_ushort
 */
void ArrayMultiDimensionLiteralsUShort::var_array_ushort(
        std::array<std::array<std::array<uint16_t, 5>, 10>, 5>&& _var_array_ushort)
{
    m_var_array_ushort = std::move(_var_array_ushort);
}

/*!
 * @brief This function returns a constant reference to member var_array_ushort
 * @return Constant reference to member var_array_ushort
 */
const std::array<std::array<std::array<uint16_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsUShort::var_array_ushort() const
{
    return m_var_array_ushort;
}

/*!
 * @brief This function returns a reference to member var_array_ushort
 * @return Reference to member var_array_ushort
 */
std::array<std::array<std::array<uint16_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsUShort::var_array_ushort()
{
    return m_var_array_ushort;
}


size_t ArrayMultiDimensionLiteralsUShort::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsUShort_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsUShort::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsUShort::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsLong::ArrayMultiDimensionLiteralsLong()
{
    // long m_var_array_long
    memset(&m_var_array_long, 0, (10 * 5 * 5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsLong::~ArrayMultiDimensionLiteralsLong()
{
}

ArrayMultiDimensionLiteralsLong::ArrayMultiDimensionLiteralsLong(
        const ArrayMultiDimensionLiteralsLong& x)
{
    m_var_array_long = x.m_var_array_long;
}

ArrayMultiDimensionLiteralsLong::ArrayMultiDimensionLiteralsLong(
        ArrayMultiDimensionLiteralsLong&& x) noexcept 
{
    m_var_array_long = std::move(x.m_var_array_long);
}

ArrayMultiDimensionLiteralsLong& ArrayMultiDimensionLiteralsLong::operator =(
        const ArrayMultiDimensionLiteralsLong& x)
{

    m_var_array_long = x.m_var_array_long;

    return *this;
}

ArrayMultiDimensionLiteralsLong& ArrayMultiDimensionLiteralsLong::operator =(
        ArrayMultiDimensionLiteralsLong&& x) noexcept
{

    m_var_array_long = std::move(x.m_var_array_long);

    return *this;
}

bool ArrayMultiDimensionLiteralsLong::operator ==(
        const ArrayMultiDimensionLiteralsLong& x) const
{

    return (m_var_array_long == x.m_var_array_long);
}

bool ArrayMultiDimensionLiteralsLong::operator !=(
        const ArrayMultiDimensionLiteralsLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsLong::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 5 * 5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_long.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_long[b].size(); ++c)
        {
            scdr << m_var_array_long[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_long.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_long[e].size(); ++f)
        {
            dcdr >> m_var_array_long[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_long
 * @param _var_array_long New value to be copied in member var_array_long
 */
void ArrayMultiDimensionLiteralsLong::var_array_long(
        const std::array<std::array<std::array<int32_t, 5>, 5>, 10>& _var_array_long)
{
    m_var_array_long = _var_array_long;
}

/*!
 * @brief This function moves the value in member var_array_long
 * @param _var_array_long New value to be moved in member var_array_long
 */
void ArrayMultiDimensionLiteralsLong::var_array_long(
        std::array<std::array<std::array<int32_t, 5>, 5>, 10>&& _var_array_long)
{
    m_var_array_long = std::move(_var_array_long);
}

/*!
 * @brief This function returns a constant reference to member var_array_long
 * @return Constant reference to member var_array_long
 */
const std::array<std::array<std::array<int32_t, 5>, 5>, 10>& ArrayMultiDimensionLiteralsLong::var_array_long() const
{
    return m_var_array_long;
}

/*!
 * @brief This function returns a reference to member var_array_long
 * @return Reference to member var_array_long
 */
std::array<std::array<std::array<int32_t, 5>, 5>, 10>& ArrayMultiDimensionLiteralsLong::var_array_long()
{
    return m_var_array_long;
}


size_t ArrayMultiDimensionLiteralsLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsULong::ArrayMultiDimensionLiteralsULong()
{
    // unsigned long m_var_array_ulong
    memset(&m_var_array_ulong, 0, (10 * 10 * 5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsULong::~ArrayMultiDimensionLiteralsULong()
{
}

ArrayMultiDimensionLiteralsULong::ArrayMultiDimensionLiteralsULong(
        const ArrayMultiDimensionLiteralsULong& x)
{
    m_var_array_ulong = x.m_var_array_ulong;
}

ArrayMultiDimensionLiteralsULong::ArrayMultiDimensionLiteralsULong(
        ArrayMultiDimensionLiteralsULong&& x) noexcept 
{
    m_var_array_ulong = std::move(x.m_var_array_ulong);
}

ArrayMultiDimensionLiteralsULong& ArrayMultiDimensionLiteralsULong::operator =(
        const ArrayMultiDimensionLiteralsULong& x)
{

    m_var_array_ulong = x.m_var_array_ulong;

    return *this;
}

ArrayMultiDimensionLiteralsULong& ArrayMultiDimensionLiteralsULong::operator =(
        ArrayMultiDimensionLiteralsULong&& x) noexcept
{

    m_var_array_ulong = std::move(x.m_var_array_ulong);

    return *this;
}

bool ArrayMultiDimensionLiteralsULong::operator ==(
        const ArrayMultiDimensionLiteralsULong& x) const
{

    return (m_var_array_ulong == x.m_var_array_ulong);
}

bool ArrayMultiDimensionLiteralsULong::operator !=(
        const ArrayMultiDimensionLiteralsULong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsULong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsULong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsULong::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsULong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsULong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ulong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ulong[b].size(); ++c)
        {
            scdr << m_var_array_ulong[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsULong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ulong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ulong[e].size(); ++f)
        {
            dcdr >> m_var_array_ulong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ulong
 * @param _var_array_ulong New value to be copied in member var_array_ulong
 */
void ArrayMultiDimensionLiteralsULong::var_array_ulong(
        const std::array<std::array<std::array<uint32_t, 5>, 10>, 10>& _var_array_ulong)
{
    m_var_array_ulong = _var_array_ulong;
}

/*!
 * @brief This function moves the value in member var_array_ulong
 * @param _var_array_ulong New value to be moved in member var_array_ulong
 */
void ArrayMultiDimensionLiteralsULong::var_array_ulong(
        std::array<std::array<std::array<uint32_t, 5>, 10>, 10>&& _var_array_ulong)
{
    m_var_array_ulong = std::move(_var_array_ulong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulong
 * @return Constant reference to member var_array_ulong
 */
const std::array<std::array<std::array<uint32_t, 5>, 10>, 10>& ArrayMultiDimensionLiteralsULong::var_array_ulong() const
{
    return m_var_array_ulong;
}

/*!
 * @brief This function returns a reference to member var_array_ulong
 * @return Reference to member var_array_ulong
 */
std::array<std::array<std::array<uint32_t, 5>, 10>, 10>& ArrayMultiDimensionLiteralsULong::var_array_ulong()
{
    return m_var_array_ulong;
}


size_t ArrayMultiDimensionLiteralsULong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsULong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsULong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsULong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsLongLong::ArrayMultiDimensionLiteralsLongLong()
{
    // long long m_var_array_longlong
    memset(&m_var_array_longlong, 0, (5 * 10 * 5) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsLongLong::~ArrayMultiDimensionLiteralsLongLong()
{
}

ArrayMultiDimensionLiteralsLongLong::ArrayMultiDimensionLiteralsLongLong(
        const ArrayMultiDimensionLiteralsLongLong& x)
{
    m_var_array_longlong = x.m_var_array_longlong;
}

ArrayMultiDimensionLiteralsLongLong::ArrayMultiDimensionLiteralsLongLong(
        ArrayMultiDimensionLiteralsLongLong&& x) noexcept 
{
    m_var_array_longlong = std::move(x.m_var_array_longlong);
}

ArrayMultiDimensionLiteralsLongLong& ArrayMultiDimensionLiteralsLongLong::operator =(
        const ArrayMultiDimensionLiteralsLongLong& x)
{

    m_var_array_longlong = x.m_var_array_longlong;

    return *this;
}

ArrayMultiDimensionLiteralsLongLong& ArrayMultiDimensionLiteralsLongLong::operator =(
        ArrayMultiDimensionLiteralsLongLong&& x) noexcept
{

    m_var_array_longlong = std::move(x.m_var_array_longlong);

    return *this;
}

bool ArrayMultiDimensionLiteralsLongLong::operator ==(
        const ArrayMultiDimensionLiteralsLongLong& x) const
{

    return (m_var_array_longlong == x.m_var_array_longlong);
}

bool ArrayMultiDimensionLiteralsLongLong::operator !=(
        const ArrayMultiDimensionLiteralsLongLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsLongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLongLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsLongLong::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsLongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 5) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsLongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_longlong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_longlong[b].size(); ++c)
        {
            scdr << m_var_array_longlong[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsLongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_longlong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_longlong[e].size(); ++f)
        {
            dcdr >> m_var_array_longlong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_longlong
 * @param _var_array_longlong New value to be copied in member var_array_longlong
 */
void ArrayMultiDimensionLiteralsLongLong::var_array_longlong(
        const std::array<std::array<std::array<int64_t, 5>, 10>, 5>& _var_array_longlong)
{
    m_var_array_longlong = _var_array_longlong;
}

/*!
 * @brief This function moves the value in member var_array_longlong
 * @param _var_array_longlong New value to be moved in member var_array_longlong
 */
void ArrayMultiDimensionLiteralsLongLong::var_array_longlong(
        std::array<std::array<std::array<int64_t, 5>, 10>, 5>&& _var_array_longlong)
{
    m_var_array_longlong = std::move(_var_array_longlong);
}

/*!
 * @brief This function returns a constant reference to member var_array_longlong
 * @return Constant reference to member var_array_longlong
 */
const std::array<std::array<std::array<int64_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsLongLong::var_array_longlong() const
{
    return m_var_array_longlong;
}

/*!
 * @brief This function returns a reference to member var_array_longlong
 * @return Reference to member var_array_longlong
 */
std::array<std::array<std::array<int64_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsLongLong::var_array_longlong()
{
    return m_var_array_longlong;
}


size_t ArrayMultiDimensionLiteralsLongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLongLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsLongLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsLongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsULongLong::ArrayMultiDimensionLiteralsULongLong()
{
    // unsigned long long m_var_array_ulonglong
    memset(&m_var_array_ulonglong, 0, (10 * 10 * 10) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsULongLong::~ArrayMultiDimensionLiteralsULongLong()
{
}

ArrayMultiDimensionLiteralsULongLong::ArrayMultiDimensionLiteralsULongLong(
        const ArrayMultiDimensionLiteralsULongLong& x)
{
    m_var_array_ulonglong = x.m_var_array_ulonglong;
}

ArrayMultiDimensionLiteralsULongLong::ArrayMultiDimensionLiteralsULongLong(
        ArrayMultiDimensionLiteralsULongLong&& x) noexcept 
{
    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);
}

ArrayMultiDimensionLiteralsULongLong& ArrayMultiDimensionLiteralsULongLong::operator =(
        const ArrayMultiDimensionLiteralsULongLong& x)
{

    m_var_array_ulonglong = x.m_var_array_ulonglong;

    return *this;
}

ArrayMultiDimensionLiteralsULongLong& ArrayMultiDimensionLiteralsULongLong::operator =(
        ArrayMultiDimensionLiteralsULongLong&& x) noexcept
{

    m_var_array_ulonglong = std::move(x.m_var_array_ulonglong);

    return *this;
}

bool ArrayMultiDimensionLiteralsULongLong::operator ==(
        const ArrayMultiDimensionLiteralsULongLong& x) const
{

    return (m_var_array_ulonglong == x.m_var_array_ulonglong);
}

bool ArrayMultiDimensionLiteralsULongLong::operator !=(
        const ArrayMultiDimensionLiteralsULongLong& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsULongLong::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsULongLong_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsULongLong::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsULongLong& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsULongLong::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_ulonglong.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_ulonglong[b].size(); ++c)
        {
            scdr << m_var_array_ulonglong[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsULongLong::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_ulonglong.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_ulonglong[e].size(); ++f)
        {
            dcdr >> m_var_array_ulonglong[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be copied in member var_array_ulonglong
 */
void ArrayMultiDimensionLiteralsULongLong::var_array_ulonglong(
        const std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& _var_array_ulonglong)
{
    m_var_array_ulonglong = _var_array_ulonglong;
}

/*!
 * @brief This function moves the value in member var_array_ulonglong
 * @param _var_array_ulonglong New value to be moved in member var_array_ulonglong
 */
void ArrayMultiDimensionLiteralsULongLong::var_array_ulonglong(
        std::array<std::array<std::array<uint64_t, 10>, 10>, 10>&& _var_array_ulonglong)
{
    m_var_array_ulonglong = std::move(_var_array_ulonglong);
}

/*!
 * @brief This function returns a constant reference to member var_array_ulonglong
 * @return Constant reference to member var_array_ulonglong
 */
const std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& ArrayMultiDimensionLiteralsULongLong::var_array_ulonglong() const
{
    return m_var_array_ulonglong;
}

/*!
 * @brief This function returns a reference to member var_array_ulonglong
 * @return Reference to member var_array_ulonglong
 */
std::array<std::array<std::array<uint64_t, 10>, 10>, 10>& ArrayMultiDimensionLiteralsULongLong::var_array_ulonglong()
{
    return m_var_array_ulonglong;
}


size_t ArrayMultiDimensionLiteralsULongLong::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsULongLong_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsULongLong::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsULongLong::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsFloat::ArrayMultiDimensionLiteralsFloat()
{
    // float m_var_array_float
    memset(&m_var_array_float, 0, (10 * 5 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsFloat::~ArrayMultiDimensionLiteralsFloat()
{
}

ArrayMultiDimensionLiteralsFloat::ArrayMultiDimensionLiteralsFloat(
        const ArrayMultiDimensionLiteralsFloat& x)
{
    m_var_array_float = x.m_var_array_float;
}

ArrayMultiDimensionLiteralsFloat::ArrayMultiDimensionLiteralsFloat(
        ArrayMultiDimensionLiteralsFloat&& x) noexcept 
{
    m_var_array_float = std::move(x.m_var_array_float);
}

ArrayMultiDimensionLiteralsFloat& ArrayMultiDimensionLiteralsFloat::operator =(
        const ArrayMultiDimensionLiteralsFloat& x)
{

    m_var_array_float = x.m_var_array_float;

    return *this;
}

ArrayMultiDimensionLiteralsFloat& ArrayMultiDimensionLiteralsFloat::operator =(
        ArrayMultiDimensionLiteralsFloat&& x) noexcept
{

    m_var_array_float = std::move(x.m_var_array_float);

    return *this;
}

bool ArrayMultiDimensionLiteralsFloat::operator ==(
        const ArrayMultiDimensionLiteralsFloat& x) const
{

    return (m_var_array_float == x.m_var_array_float);
}

bool ArrayMultiDimensionLiteralsFloat::operator !=(
        const ArrayMultiDimensionLiteralsFloat& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsFloat_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsFloat::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 5 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_float.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_float[b].size(); ++c)
        {
            scdr << m_var_array_float[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_float.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_float[e].size(); ++f)
        {
            dcdr >> m_var_array_float[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_float
 * @param _var_array_float New value to be copied in member var_array_float
 */
void ArrayMultiDimensionLiteralsFloat::var_array_float(
        const std::array<std::array<std::array<float, 10>, 5>, 10>& _var_array_float)
{
    m_var_array_float = _var_array_float;
}

/*!
 * @brief This function moves the value in member var_array_float
 * @param _var_array_float New value to be moved in member var_array_float
 */
void ArrayMultiDimensionLiteralsFloat::var_array_float(
        std::array<std::array<std::array<float, 10>, 5>, 10>&& _var_array_float)
{
    m_var_array_float = std::move(_var_array_float);
}

/*!
 * @brief This function returns a constant reference to member var_array_float
 * @return Constant reference to member var_array_float
 */
const std::array<std::array<std::array<float, 10>, 5>, 10>& ArrayMultiDimensionLiteralsFloat::var_array_float() const
{
    return m_var_array_float;
}

/*!
 * @brief This function returns a reference to member var_array_float
 * @return Reference to member var_array_float
 */
std::array<std::array<std::array<float, 10>, 5>, 10>& ArrayMultiDimensionLiteralsFloat::var_array_float()
{
    return m_var_array_float;
}


size_t ArrayMultiDimensionLiteralsFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsFloat_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsFloat::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsDouble::ArrayMultiDimensionLiteralsDouble()
{
    // double m_var_array_double
    memset(&m_var_array_double, 0, (5 * 10 * 5) * 8);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsDouble::~ArrayMultiDimensionLiteralsDouble()
{
}

ArrayMultiDimensionLiteralsDouble::ArrayMultiDimensionLiteralsDouble(
        const ArrayMultiDimensionLiteralsDouble& x)
{
    m_var_array_double = x.m_var_array_double;
}

ArrayMultiDimensionLiteralsDouble::ArrayMultiDimensionLiteralsDouble(
        ArrayMultiDimensionLiteralsDouble&& x) noexcept 
{
    m_var_array_double = std::move(x.m_var_array_double);
}

ArrayMultiDimensionLiteralsDouble& ArrayMultiDimensionLiteralsDouble::operator =(
        const ArrayMultiDimensionLiteralsDouble& x)
{

    m_var_array_double = x.m_var_array_double;

    return *this;
}

ArrayMultiDimensionLiteralsDouble& ArrayMultiDimensionLiteralsDouble::operator =(
        ArrayMultiDimensionLiteralsDouble&& x) noexcept
{

    m_var_array_double = std::move(x.m_var_array_double);

    return *this;
}

bool ArrayMultiDimensionLiteralsDouble::operator ==(
        const ArrayMultiDimensionLiteralsDouble& x) const
{

    return (m_var_array_double == x.m_var_array_double);
}

bool ArrayMultiDimensionLiteralsDouble::operator !=(
        const ArrayMultiDimensionLiteralsDouble& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsDouble_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsDouble::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 5) * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_double.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_double[b].size(); ++c)
        {
            scdr << m_var_array_double[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_double.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_double[e].size(); ++f)
        {
            dcdr >> m_var_array_double[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_double
 * @param _var_array_double New value to be copied in member var_array_double
 */
void ArrayMultiDimensionLiteralsDouble::var_array_double(
        const std::array<std::array<std::array<double, 5>, 10>, 5>& _var_array_double)
{
    m_var_array_double = _var_array_double;
}

/*!
 * @brief This function moves the value in member var_array_double
 * @param _var_array_double New value to be moved in member var_array_double
 */
void ArrayMultiDimensionLiteralsDouble::var_array_double(
        std::array<std::array<std::array<double, 5>, 10>, 5>&& _var_array_double)
{
    m_var_array_double = std::move(_var_array_double);
}

/*!
 * @brief This function returns a constant reference to member var_array_double
 * @return Constant reference to member var_array_double
 */
const std::array<std::array<std::array<double, 5>, 10>, 5>& ArrayMultiDimensionLiteralsDouble::var_array_double() const
{
    return m_var_array_double;
}

/*!
 * @brief This function returns a reference to member var_array_double
 * @return Reference to member var_array_double
 */
std::array<std::array<std::array<double, 5>, 10>, 5>& ArrayMultiDimensionLiteralsDouble::var_array_double()
{
    return m_var_array_double;
}


size_t ArrayMultiDimensionLiteralsDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsDouble_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsDouble::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsLongDouble::ArrayMultiDimensionLiteralsLongDouble()
{
    // long double m_var_array_longdouble
    memset(&m_var_array_longdouble, 0, (5 * 5 * 10) * 16);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsLongDouble::~ArrayMultiDimensionLiteralsLongDouble()
{
}

ArrayMultiDimensionLiteralsLongDouble::ArrayMultiDimensionLiteralsLongDouble(
        const ArrayMultiDimensionLiteralsLongDouble& x)
{
    m_var_array_longdouble = x.m_var_array_longdouble;
}

ArrayMultiDimensionLiteralsLongDouble::ArrayMultiDimensionLiteralsLongDouble(
        ArrayMultiDimensionLiteralsLongDouble&& x) noexcept 
{
    m_var_array_longdouble = std::move(x.m_var_array_longdouble);
}

ArrayMultiDimensionLiteralsLongDouble& ArrayMultiDimensionLiteralsLongDouble::operator =(
        const ArrayMultiDimensionLiteralsLongDouble& x)
{

    m_var_array_longdouble = x.m_var_array_longdouble;

    return *this;
}

ArrayMultiDimensionLiteralsLongDouble& ArrayMultiDimensionLiteralsLongDouble::operator =(
        ArrayMultiDimensionLiteralsLongDouble&& x) noexcept
{

    m_var_array_longdouble = std::move(x.m_var_array_longdouble);

    return *this;
}

bool ArrayMultiDimensionLiteralsLongDouble::operator ==(
        const ArrayMultiDimensionLiteralsLongDouble& x) const
{

    return (m_var_array_longdouble == x.m_var_array_longdouble);
}

bool ArrayMultiDimensionLiteralsLongDouble::operator !=(
        const ArrayMultiDimensionLiteralsLongDouble& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsLongDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLongDouble_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsLongDouble::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsLongDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 5 * 10) * 16) + eprosima::fastcdr::Cdr::alignment(current_alignment, 16);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsLongDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_longdouble.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_longdouble[b].size(); ++c)
        {
            scdr << m_var_array_longdouble[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsLongDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_longdouble.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_longdouble[e].size(); ++f)
        {
            dcdr >> m_var_array_longdouble[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be copied in member var_array_longdouble
 */
void ArrayMultiDimensionLiteralsLongDouble::var_array_longdouble(
        const std::array<std::array<std::array<long double, 10>, 5>, 5>& _var_array_longdouble)
{
    m_var_array_longdouble = _var_array_longdouble;
}

/*!
 * @brief This function moves the value in member var_array_longdouble
 * @param _var_array_longdouble New value to be moved in member var_array_longdouble
 */
void ArrayMultiDimensionLiteralsLongDouble::var_array_longdouble(
        std::array<std::array<std::array<long double, 10>, 5>, 5>&& _var_array_longdouble)
{
    m_var_array_longdouble = std::move(_var_array_longdouble);
}

/*!
 * @brief This function returns a constant reference to member var_array_longdouble
 * @return Constant reference to member var_array_longdouble
 */
const std::array<std::array<std::array<long double, 10>, 5>, 5>& ArrayMultiDimensionLiteralsLongDouble::var_array_longdouble() const
{
    return m_var_array_longdouble;
}

/*!
 * @brief This function returns a reference to member var_array_longdouble
 * @return Reference to member var_array_longdouble
 */
std::array<std::array<std::array<long double, 10>, 5>, 5>& ArrayMultiDimensionLiteralsLongDouble::var_array_longdouble()
{
    return m_var_array_longdouble;
}


size_t ArrayMultiDimensionLiteralsLongDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsLongDouble_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsLongDouble::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsLongDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsBoolean::ArrayMultiDimensionLiteralsBoolean()
{
    // boolean m_var_array_boolean
    memset(&m_var_array_boolean, 0, (10 * 5 * 5) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsBoolean::~ArrayMultiDimensionLiteralsBoolean()
{
}

ArrayMultiDimensionLiteralsBoolean::ArrayMultiDimensionLiteralsBoolean(
        const ArrayMultiDimensionLiteralsBoolean& x)
{
    m_var_array_boolean = x.m_var_array_boolean;
}

ArrayMultiDimensionLiteralsBoolean::ArrayMultiDimensionLiteralsBoolean(
        ArrayMultiDimensionLiteralsBoolean&& x) noexcept 
{
    m_var_array_boolean = std::move(x.m_var_array_boolean);
}

ArrayMultiDimensionLiteralsBoolean& ArrayMultiDimensionLiteralsBoolean::operator =(
        const ArrayMultiDimensionLiteralsBoolean& x)
{

    m_var_array_boolean = x.m_var_array_boolean;

    return *this;
}

ArrayMultiDimensionLiteralsBoolean& ArrayMultiDimensionLiteralsBoolean::operator =(
        ArrayMultiDimensionLiteralsBoolean&& x) noexcept
{

    m_var_array_boolean = std::move(x.m_var_array_boolean);

    return *this;
}

bool ArrayMultiDimensionLiteralsBoolean::operator ==(
        const ArrayMultiDimensionLiteralsBoolean& x) const
{

    return (m_var_array_boolean == x.m_var_array_boolean);
}

bool ArrayMultiDimensionLiteralsBoolean::operator !=(
        const ArrayMultiDimensionLiteralsBoolean& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsBoolean::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoolean_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsBoolean::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsBoolean& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 5 * 5) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsBoolean::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_boolean.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_boolean[b].size(); ++c)
        {
            scdr << m_var_array_boolean[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsBoolean::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_boolean.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_boolean[e].size(); ++f)
        {
            dcdr >> m_var_array_boolean[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_boolean
 * @param _var_array_boolean New value to be copied in member var_array_boolean
 */
void ArrayMultiDimensionLiteralsBoolean::var_array_boolean(
        const std::array<std::array<std::array<bool, 5>, 5>, 10>& _var_array_boolean)
{
    m_var_array_boolean = _var_array_boolean;
}

/*!
 * @brief This function moves the value in member var_array_boolean
 * @param _var_array_boolean New value to be moved in member var_array_boolean
 */
void ArrayMultiDimensionLiteralsBoolean::var_array_boolean(
        std::array<std::array<std::array<bool, 5>, 5>, 10>&& _var_array_boolean)
{
    m_var_array_boolean = std::move(_var_array_boolean);
}

/*!
 * @brief This function returns a constant reference to member var_array_boolean
 * @return Constant reference to member var_array_boolean
 */
const std::array<std::array<std::array<bool, 5>, 5>, 10>& ArrayMultiDimensionLiteralsBoolean::var_array_boolean() const
{
    return m_var_array_boolean;
}

/*!
 * @brief This function returns a reference to member var_array_boolean
 * @return Reference to member var_array_boolean
 */
std::array<std::array<std::array<bool, 5>, 5>, 10>& ArrayMultiDimensionLiteralsBoolean::var_array_boolean()
{
    return m_var_array_boolean;
}


size_t ArrayMultiDimensionLiteralsBoolean::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoolean_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsBoolean::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsBoolean::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsOctet::ArrayMultiDimensionLiteralsOctet()
{
    // octet m_var_array_octet
    memset(&m_var_array_octet, 0, (5 * 10 * 5) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsOctet::~ArrayMultiDimensionLiteralsOctet()
{
}

ArrayMultiDimensionLiteralsOctet::ArrayMultiDimensionLiteralsOctet(
        const ArrayMultiDimensionLiteralsOctet& x)
{
    m_var_array_octet = x.m_var_array_octet;
}

ArrayMultiDimensionLiteralsOctet::ArrayMultiDimensionLiteralsOctet(
        ArrayMultiDimensionLiteralsOctet&& x) noexcept 
{
    m_var_array_octet = std::move(x.m_var_array_octet);
}

ArrayMultiDimensionLiteralsOctet& ArrayMultiDimensionLiteralsOctet::operator =(
        const ArrayMultiDimensionLiteralsOctet& x)
{

    m_var_array_octet = x.m_var_array_octet;

    return *this;
}

ArrayMultiDimensionLiteralsOctet& ArrayMultiDimensionLiteralsOctet::operator =(
        ArrayMultiDimensionLiteralsOctet&& x) noexcept
{

    m_var_array_octet = std::move(x.m_var_array_octet);

    return *this;
}

bool ArrayMultiDimensionLiteralsOctet::operator ==(
        const ArrayMultiDimensionLiteralsOctet& x) const
{

    return (m_var_array_octet == x.m_var_array_octet);
}

bool ArrayMultiDimensionLiteralsOctet::operator !=(
        const ArrayMultiDimensionLiteralsOctet& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsOctet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsOctet_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsOctet::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsOctet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 5) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsOctet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_octet.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_octet[b].size(); ++c)
        {
            scdr << m_var_array_octet[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsOctet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_octet.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_octet[e].size(); ++f)
        {
            dcdr >> m_var_array_octet[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_octet
 * @param _var_array_octet New value to be copied in member var_array_octet
 */
void ArrayMultiDimensionLiteralsOctet::var_array_octet(
        const std::array<std::array<std::array<uint8_t, 5>, 10>, 5>& _var_array_octet)
{
    m_var_array_octet = _var_array_octet;
}

/*!
 * @brief This function moves the value in member var_array_octet
 * @param _var_array_octet New value to be moved in member var_array_octet
 */
void ArrayMultiDimensionLiteralsOctet::var_array_octet(
        std::array<std::array<std::array<uint8_t, 5>, 10>, 5>&& _var_array_octet)
{
    m_var_array_octet = std::move(_var_array_octet);
}

/*!
 * @brief This function returns a constant reference to member var_array_octet
 * @return Constant reference to member var_array_octet
 */
const std::array<std::array<std::array<uint8_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsOctet::var_array_octet() const
{
    return m_var_array_octet;
}

/*!
 * @brief This function returns a reference to member var_array_octet
 * @return Reference to member var_array_octet
 */
std::array<std::array<std::array<uint8_t, 5>, 10>, 5>& ArrayMultiDimensionLiteralsOctet::var_array_octet()
{
    return m_var_array_octet;
}


size_t ArrayMultiDimensionLiteralsOctet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsOctet_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsOctet::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsOctet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsChar::ArrayMultiDimensionLiteralsChar()
{
    // char m_var_array_char
    memset(&m_var_array_char, 0, (10 * 5 * 10) * 1);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsChar::~ArrayMultiDimensionLiteralsChar()
{
}

ArrayMultiDimensionLiteralsChar::ArrayMultiDimensionLiteralsChar(
        const ArrayMultiDimensionLiteralsChar& x)
{
    m_var_array_char = x.m_var_array_char;
}

ArrayMultiDimensionLiteralsChar::ArrayMultiDimensionLiteralsChar(
        ArrayMultiDimensionLiteralsChar&& x) noexcept 
{
    m_var_array_char = std::move(x.m_var_array_char);
}

ArrayMultiDimensionLiteralsChar& ArrayMultiDimensionLiteralsChar::operator =(
        const ArrayMultiDimensionLiteralsChar& x)
{

    m_var_array_char = x.m_var_array_char;

    return *this;
}

ArrayMultiDimensionLiteralsChar& ArrayMultiDimensionLiteralsChar::operator =(
        ArrayMultiDimensionLiteralsChar&& x) noexcept
{

    m_var_array_char = std::move(x.m_var_array_char);

    return *this;
}

bool ArrayMultiDimensionLiteralsChar::operator ==(
        const ArrayMultiDimensionLiteralsChar& x) const
{

    return (m_var_array_char == x.m_var_array_char);
}

bool ArrayMultiDimensionLiteralsChar::operator !=(
        const ArrayMultiDimensionLiteralsChar& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsChar_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsChar::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 5 * 10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_char.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_char[b].size(); ++c)
        {
            scdr << m_var_array_char[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_char.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_char[e].size(); ++f)
        {
            dcdr >> m_var_array_char[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_char
 * @param _var_array_char New value to be copied in member var_array_char
 */
void ArrayMultiDimensionLiteralsChar::var_array_char(
        const std::array<std::array<std::array<char, 10>, 5>, 10>& _var_array_char)
{
    m_var_array_char = _var_array_char;
}

/*!
 * @brief This function moves the value in member var_array_char
 * @param _var_array_char New value to be moved in member var_array_char
 */
void ArrayMultiDimensionLiteralsChar::var_array_char(
        std::array<std::array<std::array<char, 10>, 5>, 10>&& _var_array_char)
{
    m_var_array_char = std::move(_var_array_char);
}

/*!
 * @brief This function returns a constant reference to member var_array_char
 * @return Constant reference to member var_array_char
 */
const std::array<std::array<std::array<char, 10>, 5>, 10>& ArrayMultiDimensionLiteralsChar::var_array_char() const
{
    return m_var_array_char;
}

/*!
 * @brief This function returns a reference to member var_array_char
 * @return Reference to member var_array_char
 */
std::array<std::array<std::array<char, 10>, 5>, 10>& ArrayMultiDimensionLiteralsChar::var_array_char()
{
    return m_var_array_char;
}


size_t ArrayMultiDimensionLiteralsChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsChar_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsChar::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsWChar::ArrayMultiDimensionLiteralsWChar()
{
    // wchar m_var_array_wchar
    memset(&m_var_array_wchar, 0, (10 * 10 * 5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsWChar::~ArrayMultiDimensionLiteralsWChar()
{
}

ArrayMultiDimensionLiteralsWChar::ArrayMultiDimensionLiteralsWChar(
        const ArrayMultiDimensionLiteralsWChar& x)
{
    m_var_array_wchar = x.m_var_array_wchar;
}

ArrayMultiDimensionLiteralsWChar::ArrayMultiDimensionLiteralsWChar(
        ArrayMultiDimensionLiteralsWChar&& x) noexcept 
{
    m_var_array_wchar = std::move(x.m_var_array_wchar);
}

ArrayMultiDimensionLiteralsWChar& ArrayMultiDimensionLiteralsWChar::operator =(
        const ArrayMultiDimensionLiteralsWChar& x)
{

    m_var_array_wchar = x.m_var_array_wchar;

    return *this;
}

ArrayMultiDimensionLiteralsWChar& ArrayMultiDimensionLiteralsWChar::operator =(
        ArrayMultiDimensionLiteralsWChar&& x) noexcept
{

    m_var_array_wchar = std::move(x.m_var_array_wchar);

    return *this;
}

bool ArrayMultiDimensionLiteralsWChar::operator ==(
        const ArrayMultiDimensionLiteralsWChar& x) const
{

    return (m_var_array_wchar == x.m_var_array_wchar);
}

bool ArrayMultiDimensionLiteralsWChar::operator !=(
        const ArrayMultiDimensionLiteralsWChar& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsWChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsWChar_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsWChar::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsWChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsWChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_wchar.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_wchar[b].size(); ++c)
        {
            scdr << m_var_array_wchar[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsWChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_wchar.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_wchar[e].size(); ++f)
        {
            dcdr >> m_var_array_wchar[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_wchar
 * @param _var_array_wchar New value to be copied in member var_array_wchar
 */
void ArrayMultiDimensionLiteralsWChar::var_array_wchar(
        const std::array<std::array<std::array<wchar_t, 5>, 10>, 10>& _var_array_wchar)
{
    m_var_array_wchar = _var_array_wchar;
}

/*!
 * @brief This function moves the value in member var_array_wchar
 * @param _var_array_wchar New value to be moved in member var_array_wchar
 */
void ArrayMultiDimensionLiteralsWChar::var_array_wchar(
        std::array<std::array<std::array<wchar_t, 5>, 10>, 10>&& _var_array_wchar)
{
    m_var_array_wchar = std::move(_var_array_wchar);
}

/*!
 * @brief This function returns a constant reference to member var_array_wchar
 * @return Constant reference to member var_array_wchar
 */
const std::array<std::array<std::array<wchar_t, 5>, 10>, 10>& ArrayMultiDimensionLiteralsWChar::var_array_wchar() const
{
    return m_var_array_wchar;
}

/*!
 * @brief This function returns a reference to member var_array_wchar
 * @return Reference to member var_array_wchar
 */
std::array<std::array<std::array<wchar_t, 5>, 10>, 10>& ArrayMultiDimensionLiteralsWChar::var_array_wchar()
{
    return m_var_array_wchar;
}


size_t ArrayMultiDimensionLiteralsWChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsWChar_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsWChar::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsWChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsString::ArrayMultiDimensionLiteralsString()
{
    // string m_var_array_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsString::~ArrayMultiDimensionLiteralsString()
{
}

ArrayMultiDimensionLiteralsString::ArrayMultiDimensionLiteralsString(
        const ArrayMultiDimensionLiteralsString& x)
{
    m_var_array_string = x.m_var_array_string;
}

ArrayMultiDimensionLiteralsString::ArrayMultiDimensionLiteralsString(
        ArrayMultiDimensionLiteralsString&& x) noexcept 
{
    m_var_array_string = std::move(x.m_var_array_string);
}

ArrayMultiDimensionLiteralsString& ArrayMultiDimensionLiteralsString::operator =(
        const ArrayMultiDimensionLiteralsString& x)
{

    m_var_array_string = x.m_var_array_string;

    return *this;
}

ArrayMultiDimensionLiteralsString& ArrayMultiDimensionLiteralsString::operator =(
        ArrayMultiDimensionLiteralsString&& x) noexcept
{

    m_var_array_string = std::move(x.m_var_array_string);

    return *this;
}

bool ArrayMultiDimensionLiteralsString::operator ==(
        const ArrayMultiDimensionLiteralsString& x) const
{

    return (m_var_array_string == x.m_var_array_string);
}

bool ArrayMultiDimensionLiteralsString::operator !=(
        const ArrayMultiDimensionLiteralsString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsString_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsString::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_string().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_string().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_string().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_string().at(a).at(b).at(c).size() + 1;


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_string.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_string[e].size(); ++f)
        {
            for (const auto& str : m_var_array_string[e][f])
            {
                scdr << str.c_str();
            }
        }

    }




}

void ArrayMultiDimensionLiteralsString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_string.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_string[h].size(); ++i)
        {
            for (auto& str : m_var_array_string[h][i])
            {
                dcdr >> str;}
        }

    }




}

/*!
 * @brief This function copies the value in member var_array_string
 * @param _var_array_string New value to be copied in member var_array_string
 */
void ArrayMultiDimensionLiteralsString::var_array_string(
        const std::array<std::array<std::array<std::string, 5>, 10>, 5>& _var_array_string)
{
    m_var_array_string = _var_array_string;
}

/*!
 * @brief This function moves the value in member var_array_string
 * @param _var_array_string New value to be moved in member var_array_string
 */
void ArrayMultiDimensionLiteralsString::var_array_string(
        std::array<std::array<std::array<std::string, 5>, 10>, 5>&& _var_array_string)
{
    m_var_array_string = std::move(_var_array_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_string
 * @return Constant reference to member var_array_string
 */
const std::array<std::array<std::array<std::string, 5>, 10>, 5>& ArrayMultiDimensionLiteralsString::var_array_string() const
{
    return m_var_array_string;
}

/*!
 * @brief This function returns a reference to member var_array_string
 * @return Reference to member var_array_string
 */
std::array<std::array<std::array<std::string, 5>, 10>, 5>& ArrayMultiDimensionLiteralsString::var_array_string()
{
    return m_var_array_string;
}


size_t ArrayMultiDimensionLiteralsString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsWString::ArrayMultiDimensionLiteralsWString()
{
    // wstring m_var_array_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsWString::~ArrayMultiDimensionLiteralsWString()
{
}

ArrayMultiDimensionLiteralsWString::ArrayMultiDimensionLiteralsWString(
        const ArrayMultiDimensionLiteralsWString& x)
{
    m_var_array_wstring = x.m_var_array_wstring;
}

ArrayMultiDimensionLiteralsWString::ArrayMultiDimensionLiteralsWString(
        ArrayMultiDimensionLiteralsWString&& x) noexcept 
{
    m_var_array_wstring = std::move(x.m_var_array_wstring);
}

ArrayMultiDimensionLiteralsWString& ArrayMultiDimensionLiteralsWString::operator =(
        const ArrayMultiDimensionLiteralsWString& x)
{

    m_var_array_wstring = x.m_var_array_wstring;

    return *this;
}

ArrayMultiDimensionLiteralsWString& ArrayMultiDimensionLiteralsWString::operator =(
        ArrayMultiDimensionLiteralsWString&& x) noexcept
{

    m_var_array_wstring = std::move(x.m_var_array_wstring);

    return *this;
}

bool ArrayMultiDimensionLiteralsWString::operator ==(
        const ArrayMultiDimensionLiteralsWString& x) const
{

    return (m_var_array_wstring == x.m_var_array_wstring);
}

bool ArrayMultiDimensionLiteralsWString::operator !=(
        const ArrayMultiDimensionLiteralsWString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsWString_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsWString::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_wstring().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_wstring().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_wstring().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_wstring().at(a).at(b).at(c).size() * 4);


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_wstring.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_wstring[e].size(); ++f)
        {
            scdr << m_var_array_wstring[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_wstring.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_wstring[h].size(); ++i)
        {
            dcdr >> m_var_array_wstring[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_wstring
 * @param _var_array_wstring New value to be copied in member var_array_wstring
 */
void ArrayMultiDimensionLiteralsWString::var_array_wstring(
        const std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& _var_array_wstring)
{
    m_var_array_wstring = _var_array_wstring;
}

/*!
 * @brief This function moves the value in member var_array_wstring
 * @param _var_array_wstring New value to be moved in member var_array_wstring
 */
void ArrayMultiDimensionLiteralsWString::var_array_wstring(
        std::array<std::array<std::array<std::wstring, 10>, 10>, 10>&& _var_array_wstring)
{
    m_var_array_wstring = std::move(_var_array_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_wstring
 * @return Constant reference to member var_array_wstring
 */
const std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& ArrayMultiDimensionLiteralsWString::var_array_wstring() const
{
    return m_var_array_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_wstring
 * @return Reference to member var_array_wstring
 */
std::array<std::array<std::array<std::wstring, 10>, 10>, 10>& ArrayMultiDimensionLiteralsWString::var_array_wstring()
{
    return m_var_array_wstring;
}


size_t ArrayMultiDimensionLiteralsWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsWString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsWString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsBoundedString::ArrayMultiDimensionLiteralsBoundedString()
{
    // Inner_alias_bounded_string_helper m_var_array_bounded_string


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsBoundedString::~ArrayMultiDimensionLiteralsBoundedString()
{
}

ArrayMultiDimensionLiteralsBoundedString::ArrayMultiDimensionLiteralsBoundedString(
        const ArrayMultiDimensionLiteralsBoundedString& x)
{
    m_var_array_bounded_string = x.m_var_array_bounded_string;
}

ArrayMultiDimensionLiteralsBoundedString::ArrayMultiDimensionLiteralsBoundedString(
        ArrayMultiDimensionLiteralsBoundedString&& x) noexcept 
{
    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);
}

ArrayMultiDimensionLiteralsBoundedString& ArrayMultiDimensionLiteralsBoundedString::operator =(
        const ArrayMultiDimensionLiteralsBoundedString& x)
{

    m_var_array_bounded_string = x.m_var_array_bounded_string;

    return *this;
}

ArrayMultiDimensionLiteralsBoundedString& ArrayMultiDimensionLiteralsBoundedString::operator =(
        ArrayMultiDimensionLiteralsBoundedString&& x) noexcept
{

    m_var_array_bounded_string = std::move(x.m_var_array_bounded_string);

    return *this;
}

bool ArrayMultiDimensionLiteralsBoundedString::operator ==(
        const ArrayMultiDimensionLiteralsBoundedString& x) const
{

    return (m_var_array_bounded_string == x.m_var_array_bounded_string);
}

bool ArrayMultiDimensionLiteralsBoundedString::operator !=(
        const ArrayMultiDimensionLiteralsBoundedString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsBoundedString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoundedString_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsBoundedString::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsBoundedString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_string().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bounded_string().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bounded_string().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.var_array_bounded_string().at(a).at(b).at(c).size() + 1;


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsBoundedString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bounded_string.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bounded_string[e].size(); ++f)
        {
            for (const auto& str : m_var_array_bounded_string[e][f])
            {
                scdr << str.c_str();
            }
        }

    }




}

void ArrayMultiDimensionLiteralsBoundedString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bounded_string.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bounded_string[h].size(); ++i)
        {
            for (auto& str : m_var_array_bounded_string[h][i])
            {
            {
                std::string aux_str;
                dcdr >> aux_str;
                str = aux_str.c_str();
            }}
        }

    }




}

/*!
 * @brief This function copies the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be copied in member var_array_bounded_string
 */
void ArrayMultiDimensionLiteralsBoundedString::var_array_bounded_string(
        const std::array<std::array<std::array<Inner_alias_bounded_string_helper, 5>, 10>, 5>& _var_array_bounded_string)
{
    m_var_array_bounded_string = _var_array_bounded_string;
}

/*!
 * @brief This function moves the value in member var_array_bounded_string
 * @param _var_array_bounded_string New value to be moved in member var_array_bounded_string
 */
void ArrayMultiDimensionLiteralsBoundedString::var_array_bounded_string(
        std::array<std::array<std::array<Inner_alias_bounded_string_helper, 5>, 10>, 5>&& _var_array_bounded_string)
{
    m_var_array_bounded_string = std::move(_var_array_bounded_string);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_string
 * @return Constant reference to member var_array_bounded_string
 */
const std::array<std::array<std::array<Inner_alias_bounded_string_helper, 5>, 10>, 5>& ArrayMultiDimensionLiteralsBoundedString::var_array_bounded_string() const
{
    return m_var_array_bounded_string;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_string
 * @return Reference to member var_array_bounded_string
 */
std::array<std::array<std::array<Inner_alias_bounded_string_helper, 5>, 10>, 5>& ArrayMultiDimensionLiteralsBoundedString::var_array_bounded_string()
{
    return m_var_array_bounded_string;
}


size_t ArrayMultiDimensionLiteralsBoundedString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoundedString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsBoundedString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsBoundedString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsBoundedWString::ArrayMultiDimensionLiteralsBoundedWString()
{
    // Inner_alias_bounded_wstring_helper m_var_array_bounded_wstring


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsBoundedWString::~ArrayMultiDimensionLiteralsBoundedWString()
{
}

ArrayMultiDimensionLiteralsBoundedWString::ArrayMultiDimensionLiteralsBoundedWString(
        const ArrayMultiDimensionLiteralsBoundedWString& x)
{
    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;
}

ArrayMultiDimensionLiteralsBoundedWString::ArrayMultiDimensionLiteralsBoundedWString(
        ArrayMultiDimensionLiteralsBoundedWString&& x) noexcept 
{
    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);
}

ArrayMultiDimensionLiteralsBoundedWString& ArrayMultiDimensionLiteralsBoundedWString::operator =(
        const ArrayMultiDimensionLiteralsBoundedWString& x)
{

    m_var_array_bounded_wstring = x.m_var_array_bounded_wstring;

    return *this;
}

ArrayMultiDimensionLiteralsBoundedWString& ArrayMultiDimensionLiteralsBoundedWString::operator =(
        ArrayMultiDimensionLiteralsBoundedWString&& x) noexcept
{

    m_var_array_bounded_wstring = std::move(x.m_var_array_bounded_wstring);

    return *this;
}

bool ArrayMultiDimensionLiteralsBoundedWString::operator ==(
        const ArrayMultiDimensionLiteralsBoundedWString& x) const
{

    return (m_var_array_bounded_wstring == x.m_var_array_bounded_wstring);
}

bool ArrayMultiDimensionLiteralsBoundedWString::operator !=(
        const ArrayMultiDimensionLiteralsBoundedWString& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsBoundedWString::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoundedWString_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsBoundedWString::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsBoundedWString& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bounded_wstring().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bounded_wstring().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bounded_wstring().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + (data.var_array_bounded_wstring().at(a).at(b).at(c).size() * 4);


            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsBoundedWString::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bounded_wstring.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bounded_wstring[e].size(); ++f)
        {
            scdr << m_var_array_bounded_wstring[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsBoundedWString::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bounded_wstring.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bounded_wstring[h].size(); ++i)
        {
            dcdr >> m_var_array_bounded_wstring[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be copied in member var_array_bounded_wstring
 */
void ArrayMultiDimensionLiteralsBoundedWString::var_array_bounded_wstring(
        const std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = _var_array_bounded_wstring;
}

/*!
 * @brief This function moves the value in member var_array_bounded_wstring
 * @param _var_array_bounded_wstring New value to be moved in member var_array_bounded_wstring
 */
void ArrayMultiDimensionLiteralsBoundedWString::var_array_bounded_wstring(
        std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>&& _var_array_bounded_wstring)
{
    m_var_array_bounded_wstring = std::move(_var_array_bounded_wstring);
}

/*!
 * @brief This function returns a constant reference to member var_array_bounded_wstring
 * @return Constant reference to member var_array_bounded_wstring
 */
const std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsBoundedWString::var_array_bounded_wstring() const
{
    return m_var_array_bounded_wstring;
}

/*!
 * @brief This function returns a reference to member var_array_bounded_wstring
 * @return Reference to member var_array_bounded_wstring
 */
std::array<std::array<std::array<Inner_alias_bounded_wstring_helper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsBoundedWString::var_array_bounded_wstring()
{
    return m_var_array_bounded_wstring;
}


size_t ArrayMultiDimensionLiteralsBoundedWString::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBoundedWString_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsBoundedWString::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsBoundedWString::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsEnum::ArrayMultiDimensionLiteralsEnum()
{
    // InnerEnumHelper m_var_array_enum
    memset(&m_var_array_enum, 0, (10 * 5 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsEnum::~ArrayMultiDimensionLiteralsEnum()
{
}

ArrayMultiDimensionLiteralsEnum::ArrayMultiDimensionLiteralsEnum(
        const ArrayMultiDimensionLiteralsEnum& x)
{
    m_var_array_enum = x.m_var_array_enum;
}

ArrayMultiDimensionLiteralsEnum::ArrayMultiDimensionLiteralsEnum(
        ArrayMultiDimensionLiteralsEnum&& x) noexcept 
{
    m_var_array_enum = std::move(x.m_var_array_enum);
}

ArrayMultiDimensionLiteralsEnum& ArrayMultiDimensionLiteralsEnum::operator =(
        const ArrayMultiDimensionLiteralsEnum& x)
{

    m_var_array_enum = x.m_var_array_enum;

    return *this;
}

ArrayMultiDimensionLiteralsEnum& ArrayMultiDimensionLiteralsEnum::operator =(
        ArrayMultiDimensionLiteralsEnum&& x) noexcept
{

    m_var_array_enum = std::move(x.m_var_array_enum);

    return *this;
}

bool ArrayMultiDimensionLiteralsEnum::operator ==(
        const ArrayMultiDimensionLiteralsEnum& x) const
{

    return (m_var_array_enum == x.m_var_array_enum);
}

bool ArrayMultiDimensionLiteralsEnum::operator !=(
        const ArrayMultiDimensionLiteralsEnum& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsEnum::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsEnum_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsEnum::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsEnum& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 5 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsEnum::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_enum.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_enum[b].size(); ++c)
        {
            scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_enum[b][c].data()), m_var_array_enum[b][c].size());
        }    

    }    

}

void ArrayMultiDimensionLiteralsEnum::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_enum.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_enum[e].size(); ++f)
        {
            dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_enum[e][f].data()), m_var_array_enum[e][f].size());
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_enum
 * @param _var_array_enum New value to be copied in member var_array_enum
 */
void ArrayMultiDimensionLiteralsEnum::var_array_enum(
        const std::array<std::array<std::array<InnerEnumHelper, 10>, 5>, 10>& _var_array_enum)
{
    m_var_array_enum = _var_array_enum;
}

/*!
 * @brief This function moves the value in member var_array_enum
 * @param _var_array_enum New value to be moved in member var_array_enum
 */
void ArrayMultiDimensionLiteralsEnum::var_array_enum(
        std::array<std::array<std::array<InnerEnumHelper, 10>, 5>, 10>&& _var_array_enum)
{
    m_var_array_enum = std::move(_var_array_enum);
}

/*!
 * @brief This function returns a constant reference to member var_array_enum
 * @return Constant reference to member var_array_enum
 */
const std::array<std::array<std::array<InnerEnumHelper, 10>, 5>, 10>& ArrayMultiDimensionLiteralsEnum::var_array_enum() const
{
    return m_var_array_enum;
}

/*!
 * @brief This function returns a reference to member var_array_enum
 * @return Reference to member var_array_enum
 */
std::array<std::array<std::array<InnerEnumHelper, 10>, 5>, 10>& ArrayMultiDimensionLiteralsEnum::var_array_enum()
{
    return m_var_array_enum;
}


size_t ArrayMultiDimensionLiteralsEnum::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsEnum_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsEnum::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsEnum::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsBitMask::ArrayMultiDimensionLiteralsBitMask()
{
    // InnerBitMaskHelper m_var_array_bitmask
    memset(&m_var_array_bitmask, 0, (5 * 10 * 5) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsBitMask::~ArrayMultiDimensionLiteralsBitMask()
{
}

ArrayMultiDimensionLiteralsBitMask::ArrayMultiDimensionLiteralsBitMask(
        const ArrayMultiDimensionLiteralsBitMask& x)
{
    m_var_array_bitmask = x.m_var_array_bitmask;
}

ArrayMultiDimensionLiteralsBitMask::ArrayMultiDimensionLiteralsBitMask(
        ArrayMultiDimensionLiteralsBitMask&& x) noexcept 
{
    m_var_array_bitmask = std::move(x.m_var_array_bitmask);
}

ArrayMultiDimensionLiteralsBitMask& ArrayMultiDimensionLiteralsBitMask::operator =(
        const ArrayMultiDimensionLiteralsBitMask& x)
{

    m_var_array_bitmask = x.m_var_array_bitmask;

    return *this;
}

ArrayMultiDimensionLiteralsBitMask& ArrayMultiDimensionLiteralsBitMask::operator =(
        ArrayMultiDimensionLiteralsBitMask&& x) noexcept
{

    m_var_array_bitmask = std::move(x.m_var_array_bitmask);

    return *this;
}

bool ArrayMultiDimensionLiteralsBitMask::operator ==(
        const ArrayMultiDimensionLiteralsBitMask& x) const
{

    return (m_var_array_bitmask == x.m_var_array_bitmask);
}

bool ArrayMultiDimensionLiteralsBitMask::operator !=(
        const ArrayMultiDimensionLiteralsBitMask& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsBitMask::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBitMask_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsBitMask::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsBitMask& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((5 * 10 * 5) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsBitMask::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_bitmask.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_bitmask[b].size(); ++c)
        {
            scdr.serializeArray(reinterpret_cast<const uint32_t*>(m_var_array_bitmask[b][c].data()), m_var_array_bitmask[b][c].size());
        }    

    }    

}

void ArrayMultiDimensionLiteralsBitMask::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_bitmask.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bitmask[e].size(); ++f)
        {
            dcdr.deserializeArray(reinterpret_cast<uint32_t*>(m_var_array_bitmask[e][f].data()), m_var_array_bitmask[e][f].size());
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be copied in member var_array_bitmask
 */
void ArrayMultiDimensionLiteralsBitMask::var_array_bitmask(
        const std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5>& _var_array_bitmask)
{
    m_var_array_bitmask = _var_array_bitmask;
}

/*!
 * @brief This function moves the value in member var_array_bitmask
 * @param _var_array_bitmask New value to be moved in member var_array_bitmask
 */
void ArrayMultiDimensionLiteralsBitMask::var_array_bitmask(
        std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5>&& _var_array_bitmask)
{
    m_var_array_bitmask = std::move(_var_array_bitmask);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitmask
 * @return Constant reference to member var_array_bitmask
 */
const std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5>& ArrayMultiDimensionLiteralsBitMask::var_array_bitmask() const
{
    return m_var_array_bitmask;
}

/*!
 * @brief This function returns a reference to member var_array_bitmask
 * @return Reference to member var_array_bitmask
 */
std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5>& ArrayMultiDimensionLiteralsBitMask::var_array_bitmask()
{
    return m_var_array_bitmask;
}


size_t ArrayMultiDimensionLiteralsBitMask::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBitMask_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsBitMask::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsBitMask::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsAlias::ArrayMultiDimensionLiteralsAlias()
{
    // InnerAliasHelper m_var_array_alias
    memset(&m_var_array_alias, 0, (10 * 10 * 10) * 4);


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsAlias::~ArrayMultiDimensionLiteralsAlias()
{
}

ArrayMultiDimensionLiteralsAlias::ArrayMultiDimensionLiteralsAlias(
        const ArrayMultiDimensionLiteralsAlias& x)
{
    m_var_array_alias = x.m_var_array_alias;
}

ArrayMultiDimensionLiteralsAlias::ArrayMultiDimensionLiteralsAlias(
        ArrayMultiDimensionLiteralsAlias&& x) noexcept 
{
    m_var_array_alias = std::move(x.m_var_array_alias);
}

ArrayMultiDimensionLiteralsAlias& ArrayMultiDimensionLiteralsAlias::operator =(
        const ArrayMultiDimensionLiteralsAlias& x)
{

    m_var_array_alias = x.m_var_array_alias;

    return *this;
}

ArrayMultiDimensionLiteralsAlias& ArrayMultiDimensionLiteralsAlias::operator =(
        ArrayMultiDimensionLiteralsAlias&& x) noexcept
{

    m_var_array_alias = std::move(x.m_var_array_alias);

    return *this;
}

bool ArrayMultiDimensionLiteralsAlias::operator ==(
        const ArrayMultiDimensionLiteralsAlias& x) const
{

    return (m_var_array_alias == x.m_var_array_alias);
}

bool ArrayMultiDimensionLiteralsAlias::operator !=(
        const ArrayMultiDimensionLiteralsAlias& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsAlias::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsAlias_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsAlias::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsAlias& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((10 * 10 * 10) * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsAlias::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t b = 0; b < m_var_array_alias.size(); ++b)
    {
        for (uint32_t c = 0; c < m_var_array_alias[b].size(); ++c)
        {
            scdr << m_var_array_alias[b][c];
        }    

    }    

}

void ArrayMultiDimensionLiteralsAlias::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t e = 0; e < m_var_array_alias.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_alias[e].size(); ++f)
        {
            dcdr >> m_var_array_alias[e][f];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_alias
 * @param _var_array_alias New value to be copied in member var_array_alias
 */
void ArrayMultiDimensionLiteralsAlias::var_array_alias(
        const std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& _var_array_alias)
{
    m_var_array_alias = _var_array_alias;
}

/*!
 * @brief This function moves the value in member var_array_alias
 * @param _var_array_alias New value to be moved in member var_array_alias
 */
void ArrayMultiDimensionLiteralsAlias::var_array_alias(
        std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>&& _var_array_alias)
{
    m_var_array_alias = std::move(_var_array_alias);
}

/*!
 * @brief This function returns a constant reference to member var_array_alias
 * @return Constant reference to member var_array_alias
 */
const std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsAlias::var_array_alias() const
{
    return m_var_array_alias;
}

/*!
 * @brief This function returns a reference to member var_array_alias
 * @return Reference to member var_array_alias
 */
std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsAlias::var_array_alias()
{
    return m_var_array_alias;
}


size_t ArrayMultiDimensionLiteralsAlias::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsAlias_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsAlias::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsAlias::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsSequence::ArrayMultiDimensionLiteralsSequence()
{
    // sequence<long> m_var_array_sequence


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsSequence::~ArrayMultiDimensionLiteralsSequence()
{
}

ArrayMultiDimensionLiteralsSequence::ArrayMultiDimensionLiteralsSequence(
        const ArrayMultiDimensionLiteralsSequence& x)
{
    m_var_array_sequence = x.m_var_array_sequence;
}

ArrayMultiDimensionLiteralsSequence::ArrayMultiDimensionLiteralsSequence(
        ArrayMultiDimensionLiteralsSequence&& x) noexcept 
{
    m_var_array_sequence = std::move(x.m_var_array_sequence);
}

ArrayMultiDimensionLiteralsSequence& ArrayMultiDimensionLiteralsSequence::operator =(
        const ArrayMultiDimensionLiteralsSequence& x)
{

    m_var_array_sequence = x.m_var_array_sequence;

    return *this;
}

ArrayMultiDimensionLiteralsSequence& ArrayMultiDimensionLiteralsSequence::operator =(
        ArrayMultiDimensionLiteralsSequence&& x) noexcept
{

    m_var_array_sequence = std::move(x.m_var_array_sequence);

    return *this;
}

bool ArrayMultiDimensionLiteralsSequence::operator ==(
        const ArrayMultiDimensionLiteralsSequence& x) const
{

    return (m_var_array_sequence == x.m_var_array_sequence);
}

bool ArrayMultiDimensionLiteralsSequence::operator !=(
        const ArrayMultiDimensionLiteralsSequence& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsSequence::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsSequence_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsSequence::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsSequence& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_sequence().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_sequence().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_sequence().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    if (data.var_array_sequence().at(a).at(b).at(c).size() > 0)
                    {
                        current_alignment += (data.var_array_sequence().at(a).at(b).at(c).size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    }



            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsSequence::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t f = 0; f < m_var_array_sequence.size(); ++f)
    {
        for (uint32_t g = 0; g < m_var_array_sequence[f].size(); ++g)
        {
            scdr << m_var_array_sequence[f][g];
        }    

    }    

}

void ArrayMultiDimensionLiteralsSequence::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t i = 0; i < m_var_array_sequence.size(); ++i)
    {
        for (uint32_t j = 0; j < m_var_array_sequence[i].size(); ++j)
        {
            dcdr >> m_var_array_sequence[i][j];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_sequence
 * @param _var_array_sequence New value to be copied in member var_array_sequence
 */
void ArrayMultiDimensionLiteralsSequence::var_array_sequence(
        const std::array<std::array<std::array<std::vector<int32_t>, 10>, 5>, 10>& _var_array_sequence)
{
    m_var_array_sequence = _var_array_sequence;
}

/*!
 * @brief This function moves the value in member var_array_sequence
 * @param _var_array_sequence New value to be moved in member var_array_sequence
 */
void ArrayMultiDimensionLiteralsSequence::var_array_sequence(
        std::array<std::array<std::array<std::vector<int32_t>, 10>, 5>, 10>&& _var_array_sequence)
{
    m_var_array_sequence = std::move(_var_array_sequence);
}

/*!
 * @brief This function returns a constant reference to member var_array_sequence
 * @return Constant reference to member var_array_sequence
 */
const std::array<std::array<std::array<std::vector<int32_t>, 10>, 5>, 10>& ArrayMultiDimensionLiteralsSequence::var_array_sequence() const
{
    return m_var_array_sequence;
}

/*!
 * @brief This function returns a reference to member var_array_sequence
 * @return Reference to member var_array_sequence
 */
std::array<std::array<std::array<std::vector<int32_t>, 10>, 5>, 10>& ArrayMultiDimensionLiteralsSequence::var_array_sequence()
{
    return m_var_array_sequence;
}


size_t ArrayMultiDimensionLiteralsSequence::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsSequence_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsSequence::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsSequence::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsMap::ArrayMultiDimensionLiteralsMap()
{
    // map<long, long> m_var_array_map


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsMap::~ArrayMultiDimensionLiteralsMap()
{
}

ArrayMultiDimensionLiteralsMap::ArrayMultiDimensionLiteralsMap(
        const ArrayMultiDimensionLiteralsMap& x)
{
    m_var_array_map = x.m_var_array_map;
}

ArrayMultiDimensionLiteralsMap::ArrayMultiDimensionLiteralsMap(
        ArrayMultiDimensionLiteralsMap&& x) noexcept 
{
    m_var_array_map = std::move(x.m_var_array_map);
}

ArrayMultiDimensionLiteralsMap& ArrayMultiDimensionLiteralsMap::operator =(
        const ArrayMultiDimensionLiteralsMap& x)
{

    m_var_array_map = x.m_var_array_map;

    return *this;
}

ArrayMultiDimensionLiteralsMap& ArrayMultiDimensionLiteralsMap::operator =(
        ArrayMultiDimensionLiteralsMap&& x) noexcept
{

    m_var_array_map = std::move(x.m_var_array_map);

    return *this;
}

bool ArrayMultiDimensionLiteralsMap::operator ==(
        const ArrayMultiDimensionLiteralsMap& x) const
{

    return (m_var_array_map == x.m_var_array_map);
}

bool ArrayMultiDimensionLiteralsMap::operator !=(
        const ArrayMultiDimensionLiteralsMap& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsMap_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsMap::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_map().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_map().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_map().at(a).at(b).size(); ++c)
            {

                    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                    for(auto d : data.var_array_map().at(a).at(b).at(c))
                    {
                        (void)d;

                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
                    }

            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_map.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_map[e].size(); ++f)
        {
            scdr << m_var_array_map[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_map.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_map[h].size(); ++i)
        {
            dcdr >> m_var_array_map[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_map
 * @param _var_array_map New value to be copied in member var_array_map
 */
void ArrayMultiDimensionLiteralsMap::var_array_map(
        const std::array<std::array<std::array<std::map<int32_t, int32_t>, 5>, 10>, 5>& _var_array_map)
{
    m_var_array_map = _var_array_map;
}

/*!
 * @brief This function moves the value in member var_array_map
 * @param _var_array_map New value to be moved in member var_array_map
 */
void ArrayMultiDimensionLiteralsMap::var_array_map(
        std::array<std::array<std::array<std::map<int32_t, int32_t>, 5>, 10>, 5>&& _var_array_map)
{
    m_var_array_map = std::move(_var_array_map);
}

/*!
 * @brief This function returns a constant reference to member var_array_map
 * @return Constant reference to member var_array_map
 */
const std::array<std::array<std::array<std::map<int32_t, int32_t>, 5>, 10>, 5>& ArrayMultiDimensionLiteralsMap::var_array_map() const
{
    return m_var_array_map;
}

/*!
 * @brief This function returns a reference to member var_array_map
 * @return Reference to member var_array_map
 */
std::array<std::array<std::array<std::map<int32_t, int32_t>, 5>, 10>, 5>& ArrayMultiDimensionLiteralsMap::var_array_map()
{
    return m_var_array_map;
}


size_t ArrayMultiDimensionLiteralsMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsMap_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsMap::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsUnion::ArrayMultiDimensionLiteralsUnion()
{
    // InnerUnionHelper m_var_array_union


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsUnion::~ArrayMultiDimensionLiteralsUnion()
{
}

ArrayMultiDimensionLiteralsUnion::ArrayMultiDimensionLiteralsUnion(
        const ArrayMultiDimensionLiteralsUnion& x)
{
    m_var_array_union = x.m_var_array_union;
}

ArrayMultiDimensionLiteralsUnion::ArrayMultiDimensionLiteralsUnion(
        ArrayMultiDimensionLiteralsUnion&& x) noexcept 
{
    m_var_array_union = std::move(x.m_var_array_union);
}

ArrayMultiDimensionLiteralsUnion& ArrayMultiDimensionLiteralsUnion::operator =(
        const ArrayMultiDimensionLiteralsUnion& x)
{

    m_var_array_union = x.m_var_array_union;

    return *this;
}

ArrayMultiDimensionLiteralsUnion& ArrayMultiDimensionLiteralsUnion::operator =(
        ArrayMultiDimensionLiteralsUnion&& x) noexcept
{

    m_var_array_union = std::move(x.m_var_array_union);

    return *this;
}

bool ArrayMultiDimensionLiteralsUnion::operator ==(
        const ArrayMultiDimensionLiteralsUnion& x) const
{

    return (m_var_array_union == x.m_var_array_union);
}

bool ArrayMultiDimensionLiteralsUnion::operator !=(
        const ArrayMultiDimensionLiteralsUnion& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsUnion::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsUnion_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsUnion::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_union().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_union().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_union().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerUnionHelper::getCdrSerializedSize(data.var_array_union().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_union.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_union[e].size(); ++f)
        {
            scdr << m_var_array_union[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsUnion::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_union.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_union[h].size(); ++i)
        {
            dcdr >> m_var_array_union[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_union
 * @param _var_array_union New value to be copied in member var_array_union
 */
void ArrayMultiDimensionLiteralsUnion::var_array_union(
        const std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& _var_array_union)
{
    m_var_array_union = _var_array_union;
}

/*!
 * @brief This function moves the value in member var_array_union
 * @param _var_array_union New value to be moved in member var_array_union
 */
void ArrayMultiDimensionLiteralsUnion::var_array_union(
        std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>&& _var_array_union)
{
    m_var_array_union = std::move(_var_array_union);
}

/*!
 * @brief This function returns a constant reference to member var_array_union
 * @return Constant reference to member var_array_union
 */
const std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsUnion::var_array_union() const
{
    return m_var_array_union;
}

/*!
 * @brief This function returns a reference to member var_array_union
 * @return Reference to member var_array_union
 */
std::array<std::array<std::array<InnerUnionHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsUnion::var_array_union()
{
    return m_var_array_union;
}


size_t ArrayMultiDimensionLiteralsUnion::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsUnion_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsUnion::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsUnion::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsStructure::ArrayMultiDimensionLiteralsStructure()
{
    // InnerStructureHelper m_var_array_structure


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsStructure::~ArrayMultiDimensionLiteralsStructure()
{
}

ArrayMultiDimensionLiteralsStructure::ArrayMultiDimensionLiteralsStructure(
        const ArrayMultiDimensionLiteralsStructure& x)
{
    m_var_array_structure = x.m_var_array_structure;
}

ArrayMultiDimensionLiteralsStructure::ArrayMultiDimensionLiteralsStructure(
        ArrayMultiDimensionLiteralsStructure&& x) noexcept 
{
    m_var_array_structure = std::move(x.m_var_array_structure);
}

ArrayMultiDimensionLiteralsStructure& ArrayMultiDimensionLiteralsStructure::operator =(
        const ArrayMultiDimensionLiteralsStructure& x)
{

    m_var_array_structure = x.m_var_array_structure;

    return *this;
}

ArrayMultiDimensionLiteralsStructure& ArrayMultiDimensionLiteralsStructure::operator =(
        ArrayMultiDimensionLiteralsStructure&& x) noexcept
{

    m_var_array_structure = std::move(x.m_var_array_structure);

    return *this;
}

bool ArrayMultiDimensionLiteralsStructure::operator ==(
        const ArrayMultiDimensionLiteralsStructure& x) const
{

    return (m_var_array_structure == x.m_var_array_structure);
}

bool ArrayMultiDimensionLiteralsStructure::operator !=(
        const ArrayMultiDimensionLiteralsStructure& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsStructure::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsStructure_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsStructure::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsStructure& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_structure().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_structure().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_structure().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerStructureHelper::getCdrSerializedSize(data.var_array_structure().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsStructure::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_structure.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_structure[e].size(); ++f)
        {
            scdr << m_var_array_structure[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsStructure::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_structure.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_structure[h].size(); ++i)
        {
            dcdr >> m_var_array_structure[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_structure
 * @param _var_array_structure New value to be copied in member var_array_structure
 */
void ArrayMultiDimensionLiteralsStructure::var_array_structure(
        const std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5>& _var_array_structure)
{
    m_var_array_structure = _var_array_structure;
}

/*!
 * @brief This function moves the value in member var_array_structure
 * @param _var_array_structure New value to be moved in member var_array_structure
 */
void ArrayMultiDimensionLiteralsStructure::var_array_structure(
        std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5>&& _var_array_structure)
{
    m_var_array_structure = std::move(_var_array_structure);
}

/*!
 * @brief This function returns a constant reference to member var_array_structure
 * @return Constant reference to member var_array_structure
 */
const std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5>& ArrayMultiDimensionLiteralsStructure::var_array_structure() const
{
    return m_var_array_structure;
}

/*!
 * @brief This function returns a reference to member var_array_structure
 * @return Reference to member var_array_structure
 */
std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5>& ArrayMultiDimensionLiteralsStructure::var_array_structure()
{
    return m_var_array_structure;
}


size_t ArrayMultiDimensionLiteralsStructure::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsStructure_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsStructure::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsStructure::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


ArrayMultiDimensionLiteralsBitSet::ArrayMultiDimensionLiteralsBitSet()
{
    // InnerBitsetHelper m_var_array_bitset


    // Just to register all known types
    registerarraysTypes();
}

ArrayMultiDimensionLiteralsBitSet::~ArrayMultiDimensionLiteralsBitSet()
{
}

ArrayMultiDimensionLiteralsBitSet::ArrayMultiDimensionLiteralsBitSet(
        const ArrayMultiDimensionLiteralsBitSet& x)
{
    m_var_array_bitset = x.m_var_array_bitset;
}

ArrayMultiDimensionLiteralsBitSet::ArrayMultiDimensionLiteralsBitSet(
        ArrayMultiDimensionLiteralsBitSet&& x) noexcept 
{
    m_var_array_bitset = std::move(x.m_var_array_bitset);
}

ArrayMultiDimensionLiteralsBitSet& ArrayMultiDimensionLiteralsBitSet::operator =(
        const ArrayMultiDimensionLiteralsBitSet& x)
{

    m_var_array_bitset = x.m_var_array_bitset;

    return *this;
}

ArrayMultiDimensionLiteralsBitSet& ArrayMultiDimensionLiteralsBitSet::operator =(
        ArrayMultiDimensionLiteralsBitSet&& x) noexcept
{

    m_var_array_bitset = std::move(x.m_var_array_bitset);

    return *this;
}

bool ArrayMultiDimensionLiteralsBitSet::operator ==(
        const ArrayMultiDimensionLiteralsBitSet& x) const
{

    return (m_var_array_bitset == x.m_var_array_bitset);
}

bool ArrayMultiDimensionLiteralsBitSet::operator !=(
        const ArrayMultiDimensionLiteralsBitSet& x) const
{
    return !(*this == x);
}

size_t ArrayMultiDimensionLiteralsBitSet::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBitSet_max_cdr_typesize;
}

size_t ArrayMultiDimensionLiteralsBitSet::getCdrSerializedSize(
        const ArrayMultiDimensionLiteralsBitSet& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.var_array_bitset().size(); ++a)
    {

        for(size_t b = 0; b < data.var_array_bitset().at(a).size(); ++b)
        {

            for(size_t c = 0; c < data.var_array_bitset().at(a).at(b).size(); ++c)
            {

                    current_alignment += InnerBitsetHelper::getCdrSerializedSize(data.var_array_bitset().at(a).at(b).at(c), current_alignment);
            }
        }
    }
    return current_alignment - initial_alignment;
}

void ArrayMultiDimensionLiteralsBitSet::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    for (uint32_t e = 0; e < m_var_array_bitset.size(); ++e)
    {
        for (uint32_t f = 0; f < m_var_array_bitset[e].size(); ++f)
        {
            scdr << m_var_array_bitset[e][f];
        }    

    }    

}

void ArrayMultiDimensionLiteralsBitSet::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    for (uint32_t h = 0; h < m_var_array_bitset.size(); ++h)
    {
        for (uint32_t i = 0; i < m_var_array_bitset[h].size(); ++i)
        {
            dcdr >> m_var_array_bitset[h][i];
        }

    }

}

/*!
 * @brief This function copies the value in member var_array_bitset
 * @param _var_array_bitset New value to be copied in member var_array_bitset
 */
void ArrayMultiDimensionLiteralsBitSet::var_array_bitset(
        const std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& _var_array_bitset)
{
    m_var_array_bitset = _var_array_bitset;
}

/*!
 * @brief This function moves the value in member var_array_bitset
 * @param _var_array_bitset New value to be moved in member var_array_bitset
 */
void ArrayMultiDimensionLiteralsBitSet::var_array_bitset(
        std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>&& _var_array_bitset)
{
    m_var_array_bitset = std::move(_var_array_bitset);
}

/*!
 * @brief This function returns a constant reference to member var_array_bitset
 * @return Constant reference to member var_array_bitset
 */
const std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsBitSet::var_array_bitset() const
{
    return m_var_array_bitset;
}

/*!
 * @brief This function returns a reference to member var_array_bitset
 * @return Reference to member var_array_bitset
 */
std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>& ArrayMultiDimensionLiteralsBitSet::var_array_bitset()
{
    return m_var_array_bitset;
}


size_t ArrayMultiDimensionLiteralsBitSet::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayMultiDimensionLiteralsBitSet_max_key_cdr_typesize;
}

bool ArrayMultiDimensionLiteralsBitSet::isKeyDefined()
{
    return false;
}

void ArrayMultiDimensionLiteralsBitSet::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedSmallArrays::BoundedSmallArrays()
{
    // short m_var_array_small
    memset(&m_var_array_small, 0, (1) * 2);


    // Just to register all known types
    registerarraysTypes();
}

BoundedSmallArrays::~BoundedSmallArrays()
{
}

BoundedSmallArrays::BoundedSmallArrays(
        const BoundedSmallArrays& x)
{
    m_var_array_small = x.m_var_array_small;
}

BoundedSmallArrays::BoundedSmallArrays(
        BoundedSmallArrays&& x) noexcept 
{
    m_var_array_small = std::move(x.m_var_array_small);
}

BoundedSmallArrays& BoundedSmallArrays::operator =(
        const BoundedSmallArrays& x)
{

    m_var_array_small = x.m_var_array_small;

    return *this;
}

BoundedSmallArrays& BoundedSmallArrays::operator =(
        BoundedSmallArrays&& x) noexcept
{

    m_var_array_small = std::move(x.m_var_array_small);

    return *this;
}

bool BoundedSmallArrays::operator ==(
        const BoundedSmallArrays& x) const
{

    return (m_var_array_small == x.m_var_array_small);
}

bool BoundedSmallArrays::operator !=(
        const BoundedSmallArrays& x) const
{
    return !(*this == x);
}

size_t BoundedSmallArrays::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedSmallArrays_max_cdr_typesize;
}

size_t BoundedSmallArrays::getCdrSerializedSize(
        const BoundedSmallArrays& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((1) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void BoundedSmallArrays::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_small;

}

void BoundedSmallArrays::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_small;

}

/*!
 * @brief This function copies the value in member var_array_small
 * @param _var_array_small New value to be copied in member var_array_small
 */
void BoundedSmallArrays::var_array_small(
        const std::array<int16_t, 1>& _var_array_small)
{
    m_var_array_small = _var_array_small;
}

/*!
 * @brief This function moves the value in member var_array_small
 * @param _var_array_small New value to be moved in member var_array_small
 */
void BoundedSmallArrays::var_array_small(
        std::array<int16_t, 1>&& _var_array_small)
{
    m_var_array_small = std::move(_var_array_small);
}

/*!
 * @brief This function returns a constant reference to member var_array_small
 * @return Constant reference to member var_array_small
 */
const std::array<int16_t, 1>& BoundedSmallArrays::var_array_small() const
{
    return m_var_array_small;
}

/*!
 * @brief This function returns a reference to member var_array_small
 * @return Reference to member var_array_small
 */
std::array<int16_t, 1>& BoundedSmallArrays::var_array_small()
{
    return m_var_array_small;
}


size_t BoundedSmallArrays::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedSmallArrays_max_key_cdr_typesize;
}

bool BoundedSmallArrays::isKeyDefined()
{
    return false;
}

void BoundedSmallArrays::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


BoundedBigArrays::BoundedBigArrays()
{
    // short m_var_array_big
    memset(&m_var_array_big, 0, (41925) * 2);


    // Just to register all known types
    registerarraysTypes();
}

BoundedBigArrays::~BoundedBigArrays()
{
}

BoundedBigArrays::BoundedBigArrays(
        const BoundedBigArrays& x)
{
    m_var_array_big = x.m_var_array_big;
}

BoundedBigArrays::BoundedBigArrays(
        BoundedBigArrays&& x) noexcept 
{
    m_var_array_big = std::move(x.m_var_array_big);
}

BoundedBigArrays& BoundedBigArrays::operator =(
        const BoundedBigArrays& x)
{

    m_var_array_big = x.m_var_array_big;

    return *this;
}

BoundedBigArrays& BoundedBigArrays::operator =(
        BoundedBigArrays&& x) noexcept
{

    m_var_array_big = std::move(x.m_var_array_big);

    return *this;
}

bool BoundedBigArrays::operator ==(
        const BoundedBigArrays& x) const
{

    return (m_var_array_big == x.m_var_array_big);
}

bool BoundedBigArrays::operator !=(
        const BoundedBigArrays& x) const
{
    return !(*this == x);
}

size_t BoundedBigArrays::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedBigArrays_max_cdr_typesize;
}

size_t BoundedBigArrays::getCdrSerializedSize(
        const BoundedBigArrays& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ((41925) * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void BoundedBigArrays::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_var_array_big;

}

void BoundedBigArrays::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_var_array_big;

}

/*!
 * @brief This function copies the value in member var_array_big
 * @param _var_array_big New value to be copied in member var_array_big
 */
void BoundedBigArrays::var_array_big(
        const std::array<int16_t, 41925>& _var_array_big)
{
    m_var_array_big = _var_array_big;
}

/*!
 * @brief This function moves the value in member var_array_big
 * @param _var_array_big New value to be moved in member var_array_big
 */
void BoundedBigArrays::var_array_big(
        std::array<int16_t, 41925>&& _var_array_big)
{
    m_var_array_big = std::move(_var_array_big);
}

/*!
 * @brief This function returns a constant reference to member var_array_big
 * @return Constant reference to member var_array_big
 */
const std::array<int16_t, 41925>& BoundedBigArrays::var_array_big() const
{
    return m_var_array_big;
}

/*!
 * @brief This function returns a reference to member var_array_big
 * @return Reference to member var_array_big
 */
std::array<int16_t, 41925>& BoundedBigArrays::var_array_big()
{
    return m_var_array_big;
}


size_t BoundedBigArrays::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BoundedBigArrays_max_key_cdr_typesize;
}

bool BoundedBigArrays::isKeyDefined()
{
    return false;
}

void BoundedBigArrays::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

