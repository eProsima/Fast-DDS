// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file arraysPubSubTypes.h
 * This header file contains the declaration of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#ifndef _FAST_DDS_GENERATED_ARRAYS_PUBSUBTYPES_H_
#define _FAST_DDS_GENERATED_ARRAYS_PUBSUBTYPES_H_

#include <fastdds/dds/topic/TopicDataType.hpp>
#include <fastrtps/utils/md5.h>

#include "arrays.h"

#include "helpers/basic_inner_typesPubSubTypes.h"

#if !defined(GEN_API_VER) || (GEN_API_VER != 1)
#error \
    Generated arrays is not compatible with current installed Fast DDS. Please, regenerate it with fastddsgen.
#endif  // GEN_API_VER

typedef int32_t InnerAliasHelper;
typedef eprosima::fastrtps::fixed_string<10> Inner_alias_bounded_string_helper;
typedef std::wstring Inner_alias_bounded_wstring_helper;
typedef std::array<int16_t, 2> Inner_alias_array_helper;
typedef std::vector<int16_t> Inner_alias_sequence_helper;
typedef std::map<int32_t, int32_t> Inner_alias_map_helper;

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayShort_f
    {
        typedef std::array<int16_t, 10> ArrayShort::* type;
        friend constexpr type get(
                ArrayShort_f);
    };

    template struct ArrayShort_rob<ArrayShort_f, &ArrayShort::m_var_array_short>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayShort type;

    eProsima_user_DllExport ArrayShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 20ULL == (detail::ArrayShort_offset_of<ArrayShort, detail::ArrayShort_f>() + sizeof(std::array<int16_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayUShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayUShort_f
    {
        typedef std::array<uint16_t, 10> ArrayUShort::* type;
        friend constexpr type get(
                ArrayUShort_f);
    };

    template struct ArrayUShort_rob<ArrayUShort_f, &ArrayUShort::m_var_array_ushort>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayUShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayUShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayUShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayUShort type;

    eProsima_user_DllExport ArrayUShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayUShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayUShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 20ULL == (detail::ArrayUShort_offset_of<ArrayUShort, detail::ArrayUShort_f>() + sizeof(std::array<uint16_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayLong_f
    {
        typedef std::array<int32_t, 10> ArrayLong::* type;
        friend constexpr type get(
                ArrayLong_f);
    };

    template struct ArrayLong_rob<ArrayLong_f, &ArrayLong::m_var_array_long>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayLong type;

    eProsima_user_DllExport ArrayLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayLong_offset_of<ArrayLong, detail::ArrayLong_f>() + sizeof(std::array<int32_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayULong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayULong_f
    {
        typedef std::array<uint32_t, 10> ArrayULong::* type;
        friend constexpr type get(
                ArrayULong_f);
    };

    template struct ArrayULong_rob<ArrayULong_f, &ArrayULong::m_var_array_ulong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayULong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayULong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayULongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayULong type;

    eProsima_user_DllExport ArrayULongPubSubType();

    eProsima_user_DllExport virtual ~ArrayULongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayULong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayULong_offset_of<ArrayULong, detail::ArrayULong_f>() + sizeof(std::array<uint32_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayLongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayLongLong_f
    {
        typedef std::array<int64_t, 10> ArrayLongLong::* type;
        friend constexpr type get(
                ArrayLongLong_f);
    };

    template struct ArrayLongLong_rob<ArrayLongLong_f, &ArrayLongLong::m_var_array_longlong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayLongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayLongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayLongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayLongLong type;

    eProsima_user_DllExport ArrayLongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayLongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayLongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArrayLongLong_offset_of<ArrayLongLong, detail::ArrayLongLong_f>() + sizeof(std::array<int64_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayULongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayULongLong_f
    {
        typedef std::array<uint64_t, 10> ArrayULongLong::* type;
        friend constexpr type get(
                ArrayULongLong_f);
    };

    template struct ArrayULongLong_rob<ArrayULongLong_f, &ArrayULongLong::m_var_array_ulonglong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayULongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayULongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayULongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayULongLong type;

    eProsima_user_DllExport ArrayULongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayULongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayULongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArrayULongLong_offset_of<ArrayULongLong, detail::ArrayULongLong_f>() + sizeof(std::array<uint64_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayFloat_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayFloat_f
    {
        typedef std::array<float, 10> ArrayFloat::* type;
        friend constexpr type get(
                ArrayFloat_f);
    };

    template struct ArrayFloat_rob<ArrayFloat_f, &ArrayFloat::m_var_array_float>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayFloat_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayFloat defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayFloatPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayFloat type;

    eProsima_user_DllExport ArrayFloatPubSubType();

    eProsima_user_DllExport virtual ~ArrayFloatPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayFloat();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayFloat_offset_of<ArrayFloat, detail::ArrayFloat_f>() + sizeof(std::array<float, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayDouble_f
    {
        typedef std::array<double, 10> ArrayDouble::* type;
        friend constexpr type get(
                ArrayDouble_f);
    };

    template struct ArrayDouble_rob<ArrayDouble_f, &ArrayDouble::m_var_array_double>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayDouble type;

    eProsima_user_DllExport ArrayDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArrayDouble_offset_of<ArrayDouble, detail::ArrayDouble_f>() + sizeof(std::array<double, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayLongDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayLongDouble_f
    {
        typedef std::array<long double, 10> ArrayLongDouble::* type;
        friend constexpr type get(
                ArrayLongDouble_f);
    };

    template struct ArrayLongDouble_rob<ArrayLongDouble_f, &ArrayLongDouble::m_var_array_longdouble>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayLongDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayLongDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayLongDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayLongDouble type;

    eProsima_user_DllExport ArrayLongDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayLongDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayLongDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 160ULL == (detail::ArrayLongDouble_offset_of<ArrayLongDouble, detail::ArrayLongDouble_f>() + sizeof(std::array<long double, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayBoolean_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayBoolean_f
    {
        typedef std::array<bool, 10> ArrayBoolean::* type;
        friend constexpr type get(
                ArrayBoolean_f);
    };

    template struct ArrayBoolean_rob<ArrayBoolean_f, &ArrayBoolean::m_var_array_boolean>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayBoolean_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayBoolean defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayBooleanPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBoolean type;

    eProsima_user_DllExport ArrayBooleanPubSubType();

    eProsima_user_DllExport virtual ~ArrayBooleanPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayBoolean();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 10ULL == (detail::ArrayBoolean_offset_of<ArrayBoolean, detail::ArrayBoolean_f>() + sizeof(std::array<bool, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayOctet_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayOctet_f
    {
        typedef std::array<uint8_t, 10> ArrayOctet::* type;
        friend constexpr type get(
                ArrayOctet_f);
    };

    template struct ArrayOctet_rob<ArrayOctet_f, &ArrayOctet::m_var_array_octet>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayOctet_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayOctet defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayOctetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayOctet type;

    eProsima_user_DllExport ArrayOctetPubSubType();

    eProsima_user_DllExport virtual ~ArrayOctetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayOctet();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 10ULL == (detail::ArrayOctet_offset_of<ArrayOctet, detail::ArrayOctet_f>() + sizeof(std::array<uint8_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayChar_f
    {
        typedef std::array<char, 10> ArrayChar::* type;
        friend constexpr type get(
                ArrayChar_f);
    };

    template struct ArrayChar_rob<ArrayChar_f, &ArrayChar::m_var_array_char>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayChar type;

    eProsima_user_DllExport ArrayCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 10ULL == (detail::ArrayChar_offset_of<ArrayChar, detail::ArrayChar_f>() + sizeof(std::array<char, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayWChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayWChar_f
    {
        typedef std::array<wchar_t, 10> ArrayWChar::* type;
        friend constexpr type get(
                ArrayWChar_f);
    };

    template struct ArrayWChar_rob<ArrayWChar_f, &ArrayWChar::m_var_array_wchar>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayWChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayWChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayWCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayWChar type;

    eProsima_user_DllExport ArrayWCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayWCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayWChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayWChar_offset_of<ArrayWChar, detail::ArrayWChar_f>() + sizeof(std::array<wchar_t, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArrayString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayString type;

    eProsima_user_DllExport ArrayStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayWString type;

    eProsima_user_DllExport ArrayWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayBoundedString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayBoundedStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBoundedString type;

    eProsima_user_DllExport ArrayBoundedStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayBoundedStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayBoundedWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayBoundedWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBoundedWString type;

    eProsima_user_DllExport ArrayBoundedWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayBoundedWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayEnum defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayEnumPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayEnum type;

    eProsima_user_DllExport ArrayEnumPubSubType();

    eProsima_user_DllExport virtual ~ArrayEnumPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayBitMask_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayBitMask_f
    {
        typedef std::array<InnerBitMaskHelper, 10> ArrayBitMask::* type;
        friend constexpr type get(
                ArrayBitMask_f);
    };

    template struct ArrayBitMask_rob<ArrayBitMask_f, &ArrayBitMask::m_var_array_bitmask>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayBitMask_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayBitMask defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayBitMaskPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBitMask type;

    eProsima_user_DllExport ArrayBitMaskPubSubType();

    eProsima_user_DllExport virtual ~ArrayBitMaskPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayBitMask();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayBitMask_offset_of<ArrayBitMask, detail::ArrayBitMask_f>() + sizeof(std::array<InnerBitMaskHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayAlias_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayAlias_f
    {
        typedef std::array<InnerAliasHelper, 10> ArrayAlias::* type;
        friend constexpr type get(
                ArrayAlias_f);
    };

    template struct ArrayAlias_rob<ArrayAlias_f, &ArrayAlias::m_var_array_alias>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayAlias_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayAlias defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayAliasPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayAlias type;

    eProsima_user_DllExport ArrayAliasPubSubType();

    eProsima_user_DllExport virtual ~ArrayAliasPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayAlias();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArrayAlias_offset_of<ArrayAlias, detail::ArrayAlias_f>() + sizeof(std::array<InnerAliasHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayShortArray_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayShortArray_f
    {
        typedef std::array<std::array<int16_t, 10>, 10> ArrayShortArray::* type;
        friend constexpr type get(
                ArrayShortArray_f);
    };

    template struct ArrayShortArray_rob<ArrayShortArray_f, &ArrayShortArray::m_var_array_short_array>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayShortArray_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayShortArray defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayShortArrayPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayShortArray type;

    eProsima_user_DllExport ArrayShortArrayPubSubType();

    eProsima_user_DllExport virtual ~ArrayShortArrayPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayShortArray();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 200ULL == (detail::ArrayShortArray_offset_of<ArrayShortArray, detail::ArrayShortArray_f>() + sizeof(std::array<std::array<int16_t, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArraySequence defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySequencePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySequence type;

    eProsima_user_DllExport ArraySequencePubSubType();

    eProsima_user_DllExport virtual ~ArraySequencePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMap defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMapPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMap type;

    eProsima_user_DllExport ArrayMapPubSubType();

    eProsima_user_DllExport virtual ~ArrayMapPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayUnion defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayUnionPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayUnion type;

    eProsima_user_DllExport ArrayUnionPubSubType();

    eProsima_user_DllExport virtual ~ArrayUnionPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayStructure_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayStructure_f
    {
        typedef std::array<InnerStructureHelper, 10> ArrayStructure::* type;
        friend constexpr type get(
                ArrayStructure_f);
    };

    template struct ArrayStructure_rob<ArrayStructure_f, &ArrayStructure::m_var_array_structure>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayStructure_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayStructure defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayStructurePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayStructure type;

    eProsima_user_DllExport ArrayStructurePubSubType();

    eProsima_user_DllExport virtual ~ArrayStructurePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayStructure();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArrayStructure_offset_of<ArrayStructure, detail::ArrayStructure_f>() + sizeof(std::array<InnerStructureHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayBitset_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayBitset_f
    {
        typedef std::array<InnerBitsetHelper, 10> ArrayBitset::* type;
        friend constexpr type get(
                ArrayBitset_f);
    };

    template struct ArrayBitset_rob<ArrayBitset_f, &ArrayBitset::m_var_array_bitset>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayBitset_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayBitset defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayBitsetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayBitset type;

    eProsima_user_DllExport ArrayBitsetPubSubType();

    eProsima_user_DllExport virtual ~ArrayBitsetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayBitset();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArrayBitset_offset_of<ArrayBitset, detail::ArrayBitset_f>() + sizeof(std::array<InnerBitsetHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionShort_f
    {
        typedef std::array<std::array<std::array<int16_t, 10>, 10>, 10> ArrayMultiDimensionShort::* type;
        friend constexpr type get(
                ArrayMultiDimensionShort_f);
    };

    template struct ArrayMultiDimensionShort_rob<ArrayMultiDimensionShort_f, &ArrayMultiDimensionShort::m_var_array_short>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionShort type;

    eProsima_user_DllExport ArrayMultiDimensionShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionShort_offset_of<ArrayMultiDimensionShort, detail::ArrayMultiDimensionShort_f>() + sizeof(std::array<std::array<std::array<int16_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionUShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionUShort_f
    {
        typedef std::array<std::array<std::array<uint16_t, 10>, 10>, 10> ArrayMultiDimensionUShort::* type;
        friend constexpr type get(
                ArrayMultiDimensionUShort_f);
    };

    template struct ArrayMultiDimensionUShort_rob<ArrayMultiDimensionUShort_f, &ArrayMultiDimensionUShort::m_var_array_ushort>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionUShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionUShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionUShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionUShort type;

    eProsima_user_DllExport ArrayMultiDimensionUShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionUShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionUShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionUShort_offset_of<ArrayMultiDimensionUShort, detail::ArrayMultiDimensionUShort_f>() + sizeof(std::array<std::array<std::array<uint16_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLong_f
    {
        typedef std::array<std::array<std::array<int32_t, 10>, 10>, 10> ArrayMultiDimensionLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLong_f);
    };

    template struct ArrayMultiDimensionLong_rob<ArrayMultiDimensionLong_f, &ArrayMultiDimensionLong::m_var_array_long>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLong type;

    eProsima_user_DllExport ArrayMultiDimensionLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionLong_offset_of<ArrayMultiDimensionLong, detail::ArrayMultiDimensionLong_f>() + sizeof(std::array<std::array<std::array<int32_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionULong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionULong_f
    {
        typedef std::array<std::array<std::array<uint32_t, 10>, 10>, 10> ArrayMultiDimensionULong::* type;
        friend constexpr type get(
                ArrayMultiDimensionULong_f);
    };

    template struct ArrayMultiDimensionULong_rob<ArrayMultiDimensionULong_f, &ArrayMultiDimensionULong::m_var_array_ulong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionULong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionULong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionULongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionULong type;

    eProsima_user_DllExport ArrayMultiDimensionULongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionULongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionULong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionULong_offset_of<ArrayMultiDimensionULong, detail::ArrayMultiDimensionULong_f>() + sizeof(std::array<std::array<std::array<uint32_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLongLong_f
    {
        typedef std::array<std::array<std::array<int64_t, 10>, 10>, 10> ArrayMultiDimensionLongLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLongLong_f);
    };

    template struct ArrayMultiDimensionLongLong_rob<ArrayMultiDimensionLongLong_f, &ArrayMultiDimensionLongLong::m_var_array_longlong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLongLong type;

    eProsima_user_DllExport ArrayMultiDimensionLongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionLongLong_offset_of<ArrayMultiDimensionLongLong, detail::ArrayMultiDimensionLongLong_f>() + sizeof(std::array<std::array<std::array<int64_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionULongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionULongLong_f
    {
        typedef std::array<std::array<std::array<uint64_t, 10>, 10>, 10> ArrayMultiDimensionULongLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionULongLong_f);
    };

    template struct ArrayMultiDimensionULongLong_rob<ArrayMultiDimensionULongLong_f, &ArrayMultiDimensionULongLong::m_var_array_ulonglong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionULongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionULongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionULongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionULongLong type;

    eProsima_user_DllExport ArrayMultiDimensionULongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionULongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionULongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionULongLong_offset_of<ArrayMultiDimensionULongLong, detail::ArrayMultiDimensionULongLong_f>() + sizeof(std::array<std::array<std::array<uint64_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionFloat_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionFloat_f
    {
        typedef std::array<std::array<std::array<float, 10>, 10>, 10> ArrayMultiDimensionFloat::* type;
        friend constexpr type get(
                ArrayMultiDimensionFloat_f);
    };

    template struct ArrayMultiDimensionFloat_rob<ArrayMultiDimensionFloat_f, &ArrayMultiDimensionFloat::m_var_array_float>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionFloat_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionFloat defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionFloatPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionFloat type;

    eProsima_user_DllExport ArrayMultiDimensionFloatPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionFloatPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionFloat();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionFloat_offset_of<ArrayMultiDimensionFloat, detail::ArrayMultiDimensionFloat_f>() + sizeof(std::array<std::array<std::array<float, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionDouble_f
    {
        typedef std::array<std::array<std::array<double, 10>, 10>, 10> ArrayMultiDimensionDouble::* type;
        friend constexpr type get(
                ArrayMultiDimensionDouble_f);
    };

    template struct ArrayMultiDimensionDouble_rob<ArrayMultiDimensionDouble_f, &ArrayMultiDimensionDouble::m_var_array_double>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionDouble type;

    eProsima_user_DllExport ArrayMultiDimensionDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionDouble_offset_of<ArrayMultiDimensionDouble, detail::ArrayMultiDimensionDouble_f>() + sizeof(std::array<std::array<std::array<double, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLongDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLongDouble_f
    {
        typedef std::array<std::array<std::array<long double, 10>, 10>, 10> ArrayMultiDimensionLongDouble::* type;
        friend constexpr type get(
                ArrayMultiDimensionLongDouble_f);
    };

    template struct ArrayMultiDimensionLongDouble_rob<ArrayMultiDimensionLongDouble_f, &ArrayMultiDimensionLongDouble::m_var_array_longdouble>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLongDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLongDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLongDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLongDouble type;

    eProsima_user_DllExport ArrayMultiDimensionLongDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLongDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLongDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 16000ULL == (detail::ArrayMultiDimensionLongDouble_offset_of<ArrayMultiDimensionLongDouble, detail::ArrayMultiDimensionLongDouble_f>() + sizeof(std::array<std::array<std::array<long double, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionBoolean_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionBoolean_f
    {
        typedef std::array<std::array<std::array<bool, 10>, 10>, 10> ArrayMultiDimensionBoolean::* type;
        friend constexpr type get(
                ArrayMultiDimensionBoolean_f);
    };

    template struct ArrayMultiDimensionBoolean_rob<ArrayMultiDimensionBoolean_f, &ArrayMultiDimensionBoolean::m_var_array_boolean>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionBoolean_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionBoolean defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionBooleanPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionBoolean type;

    eProsima_user_DllExport ArrayMultiDimensionBooleanPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionBooleanPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionBoolean();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 1000ULL == (detail::ArrayMultiDimensionBoolean_offset_of<ArrayMultiDimensionBoolean, detail::ArrayMultiDimensionBoolean_f>() + sizeof(std::array<std::array<std::array<bool, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionOctet_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionOctet_f
    {
        typedef std::array<std::array<std::array<uint8_t, 10>, 10>, 10> ArrayMultiDimensionOctet::* type;
        friend constexpr type get(
                ArrayMultiDimensionOctet_f);
    };

    template struct ArrayMultiDimensionOctet_rob<ArrayMultiDimensionOctet_f, &ArrayMultiDimensionOctet::m_var_array_octet>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionOctet_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionOctet defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionOctetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionOctet type;

    eProsima_user_DllExport ArrayMultiDimensionOctetPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionOctetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionOctet();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 1000ULL == (detail::ArrayMultiDimensionOctet_offset_of<ArrayMultiDimensionOctet, detail::ArrayMultiDimensionOctet_f>() + sizeof(std::array<std::array<std::array<uint8_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionChar_f
    {
        typedef std::array<std::array<std::array<char, 10>, 10>, 10> ArrayMultiDimensionChar::* type;
        friend constexpr type get(
                ArrayMultiDimensionChar_f);
    };

    template struct ArrayMultiDimensionChar_rob<ArrayMultiDimensionChar_f, &ArrayMultiDimensionChar::m_var_array_char>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionChar type;

    eProsima_user_DllExport ArrayMultiDimensionCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 1000ULL == (detail::ArrayMultiDimensionChar_offset_of<ArrayMultiDimensionChar, detail::ArrayMultiDimensionChar_f>() + sizeof(std::array<std::array<std::array<char, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionWChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionWChar_f
    {
        typedef std::array<std::array<std::array<wchar_t, 10>, 10>, 10> ArrayMultiDimensionWChar::* type;
        friend constexpr type get(
                ArrayMultiDimensionWChar_f);
    };

    template struct ArrayMultiDimensionWChar_rob<ArrayMultiDimensionWChar_f, &ArrayMultiDimensionWChar::m_var_array_wchar>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionWChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionWChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionWCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionWChar type;

    eProsima_user_DllExport ArrayMultiDimensionWCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionWCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionWChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionWChar_offset_of<ArrayMultiDimensionWChar, detail::ArrayMultiDimensionWChar_f>() + sizeof(std::array<std::array<std::array<wchar_t, 10>, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionString type;

    eProsima_user_DllExport ArrayMultiDimensionStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionWString type;

    eProsima_user_DllExport ArrayMultiDimensionWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionBoundedString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionBoundedStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionBoundedString type;

    eProsima_user_DllExport ArrayMultiDimensionBoundedStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionBoundedStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionBoundedWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionBoundedWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionBoundedWString type;

    eProsima_user_DllExport ArrayMultiDimensionBoundedWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionBoundedWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionEnum defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionEnumPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionEnum type;

    eProsima_user_DllExport ArrayMultiDimensionEnumPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionEnumPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionBitMask_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionBitMask_f
    {
        typedef std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10> ArrayMultiDimensionBitMask::* type;
        friend constexpr type get(
                ArrayMultiDimensionBitMask_f);
    };

    template struct ArrayMultiDimensionBitMask_rob<ArrayMultiDimensionBitMask_f, &ArrayMultiDimensionBitMask::m_var_array_bitmask>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionBitMask_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionBitMask defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionBitMaskPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionBitMask type;

    eProsima_user_DllExport ArrayMultiDimensionBitMaskPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionBitMaskPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionBitMask();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionBitMask_offset_of<ArrayMultiDimensionBitMask, detail::ArrayMultiDimensionBitMask_f>() + sizeof(std::array<std::array<std::array<InnerBitMaskHelper, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionAlias_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionAlias_f
    {
        typedef std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10> ArrayMultiDimensionAlias::* type;
        friend constexpr type get(
                ArrayMultiDimensionAlias_f);
    };

    template struct ArrayMultiDimensionAlias_rob<ArrayMultiDimensionAlias_f, &ArrayMultiDimensionAlias::m_var_array_alias>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionAlias_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionAlias defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionAliasPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionAlias type;

    eProsima_user_DllExport ArrayMultiDimensionAliasPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionAliasPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionAlias();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionAlias_offset_of<ArrayMultiDimensionAlias, detail::ArrayMultiDimensionAlias_f>() + sizeof(std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionSequence defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionSequencePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionSequence type;

    eProsima_user_DllExport ArrayMultiDimensionSequencePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionSequencePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionMap defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionMapPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionMap type;

    eProsima_user_DllExport ArrayMultiDimensionMapPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionMapPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionUnion defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionUnionPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionUnion type;

    eProsima_user_DllExport ArrayMultiDimensionUnionPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionUnionPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionStructure_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionStructure_f
    {
        typedef std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10> ArrayMultiDimensionStructure::* type;
        friend constexpr type get(
                ArrayMultiDimensionStructure_f);
    };

    template struct ArrayMultiDimensionStructure_rob<ArrayMultiDimensionStructure_f, &ArrayMultiDimensionStructure::m_var_array_structure>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionStructure_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionStructure defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionStructurePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionStructure type;

    eProsima_user_DllExport ArrayMultiDimensionStructurePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionStructurePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionStructure();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionStructure_offset_of<ArrayMultiDimensionStructure, detail::ArrayMultiDimensionStructure_f>() + sizeof(std::array<std::array<std::array<InnerStructureHelper, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionBitset_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionBitset_f
    {
        typedef std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10> ArrayMultiDimensionBitset::* type;
        friend constexpr type get(
                ArrayMultiDimensionBitset_f);
    };

    template struct ArrayMultiDimensionBitset_rob<ArrayMultiDimensionBitset_f, &ArrayMultiDimensionBitset::m_var_array_bitset>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionBitset_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionBitset defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionBitsetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionBitset type;

    eProsima_user_DllExport ArrayMultiDimensionBitsetPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionBitsetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionBitset();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionBitset_offset_of<ArrayMultiDimensionBitset, detail::ArrayMultiDimensionBitset_f>() + sizeof(std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>));

    }};



#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsShort_f
    {
        typedef std::array<int16_t, 5> ArraySingleDimensionLiteralsShort::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsShort_f);
    };

    template struct ArraySingleDimensionLiteralsShort_rob<ArraySingleDimensionLiteralsShort_f, &ArraySingleDimensionLiteralsShort::m_var_array_short>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsShort type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsShortPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 10ULL == (detail::ArraySingleDimensionLiteralsShort_offset_of<ArraySingleDimensionLiteralsShort, detail::ArraySingleDimensionLiteralsShort_f>() + sizeof(std::array<int16_t, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsUnsignedShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsUnsignedShort_f
    {
        typedef std::array<uint16_t, 10> ArraySingleDimensionLiteralsUnsignedShort::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsUnsignedShort_f);
    };

    template struct ArraySingleDimensionLiteralsUnsignedShort_rob<ArraySingleDimensionLiteralsUnsignedShort_f, &ArraySingleDimensionLiteralsUnsignedShort::m_var_array_ushort>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsUnsignedShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsUnsignedShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsUnsignedShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsUnsignedShort type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsUnsignedShortPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsUnsignedShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsUnsignedShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 20ULL == (detail::ArraySingleDimensionLiteralsUnsignedShort_offset_of<ArraySingleDimensionLiteralsUnsignedShort, detail::ArraySingleDimensionLiteralsUnsignedShort_f>() + sizeof(std::array<uint16_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsLong_f
    {
        typedef std::array<int32_t, 10> ArraySingleDimensionLiteralsLong::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsLong_f);
    };

    template struct ArraySingleDimensionLiteralsLong_rob<ArraySingleDimensionLiteralsLong_f, &ArraySingleDimensionLiteralsLong::m_var_array_long>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsLong type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsLongPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsLong_offset_of<ArraySingleDimensionLiteralsLong, detail::ArraySingleDimensionLiteralsLong_f>() + sizeof(std::array<int32_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsUnsignedLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsUnsignedLong_f
    {
        typedef std::array<uint32_t, 10> ArraySingleDimensionLiteralsUnsignedLong::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsUnsignedLong_f);
    };

    template struct ArraySingleDimensionLiteralsUnsignedLong_rob<ArraySingleDimensionLiteralsUnsignedLong_f, &ArraySingleDimensionLiteralsUnsignedLong::m_var_array_ulong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsUnsignedLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsUnsignedLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsUnsignedLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsUnsignedLong type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsUnsignedLongPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsUnsignedLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsUnsignedLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsUnsignedLong_offset_of<ArraySingleDimensionLiteralsUnsignedLong, detail::ArraySingleDimensionLiteralsUnsignedLong_f>() + sizeof(std::array<uint32_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsLongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsLongLong_f
    {
        typedef std::array<int64_t, 10> ArraySingleDimensionLiteralsLongLong::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsLongLong_f);
    };

    template struct ArraySingleDimensionLiteralsLongLong_rob<ArraySingleDimensionLiteralsLongLong_f, &ArraySingleDimensionLiteralsLongLong::m_var_array_longlong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsLongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsLongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsLongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsLongLong type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsLongLongPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsLongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsLongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArraySingleDimensionLiteralsLongLong_offset_of<ArraySingleDimensionLiteralsLongLong, detail::ArraySingleDimensionLiteralsLongLong_f>() + sizeof(std::array<int64_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsUnsignedLongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsUnsignedLongLong_f
    {
        typedef std::array<uint64_t, 10> ArraySingleDimensionLiteralsUnsignedLongLong::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsUnsignedLongLong_f);
    };

    template struct ArraySingleDimensionLiteralsUnsignedLongLong_rob<ArraySingleDimensionLiteralsUnsignedLongLong_f, &ArraySingleDimensionLiteralsUnsignedLongLong::m_var_array_ulonglong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsUnsignedLongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsUnsignedLongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsUnsignedLongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsUnsignedLongLong type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsUnsignedLongLongPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsUnsignedLongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsUnsignedLongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArraySingleDimensionLiteralsUnsignedLongLong_offset_of<ArraySingleDimensionLiteralsUnsignedLongLong, detail::ArraySingleDimensionLiteralsUnsignedLongLong_f>() + sizeof(std::array<uint64_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsFloat_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsFloat_f
    {
        typedef std::array<float, 5> ArraySingleDimensionLiteralsFloat::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsFloat_f);
    };

    template struct ArraySingleDimensionLiteralsFloat_rob<ArraySingleDimensionLiteralsFloat_f, &ArraySingleDimensionLiteralsFloat::m_var_array_float>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsFloat_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsFloat defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsFloatPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsFloat type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsFloatPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsFloatPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsFloat();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 20ULL == (detail::ArraySingleDimensionLiteralsFloat_offset_of<ArraySingleDimensionLiteralsFloat, detail::ArraySingleDimensionLiteralsFloat_f>() + sizeof(std::array<float, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsDouble_f
    {
        typedef std::array<double, 10> ArraySingleDimensionLiteralsDouble::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsDouble_f);
    };

    template struct ArraySingleDimensionLiteralsDouble_rob<ArraySingleDimensionLiteralsDouble_f, &ArraySingleDimensionLiteralsDouble::m_var_array_double>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsDouble type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsDoublePubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArraySingleDimensionLiteralsDouble_offset_of<ArraySingleDimensionLiteralsDouble, detail::ArraySingleDimensionLiteralsDouble_f>() + sizeof(std::array<double, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsLongDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsLongDouble_f
    {
        typedef std::array<long double, 10> ArraySingleDimensionLiteralsLongDouble::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsLongDouble_f);
    };

    template struct ArraySingleDimensionLiteralsLongDouble_rob<ArraySingleDimensionLiteralsLongDouble_f, &ArraySingleDimensionLiteralsLongDouble::m_var_array_longdouble>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsLongDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsLongDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsLongDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsLongDouble type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsLongDoublePubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsLongDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsLongDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 160ULL == (detail::ArraySingleDimensionLiteralsLongDouble_offset_of<ArraySingleDimensionLiteralsLongDouble, detail::ArraySingleDimensionLiteralsLongDouble_f>() + sizeof(std::array<long double, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsBoolean_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsBoolean_f
    {
        typedef std::array<bool, 5> ArraySingleDimensionLiteralsBoolean::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsBoolean_f);
    };

    template struct ArraySingleDimensionLiteralsBoolean_rob<ArraySingleDimensionLiteralsBoolean_f, &ArraySingleDimensionLiteralsBoolean::m_var_array_boolean>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsBoolean_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsBoolean defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsBooleanPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsBoolean type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsBooleanPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsBooleanPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsBoolean();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 5ULL == (detail::ArraySingleDimensionLiteralsBoolean_offset_of<ArraySingleDimensionLiteralsBoolean, detail::ArraySingleDimensionLiteralsBoolean_f>() + sizeof(std::array<bool, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsOctet_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsOctet_f
    {
        typedef std::array<uint8_t, 10> ArraySingleDimensionLiteralsOctet::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsOctet_f);
    };

    template struct ArraySingleDimensionLiteralsOctet_rob<ArraySingleDimensionLiteralsOctet_f, &ArraySingleDimensionLiteralsOctet::m_var_array_octet>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsOctet_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsOctet defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsOctetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsOctet type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsOctetPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsOctetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsOctet();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 10ULL == (detail::ArraySingleDimensionLiteralsOctet_offset_of<ArraySingleDimensionLiteralsOctet, detail::ArraySingleDimensionLiteralsOctet_f>() + sizeof(std::array<uint8_t, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsChar_f
    {
        typedef std::array<char, 5> ArraySingleDimensionLiteralsChar::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsChar_f);
    };

    template struct ArraySingleDimensionLiteralsChar_rob<ArraySingleDimensionLiteralsChar_f, &ArraySingleDimensionLiteralsChar::m_var_array_char>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsChar type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsCharPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 5ULL == (detail::ArraySingleDimensionLiteralsChar_offset_of<ArraySingleDimensionLiteralsChar, detail::ArraySingleDimensionLiteralsChar_f>() + sizeof(std::array<char, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsWChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsWChar_f
    {
        typedef std::array<wchar_t, 10> ArraySingleDimensionLiteralsWChar::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsWChar_f);
    };

    template struct ArraySingleDimensionLiteralsWChar_rob<ArraySingleDimensionLiteralsWChar_f, &ArraySingleDimensionLiteralsWChar::m_var_array_wchar>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsWChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsWChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsWCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsWChar type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsWCharPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsWCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsWChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsWChar_offset_of<ArraySingleDimensionLiteralsWChar, detail::ArraySingleDimensionLiteralsWChar_f>() + sizeof(std::array<wchar_t, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsString type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsStringPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsWString type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsWStringPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsBoundedString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsBoundedStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsBoundedString type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsBoundedStringPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsBoundedStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsBoundedWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsBoundedWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsBoundedWString type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsBoundedWStringPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsBoundedWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsEnum defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsEnumPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsEnum type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsEnumPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsEnumPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsBitMask_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsBitMask_f
    {
        typedef std::array<InnerBitMaskHelper, 10> ArraySingleDimensionLiteralsBitMask::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsBitMask_f);
    };

    template struct ArraySingleDimensionLiteralsBitMask_rob<ArraySingleDimensionLiteralsBitMask_f, &ArraySingleDimensionLiteralsBitMask::m_var_array_bitmask>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsBitMask_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsBitMask defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsBitMaskPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsBitMask type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsBitMaskPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsBitMaskPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsBitMask();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsBitMask_offset_of<ArraySingleDimensionLiteralsBitMask, detail::ArraySingleDimensionLiteralsBitMask_f>() + sizeof(std::array<InnerBitMaskHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsAlias_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsAlias_f
    {
        typedef std::array<InnerAliasHelper, 10> ArraySingleDimensionLiteralsAlias::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsAlias_f);
    };

    template struct ArraySingleDimensionLiteralsAlias_rob<ArraySingleDimensionLiteralsAlias_f, &ArraySingleDimensionLiteralsAlias::m_var_array_alias>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsAlias_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsAlias defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsAliasPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsAlias type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsAliasPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsAliasPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsAlias();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsAlias_offset_of<ArraySingleDimensionLiteralsAlias, detail::ArraySingleDimensionLiteralsAlias_f>() + sizeof(std::array<InnerAliasHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsShortArray_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsShortArray_f
    {
        typedef std::array<std::array<int16_t, 10>, 10> ArraySingleDimensionLiteralsShortArray::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsShortArray_f);
    };

    template struct ArraySingleDimensionLiteralsShortArray_rob<ArraySingleDimensionLiteralsShortArray_f, &ArraySingleDimensionLiteralsShortArray::m_var_array_short_array>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsShortArray_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsShortArray defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsShortArrayPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsShortArray type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsShortArrayPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsShortArrayPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsShortArray();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 200ULL == (detail::ArraySingleDimensionLiteralsShortArray_offset_of<ArraySingleDimensionLiteralsShortArray, detail::ArraySingleDimensionLiteralsShortArray_f>() + sizeof(std::array<std::array<int16_t, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsSequence defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsSequencePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsSequence type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsSequencePubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsSequencePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsMap defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsMapPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsMap type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsMapPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsMapPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsUnion defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsUnionPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsUnion type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsUnionPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsUnionPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsStructure_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsStructure_f
    {
        typedef std::array<InnerStructureHelper, 5> ArraySingleDimensionLiteralsStructure::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsStructure_f);
    };

    template struct ArraySingleDimensionLiteralsStructure_rob<ArraySingleDimensionLiteralsStructure_f, &ArraySingleDimensionLiteralsStructure::m_var_array_structure>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsStructure_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsStructure defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsStructurePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsStructure type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsStructurePubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsStructurePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsStructure();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 40ULL == (detail::ArraySingleDimensionLiteralsStructure_offset_of<ArraySingleDimensionLiteralsStructure, detail::ArraySingleDimensionLiteralsStructure_f>() + sizeof(std::array<InnerStructureHelper, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArraySingleDimensionLiteralsBitset_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArraySingleDimensionLiteralsBitset_f
    {
        typedef std::array<InnerBitsetHelper, 10> ArraySingleDimensionLiteralsBitset::* type;
        friend constexpr type get(
                ArraySingleDimensionLiteralsBitset_f);
    };

    template struct ArraySingleDimensionLiteralsBitset_rob<ArraySingleDimensionLiteralsBitset_f, &ArraySingleDimensionLiteralsBitset::m_var_array_bitset>;

    template <typename T, typename Tag>
    inline size_t constexpr ArraySingleDimensionLiteralsBitset_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArraySingleDimensionLiteralsBitset defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArraySingleDimensionLiteralsBitsetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArraySingleDimensionLiteralsBitset type;

    eProsima_user_DllExport ArraySingleDimensionLiteralsBitsetPubSubType();

    eProsima_user_DllExport virtual ~ArraySingleDimensionLiteralsBitsetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArraySingleDimensionLiteralsBitset();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 80ULL == (detail::ArraySingleDimensionLiteralsBitset_offset_of<ArraySingleDimensionLiteralsBitset, detail::ArraySingleDimensionLiteralsBitset_f>() + sizeof(std::array<InnerBitsetHelper, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsShort_f
    {
        typedef std::array<std::array<std::array<int16_t, 2>, 10>, 5> ArrayMultiDimensionLiteralsShort::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsShort_f);
    };

    template struct ArrayMultiDimensionLiteralsShort_rob<ArrayMultiDimensionLiteralsShort_f, &ArrayMultiDimensionLiteralsShort::m_var_array_short>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsShort type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 200ULL == (detail::ArrayMultiDimensionLiteralsShort_offset_of<ArrayMultiDimensionLiteralsShort, detail::ArrayMultiDimensionLiteralsShort_f>() + sizeof(std::array<std::array<std::array<int16_t, 2>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsUShort_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsUShort_f
    {
        typedef std::array<std::array<std::array<uint16_t, 5>, 10>, 5> ArrayMultiDimensionLiteralsUShort::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsUShort_f);
    };

    template struct ArrayMultiDimensionLiteralsUShort_rob<ArrayMultiDimensionLiteralsUShort_f, &ArrayMultiDimensionLiteralsUShort::m_var_array_ushort>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsUShort_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsUShort defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsUShortPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsUShort type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsUShortPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsUShortPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsUShort();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 500ULL == (detail::ArrayMultiDimensionLiteralsUShort_offset_of<ArrayMultiDimensionLiteralsUShort, detail::ArrayMultiDimensionLiteralsUShort_f>() + sizeof(std::array<std::array<std::array<uint16_t, 5>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsLong_f
    {
        typedef std::array<std::array<std::array<int32_t, 5>, 5>, 10> ArrayMultiDimensionLiteralsLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsLong_f);
    };

    template struct ArrayMultiDimensionLiteralsLong_rob<ArrayMultiDimensionLiteralsLong_f, &ArrayMultiDimensionLiteralsLong::m_var_array_long>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsLong type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 1000ULL == (detail::ArrayMultiDimensionLiteralsLong_offset_of<ArrayMultiDimensionLiteralsLong, detail::ArrayMultiDimensionLiteralsLong_f>() + sizeof(std::array<std::array<std::array<int32_t, 5>, 5>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsULong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsULong_f
    {
        typedef std::array<std::array<std::array<uint32_t, 5>, 10>, 10> ArrayMultiDimensionLiteralsULong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsULong_f);
    };

    template struct ArrayMultiDimensionLiteralsULong_rob<ArrayMultiDimensionLiteralsULong_f, &ArrayMultiDimensionLiteralsULong::m_var_array_ulong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsULong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsULong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsULongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsULong type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsULongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsULongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsULong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsULong_offset_of<ArrayMultiDimensionLiteralsULong, detail::ArrayMultiDimensionLiteralsULong_f>() + sizeof(std::array<std::array<std::array<uint32_t, 5>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsLongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsLongLong_f
    {
        typedef std::array<std::array<std::array<int64_t, 5>, 10>, 5> ArrayMultiDimensionLiteralsLongLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsLongLong_f);
    };

    template struct ArrayMultiDimensionLiteralsLongLong_rob<ArrayMultiDimensionLiteralsLongLong_f, &ArrayMultiDimensionLiteralsLongLong::m_var_array_longlong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsLongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsLongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsLongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsLongLong type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsLongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsLongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsLongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsLongLong_offset_of<ArrayMultiDimensionLiteralsLongLong, detail::ArrayMultiDimensionLiteralsLongLong_f>() + sizeof(std::array<std::array<std::array<int64_t, 5>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsULongLong_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsULongLong_f
    {
        typedef std::array<std::array<std::array<uint64_t, 10>, 10>, 10> ArrayMultiDimensionLiteralsULongLong::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsULongLong_f);
    };

    template struct ArrayMultiDimensionLiteralsULongLong_rob<ArrayMultiDimensionLiteralsULongLong_f, &ArrayMultiDimensionLiteralsULongLong::m_var_array_ulonglong>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsULongLong_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsULongLong defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsULongLongPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsULongLong type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsULongLongPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsULongLongPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsULongLong();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionLiteralsULongLong_offset_of<ArrayMultiDimensionLiteralsULongLong, detail::ArrayMultiDimensionLiteralsULongLong_f>() + sizeof(std::array<std::array<std::array<uint64_t, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsFloat_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsFloat_f
    {
        typedef std::array<std::array<std::array<float, 10>, 5>, 10> ArrayMultiDimensionLiteralsFloat::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsFloat_f);
    };

    template struct ArrayMultiDimensionLiteralsFloat_rob<ArrayMultiDimensionLiteralsFloat_f, &ArrayMultiDimensionLiteralsFloat::m_var_array_float>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsFloat_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsFloat defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsFloatPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsFloat type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsFloatPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsFloatPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsFloat();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsFloat_offset_of<ArrayMultiDimensionLiteralsFloat, detail::ArrayMultiDimensionLiteralsFloat_f>() + sizeof(std::array<std::array<std::array<float, 10>, 5>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsDouble_f
    {
        typedef std::array<std::array<std::array<double, 5>, 10>, 5> ArrayMultiDimensionLiteralsDouble::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsDouble_f);
    };

    template struct ArrayMultiDimensionLiteralsDouble_rob<ArrayMultiDimensionLiteralsDouble_f, &ArrayMultiDimensionLiteralsDouble::m_var_array_double>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsDouble type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsDouble_offset_of<ArrayMultiDimensionLiteralsDouble, detail::ArrayMultiDimensionLiteralsDouble_f>() + sizeof(std::array<std::array<std::array<double, 5>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsLongDouble_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsLongDouble_f
    {
        typedef std::array<std::array<std::array<long double, 10>, 5>, 5> ArrayMultiDimensionLiteralsLongDouble::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsLongDouble_f);
    };

    template struct ArrayMultiDimensionLiteralsLongDouble_rob<ArrayMultiDimensionLiteralsLongDouble_f, &ArrayMultiDimensionLiteralsLongDouble::m_var_array_longdouble>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsLongDouble_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsLongDouble defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsLongDoublePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsLongDouble type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsLongDoublePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsLongDoublePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsLongDouble();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionLiteralsLongDouble_offset_of<ArrayMultiDimensionLiteralsLongDouble, detail::ArrayMultiDimensionLiteralsLongDouble_f>() + sizeof(std::array<std::array<std::array<long double, 10>, 5>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsBoolean_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsBoolean_f
    {
        typedef std::array<std::array<std::array<bool, 5>, 5>, 10> ArrayMultiDimensionLiteralsBoolean::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsBoolean_f);
    };

    template struct ArrayMultiDimensionLiteralsBoolean_rob<ArrayMultiDimensionLiteralsBoolean_f, &ArrayMultiDimensionLiteralsBoolean::m_var_array_boolean>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsBoolean_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsBoolean defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsBooleanPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsBoolean type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsBooleanPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsBooleanPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsBoolean();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 250ULL == (detail::ArrayMultiDimensionLiteralsBoolean_offset_of<ArrayMultiDimensionLiteralsBoolean, detail::ArrayMultiDimensionLiteralsBoolean_f>() + sizeof(std::array<std::array<std::array<bool, 5>, 5>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsOctet_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsOctet_f
    {
        typedef std::array<std::array<std::array<uint8_t, 5>, 10>, 5> ArrayMultiDimensionLiteralsOctet::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsOctet_f);
    };

    template struct ArrayMultiDimensionLiteralsOctet_rob<ArrayMultiDimensionLiteralsOctet_f, &ArrayMultiDimensionLiteralsOctet::m_var_array_octet>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsOctet_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsOctet defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsOctetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsOctet type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsOctetPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsOctetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsOctet();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 250ULL == (detail::ArrayMultiDimensionLiteralsOctet_offset_of<ArrayMultiDimensionLiteralsOctet, detail::ArrayMultiDimensionLiteralsOctet_f>() + sizeof(std::array<std::array<std::array<uint8_t, 5>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsChar_f
    {
        typedef std::array<std::array<std::array<char, 10>, 5>, 10> ArrayMultiDimensionLiteralsChar::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsChar_f);
    };

    template struct ArrayMultiDimensionLiteralsChar_rob<ArrayMultiDimensionLiteralsChar_f, &ArrayMultiDimensionLiteralsChar::m_var_array_char>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsChar type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 500ULL == (detail::ArrayMultiDimensionLiteralsChar_offset_of<ArrayMultiDimensionLiteralsChar, detail::ArrayMultiDimensionLiteralsChar_f>() + sizeof(std::array<std::array<std::array<char, 10>, 5>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsWChar_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsWChar_f
    {
        typedef std::array<std::array<std::array<wchar_t, 5>, 10>, 10> ArrayMultiDimensionLiteralsWChar::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsWChar_f);
    };

    template struct ArrayMultiDimensionLiteralsWChar_rob<ArrayMultiDimensionLiteralsWChar_f, &ArrayMultiDimensionLiteralsWChar::m_var_array_wchar>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsWChar_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsWChar defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsWCharPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsWChar type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsWCharPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsWCharPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsWChar();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsWChar_offset_of<ArrayMultiDimensionLiteralsWChar, detail::ArrayMultiDimensionLiteralsWChar_f>() + sizeof(std::array<std::array<std::array<wchar_t, 5>, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsString type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsWString type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsBoundedString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsBoundedStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsBoundedString type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsBoundedStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsBoundedStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsBoundedWString defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsBoundedWStringPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsBoundedWString type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsBoundedWStringPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsBoundedWStringPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsEnum defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsEnumPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsEnum type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsEnumPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsEnumPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsBitMask_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsBitMask_f
    {
        typedef std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5> ArrayMultiDimensionLiteralsBitMask::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsBitMask_f);
    };

    template struct ArrayMultiDimensionLiteralsBitMask_rob<ArrayMultiDimensionLiteralsBitMask_f, &ArrayMultiDimensionLiteralsBitMask::m_var_array_bitmask>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsBitMask_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsBitMask defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsBitMaskPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsBitMask type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsBitMaskPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsBitMaskPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsBitMask();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 1000ULL == (detail::ArrayMultiDimensionLiteralsBitMask_offset_of<ArrayMultiDimensionLiteralsBitMask, detail::ArrayMultiDimensionLiteralsBitMask_f>() + sizeof(std::array<std::array<std::array<InnerBitMaskHelper, 5>, 10>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsAlias_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsAlias_f
    {
        typedef std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10> ArrayMultiDimensionLiteralsAlias::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsAlias_f);
    };

    template struct ArrayMultiDimensionLiteralsAlias_rob<ArrayMultiDimensionLiteralsAlias_f, &ArrayMultiDimensionLiteralsAlias::m_var_array_alias>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsAlias_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsAlias defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsAliasPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsAlias type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsAliasPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsAliasPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsAlias();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 4000ULL == (detail::ArrayMultiDimensionLiteralsAlias_offset_of<ArrayMultiDimensionLiteralsAlias, detail::ArrayMultiDimensionLiteralsAlias_f>() + sizeof(std::array<std::array<std::array<InnerAliasHelper, 10>, 10>, 10>));

    }};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsSequence defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsSequencePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsSequence type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsSequencePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsSequencePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsMap defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsMapPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsMap type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsMapPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsMapPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsUnion defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsUnionPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsUnion type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsUnionPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsUnionPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        (void)memory;
        return false;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsStructure_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsStructure_f
    {
        typedef std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5> ArrayMultiDimensionLiteralsStructure::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsStructure_f);
    };

    template struct ArrayMultiDimensionLiteralsStructure_rob<ArrayMultiDimensionLiteralsStructure_f, &ArrayMultiDimensionLiteralsStructure::m_var_array_structure>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsStructure_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsStructure defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsStructurePubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsStructure type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsStructurePubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsStructurePubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsStructure();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2000ULL == (detail::ArrayMultiDimensionLiteralsStructure_offset_of<ArrayMultiDimensionLiteralsStructure, detail::ArrayMultiDimensionLiteralsStructure_f>() + sizeof(std::array<std::array<std::array<InnerStructureHelper, 10>, 5>, 5>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct ArrayMultiDimensionLiteralsBitSet_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct ArrayMultiDimensionLiteralsBitSet_f
    {
        typedef std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10> ArrayMultiDimensionLiteralsBitSet::* type;
        friend constexpr type get(
                ArrayMultiDimensionLiteralsBitSet_f);
    };

    template struct ArrayMultiDimensionLiteralsBitSet_rob<ArrayMultiDimensionLiteralsBitSet_f, &ArrayMultiDimensionLiteralsBitSet::m_var_array_bitset>;

    template <typename T, typename Tag>
    inline size_t constexpr ArrayMultiDimensionLiteralsBitSet_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type ArrayMultiDimensionLiteralsBitSet defined by the user in the IDL file.
 * @ingroup arrays
 */
class ArrayMultiDimensionLiteralsBitSetPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef ArrayMultiDimensionLiteralsBitSet type;

    eProsima_user_DllExport ArrayMultiDimensionLiteralsBitSetPubSubType();

    eProsima_user_DllExport virtual ~ArrayMultiDimensionLiteralsBitSetPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) ArrayMultiDimensionLiteralsBitSet();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 8000ULL == (detail::ArrayMultiDimensionLiteralsBitSet_offset_of<ArrayMultiDimensionLiteralsBitSet, detail::ArrayMultiDimensionLiteralsBitSet_f>() + sizeof(std::array<std::array<std::array<InnerBitsetHelper, 10>, 10>, 10>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BoundedSmallArrays_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BoundedSmallArrays_f
    {
        typedef std::array<int16_t, 1> BoundedSmallArrays::* type;
        friend constexpr type get(
                BoundedSmallArrays_f);
    };

    template struct BoundedSmallArrays_rob<BoundedSmallArrays_f, &BoundedSmallArrays::m_var_array_small>;

    template <typename T, typename Tag>
    inline size_t constexpr BoundedSmallArrays_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type BoundedSmallArrays defined by the user in the IDL file.
 * @ingroup arrays
 */
class BoundedSmallArraysPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BoundedSmallArrays type;

    eProsima_user_DllExport BoundedSmallArraysPubSubType();

    eProsima_user_DllExport virtual ~BoundedSmallArraysPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) BoundedSmallArrays();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 2ULL == (detail::BoundedSmallArrays_offset_of<BoundedSmallArrays, detail::BoundedSmallArrays_f>() + sizeof(std::array<int16_t, 1>));

    }};

#ifndef SWIG
namespace detail {

    template<typename Tag, typename Tag::type M>
    struct BoundedBigArrays_rob
    {
        friend constexpr typename Tag::type get(
                Tag)
        {
            return M;
        }
    };

    struct BoundedBigArrays_f
    {
        typedef std::array<int16_t, 41925> BoundedBigArrays::* type;
        friend constexpr type get(
                BoundedBigArrays_f);
    };

    template struct BoundedBigArrays_rob<BoundedBigArrays_f, &BoundedBigArrays::m_var_array_big>;

    template <typename T, typename Tag>
    inline size_t constexpr BoundedBigArrays_offset_of() {
        return ((::size_t) &reinterpret_cast<char const volatile&>((((T*)0)->*get(Tag()))));
    }
}
#endif

/*!
 * @brief This class represents the TopicDataType of the type BoundedBigArrays defined by the user in the IDL file.
 * @ingroup arrays
 */
class BoundedBigArraysPubSubType : public eprosima::fastdds::dds::TopicDataType
{
public:

    typedef BoundedBigArrays type;

    eProsima_user_DllExport BoundedBigArraysPubSubType();

    eProsima_user_DllExport virtual ~BoundedBigArraysPubSubType() override;

    eProsima_user_DllExport virtual bool serialize(
            void* data,
            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override;

    eProsima_user_DllExport virtual bool deserialize(
            eprosima::fastrtps::rtps::SerializedPayload_t* payload,
            void* data) override;

    eProsima_user_DllExport virtual std::function<uint32_t()> getSerializedSizeProvider(
            void* data) override;

    eProsima_user_DllExport virtual bool getKey(
            void* data,
            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,
            bool force_md5 = false) override;

    eProsima_user_DllExport virtual void* createData() override;

    eProsima_user_DllExport virtual void deleteData(
            void* data) override;

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED
    eProsima_user_DllExport inline bool is_bounded() const override
    {
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED

#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN
    eProsima_user_DllExport inline bool is_plain() const override
    {
        return is_plain_impl();
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN

#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE
    eProsima_user_DllExport inline bool construct_sample(
            void* memory) const override
    {
        new (memory) BoundedBigArrays();
        return true;
    }

#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE

    MD5 m_md5;
    unsigned char* m_keyBuffer;

private:

    static constexpr bool is_plain_impl()
    {
        return 83850ULL == (detail::BoundedBigArrays_offset_of<BoundedBigArrays, detail::BoundedBigArrays_f>() + sizeof(std::array<int16_t, 41925>));

    }};

#endif // _FAST_DDS_GENERATED_ARRAYS_PUBSUBTYPES_H_

